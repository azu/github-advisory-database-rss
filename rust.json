{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Previously, the worst case weight was always accounted as the block weight for all cases. In case of large EVM gas refunds, this can lead to block spamming attacks -- the adversary can construct blocks with transactions that have large amount of refunds or unused gases with reverts, and as a result inflate up the chain gas prices. This issue is fixed by properly refund unused weights after each EVM execution.</p>\n<p>The impact of this issue is limited in that the spamming attack would still be costly for any adversary, and it has no ability to alter any chain state. </p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue is fixed in <a href=\"https://github.com/paritytech/frontier/pull/851\">https://github.com/paritytech/frontier/pull/851</a></p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None.</p>\n<h3 id=\"references\">References</h3>\n<p><em>Are there any links users can visit to find out more?</em></p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Open an issue in <a href=\"https://github.com/paritytech/frontier/issues\">Frontier repo</a></li>\n<li>Email <a href=\"mailto:wei@that.world\">Wei</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/paritytech/frontier/security/advisories/GHSA-v57h-6hmh-g2p4\">https://github.com/paritytech/frontier/security/advisories/GHSA-v57h-6hmh-g2p4</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/851\">https://github.com/paritytech/frontier/pull/851</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-39242\">https://nvd.nist.gov/vuln/detail/CVE-2022-39242</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-v57h-6hmh-g2p4\">https://github.com/advisories/GHSA-v57h-6hmh-g2p4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-v57h-6hmh-g2p4",
            "title": "[pallet-ethereum] Weight not properly refunded after EVM execution",
            "date_modified": "2024-10-24T21:56:02.000Z",
            "date_published": "2022-09-23T22:07:10.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-v57h-6hmh-g2p4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>In the newly introduced signed Frontier-specific extrinsic for <code>pallet-ethereum</code>, a large part of transaction validation logic was only called in transaction pool validation, but not in block execution. Malicious validators can take advantage of this to put invalid transactions into a block.</p>\n<p>The attack is limited in that the signature is always validated, and the majority of the validation is done again in the subsequent <code>pallet-evm</code> execution logic. However, do note that a chain ID replay attack was possible. In addition, spamming attacks are of main concerns, while they are limited by Substrate block size limits and other factors.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue is patched in commit 146bb48849e5393004be5c88beefe76fdf009aba.</p>\n<h3 id=\"references\">References</h3>\n<p>Patch PR: <a href=\"https://github.com/paritytech/frontier/pull/495\">https://github.com/paritytech/frontier/pull/495</a></p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Open an issue in <a href=\"https://github.com/paritytech/frontier/issues\">Frontier repo</a></li>\n</ul>\n<h3 id=\"special-thanks\">Special thanks</h3>\n<p>Special thanks to @librelois, @nanocryk and the Moonbeam team for reporting and fixing this security vulnerability.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/paritytech/frontier/security/advisories/GHSA-vj62-g63v-f8mf\">https://github.com/paritytech/frontier/security/advisories/GHSA-vj62-g63v-f8mf</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/495\">https://github.com/paritytech/frontier/pull/495</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/commit/146bb48849e5393004be5c88beefe76fdf009aba\">https://github.com/paritytech/frontier/commit/146bb48849e5393004be5c88beefe76fdf009aba</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-41138\">https://nvd.nist.gov/vuln/detail/CVE-2021-41138</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/497\">https://github.com/paritytech/frontier/pull/497</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vj62-g63v-f8mf\">https://github.com/advisories/GHSA-vj62-g63v-f8mf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vj62-g63v-f8mf",
            "title": "[pallet-ethereum] Validity check missing in Frontier",
            "date_modified": "2024-10-24T21:53:17.000Z",
            "date_published": "2021-10-13T18:53:38.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vj62-g63v-f8mf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A bug in Frontier's MODEXP precompile implementation can cause an integer underflow in certain conditions. This will cause a node crash for debug builds. For release builds (and production WebAssembly binaries), the impact is limited as it can only cause a normal EVM out-of-gas. It is recommended that you apply the patch as soon as possible.</p>\n<p>If you do not use MODEXP precompile in your runtime, then you are not impacted.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Patches are applied in PR #549.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None.</p>\n<h3 id=\"references\">References</h3>\n<p>Patch PR: #549</p>\n<h3 id=\"credits\">Credits</h3>\n<p>Thanks to SR-Labs for discovering the security vulnerability, and thanks to PureStake team for the patches.</p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Open an issue in the <a href=\"https://github.com/paritytech/frontier\">Frontier repo</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/paritytech/frontier/security/advisories/GHSA-cjg2-2fjg-fph4\">https://github.com/paritytech/frontier/security/advisories/GHSA-cjg2-2fjg-fph4</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-21685\">https://nvd.nist.gov/vuln/detail/CVE-2022-21685</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/549\">https://github.com/paritytech/frontier/pull/549</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/commit/8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664\">https://github.com/paritytech/frontier/commit/8a93fdc6c9f4eb1d2f2a11b7ff1d12d70bf5a664</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cjg2-2fjg-fph4\">https://github.com/advisories/GHSA-cjg2-2fjg-fph4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cjg2-2fjg-fph4",
            "title": "[pallet-evm-precompile-modexp] Integer underflow in Frontier",
            "date_modified": "2024-10-24T21:50:43.000Z",
            "date_published": "2022-01-14T21:03:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cjg2-2fjg-fph4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A low severity security issue was discovered affecting parsing of the RPC result of the exit reason in case of EVM reversion. In release build, this would cause the exit reason being incorrectly parsed and returned by RPC. In debug build, this would cause an overflow panic.</p>\n<p>No action is needed unless you have a bridge node that needs to distinguish different reversion exit reasons and you used RPC for this.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue is patched in <a href=\"https://github.com/paritytech/frontier/pull/820\">https://github.com/paritytech/frontier/pull/820</a></p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None.</p>\n<h3 id=\"references\">References</h3>\n<p>PR <a href=\"https://github.com/paritytech/frontier/pull/820\">https://github.com/paritytech/frontier/pull/820</a></p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Email <a href=\"mailto:wei@that.world\">Wei Tang</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/paritytech/frontier/security/advisories/GHSA-mjvm-mhgc-q4gp\">https://github.com/paritytech/frontier/security/advisories/GHSA-mjvm-mhgc-q4gp</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/820\">https://github.com/paritytech/frontier/pull/820</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/commit/fff8cc43b7756ce3979a38fc473f38e6e24ac451\">https://github.com/paritytech/frontier/commit/fff8cc43b7756ce3979a38fc473f38e6e24ac451</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-36008\">https://nvd.nist.gov/vuln/detail/CVE-2022-36008</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mjvm-mhgc-q4gp\">https://github.com/advisories/GHSA-mjvm-mhgc-q4gp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mjvm-mhgc-q4gp",
            "title": "[fc-rpc] Incorrect parsing of EVM reversion exit reason in RPC",
            "date_modified": "2024-10-24T21:48:35.000Z",
            "date_published": "2022-08-18T19:18:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mjvm-mhgc-q4gp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Frontier's <code>modexp</code> precompile uses <code>num-bigint</code> crate under the hood. <a href=\"https://github.com/rust-num/num-bigint/blob/6f2b8e0fc218dbd0f49bebb8db2d1a771fe6bafa/src/biguint/power.rs#L134\">In the implementation</a>, the cases for modulus being even and modulus being odd are treated separately. Odd modulus uses the fast Montgomery multiplication, and even modulus uses the slow plain power algorithm. This gas cost discrepancy was not accounted for in the <code>modexp</code> precompile, leading to possible denial of service attacks.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>No fixes for <code>num-bigint</code> is currently available, and thus this advisory will be first fixed in the short term by raising the gas costs for even modulus, and in the long term fixing it in <code>num-bigint</code> or switching to another modexp implementation.</p>\n<p>The short-term fix for Frontier is deployed at <a href=\"https://github.com/paritytech/frontier/pull/1017\">PR 1017</a>.</p>\n<p>The recommendations are as follows:</p>\n<ul>\n<li>If you anticipate malicious validators, it's recommended to issue an emergency runtime upgrade as soon as possible.</li>\n<li>If you do not anticipate malicious validators, it's recommended to issue a normal runtime upgrade, as Substrate has builtin timeout protection when validators are building blocks.</li>\n</ul>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None.</p>\n<h3 id=\"references\">References</h3>\n<p>A similar issue was presented in Geth's implementation and the fix can be found <a href=\"https://go-review.googlesource.com/c/go/+/420897\">here</a>.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/paritytech/frontier/security/advisories/GHSA-fcmm-54jp-7vf6\">https://github.com/paritytech/frontier/security/advisories/GHSA-fcmm-54jp-7vf6</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/1017\">https://github.com/paritytech/frontier/pull/1017</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/commit/5af12e94d7dfc8a0208a290643a800f55de7b219\">https://github.com/paritytech/frontier/commit/5af12e94d7dfc8a0208a290643a800f55de7b219</a></li>\n<li><a href=\"https://github.com/rust-num/num-bigint/blob/6f2b8e0fc218dbd0f49bebb8db2d1a771fe6bafa/src/biguint/power.rs#L134\">https://github.com/rust-num/num-bigint/blob/6f2b8e0fc218dbd0f49bebb8db2d1a771fe6bafa/src/biguint/power.rs#L134</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-28431\">https://nvd.nist.gov/vuln/detail/CVE-2023-28431</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fcmm-54jp-7vf6\">https://github.com/advisories/GHSA-fcmm-54jp-7vf6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fcmm-54jp-7vf6",
            "title": "[pallet-evm-precompile-modexp] Frontier's modexp precompile is slow for even modulus",
            "date_modified": "2024-10-24T21:21:00.000Z",
            "date_published": "2023-03-21T22:31:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fcmm-54jp-7vf6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A bug in <code>pallet-ethereum</code> can cause invalid transactions to be included in the Ethereum block state in <code>pallet-ethereum</code> due to not validating the input data size. Any invalid transactions included this way have no possibility to alter the internal Ethereum or Substrate state. The transaction will appear to have be included, but is of no effect as it is rejected by the EVM engine. The impact is further limited by Substrate extrinsic size constraints.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Patches are applied in PR #465.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None.</p>\n<h3 id=\"references\">References</h3>\n<p>Patch PR: <a href=\"https://github.com/paritytech/frontier/pull/465\">https://github.com/paritytech/frontier/pull/465</a></p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Open an issue in the <a href=\"https://github.com/paritytech/frontier\">Frontier repo</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/paritytech/frontier/security/advisories/GHSA-hw4v-5x4h-c3xm\">https://github.com/paritytech/frontier/security/advisories/GHSA-hw4v-5x4h-c3xm</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/commit/dd112e\">https://github.com/paritytech/frontier/commit/dd112e</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-39193\">https://nvd.nist.gov/vuln/detail/CVE-2021-39193</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/465\">https://github.com/paritytech/frontier/pull/465</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/465/commits/8a2b890a2fb477d5fedd0e4335b00623832849ae\">https://github.com/paritytech/frontier/pull/465/commits/8a2b890a2fb477d5fedd0e4335b00623832849ae</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/commit/0b962f218f0cdd796dadfe26c3f09e68f7861b26\">https://github.com/paritytech/frontier/commit/0b962f218f0cdd796dadfe26c3f09e68f7861b26</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hw4v-5x4h-c3xm\">https://github.com/advisories/GHSA-hw4v-5x4h-c3xm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hw4v-5x4h-c3xm",
            "title": "[pallet-ethereum] Transaction validity oversight in pallet-ethereum",
            "date_modified": "2024-10-24T21:18:32.000Z",
            "date_published": "2021-09-01T18:22:48.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hw4v-5x4h-c3xm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>The <code>gix</code> and <code>ein</code> commands write pathnames and other metadata literally to terminals, even if they contain characters terminals treat specially, including ANSI escape sequences. This sometimes allows an untrusted repository to misrepresent its contents and to alter or concoct error messages.</p>\n<h3 id=\"details\">Details</h3>\n<p><code>gitoxide-core</code>, which provides most underlying functionality of the <code>gix</code> and <code>ein</code> commands, does not neutralize newlines, backspaces, or control characters—including those that form ANSI escape sequences—that appear in a repository's paths, author and committer names, commit messages, or other metadata. Such text may be written as part of the output of a command, as well as appearing in error messages when an operation fails.</p>\n<p>ANSI escape sequences are of particular concern because, when printed to a terminal, they can change colors, including to render subsequent text unreadable; reposition the cursor to write text in a different location, including where text has already been written; clear the terminal; set the terminal title-bar text to arbitrary values; render the terminal temporarily unusable; and other such operations.</p>\n<p>The effect is mostly an annoyance. But the author of a malicious repository who can predict how information from the repository may be accessed can cause files in the repository to be concealed or otherwise misrepresented, as well as rewrite all or part of error messages, or mimic error messages convincingly by repositioning the cursor and writing colored text.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>On a Unix-like system in a POSIX-compatible shell, run:</p>\n<pre><code class=\"language-sh\">git init misleading-path\ncd misleading-path\ntouch \"$(printf '\\033]0;Boo!\\007\\033[2K\\r\\033[91mError: Repository is corrupted. Run \\033[96mEVIL_COMMAND\\033[91m to attempt recovery.\\033[0m')\"\ngit add .\ngit commit -m 'Initial commit'\n</code></pre>\n<p>In the repository—or, if desired, in a clone of it, to show that this is exploitable by getting a user to clone an untrusted repository—run this command, which outputs entries in a three-column form showing type, hash, and filename:</p>\n<pre><code class=\"language-sh\">gix tree entries\n</code></pre>\n<p>Although the output is of that form, it does not appear to be. Instead, the output in a terminal looks like this, colorized to appear to be an error message, with <code>EVIL_COMMAND</code> in another color, and with no other text:</p>\n<pre><code class=\"language-text\">Error: Repository is corrupted. Run EVIL_COMMAND to attempt recovery.\n</code></pre>\n<p>In some terminals, a beep or other sound will be made. In most terminals, the title bar text will be changed to <code>Boo!</code>, though in some shells this may be immediately undone when printing the prompt. These elements are included to showcase the abilities of ANSI escape sequences, but they are not usually themselves threats.</p>\n<p>To see what is actually produced, <code>gix tree entries</code> can be piped to a command that displays special characters symbolically, such as <code>less</code> or <code>cat -v</code> if available.</p>\n<pre><code class=\"language-text\">BLOB e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ESC]0;Boo!^GESC[2K^MESC[91mError: Repository is corrupted. Run ESC[96mEVIL_COMMANDESC[91m to attempt recovery.ESC[0m\n</code></pre>\n<p>That shows the effect on <code>gix tree entries</code>, but various other commands are also affected, and the escape sequences and other special characters can also appear in non-path metadata, such as in the <code>user.name</code> used to create a commit.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>For users who do not clone or operate in clones of untrusted repositories, there is no impact.</p>\n<p>Windows is much less affected than Unix-like systems due to limitations on what characters can appear in filenames, and because traditionally Windows terminals do not support as many ANSI escape sequences.</p>\n<p>Because different <code>gix</code> and <code>ein</code> commands display different data in different formats, the author of a malicious repository must guess how it will be used, which complicates crafting truly convincing output, though it may be possible to craft a repository where <code>gix clone</code> fails to clone it but produces a misleading message.</p>\n<p>Although this is mainly exploitable on systems <em>other</em> than Windows, in the ability to produce misleading output this superficially resembles CVE-2024-35197. But this is much more limited, because:</p>\n<ul>\n<li>The misleading output can only be made to go where the application is already sending output. Redirection is not defeated, and devices to access cannot be chosen by the attacker.</li>\n<li>The misleading output can only be take place <em>when</em> the application is already producing output. This limitation complicates the production of believable messages.</li>\n<li>Only terminals are affected. Even if a standard stream is redirected to another file or device, these special characters would not have a special effect, unless echoed later without sanitization.</li>\n<li>Reading and blocking cannot be performed.</li>\n<li>Applications other than the gitoxide <code>gix</code> and <code>ein</code> executables are unaffected. The exception is if another application uses <code>gitoxide-core</code>. But this is explicitly discouraged in the <code>gitoxide-core</code> documentation and is believed to be rare.</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h\">https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-43785\">https://nvd.nist.gov/vuln/detail/CVE-2024-43785</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0364.html\">https://rustsec.org/advisories/RUSTSEC-2024-0364.html</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-88g2-r9rw-g55h\">https://github.com/advisories/GHSA-88g2-r9rw-g55h</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-88g2-r9rw-g55h",
            "title": "[gitoxide] gitoxide-core does not neutralize special characters for terminals",
            "date_modified": "2024-10-24T14:33:18.000Z",
            "date_published": "2024-08-22T16:41:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-88g2-r9rw-g55h"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>The <code>gix</code> and <code>ein</code> commands write pathnames and other metadata literally to terminals, even if they contain characters terminals treat specially, including ANSI escape sequences. This sometimes allows an untrusted repository to misrepresent its contents and to alter or concoct error messages.</p>\n<h3 id=\"details\">Details</h3>\n<p><code>gitoxide-core</code>, which provides most underlying functionality of the <code>gix</code> and <code>ein</code> commands, does not neutralize newlines, backspaces, or control characters—including those that form ANSI escape sequences—that appear in a repository's paths, author and committer names, commit messages, or other metadata. Such text may be written as part of the output of a command, as well as appearing in error messages when an operation fails.</p>\n<p>ANSI escape sequences are of particular concern because, when printed to a terminal, they can change colors, including to render subsequent text unreadable; reposition the cursor to write text in a different location, including where text has already been written; clear the terminal; set the terminal title-bar text to arbitrary values; render the terminal temporarily unusable; and other such operations.</p>\n<p>The effect is mostly an annoyance. But the author of a malicious repository who can predict how information from the repository may be accessed can cause files in the repository to be concealed or otherwise misrepresented, as well as rewrite all or part of error messages, or mimic error messages convincingly by repositioning the cursor and writing colored text.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>On a Unix-like system in a POSIX-compatible shell, run:</p>\n<pre><code class=\"language-sh\">git init misleading-path\ncd misleading-path\ntouch \"$(printf '\\033]0;Boo!\\007\\033[2K\\r\\033[91mError: Repository is corrupted. Run \\033[96mEVIL_COMMAND\\033[91m to attempt recovery.\\033[0m')\"\ngit add .\ngit commit -m 'Initial commit'\n</code></pre>\n<p>In the repository—or, if desired, in a clone of it, to show that this is exploitable by getting a user to clone an untrusted repository—run this command, which outputs entries in a three-column form showing type, hash, and filename:</p>\n<pre><code class=\"language-sh\">gix tree entries\n</code></pre>\n<p>Although the output is of that form, it does not appear to be. Instead, the output in a terminal looks like this, colorized to appear to be an error message, with <code>EVIL_COMMAND</code> in another color, and with no other text:</p>\n<pre><code class=\"language-text\">Error: Repository is corrupted. Run EVIL_COMMAND to attempt recovery.\n</code></pre>\n<p>In some terminals, a beep or other sound will be made. In most terminals, the title bar text will be changed to <code>Boo!</code>, though in some shells this may be immediately undone when printing the prompt. These elements are included to showcase the abilities of ANSI escape sequences, but they are not usually themselves threats.</p>\n<p>To see what is actually produced, <code>gix tree entries</code> can be piped to a command that displays special characters symbolically, such as <code>less</code> or <code>cat -v</code> if available.</p>\n<pre><code class=\"language-text\">BLOB e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ESC]0;Boo!^GESC[2K^MESC[91mError: Repository is corrupted. Run ESC[96mEVIL_COMMANDESC[91m to attempt recovery.ESC[0m\n</code></pre>\n<p>That shows the effect on <code>gix tree entries</code>, but various other commands are also affected, and the escape sequences and other special characters can also appear in non-path metadata, such as in the <code>user.name</code> used to create a commit.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>For users who do not clone or operate in clones of untrusted repositories, there is no impact.</p>\n<p>Windows is much less affected than Unix-like systems due to limitations on what characters can appear in filenames, and because traditionally Windows terminals do not support as many ANSI escape sequences.</p>\n<p>Because different <code>gix</code> and <code>ein</code> commands display different data in different formats, the author of a malicious repository must guess how it will be used, which complicates crafting truly convincing output, though it may be possible to craft a repository where <code>gix clone</code> fails to clone it but produces a misleading message.</p>\n<p>Although this is mainly exploitable on systems <em>other</em> than Windows, in the ability to produce misleading output this superficially resembles CVE-2024-35197. But this is much more limited, because:</p>\n<ul>\n<li>The misleading output can only be made to go where the application is already sending output. Redirection is not defeated, and devices to access cannot be chosen by the attacker.</li>\n<li>The misleading output can only be take place <em>when</em> the application is already producing output. This limitation complicates the production of believable messages.</li>\n<li>Only terminals are affected. Even if a standard stream is redirected to another file or device, these special characters would not have a special effect, unless echoed later without sanitization.</li>\n<li>Reading and blocking cannot be performed.</li>\n<li>Applications other than the gitoxide <code>gix</code> and <code>ein</code> executables are unaffected. The exception is if another application uses <code>gitoxide-core</code>. But this is explicitly discouraged in the <code>gitoxide-core</code> documentation and is believed to be rare.</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h\">https://github.com/Byron/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-43785\">https://nvd.nist.gov/vuln/detail/CVE-2024-43785</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0364.html\">https://rustsec.org/advisories/RUSTSEC-2024-0364.html</a></li>\n<li><a href=\"https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h\">https://github.com/GitoxideLabs/gitoxide/security/advisories/GHSA-88g2-r9rw-g55h</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-88g2-r9rw-g55h\">https://github.com/advisories/GHSA-88g2-r9rw-g55h</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-88g2-r9rw-g55h",
            "title": "[gitoxide-core] gitoxide-core does not neutralize special characters for terminals",
            "date_modified": "2024-10-24T14:33:18.000Z",
            "date_published": "2024-08-22T16:41:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-88g2-r9rw-g55h"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The family of functions to read \"borrowed\" values from Python weak references were fundamentally unsound, because the weak reference does itself not have ownership of the value. At any point the last strong reference could be cleared and the borrowed value would become dangling.</p>\n<p>In PyO3 0.22.4 these functions have all been deprecated and patched to leak a strong reference as a mitigation. PyO3 0.23 will remove these functions entirely.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-9979\">https://nvd.nist.gov/vuln/detail/CVE-2024-9979</a></li>\n<li><a href=\"https://github.com/PyO3/pyo3/pull/4590\">https://github.com/PyO3/pyo3/pull/4590</a></li>\n<li><a href=\"https://access.redhat.com/security/cve/CVE-2024-9979\">https://access.redhat.com/security/cve/CVE-2024-9979</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2318646\">https://bugzilla.redhat.com/show_bug.cgi?id=2318646</a></li>\n<li><a href=\"https://crates.io/crates/pyo3\">https://crates.io/crates/pyo3</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0378.html\">https://rustsec.org/advisories/RUSTSEC-2024-0378.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6jgw-rgmm-7cv6\">https://github.com/advisories/GHSA-6jgw-rgmm-7cv6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6jgw-rgmm-7cv6",
            "title": "[pyo3]  PyO3 has a risk of use-after-free in `borrowed` reads from Python weak references",
            "date_modified": "2024-10-15T17:04:56.000Z",
            "date_published": "2024-10-15T15:30:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6jgw-rgmm-7cv6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"duplicate-advisory\">Duplicate Advisory</h2>\n<p>This advisory has been withdrawn because it is a duplicate of GHSA-6jgw-rgmm-7cv6. This link is maintained to preserve external references.</p>\n<h2 id=\"original-advisory\">Original Advisory</h2>\n<p>The family of functions to read \"borrowed\" values from Python weak references were fundamentally unsound, because the weak reference does itself not have ownership of the value. At any point the last strong reference could be cleared and the borrowed value would become dangling.</p>\n<p>In PyO3 0.22.4 these functions have all been deprecated and patched to leak a strong reference as a mitigation. PyO3 0.23 will remove these functions entirely.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/PyO3/pyo3/pull/4590\">https://github.com/PyO3/pyo3/pull/4590</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0378.html\">https://rustsec.org/advisories/RUSTSEC-2024-0378.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-f8x4-f32r-w556\">https://github.com/advisories/GHSA-f8x4-f32r-w556</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-f8x4-f32r-w556",
            "title": "[pyo3] Duplicate Advisory: PyO3 has a risk of use-after-free in `borrowed` reads from Python weak references",
            "date_modified": "2024-10-15T17:13:46.000Z",
            "date_published": "2024-10-15T14:08:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-f8x4-f32r-w556"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>\n<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the \"References\" section below for a list of Wasmtime types-related APIs that are affected.</p>\n<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see \"References\" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>\n<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>\n<table>\n<thead>\n<tr>\n<th>Thread A</th>\n<th>Thread B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>decref(E) --&gt; 0</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>block_on(type registry lock)</code></td>\n</tr>\n<tr>\n<td><code>register(E') == incref(E) --&gt; 1</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>decref(E) --&gt; 0</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>unregister(E)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>acquire(type registry lock)</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>unregister(E)</code></td>\n</tr>\n</tbody></table>\n<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>\n<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>\n<ul>\n<li>21.0.2</li>\n<li>22.0.1</li>\n<li>23.0.3</li>\n<li>24.0.1</li>\n<li>25.0.2</li>\n</ul>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>\n<h3 id=\"references\">References</h3>\n<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>\n<ul>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new\"><code>wasmtime::FuncType::new</code></a><ul>\n<li>Also reachable from creation of <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html\"><code>wasmtime::Func</code></a></li>\n<li>Also reachable from <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new\"><code>wasmtime::Linker::func_*</code></a></li>\n</ul>\n</li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new\"><code>wasmtime::ArrayType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new\"><code>wasmtime::StructType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty\"><code>wasmtime::Func::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty\"><code>wasmtime::Global::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty\"><code>wasmtime::Table::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty\"><code>wasmtime::Extern::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty\"><code>wasmtime::Export::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty\"><code>wasmtime::UnknownImportError::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty\"><code>wasmtime::ImportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty\"><code>wasmtime::ExportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty\"><code>wasmtime::Val::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty\"><code>wasmtime::Ref::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty\"><code>wasmtime::AnyRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty\"><code>wasmtime::EqRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty\"><code>wasmtime::ArrayRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty\"><code>wasmtime::StructRef::ty</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html\"><code>wasmtime::FuncType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html\"><code>wasmtime::ArrayType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html\"><code>wasmtime::StructType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html\"><code>wasmtime::ExternType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html\"><code>wasmtime::GlobalType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html\"><code>wasmtime::TableType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html\"><code>wasmtime::ValType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html\"><code>wasmtime::RefType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html\"><code>wasmtime::HeapType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html\"><code>wasmtime::UnknownImportError</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html\"><code>wasmtime::Linker</code></a></li>\n</ul>\n<p>The change which introduced this bug was <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">#7969</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47813\">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m",
            "title": "[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations",
            "date_modified": "2024-10-09T19:14:36.000Z",
            "date_published": "2024-10-09T19:14:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>\n<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the \"References\" section below for a list of Wasmtime types-related APIs that are affected.</p>\n<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see \"References\" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>\n<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>\n<table>\n<thead>\n<tr>\n<th>Thread A</th>\n<th>Thread B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>decref(E) --&gt; 0</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>block_on(type registry lock)</code></td>\n</tr>\n<tr>\n<td><code>register(E') == incref(E) --&gt; 1</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>decref(E) --&gt; 0</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>unregister(E)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>acquire(type registry lock)</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>unregister(E)</code></td>\n</tr>\n</tbody></table>\n<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>\n<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>\n<ul>\n<li>21.0.2</li>\n<li>22.0.1</li>\n<li>23.0.3</li>\n<li>24.0.1</li>\n<li>25.0.2</li>\n</ul>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>\n<h3 id=\"references\">References</h3>\n<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>\n<ul>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new\"><code>wasmtime::FuncType::new</code></a><ul>\n<li>Also reachable from creation of <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html\"><code>wasmtime::Func</code></a></li>\n<li>Also reachable from <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new\"><code>wasmtime::Linker::func_*</code></a></li>\n</ul>\n</li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new\"><code>wasmtime::ArrayType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new\"><code>wasmtime::StructType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty\"><code>wasmtime::Func::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty\"><code>wasmtime::Global::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty\"><code>wasmtime::Table::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty\"><code>wasmtime::Extern::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty\"><code>wasmtime::Export::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty\"><code>wasmtime::UnknownImportError::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty\"><code>wasmtime::ImportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty\"><code>wasmtime::ExportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty\"><code>wasmtime::Val::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty\"><code>wasmtime::Ref::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty\"><code>wasmtime::AnyRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty\"><code>wasmtime::EqRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty\"><code>wasmtime::ArrayRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty\"><code>wasmtime::StructRef::ty</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html\"><code>wasmtime::FuncType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html\"><code>wasmtime::ArrayType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html\"><code>wasmtime::StructType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html\"><code>wasmtime::ExternType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html\"><code>wasmtime::GlobalType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html\"><code>wasmtime::TableType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html\"><code>wasmtime::ValType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html\"><code>wasmtime::RefType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html\"><code>wasmtime::HeapType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html\"><code>wasmtime::UnknownImportError</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html\"><code>wasmtime::Linker</code></a></li>\n</ul>\n<p>The change which introduced this bug was <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">#7969</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47813\">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m",
            "title": "[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations",
            "date_modified": "2024-10-09T19:14:36.000Z",
            "date_published": "2024-10-09T19:14:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>\n<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the \"References\" section below for a list of Wasmtime types-related APIs that are affected.</p>\n<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see \"References\" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>\n<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>\n<table>\n<thead>\n<tr>\n<th>Thread A</th>\n<th>Thread B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>decref(E) --&gt; 0</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>block_on(type registry lock)</code></td>\n</tr>\n<tr>\n<td><code>register(E') == incref(E) --&gt; 1</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>decref(E) --&gt; 0</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>unregister(E)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>acquire(type registry lock)</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>unregister(E)</code></td>\n</tr>\n</tbody></table>\n<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>\n<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>\n<ul>\n<li>21.0.2</li>\n<li>22.0.1</li>\n<li>23.0.3</li>\n<li>24.0.1</li>\n<li>25.0.2</li>\n</ul>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>\n<h3 id=\"references\">References</h3>\n<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>\n<ul>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new\"><code>wasmtime::FuncType::new</code></a><ul>\n<li>Also reachable from creation of <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html\"><code>wasmtime::Func</code></a></li>\n<li>Also reachable from <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new\"><code>wasmtime::Linker::func_*</code></a></li>\n</ul>\n</li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new\"><code>wasmtime::ArrayType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new\"><code>wasmtime::StructType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty\"><code>wasmtime::Func::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty\"><code>wasmtime::Global::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty\"><code>wasmtime::Table::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty\"><code>wasmtime::Extern::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty\"><code>wasmtime::Export::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty\"><code>wasmtime::UnknownImportError::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty\"><code>wasmtime::ImportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty\"><code>wasmtime::ExportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty\"><code>wasmtime::Val::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty\"><code>wasmtime::Ref::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty\"><code>wasmtime::AnyRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty\"><code>wasmtime::EqRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty\"><code>wasmtime::ArrayRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty\"><code>wasmtime::StructRef::ty</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html\"><code>wasmtime::FuncType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html\"><code>wasmtime::ArrayType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html\"><code>wasmtime::StructType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html\"><code>wasmtime::ExternType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html\"><code>wasmtime::GlobalType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html\"><code>wasmtime::TableType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html\"><code>wasmtime::ValType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html\"><code>wasmtime::RefType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html\"><code>wasmtime::HeapType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html\"><code>wasmtime::UnknownImportError</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html\"><code>wasmtime::Linker</code></a></li>\n</ul>\n<p>The change which introduced this bug was <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">#7969</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47813\">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m",
            "title": "[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations",
            "date_modified": "2024-10-09T19:14:36.000Z",
            "date_published": "2024-10-09T19:14:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>\n<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the \"References\" section below for a list of Wasmtime types-related APIs that are affected.</p>\n<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see \"References\" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>\n<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>\n<table>\n<thead>\n<tr>\n<th>Thread A</th>\n<th>Thread B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>decref(E) --&gt; 0</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>block_on(type registry lock)</code></td>\n</tr>\n<tr>\n<td><code>register(E') == incref(E) --&gt; 1</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>decref(E) --&gt; 0</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>unregister(E)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>acquire(type registry lock)</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>unregister(E)</code></td>\n</tr>\n</tbody></table>\n<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>\n<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>\n<ul>\n<li>21.0.2</li>\n<li>22.0.1</li>\n<li>23.0.3</li>\n<li>24.0.1</li>\n<li>25.0.2</li>\n</ul>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>\n<h3 id=\"references\">References</h3>\n<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>\n<ul>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new\"><code>wasmtime::FuncType::new</code></a><ul>\n<li>Also reachable from creation of <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html\"><code>wasmtime::Func</code></a></li>\n<li>Also reachable from <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new\"><code>wasmtime::Linker::func_*</code></a></li>\n</ul>\n</li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new\"><code>wasmtime::ArrayType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new\"><code>wasmtime::StructType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty\"><code>wasmtime::Func::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty\"><code>wasmtime::Global::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty\"><code>wasmtime::Table::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty\"><code>wasmtime::Extern::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty\"><code>wasmtime::Export::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty\"><code>wasmtime::UnknownImportError::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty\"><code>wasmtime::ImportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty\"><code>wasmtime::ExportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty\"><code>wasmtime::Val::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty\"><code>wasmtime::Ref::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty\"><code>wasmtime::AnyRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty\"><code>wasmtime::EqRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty\"><code>wasmtime::ArrayRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty\"><code>wasmtime::StructRef::ty</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html\"><code>wasmtime::FuncType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html\"><code>wasmtime::ArrayType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html\"><code>wasmtime::StructType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html\"><code>wasmtime::ExternType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html\"><code>wasmtime::GlobalType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html\"><code>wasmtime::TableType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html\"><code>wasmtime::ValType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html\"><code>wasmtime::RefType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html\"><code>wasmtime::HeapType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html\"><code>wasmtime::UnknownImportError</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html\"><code>wasmtime::Linker</code></a></li>\n</ul>\n<p>The change which introduced this bug was <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">#7969</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47813\">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m",
            "title": "[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations",
            "date_modified": "2024-10-09T19:14:36.000Z",
            "date_published": "2024-10-09T19:14:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>\n<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the \"References\" section below for a list of Wasmtime types-related APIs that are affected.</p>\n<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see \"References\" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>\n<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>\n<table>\n<thead>\n<tr>\n<th>Thread A</th>\n<th>Thread B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>decref(E) --&gt; 0</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>block_on(type registry lock)</code></td>\n</tr>\n<tr>\n<td><code>register(E') == incref(E) --&gt; 1</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>decref(E) --&gt; 0</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>acquire(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>unregister(E)</code></td>\n<td></td>\n</tr>\n<tr>\n<td><code>release(type registry lock)</code></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td><code>acquire(type registry lock)</code></td>\n</tr>\n<tr>\n<td></td>\n<td><code>unregister(E)</code></td>\n</tr>\n</tbody></table>\n<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>\n<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>\n<ul>\n<li>21.0.2</li>\n<li>22.0.1</li>\n<li>23.0.3</li>\n<li>24.0.1</li>\n<li>25.0.2</li>\n</ul>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>\n<h3 id=\"references\">References</h3>\n<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>\n<ul>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new\"><code>wasmtime::FuncType::new</code></a><ul>\n<li>Also reachable from creation of <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html\"><code>wasmtime::Func</code></a></li>\n<li>Also reachable from <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new\"><code>wasmtime::Linker::func_*</code></a></li>\n</ul>\n</li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new\"><code>wasmtime::ArrayType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new\"><code>wasmtime::StructType::new</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty\"><code>wasmtime::Func::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty\"><code>wasmtime::Global::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty\"><code>wasmtime::Table::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty\"><code>wasmtime::Extern::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty\"><code>wasmtime::Export::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty\"><code>wasmtime::UnknownImportError::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty\"><code>wasmtime::ImportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty\"><code>wasmtime::ExportType::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty\"><code>wasmtime::Val::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty\"><code>wasmtime::Ref::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty\"><code>wasmtime::AnyRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty\"><code>wasmtime::EqRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty\"><code>wasmtime::ArrayRef::ty</code></a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty\"><code>wasmtime::StructRef::ty</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html\"><code>wasmtime::FuncType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html\"><code>wasmtime::ArrayType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html\"><code>wasmtime::StructType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html\"><code>wasmtime::ExternType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html\"><code>wasmtime::GlobalType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html\"><code>wasmtime::TableType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html\"><code>wasmtime::ValType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html\"><code>wasmtime::RefType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html\"><code>wasmtime::HeapType</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html\"><code>wasmtime::UnknownImportError</code></a></li>\n<li>Dropping a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html\"><code>wasmtime::Linker</code></a></li>\n</ul>\n<p>The change which introduced this bug was <a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">#7969</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47813\">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/7969\">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7qmx-3fpx-r45m\">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m",
            "title": "[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations",
            "date_modified": "2024-10-09T19:14:36.000Z",
            "date_published": "2024-10-09T19:14:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7qmx-3fpx-r45m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>\n<p><a href=\"https://github.com/webassembly/tail-call\">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href=\"https://github.com/WebAssembly/proposals/\">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>\n<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>\n<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern \"C\"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>\n<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>\n<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>\n<ul>\n<li>21.0.x - patched in 21.0.2</li>\n<li>22.0.x - patched in 22.0.1</li>\n<li>23.0.x - patched in 23.0.3 </li>\n<li>24.0.x - patched in 24.0.1</li>\n<li>25.0.x - patched in 25.0.2</li>\n</ul>\n<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">Wasmtime's initial implementation of tail calls</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">Enabling of tail calls in 21.0.0</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Fully enabling tail calls in 22.0.0</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">The WebAssembly's <code>tail-call</code> proposal</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47763\">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>\n<li><a href=\"https://github.com/WebAssembly/proposals\">https://github.com/WebAssembly/proposals</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">https://github.com/webassembly/tail-call</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg",
            "title": "[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports",
            "date_modified": "2024-10-09T19:14:04.000Z",
            "date_published": "2024-10-09T19:14:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>\n<p><a href=\"https://github.com/webassembly/tail-call\">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href=\"https://github.com/WebAssembly/proposals/\">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>\n<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>\n<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern \"C\"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>\n<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>\n<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>\n<ul>\n<li>21.0.x - patched in 21.0.2</li>\n<li>22.0.x - patched in 22.0.1</li>\n<li>23.0.x - patched in 23.0.3 </li>\n<li>24.0.x - patched in 24.0.1</li>\n<li>25.0.x - patched in 25.0.2</li>\n</ul>\n<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">Wasmtime's initial implementation of tail calls</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">Enabling of tail calls in 21.0.0</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Fully enabling tail calls in 22.0.0</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">The WebAssembly's <code>tail-call</code> proposal</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47763\">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>\n<li><a href=\"https://github.com/WebAssembly/proposals\">https://github.com/WebAssembly/proposals</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">https://github.com/webassembly/tail-call</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg",
            "title": "[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports",
            "date_modified": "2024-10-09T19:14:04.000Z",
            "date_published": "2024-10-09T19:14:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>\n<p><a href=\"https://github.com/webassembly/tail-call\">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href=\"https://github.com/WebAssembly/proposals/\">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>\n<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>\n<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern \"C\"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>\n<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>\n<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>\n<ul>\n<li>21.0.x - patched in 21.0.2</li>\n<li>22.0.x - patched in 22.0.1</li>\n<li>23.0.x - patched in 23.0.3 </li>\n<li>24.0.x - patched in 24.0.1</li>\n<li>25.0.x - patched in 25.0.2</li>\n</ul>\n<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">Wasmtime's initial implementation of tail calls</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">Enabling of tail calls in 21.0.0</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Fully enabling tail calls in 22.0.0</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">The WebAssembly's <code>tail-call</code> proposal</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47763\">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>\n<li><a href=\"https://github.com/WebAssembly/proposals\">https://github.com/WebAssembly/proposals</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">https://github.com/webassembly/tail-call</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg",
            "title": "[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports",
            "date_modified": "2024-10-09T19:14:04.000Z",
            "date_published": "2024-10-09T19:14:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>\n<p><a href=\"https://github.com/webassembly/tail-call\">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href=\"https://github.com/WebAssembly/proposals/\">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>\n<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>\n<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern \"C\"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>\n<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>\n<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>\n<ul>\n<li>21.0.x - patched in 21.0.2</li>\n<li>22.0.x - patched in 22.0.1</li>\n<li>23.0.x - patched in 23.0.3 </li>\n<li>24.0.x - patched in 24.0.1</li>\n<li>25.0.x - patched in 25.0.2</li>\n</ul>\n<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">Wasmtime's initial implementation of tail calls</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">Enabling of tail calls in 21.0.0</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Fully enabling tail calls in 22.0.0</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">The WebAssembly's <code>tail-call</code> proposal</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47763\">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>\n<li><a href=\"https://github.com/WebAssembly/proposals\">https://github.com/WebAssembly/proposals</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">https://github.com/webassembly/tail-call</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg",
            "title": "[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports",
            "date_modified": "2024-10-09T19:14:04.000Z",
            "date_published": "2024-10-09T19:14:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>\n<p><a href=\"https://github.com/webassembly/tail-call\">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href=\"https://github.com/WebAssembly/proposals/\">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>\n<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>\n<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern \"C\"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>\n<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>\n<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>\n<ul>\n<li>21.0.x - patched in 21.0.2</li>\n<li>22.0.x - patched in 22.0.1</li>\n<li>23.0.x - patched in 23.0.3 </li>\n<li>24.0.x - patched in 24.0.1</li>\n<li>25.0.x - patched in 25.0.2</li>\n</ul>\n<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">Wasmtime's initial implementation of tail calls</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">Enabling of tail calls in 21.0.0</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">Fully enabling tail calls in 22.0.0</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">The WebAssembly's <code>tail-call</code> proposal</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-47763\">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/6774\">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8540\">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/8682\">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba\">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>\n<li><a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call\">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>\n<li><a href=\"https://github.com/WebAssembly/proposals\">https://github.com/WebAssembly/proposals</a></li>\n<li><a href=\"https://github.com/webassembly/tail-call\">https://github.com/webassembly/tail-call</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q8hx-mm92-4wvg\">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg",
            "title": "[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports",
            "date_modified": "2024-10-09T19:14:04.000Z",
            "date_published": "2024-10-09T19:14:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q8hx-mm92-4wvg"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}