{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Anyone using the <code>tendermint-light-client</code> and related packages to perform light client verification (e.g. IBC-rs, Hermes).</p>\n<p>At present, the light client does not check that the chain IDs of the trusted and untrusted headers match, resulting in a possible attack vector where someone who finds a header from an untrusted chain that satisfies all other verification conditions (e.g. enough overlapping validator signatures) could fool a light client.</p>\n<p>The attack vector is currently theoretical, and no proof-of-concept exists yet to exploit it on live networks.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users of the light client-related crates can currently upgrade to <code>v0.28.0</code>.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tendermint/tendermint/tree/main/spec/light-client\">Light Client specification</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18\">https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23507\">https://nvd.nist.gov/vuln/detail/CVE-2022-23507</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5",
            "title": "[tendermint-light-client-js] Tendermint light client verification not taking into account chain ID",
            "date_modified": "2022-12-15T22:00:22.000Z",
            "date_published": "2022-12-14T21:35:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Anyone using the <code>tendermint-light-client</code> and related packages to perform light client verification (e.g. IBC-rs, Hermes).</p>\n<p>At present, the light client does not check that the chain IDs of the trusted and untrusted headers match, resulting in a possible attack vector where someone who finds a header from an untrusted chain that satisfies all other verification conditions (e.g. enough overlapping validator signatures) could fool a light client.</p>\n<p>The attack vector is currently theoretical, and no proof-of-concept exists yet to exploit it on live networks.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users of the light client-related crates can currently upgrade to <code>v0.28.0</code>.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tendermint/tendermint/tree/main/spec/light-client\">Light Client specification</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18\">https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23507\">https://nvd.nist.gov/vuln/detail/CVE-2022-23507</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5",
            "title": "[tendermint-light-client] Tendermint light client verification not taking into account chain ID",
            "date_modified": "2022-12-15T22:00:22.000Z",
            "date_published": "2022-12-14T21:35:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Anyone using the <code>tendermint-light-client</code> and related packages to perform light client verification (e.g. IBC-rs, Hermes).</p>\n<p>At present, the light client does not check that the chain IDs of the trusted and untrusted headers match, resulting in a possible attack vector where someone who finds a header from an untrusted chain that satisfies all other verification conditions (e.g. enough overlapping validator signatures) could fool a light client.</p>\n<p>The attack vector is currently theoretical, and no proof-of-concept exists yet to exploit it on live networks.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users of the light client-related crates can currently upgrade to <code>v0.28.0</code>.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tendermint/tendermint/tree/main/spec/light-client\">Light Client specification</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18\">https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23507\">https://nvd.nist.gov/vuln/detail/CVE-2022-23507</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5",
            "title": "[tendermint-light-client-verifier] Tendermint light client verification not taking into account chain ID",
            "date_modified": "2022-12-15T22:00:22.000Z",
            "date_published": "2022-12-14T21:35:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The linux-loader crate used the offsets and sizes provided in the ELF headers to determine the offsets to read from. If those offsets pointed beyond the end of the file this could lead to an infinite loop. Virtual Machine Monitors using the <code>linux-loader</code> crate could enter an infinite loop if the ELF header of the kernel they are loading was modified in a malicious manner.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue has been addressed in 0.8.1</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The issue can be mitigated by ensuring that only trusted kernel images are loaded or by verifying that the headers to not point beyond the end of the file.</p>\n<h3 id=\"references\">References</h3>\n<p>See: <a href=\"https://github.com/rust-vmm/linux-loader/pull/125\">https://github.com/rust-vmm/linux-loader/pull/125</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-vmm/linux-loader/security/advisories/GHSA-52h2-m2cf-9jh6\">https://github.com/rust-vmm/linux-loader/security/advisories/GHSA-52h2-m2cf-9jh6</a></li>\n<li><a href=\"https://github.com/rust-vmm/linux-loader/commit/a44f152da4f38c538ed492b1efa8515be2047db2\">https://github.com/rust-vmm/linux-loader/commit/a44f152da4f38c538ed492b1efa8515be2047db2</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23523\">https://nvd.nist.gov/vuln/detail/CVE-2022-23523</a></li>\n<li><a href=\"https://github.com/rust-vmm/linux-loader/pull/125\">https://github.com/rust-vmm/linux-loader/pull/125</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-52h2-m2cf-9jh6\">https://github.com/advisories/GHSA-52h2-m2cf-9jh6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-52h2-m2cf-9jh6",
            "title": "[linux-loader] linux-loader reading beyond EOF could lead to infinite loop",
            "date_modified": "2022-12-15T22:00:47.000Z",
            "date_published": "2022-12-12T22:35:41.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-52h2-m2cf-9jh6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A problem with Candy Machine V2 allow minting NFTs to an arbitrary collection due to a missing check.</p>\n<p>Here is a description of the exploit:\nDetails:\nHere is the tx/ix to exploit:\nTransaction:\nIx 1: candy_machine v2, mint_nft, passing in empty metadata -1\nIx 2: custom handler, 0\n        cpi A --&gt; token_metadata create_metadata_account, creates NFT\n        cpi B --&gt; candy_machine v2, set_collection_during_mint\nIx 1 passes our first check for empty metadata, but eventually will hit a bot tax and return Ok.  We do have a CPI check in this function but even if we hit that or moved it to the top, it returns Ok as a bot tax and still enables the issue.\nIx 2, cpi A is Ok and mints an arbitrary NFT.\nIx 2, cpi B checks the previous instruction using index_relative_to_current-1.  This turns out to be Ix 1 which was Ok, so then your newly minted arbitrary NFT is successfully added to the collection.\nConclusion:\nCandy machine could be out of NFTs and it still works.  If the CM is closed, (we think?) it doesn't get to the check.\nThe fix needs to be in set_collection_during_mint that current program ID id candy_machine_v2.  It checks previous program ID but doesn't check current.</p>\n<p>NOTE: THIS DOES NOT AFFECT Cmv3</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-9v25-r5q2-2p6w\">https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-9v25-r5q2-2p6w</a></li>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/commit/e6b3aff603ac06236bf77c2ec21ead93c6836dce\">https://github.com/metaplex-foundation/metaplex-program-library/commit/e6b3aff603ac06236bf77c2ec21ead93c6836dce</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9v25-r5q2-2p6w\">https://github.com/advisories/GHSA-9v25-r5q2-2p6w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9v25-r5q2-2p6w",
            "title": "[mpl-candy-machine] Candy Machine Set Collection During Mint Missing Check",
            "date_modified": "2022-12-12T22:03:21.000Z",
            "date_published": "2022-12-12T22:03:19.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9v25-r5q2-2p6w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>This was an error found by @metamania01 of the Audit Company Solshield.</p>\n<p>It allowed one to verify a creator that did not sign by making use of a provision in Token Metadata that allows Creators who have signed compressed nfts to allow them to decompress with verified creators.</p>\n<p>The issue is now patched.\nFor more info see.\n<a href=\"https://twitter.com/thehasheddude/status/1601642138143375360\">https://twitter.com/thehasheddude/status/1601642138143375360</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-8r76-fr72-j32w\">https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-8r76-fr72-j32w</a></li>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/commit/c18591a7ce9bb561940cb94df4b7c35ef9cc0f57\">https://github.com/metaplex-foundation/metaplex-program-library/commit/c18591a7ce9bb561940cb94df4b7c35ef9cc0f57</a></li>\n<li><a href=\"https://twitter.com/thehasheddude/status/1601642138143375360\">https://twitter.com/thehasheddude/status/1601642138143375360</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8r76-fr72-j32w\">https://github.com/advisories/GHSA-8r76-fr72-j32w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8r76-fr72-j32w",
            "title": "[mpl-token-metadata] Creator Verification Error when Bubblegum Activate",
            "date_modified": "2022-12-12T22:02:45.000Z",
            "date_published": "2022-12-12T22:02:42.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8r76-fr72-j32w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>This was an error found by @metamania01 of the Audit Company Solshield.</p>\n<p>It allowed one to verify a creator that did not sign by making use of a provision in Token Metadata that allows Creators who have signed compressed nfts to allow them to decompress with verified creators.</p>\n<p>The issue is now patched.\nFor more info see.\n<a href=\"https://twitter.com/thehasheddude/status/1601642138143375360\">https://twitter.com/thehasheddude/status/1601642138143375360</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-8r76-fr72-j32w\">https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-8r76-fr72-j32w</a></li>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/commit/c18591a7ce9bb561940cb94df4b7c35ef9cc0f57\">https://github.com/metaplex-foundation/metaplex-program-library/commit/c18591a7ce9bb561940cb94df4b7c35ef9cc0f57</a></li>\n<li><a href=\"https://twitter.com/thehasheddude/status/1601642138143375360\">https://twitter.com/thehasheddude/status/1601642138143375360</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8r76-fr72-j32w\">https://github.com/advisories/GHSA-8r76-fr72-j32w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8r76-fr72-j32w",
            "title": "[mpl-bubblegum] Creator Verification Error when Bubblegum Activate",
            "date_modified": "2022-12-12T22:02:45.000Z",
            "date_published": "2022-12-12T22:02:42.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8r76-fr72-j32w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.</p>\n<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>\n<p>You are unaffected if you either</p>\n<ul>\n<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>\n<li>manually checked that your usage of the method is sound</li>\n<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>\n</ul>\n<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>\n<p>See the <a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">GitHub issue</a> for example \"exploit\" code and further discussion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0070.html\">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-969w-q74q-9j8v\">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v",
            "title": "[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code",
            "date_modified": "2022-12-08T16:00:29.000Z",
            "date_published": "2022-12-08T16:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.</p>\n<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>\n<p>You are unaffected if you either</p>\n<ul>\n<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>\n<li>manually checked that your usage of the method is sound</li>\n<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>\n</ul>\n<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>\n<p>See the <a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">GitHub issue</a> for example \"exploit\" code and further discussion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0070.html\">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-969w-q74q-9j8v\">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v",
            "title": "[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code",
            "date_modified": "2022-12-08T16:00:29.000Z",
            "date_published": "2022-12-08T16:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.</p>\n<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>\n<p>You are unaffected if you either</p>\n<ul>\n<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>\n<li>manually checked that your usage of the method is sound</li>\n<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>\n</ul>\n<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>\n<p>See the <a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">GitHub issue</a> for example \"exploit\" code and further discussion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0070.html\">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-969w-q74q-9j8v\">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v",
            "title": "[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code",
            "date_modified": "2022-12-08T16:00:29.000Z",
            "date_published": "2022-12-08T16:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Unix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.</p>\n<p>The affected functions from time 0.2.7 through 0.2.22 are:</p>\n<ul>\n<li><code>time::UtcOffset::local_offset_at</code></li>\n<li><code>time::UtcOffset::try_local_offset_at</code></li>\n<li><code>time::UtcOffset::current_local_offset</code></li>\n<li><code>time::UtcOffset::try_current_local_offset</code></li>\n<li><code>time::OffsetDateTime::now_local</code></li>\n<li><code>time::OffsetDateTime::try_now_local</code></li>\n</ul>\n<p>The affected functions in time 0.1 (all versions) are:</p>\n<ul>\n<li><code>at</code></li>\n<li><code>at_utc</code></li>\n<li><code>now</code></li>\n</ul>\n<p>Non-Unix targets (including Windows and wasm) are unaffected.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>In some versions of <code>time</code>, the internal method that determines the local offset has been modified to always return <code>None</code> on the affected operating systems. This has the effect of returning an <code>Err</code> on the <code>try_*</code> methods and <code>UTC</code> on the non-<code>try_*</code> methods. In later versions, <code>time</code> will attempt to determine the number of threads running in the process. If the process is single-threaded, the call will proceed as its safety invariant is upheld.</p>\n<p>Users and library authors with time in their dependency tree must perform <code>cargo update</code>, which will pull in the updated, unaffected code.</p>\n<p>Users of time 0.1 do not have a patch and must upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Library authors must ensure that the program only has one running thread at the time of calling any affected method. Binary authors may do the same and/or ensure that no other thread is actively mutating the environment.</p>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://github.com/time-rs/time/issues/293\">time-rs/time#293</a>.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396\">https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-26235\">https://nvd.nist.gov/vuln/detail/CVE-2020-26235</a></li>\n<li><a href=\"https://github.com/time-rs/time/issues/293\">https://github.com/time-rs/time/issues/293</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0071.html\">https://rustsec.org/advisories/RUSTSEC-2020-0071.html</a></li>\n<li><a href=\"https://crates.io/crates/time/0.2.23\">https://crates.io/crates/time/0.2.23</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wcg3-cvx6-7396\">https://github.com/advisories/GHSA-wcg3-cvx6-7396</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wcg3-cvx6-7396",
            "title": "[time] Segmentation fault in time",
            "date_modified": "2022-12-08T00:54:17.000Z",
            "date_published": "2021-08-25T20:56:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wcg3-cvx6-7396"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>An attacker node can cause a victim node to allocate a large number of small memory chunks, which can ultimately lead to the victim’s process running out of memory and thus getting killed by its operating system. When executed continuously, this can lead to a denial of service attack, especially relevant on a larger scale when run against more than one node of a libp2p based network.</p>\n<h3 id=\"details\">Details</h3>\n<p>In the original version of the attack, the malicious node would continuously open new streams on a single connection using a stream multiplexer that doesn’t provide sufficient back pressure (mplex or yamux). While allocations per stream might be considered small, they multiply with the number of streams and connections. It is easy to defend against this one attack, e.g. by setting a strict per connection stream limit and connection limit. But there are other variations of this attack, e.g. causing memory allocations by sending partial payloads on various protocol levels, forcing the victim to buffer the partial payload for a period of time or by tricking the victim into pre-allocating buffers for messages which are never sent by the attacker.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users are advised to upgrade to <code>libp2p</code> <code>v0.45.1</code> or above.</p>\n<h3 id=\"references\">References</h3>\n<p>Please see our DoS Mitigation page for more information on how to incorporate mitigation strategies, monitor your application, and respond to attacks: <a href=\"https://docs.libp2p.io/reference/dos-mitigation/\">https://docs.libp2p.io/reference/dos-mitigation/</a>.</p>\n<p>Please see the related disclosure for go-libp2p: <a href=\"https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw\">https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw</a> and js-libp2p: <a href=\"https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv\">https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv</a></p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory, please email us at <a href=\"mailto:security@libp2p.io\">security@libp2p.io</a>.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw\">https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw</a></li>\n<li><a href=\"https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv\">https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv</a></li>\n<li><a href=\"https://github.com/libp2p/rust-libp2p/security/advisories/GHSA-jvgw-gccv-q5p8\">https://github.com/libp2p/rust-libp2p/security/advisories/GHSA-jvgw-gccv-q5p8</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23486\">https://nvd.nist.gov/vuln/detail/CVE-2022-23486</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jvgw-gccv-q5p8\">https://github.com/advisories/GHSA-jvgw-gccv-q5p8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jvgw-gccv-q5p8",
            "title": "[libp2p] libp2p DoS vulnerability from lack of resource management",
            "date_modified": "2022-12-20T05:04:23.000Z",
            "date_published": "2022-12-07T20:28:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jvgw-gccv-q5p8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Unix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.</p>\n<p>The affected functions from time 0.2.7 through 0.2.22 are:</p>\n<ul>\n<li><code>time::UtcOffset::local_offset_at</code></li>\n<li><code>time::UtcOffset::try_local_offset_at</code></li>\n<li><code>time::UtcOffset::current_local_offset</code></li>\n<li><code>time::UtcOffset::try_current_local_offset</code></li>\n<li><code>time::OffsetDateTime::now_local</code></li>\n<li><code>time::OffsetDateTime::try_now_local</code></li>\n</ul>\n<p>The affected functions in time 0.1 (all versions) are:</p>\n<ul>\n<li><code>at</code></li>\n<li><code>at_utc</code></li>\n<li><code>now</code></li>\n</ul>\n<p>Non-Unix targets (including Windows and wasm) are unaffected.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>In some versions of <code>time</code>, the internal method that determines the local offset has been modified to always return <code>None</code> on the affected operating systems. This has the effect of returning an <code>Err</code> on the <code>try_*</code> methods and <code>UTC</code> on the non-<code>try_*</code> methods. In later versions, <code>time</code> will attempt to determine the number of threads running in the process. If the process is single-threaded, the call will proceed as its safety invariant is upheld.</p>\n<p>Users and library authors with time in their dependency tree must perform <code>cargo update</code>, which will pull in the updated, unaffected code.</p>\n<p>Users of time 0.1 do not have a patch and must upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Library authors must ensure that the program only has one running thread at the time of calling any affected method. Binary authors may do the same and/or ensure that no other thread is actively mutating the environment.</p>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://github.com/time-rs/time/issues/293\">time-rs/time#293</a>.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396\">https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-26235\">https://nvd.nist.gov/vuln/detail/CVE-2020-26235</a></li>\n<li><a href=\"https://github.com/time-rs/time/issues/293\">https://github.com/time-rs/time/issues/293</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0071.html\">https://rustsec.org/advisories/RUSTSEC-2020-0071.html</a></li>\n<li><a href=\"https://crates.io/crates/time/0.2.23\">https://crates.io/crates/time/0.2.23</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wcg3-cvx6-7396\">https://github.com/advisories/GHSA-wcg3-cvx6-7396</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wcg3-cvx6-7396",
            "title": "[time] Segmentation fault in time",
            "date_modified": "2022-12-08T00:54:17.000Z",
            "date_published": "2021-08-25T20:56:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wcg3-cvx6-7396"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Path resolution in <code>hyper-staticfile</code> didn't correctly validate Windows paths, meaning paths like <code>/foo/bar/c:/windows/web/screen/img101.png</code> would be allowed and respond with the contents of <code>c:/windows/web/screen/img101.png</code>. Thus users could potentially read files anywhere on the filesystem.</p>\n<p>This only impacts Windows. Linux and other unix likes are not impacted by this.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/stephank/hyper-staticfile/issues/35\">https://github.com/stephank/hyper-staticfile/issues/35</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0069.html\">https://rustsec.org/advisories/RUSTSEC-2022-0069.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7p7c-pvvx-2vx3\">https://github.com/advisories/GHSA-7p7c-pvvx-2vx3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7p7c-pvvx-2vx3",
            "title": "[hyper-staticfile] hyper-staticfile's improper validation of Windows paths could lead to directory traversal attack",
            "date_modified": "2022-12-05T22:03:48.000Z",
            "date_published": "2022-12-05T22:03:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7p7c-pvvx-2vx3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Path resolution in <code>hyper-staticfile</code> didn't correctly validate Windows paths, meaning paths like <code>/foo/bar/c:/windows/web/screen/img101.png</code> would be allowed and respond with the contents of <code>c:/windows/web/screen/img101.png</code>. Thus users could potentially read files anywhere on the filesystem.</p>\n<p>This only impacts Windows. Linux and other unix likes are not impacted by this.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/stephank/hyper-staticfile/issues/35\">https://github.com/stephank/hyper-staticfile/issues/35</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0069.html\">https://rustsec.org/advisories/RUSTSEC-2022-0069.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7p7c-pvvx-2vx3\">https://github.com/advisories/GHSA-7p7c-pvvx-2vx3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7p7c-pvvx-2vx3",
            "title": "[hyper-staticfile] hyper-staticfile's improper validation of Windows paths could lead to directory traversal attack",
            "date_modified": "2022-12-05T22:03:48.000Z",
            "date_published": "2022-12-05T22:03:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7p7c-pvvx-2vx3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The Cap'n Proto library and capnp Rust package are vulnerable to out-of-bounds read due to logic error handling list-of-list. If a message consumer expects data of type \"list of pointers\", and if the consumer performs certain specific actions on such data, then a message producer can cause the consumer to read out-of-bounds memory. This could trigger a process crash in the consumer, or in some cases could allow exfiltration of private in-memory data.</p>\n<h1 id=\"impact\">Impact</h1>\n<ul>\n<li>Remotely segfault a peer by sending it a malicious message, if the victim performs certain actions on a list-of-pointer type.</li>\n<li>Possible exfiltration of memory, if the victim performs additional certain actions on a list-of-pointer type.</li>\n<li>To be vulnerable, an application must perform a specific sequence of actions, described below. At present, <strong>we are not aware of any vulnerable application</strong>, but we advise updating regardless.</li>\n</ul>\n<h1 id=\"fixed-in\">Fixed in</h1>\n<p>Unfortunately, the bug is present in inlined code, therefore the fix will require rebuilding dependent applications.</p>\n<p>C++ fix:</p>\n<ul>\n<li>git commit <a href=\"https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9\">25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>\n<li>release 0.11 (future)</li>\n<li>release 0.10.3:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.10.3.tar.gz\">https://capnproto.org/capnproto-c++-0.10.3.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.10.3.zip\">https://capnproto.org/capnproto-c++-win32-0.10.3.zip</a></li>\n</ul>\n</li>\n<li>release 0.9.2:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.9.2.tar.gz\">https://capnproto.org/capnproto-c++-0.9.2.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.9.2.zip\">https://capnproto.org/capnproto-c++-win32-0.9.2.zip</a></li>\n</ul>\n</li>\n<li>release 0.8.1:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.8.1.tar.gz\">https://capnproto.org/capnproto-c++-0.8.1.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.8.1.zip\">https://capnproto.org/capnproto-c++-win32-0.8.1.zip</a></li>\n</ul>\n</li>\n<li>release 0.7.1:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.7.1.tar.gz\">https://capnproto.org/capnproto-c++-0.7.1.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.7.1.zip\">https://capnproto.org/capnproto-c++-win32-0.7.1.zip</a></li>\n</ul>\n</li>\n<li>release 0.5.4:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.5.4.tar.gz\">https://capnproto.org/capnproto-c++-0.5.4.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.5.4.zip\">https://capnproto.org/capnproto-c++-win32-0.5.4.zip</a></li>\n</ul>\n</li>\n</ul>\n<p>Rust fix:</p>\n<ul>\n<li><code>capnp</code> crate version <code>0.15.2</code>, <code>0.14.11</code>, or <code>0.13.7</code></li>\n</ul>\n<h1 id=\"details\">Details</h1>\n<p>A specially-crafted pointer could escape bounds checking by exploiting inconsistent handling of pointers when a list-of-structs is downgraded to a list-of-pointers.</p>\n<p>For an in-depth explanation of how this bug works, see <a href=\"https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html\">David Renshaw's blog post</a>. This details below focus only on determining whether an application is vulnerable.</p>\n<p>In order to be vulnerable, an application must have certain properties.</p>\n<p>First, the application must accept messages with a schema in which a field has list-of-pointer type. This includes <code>List(Text)</code>, <code>List(Data)</code>, <code>List(List(T))</code>, or <code>List(C)</code> where <code>C</code> is an interface type. In the following discussion, we will assume this field is named <code>foo</code>.</p>\n<p>Second, the application must accept a message of this schema from a malicious source, where the attacker can maliciously encode the pointer representing the field <code>foo</code>.</p>\n<p>Third, the application must call <code>getFoo()</code> to obtain a <code>List&lt;T&gt;::Reader</code> for the field, and then use it in one of the following two ways:</p>\n<ol>\n<li><p>Pass it as the parameter to another message's <code>setFoo()</code>, thus copying the field into a new message. Note that copying the parent struct as a whole will <em>not</em> trigger the bug; the bug only occurs if the specific field <code>foo</code> is get/set on its own.</p>\n</li>\n<li><p>Convert it into <code>AnyList::Reader</code>, and then attempt to access it through that. This is much less likely; very few apps use the <code>AnyList</code> API.</p>\n</li>\n</ol>\n<p>The dynamic API equivalents of these actions (<code>capnp/dynamic.h</code>) are also affected.</p>\n<p>If the application does these steps, the attacker may be able to cause the Cap'n Proto implementation to read beyond the end of the message. This could induce a segmentation fault. Or, worse, data that happened to be in memory immediately after the message might be returned as if it were part of the message. In the latter case, if the application then forwards that data back to the attacker or sends it to another third party, this could result in exfiltration of secrets.</p>\n<p>Any exfiltration of data would have the following limitations:</p>\n<ul>\n<li>The attacker could exfiltrate no more than 512 KiB of memory immediately following the message buffer.<ul>\n<li>The attacker chooses in advance how far past the end of the message to read.</li>\n<li>The attacker's message itself must be larger than the exfiltrated data. Note that a sufficiently large message buffer will likely be allocated using mmap() in which case the attack will likely segfault.</li>\n</ul>\n</li>\n<li>The attack can only work if the 8 bytes immediately following the exfiltrated data contains a valid in-bounds Cap'n Proto pointer. The easiest way to achieve this is if the pointer is null, i.e. 8 bytes of zero.<ul>\n<li>The attacker must specify exactly how much data to exfiltrate, so must guess exactly where such a valid pointer will exist.</li>\n<li>If the exfiltrated data is not followed by a valid pointer, the attack will throw an exception. If an application has chosen to ignore exceptions (e.g. by compiling with <code>-fno-exceptions</code> and not registering an alternative exception callback) then the attack may be able to proceed anyway.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx\">https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-46149\">https://nvd.nist.gov/vuln/detail/CVE-2022-46149</a></li>\n<li><a href=\"https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9\">https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>\n<li><a href=\"https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html\">https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html</a></li>\n<li><a href=\"https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md\">https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0068.html\">https://rustsec.org/advisories/RUSTSEC-2022-0068.html</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EAHKLUMJAXJEV5BPBS5XXWBQ3ZTHGOLY/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EAHKLUMJAXJEV5BPBS5XXWBQ3ZTHGOLY/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PTS6TWD6K2NKXLEEFBPROQXMOFUTEYWY/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PTS6TWD6K2NKXLEEFBPROQXMOFUTEYWY/</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-qqff-4vw4-f6hx\">https://github.com/advisories/GHSA-qqff-4vw4-f6hx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-qqff-4vw4-f6hx",
            "title": "[capnp] Cap'n Proto and its Rust implementation vulnerable to out-of-bounds read due to logic error handling list-of-list",
            "date_modified": "2022-12-12T20:50:30.000Z",
            "date_published": "2022-12-05T17:58:16.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-qqff-4vw4-f6hx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The Cap'n Proto library and capnp Rust package are vulnerable to out-of-bounds read due to logic error handling list-of-list. If a message consumer expects data of type \"list of pointers\", and if the consumer performs certain specific actions on such data, then a message producer can cause the consumer to read out-of-bounds memory. This could trigger a process crash in the consumer, or in some cases could allow exfiltration of private in-memory data.</p>\n<h1 id=\"impact\">Impact</h1>\n<ul>\n<li>Remotely segfault a peer by sending it a malicious message, if the victim performs certain actions on a list-of-pointer type.</li>\n<li>Possible exfiltration of memory, if the victim performs additional certain actions on a list-of-pointer type.</li>\n<li>To be vulnerable, an application must perform a specific sequence of actions, described below. At present, <strong>we are not aware of any vulnerable application</strong>, but we advise updating regardless.</li>\n</ul>\n<h1 id=\"fixed-in\">Fixed in</h1>\n<p>Unfortunately, the bug is present in inlined code, therefore the fix will require rebuilding dependent applications.</p>\n<p>C++ fix:</p>\n<ul>\n<li>git commit <a href=\"https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9\">25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>\n<li>release 0.11 (future)</li>\n<li>release 0.10.3:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.10.3.tar.gz\">https://capnproto.org/capnproto-c++-0.10.3.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.10.3.zip\">https://capnproto.org/capnproto-c++-win32-0.10.3.zip</a></li>\n</ul>\n</li>\n<li>release 0.9.2:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.9.2.tar.gz\">https://capnproto.org/capnproto-c++-0.9.2.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.9.2.zip\">https://capnproto.org/capnproto-c++-win32-0.9.2.zip</a></li>\n</ul>\n</li>\n<li>release 0.8.1:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.8.1.tar.gz\">https://capnproto.org/capnproto-c++-0.8.1.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.8.1.zip\">https://capnproto.org/capnproto-c++-win32-0.8.1.zip</a></li>\n</ul>\n</li>\n<li>release 0.7.1:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.7.1.tar.gz\">https://capnproto.org/capnproto-c++-0.7.1.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.7.1.zip\">https://capnproto.org/capnproto-c++-win32-0.7.1.zip</a></li>\n</ul>\n</li>\n<li>release 0.5.4:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.5.4.tar.gz\">https://capnproto.org/capnproto-c++-0.5.4.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.5.4.zip\">https://capnproto.org/capnproto-c++-win32-0.5.4.zip</a></li>\n</ul>\n</li>\n</ul>\n<p>Rust fix:</p>\n<ul>\n<li><code>capnp</code> crate version <code>0.15.2</code>, <code>0.14.11</code>, or <code>0.13.7</code></li>\n</ul>\n<h1 id=\"details\">Details</h1>\n<p>A specially-crafted pointer could escape bounds checking by exploiting inconsistent handling of pointers when a list-of-structs is downgraded to a list-of-pointers.</p>\n<p>For an in-depth explanation of how this bug works, see <a href=\"https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html\">David Renshaw's blog post</a>. This details below focus only on determining whether an application is vulnerable.</p>\n<p>In order to be vulnerable, an application must have certain properties.</p>\n<p>First, the application must accept messages with a schema in which a field has list-of-pointer type. This includes <code>List(Text)</code>, <code>List(Data)</code>, <code>List(List(T))</code>, or <code>List(C)</code> where <code>C</code> is an interface type. In the following discussion, we will assume this field is named <code>foo</code>.</p>\n<p>Second, the application must accept a message of this schema from a malicious source, where the attacker can maliciously encode the pointer representing the field <code>foo</code>.</p>\n<p>Third, the application must call <code>getFoo()</code> to obtain a <code>List&lt;T&gt;::Reader</code> for the field, and then use it in one of the following two ways:</p>\n<ol>\n<li><p>Pass it as the parameter to another message's <code>setFoo()</code>, thus copying the field into a new message. Note that copying the parent struct as a whole will <em>not</em> trigger the bug; the bug only occurs if the specific field <code>foo</code> is get/set on its own.</p>\n</li>\n<li><p>Convert it into <code>AnyList::Reader</code>, and then attempt to access it through that. This is much less likely; very few apps use the <code>AnyList</code> API.</p>\n</li>\n</ol>\n<p>The dynamic API equivalents of these actions (<code>capnp/dynamic.h</code>) are also affected.</p>\n<p>If the application does these steps, the attacker may be able to cause the Cap'n Proto implementation to read beyond the end of the message. This could induce a segmentation fault. Or, worse, data that happened to be in memory immediately after the message might be returned as if it were part of the message. In the latter case, if the application then forwards that data back to the attacker or sends it to another third party, this could result in exfiltration of secrets.</p>\n<p>Any exfiltration of data would have the following limitations:</p>\n<ul>\n<li>The attacker could exfiltrate no more than 512 KiB of memory immediately following the message buffer.<ul>\n<li>The attacker chooses in advance how far past the end of the message to read.</li>\n<li>The attacker's message itself must be larger than the exfiltrated data. Note that a sufficiently large message buffer will likely be allocated using mmap() in which case the attack will likely segfault.</li>\n</ul>\n</li>\n<li>The attack can only work if the 8 bytes immediately following the exfiltrated data contains a valid in-bounds Cap'n Proto pointer. The easiest way to achieve this is if the pointer is null, i.e. 8 bytes of zero.<ul>\n<li>The attacker must specify exactly how much data to exfiltrate, so must guess exactly where such a valid pointer will exist.</li>\n<li>If the exfiltrated data is not followed by a valid pointer, the attack will throw an exception. If an application has chosen to ignore exceptions (e.g. by compiling with <code>-fno-exceptions</code> and not registering an alternative exception callback) then the attack may be able to proceed anyway.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx\">https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-46149\">https://nvd.nist.gov/vuln/detail/CVE-2022-46149</a></li>\n<li><a href=\"https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9\">https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>\n<li><a href=\"https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html\">https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html</a></li>\n<li><a href=\"https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md\">https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0068.html\">https://rustsec.org/advisories/RUSTSEC-2022-0068.html</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EAHKLUMJAXJEV5BPBS5XXWBQ3ZTHGOLY/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EAHKLUMJAXJEV5BPBS5XXWBQ3ZTHGOLY/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PTS6TWD6K2NKXLEEFBPROQXMOFUTEYWY/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PTS6TWD6K2NKXLEEFBPROQXMOFUTEYWY/</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-qqff-4vw4-f6hx\">https://github.com/advisories/GHSA-qqff-4vw4-f6hx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-qqff-4vw4-f6hx",
            "title": "[capnp] Cap'n Proto and its Rust implementation vulnerable to out-of-bounds read due to logic error handling list-of-list",
            "date_modified": "2022-12-12T20:50:30.000Z",
            "date_published": "2022-12-05T17:58:16.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-qqff-4vw4-f6hx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The Cap'n Proto library and capnp Rust package are vulnerable to out-of-bounds read due to logic error handling list-of-list. If a message consumer expects data of type \"list of pointers\", and if the consumer performs certain specific actions on such data, then a message producer can cause the consumer to read out-of-bounds memory. This could trigger a process crash in the consumer, or in some cases could allow exfiltration of private in-memory data.</p>\n<h1 id=\"impact\">Impact</h1>\n<ul>\n<li>Remotely segfault a peer by sending it a malicious message, if the victim performs certain actions on a list-of-pointer type.</li>\n<li>Possible exfiltration of memory, if the victim performs additional certain actions on a list-of-pointer type.</li>\n<li>To be vulnerable, an application must perform a specific sequence of actions, described below. At present, <strong>we are not aware of any vulnerable application</strong>, but we advise updating regardless.</li>\n</ul>\n<h1 id=\"fixed-in\">Fixed in</h1>\n<p>Unfortunately, the bug is present in inlined code, therefore the fix will require rebuilding dependent applications.</p>\n<p>C++ fix:</p>\n<ul>\n<li>git commit <a href=\"https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9\">25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>\n<li>release 0.11 (future)</li>\n<li>release 0.10.3:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.10.3.tar.gz\">https://capnproto.org/capnproto-c++-0.10.3.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.10.3.zip\">https://capnproto.org/capnproto-c++-win32-0.10.3.zip</a></li>\n</ul>\n</li>\n<li>release 0.9.2:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.9.2.tar.gz\">https://capnproto.org/capnproto-c++-0.9.2.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.9.2.zip\">https://capnproto.org/capnproto-c++-win32-0.9.2.zip</a></li>\n</ul>\n</li>\n<li>release 0.8.1:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.8.1.tar.gz\">https://capnproto.org/capnproto-c++-0.8.1.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.8.1.zip\">https://capnproto.org/capnproto-c++-win32-0.8.1.zip</a></li>\n</ul>\n</li>\n<li>release 0.7.1:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.7.1.tar.gz\">https://capnproto.org/capnproto-c++-0.7.1.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.7.1.zip\">https://capnproto.org/capnproto-c++-win32-0.7.1.zip</a></li>\n</ul>\n</li>\n<li>release 0.5.4:<ul>\n<li>Unix: <a href=\"https://capnproto.org/capnproto-c++-0.5.4.tar.gz\">https://capnproto.org/capnproto-c++-0.5.4.tar.gz</a></li>\n<li>Windows: <a href=\"https://capnproto.org/capnproto-c++-win32-0.5.4.zip\">https://capnproto.org/capnproto-c++-win32-0.5.4.zip</a></li>\n</ul>\n</li>\n</ul>\n<p>Rust fix:</p>\n<ul>\n<li><code>capnp</code> crate version <code>0.15.2</code>, <code>0.14.11</code>, or <code>0.13.7</code></li>\n</ul>\n<h1 id=\"details\">Details</h1>\n<p>A specially-crafted pointer could escape bounds checking by exploiting inconsistent handling of pointers when a list-of-structs is downgraded to a list-of-pointers.</p>\n<p>For an in-depth explanation of how this bug works, see <a href=\"https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html\">David Renshaw's blog post</a>. This details below focus only on determining whether an application is vulnerable.</p>\n<p>In order to be vulnerable, an application must have certain properties.</p>\n<p>First, the application must accept messages with a schema in which a field has list-of-pointer type. This includes <code>List(Text)</code>, <code>List(Data)</code>, <code>List(List(T))</code>, or <code>List(C)</code> where <code>C</code> is an interface type. In the following discussion, we will assume this field is named <code>foo</code>.</p>\n<p>Second, the application must accept a message of this schema from a malicious source, where the attacker can maliciously encode the pointer representing the field <code>foo</code>.</p>\n<p>Third, the application must call <code>getFoo()</code> to obtain a <code>List&lt;T&gt;::Reader</code> for the field, and then use it in one of the following two ways:</p>\n<ol>\n<li><p>Pass it as the parameter to another message's <code>setFoo()</code>, thus copying the field into a new message. Note that copying the parent struct as a whole will <em>not</em> trigger the bug; the bug only occurs if the specific field <code>foo</code> is get/set on its own.</p>\n</li>\n<li><p>Convert it into <code>AnyList::Reader</code>, and then attempt to access it through that. This is much less likely; very few apps use the <code>AnyList</code> API.</p>\n</li>\n</ol>\n<p>The dynamic API equivalents of these actions (<code>capnp/dynamic.h</code>) are also affected.</p>\n<p>If the application does these steps, the attacker may be able to cause the Cap'n Proto implementation to read beyond the end of the message. This could induce a segmentation fault. Or, worse, data that happened to be in memory immediately after the message might be returned as if it were part of the message. In the latter case, if the application then forwards that data back to the attacker or sends it to another third party, this could result in exfiltration of secrets.</p>\n<p>Any exfiltration of data would have the following limitations:</p>\n<ul>\n<li>The attacker could exfiltrate no more than 512 KiB of memory immediately following the message buffer.<ul>\n<li>The attacker chooses in advance how far past the end of the message to read.</li>\n<li>The attacker's message itself must be larger than the exfiltrated data. Note that a sufficiently large message buffer will likely be allocated using mmap() in which case the attack will likely segfault.</li>\n</ul>\n</li>\n<li>The attack can only work if the 8 bytes immediately following the exfiltrated data contains a valid in-bounds Cap'n Proto pointer. The easiest way to achieve this is if the pointer is null, i.e. 8 bytes of zero.<ul>\n<li>The attacker must specify exactly how much data to exfiltrate, so must guess exactly where such a valid pointer will exist.</li>\n<li>If the exfiltrated data is not followed by a valid pointer, the attack will throw an exception. If an application has chosen to ignore exceptions (e.g. by compiling with <code>-fno-exceptions</code> and not registering an alternative exception callback) then the attack may be able to proceed anyway.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx\">https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-46149\">https://nvd.nist.gov/vuln/detail/CVE-2022-46149</a></li>\n<li><a href=\"https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9\">https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>\n<li><a href=\"https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html\">https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html</a></li>\n<li><a href=\"https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md\">https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0068.html\">https://rustsec.org/advisories/RUSTSEC-2022-0068.html</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EAHKLUMJAXJEV5BPBS5XXWBQ3ZTHGOLY/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EAHKLUMJAXJEV5BPBS5XXWBQ3ZTHGOLY/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PTS6TWD6K2NKXLEEFBPROQXMOFUTEYWY/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PTS6TWD6K2NKXLEEFBPROQXMOFUTEYWY/</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-qqff-4vw4-f6hx\">https://github.com/advisories/GHSA-qqff-4vw4-f6hx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-qqff-4vw4-f6hx",
            "title": "[capnp] Cap'n Proto and its Rust implementation vulnerable to out-of-bounds read due to logic error handling list-of-list",
            "date_modified": "2022-12-12T20:50:30.000Z",
            "date_published": "2022-12-05T17:58:16.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-qqff-4vw4-f6hx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p><code>Slock&lt;T&gt;</code> unconditionally implements <code>Send</code>/<code>Sync</code>.</p>\n<p>Affected versions of this crate allows sending non-Send types to other threads,\nwhich can lead to data races and memory corruption due to the data race.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/BrokenLamp/slock-rs/issues/2\">https://github.com/BrokenLamp/slock-rs/issues/2</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0135.html\">https://rustsec.org/advisories/RUSTSEC-2020-0135.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-83r8-p8v6-6gfm\">https://github.com/advisories/GHSA-83r8-p8v6-6gfm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-83r8-p8v6-6gfm",
            "title": "[slock] Slock<T> allows sending non-Send types across thread boundaries",
            "date_modified": "2022-11-28T16:02:43.000Z",
            "date_published": "2021-08-25T21:00:20.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-83r8-p8v6-6gfm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Users of this library will be affected when using this library, the incoming secret will be disclosed unintentionally.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This have already been solved.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>No, It cannot be patched without upgrading</p>\n<h3 id=\"references\">References</h3>\n<p>No</p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Email us at <a href=\"mailto:772364230@qq.com\">email address</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tu6ge/oss-rs/security/advisories/GHSA-3w3h-7xgx-grwc\">https://github.com/tu6ge/oss-rs/security/advisories/GHSA-3w3h-7xgx-grwc</a></li>\n<li><a href=\"https://github.com/tu6ge/oss-rs/commit/e4553f7d74fce682d802f8fb073943387796df29\">https://github.com/tu6ge/oss-rs/commit/e4553f7d74fce682d802f8fb073943387796df29</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-39397\">https://nvd.nist.gov/vuln/detail/CVE-2022-39397</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3w3h-7xgx-grwc\">https://github.com/advisories/GHSA-3w3h-7xgx-grwc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3w3h-7xgx-grwc",
            "title": "[aliyun-oss-client] Leakage Aliyun KeySecret ",
            "date_modified": "2022-11-28T15:51:56.000Z",
            "date_published": "2022-11-21T20:39:05.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3w3h-7xgx-grwc"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}