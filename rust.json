{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>If an iterator passed to SmallVec::insert_many panicked in Iterator::next, destructors were run during unwinding while the vector was in an inconsistent state, possibly causing a double free (a destructor running on two copies of the same value).</p>\n<p>This is fixed in smallvec 0.6.3 by ensuring that the vector's length is not updated to include moved items until they have been removed from their original positions. Items may now be leaked if Iterator::next panics, but they will not be dropped more than once.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-20991\">https://nvd.nist.gov/vuln/detail/CVE-2018-20991</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/96\">https://github.com/servo/rust-smallvec/issues/96</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0003.html\">https://rustsec.org/advisories/RUSTSEC-2018-0003.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rxr4-x558-x7hw\">https://github.com/advisories/GHSA-rxr4-x558-x7hw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rxr4-x558-x7hw",
            "title": "[smallvec] Double free in smallvec",
            "date_modified": "2023-06-13T20:58:32.000Z",
            "date_published": "2021-08-25T20:42:54.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rxr4-x558-x7hw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Attempting to call grow on a spilled SmallVec with a value equal to the current capacity causes it to free the existing data. This performs a double free immediately and may lead to use-after-free on subsequent accesses to the SmallVec contents. An attacker that controls the value passed to grow may exploit this flaw to obtain memory contents or gain remote code execution.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15551\">https://nvd.nist.gov/vuln/detail/CVE-2019-15551</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/148\">https://github.com/servo/rust-smallvec/issues/148</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0009.html\">https://rustsec.org/advisories/RUSTSEC-2019-0009.html</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/149\">https://github.com/servo/rust-smallvec/issues/149</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/commit/c20cfa8584e649f00dc0767ab6fad63a3f59a296\">https://github.com/servo/rust-smallvec/commit/c20cfa8584e649f00dc0767ab6fad63a3f59a296</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/commit/f96322b9243405cc82701cc73f1b19313b413ab4\">https://github.com/servo/rust-smallvec/commit/f96322b9243405cc82701cc73f1b19313b413ab4</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mm7v-vpv8-xfc3\">https://github.com/advisories/GHSA-mm7v-vpv8-xfc3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mm7v-vpv8-xfc3",
            "title": "[smallvec] Double free in smallvec",
            "date_modified": "2023-06-13T20:57:37.000Z",
            "date_published": "2021-08-25T20:44:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mm7v-vpv8-xfc3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p><code>Slock&lt;T&gt;</code> unconditionally implements <code>Send</code>/<code>Sync</code>.</p>\n<p>Affected versions of this crate allows sending non-Send types to other threads,\nwhich can lead to data races and memory corruption due to the data race.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/BrokenLamp/slock-rs/issues/2\">https://github.com/BrokenLamp/slock-rs/issues/2</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0135.html\">https://rustsec.org/advisories/RUSTSEC-2020-0135.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-83r8-p8v6-6gfm\">https://github.com/advisories/GHSA-83r8-p8v6-6gfm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-83r8-p8v6-6gfm",
            "title": "[slock] Slock<T> allows sending non-Send types across thread boundaries",
            "date_modified": "2023-06-13T20:56:17.000Z",
            "date_published": "2021-08-25T21:00:20.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-83r8-p8v6-6gfm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the spin crate before 0.5.2 for Rust, when RwLock is used. Because memory ordering is mishandled, two writers can acquire the lock at the same time, violating mutual exclusion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-16137\">https://nvd.nist.gov/vuln/detail/CVE-2019-16137</a></li>\n<li><a href=\"https://github.com/mvdnes/spin-rs/issues/65\">https://github.com/mvdnes/spin-rs/issues/65</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0013.html\">https://rustsec.org/advisories/RUSTSEC-2019-0013.html</a></li>\n<li><a href=\"https://github.com/mvdnes/spin-rs/pull/66\">https://github.com/mvdnes/spin-rs/pull/66</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hv7x-f3pv-gpwr\">https://github.com/advisories/GHSA-hv7x-f3pv-gpwr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hv7x-f3pv-gpwr",
            "title": "[spin] Wrong memory orderings violates mutual exclusion in spin",
            "date_modified": "2023-06-13T20:55:22.000Z",
            "date_published": "2021-08-25T20:44:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hv7x-f3pv-gpwr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of stack_dst used a push_inner function that increased the internal length of the array and then called val.clone(). If the val.clone() call panics, the stack could drop an already dropped element or drop uninitialized memory. This issue was fixed in <code>2a4d538</code> by increasing the length of the array after elements are cloned.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-28034\">https://nvd.nist.gov/vuln/detail/CVE-2021-28034</a></li>\n<li><a href=\"https://github.com/thepowersgang/stack_dst-rs/commit/2a4d53809e3000f40085f2b229b6b1a33759881d\">https://github.com/thepowersgang/stack_dst-rs/commit/2a4d53809e3000f40085f2b229b6b1a33759881d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0033.html\">https://rustsec.org/advisories/RUSTSEC-2021-0033.html</a></li>\n<li><a href=\"https://github.com/thepowersgang/stack_dst-rs/issues/5\">https://github.com/thepowersgang/stack_dst-rs/issues/5</a></li>\n<li><a href=\"https://github.com/thepowersgang/stack_dst-rs/commit/2a4d538\">https://github.com/thepowersgang/stack_dst-rs/commit/2a4d538</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8mjx-h23h-w2pg\">https://github.com/advisories/GHSA-8mjx-h23h-w2pg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8mjx-h23h-w2pg",
            "title": "[stack_dst] Double free in stack_dst",
            "date_modified": "2023-06-13T20:52:44.000Z",
            "date_published": "2021-09-01T18:30:44.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8mjx-h23h-w2pg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A bug in the SmallVec::insert_many method caused it to allocate a buffer that was smaller than needed. It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap. This bug was only triggered if the iterator passed to insert_many yielded more items than the lower bound returned from its size_hint method.</p>\n<p>The flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted. The fix also simplified the implementation of insert_many to use less unsafe code, so it is easier to verify its correctness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-25900\">https://nvd.nist.gov/vuln/detail/CVE-2021-25900</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0003.html\">https://rustsec.org/advisories/RUSTSEC-2021-0003.html</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/252\">https://github.com/servo/rust-smallvec/issues/252</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-43w2-9j62-hq99\">https://github.com/advisories/GHSA-43w2-9j62-hq99</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-43w2-9j62-hq99",
            "title": "[smallvec] Buffer overflow in SmallVec::insert_many",
            "date_modified": "2023-06-13T20:51:42.000Z",
            "date_published": "2022-05-24T17:40:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-43w2-9j62-hq99"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A bug in the SmallVec::insert_many method caused it to allocate a buffer that was smaller than needed. It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap. This bug was only triggered if the iterator passed to insert_many yielded more items than the lower bound returned from its size_hint method.</p>\n<p>The flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted. The fix also simplified the implementation of insert_many to use less unsafe code, so it is easier to verify its correctness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-25900\">https://nvd.nist.gov/vuln/detail/CVE-2021-25900</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0003.html\">https://rustsec.org/advisories/RUSTSEC-2021-0003.html</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/252\">https://github.com/servo/rust-smallvec/issues/252</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-43w2-9j62-hq99\">https://github.com/advisories/GHSA-43w2-9j62-hq99</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-43w2-9j62-hq99",
            "title": "[smallvec] Buffer overflow in SmallVec::insert_many",
            "date_modified": "2023-06-13T20:51:42.000Z",
            "date_published": "2022-05-24T17:40:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-43w2-9j62-hq99"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The affected version of rocket contains a Clone trait implementation of LocalRequest that reuses the pointer to inner Request object. This causes data race in rare combinations of APIs if the original and the cloned objects are modified at the same time.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35882\">https://nvd.nist.gov/vuln/detail/CVE-2020-35882</a></li>\n<li><a href=\"https://github.com/SergioBenitez/Rocket/issues/1312\">https://github.com/SergioBenitez/Rocket/issues/1312</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0028.html\">https://rustsec.org/advisories/RUSTSEC-2020-0028.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8q2v-67v7-6vc6\">https://github.com/advisories/GHSA-8q2v-67v7-6vc6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8q2v-67v7-6vc6",
            "title": "[rocket] Data races in rocket",
            "date_modified": "2023-06-13T20:48:28.000Z",
            "date_published": "2021-08-25T20:48:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8q2v-67v7-6vc6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via VTab / VTabCursor.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35866\">https://nvd.nist.gov/vuln/detail/CVE-2020-35866</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/commit/c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f\">https://github.com/rusqlite/rusqlite/commit/c9ef5bd63cad5c0c123344c072b490a1a9bcbe1f</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/releases/tag/0.23.0\">https://github.com/rusqlite/rusqlite/releases/tag/0.23.0</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0014.html\">https://rustsec.org/advisories/RUSTSEC-2020-0014.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6q5w-m3c5-rv95\">https://github.com/advisories/GHSA-6q5w-m3c5-rv95</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6q5w-m3c5-rv95",
            "title": "[rusqlite] Data races in rusqlite",
            "date_modified": "2023-06-13T20:46:26.000Z",
            "date_published": "2021-08-25T20:47:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6q5w-m3c5-rv95"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via create_module.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35867\">https://nvd.nist.gov/vuln/detail/CVE-2020-35867</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/commit/3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c\">https://github.com/rusqlite/rusqlite/commit/3c6b57fe1b2cc87e7ebecde43dd836ffb1c4ea5c</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/releases/tag/0.23.0\">https://github.com/rusqlite/rusqlite/releases/tag/0.23.0</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0014.html\">https://rustsec.org/advisories/RUSTSEC-2020-0014.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-28ph-f7gx-fqj8\">https://github.com/advisories/GHSA-28ph-f7gx-fqj8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-28ph-f7gx-fqj8",
            "title": "[rusqlite] Data races in rusqlite",
            "date_modified": "2023-06-13T20:46:22.000Z",
            "date_published": "2021-08-25T20:47:57.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-28ph-f7gx-fqj8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via UnlockNotification.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35868\">https://nvd.nist.gov/vuln/detail/CVE-2020-35868</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/commit/45fd77ee43c38eea4d6f4e2e56c1667a55ec654f\">https://github.com/rusqlite/rusqlite/commit/45fd77ee43c38eea4d6f4e2e56c1667a55ec654f</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/releases/tag/0.23.0\">https://github.com/rusqlite/rusqlite/releases/tag/0.23.0</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0014.html\">https://rustsec.org/advisories/RUSTSEC-2020-0014.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3cgf-9m6x-pwwr\">https://github.com/advisories/GHSA-3cgf-9m6x-pwwr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3cgf-9m6x-pwwr",
            "title": "[rusqlite] Data races in rusqlite",
            "date_modified": "2023-06-13T20:46:20.000Z",
            "date_published": "2021-08-25T20:47:50.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3cgf-9m6x-pwwr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated because rusqlite::trace::log mishandles format strings.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35869\">https://nvd.nist.gov/vuln/detail/CVE-2020-35869</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/commit/2327d3b774927fdf48903c0bdc1ca7ec93c7c8d0\">https://github.com/rusqlite/rusqlite/commit/2327d3b774927fdf48903c0bdc1ca7ec93c7c8d0</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/releases/tag/0.23.0\">https://github.com/rusqlite/rusqlite/releases/tag/0.23.0</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0014.html\">https://rustsec.org/advisories/RUSTSEC-2020-0014.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8r7q-r9mx-35rh\">https://github.com/advisories/GHSA-8r7q-r9mx-35rh</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8r7q-r9mx-35rh",
            "title": "[rusqlite] Mishandling of format strings in rusqlite",
            "date_modified": "2023-06-13T20:46:15.000Z",
            "date_published": "2021-08-25T20:47:18.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8r7q-r9mx-35rh"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate before 0.23.0 for Rust. Memory safety can be violated via an Auxdata API data race.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35871\">https://nvd.nist.gov/vuln/detail/CVE-2020-35871</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/commit/2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3\">https://github.com/rusqlite/rusqlite/commit/2ef3628dac35aeba0a97d5fb3a57746b4e1d62b3</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/releases/tag/0.23.0\">https://github.com/rusqlite/rusqlite/releases/tag/0.23.0</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0014.html\">https://rustsec.org/advisories/RUSTSEC-2020-0014.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rjh8-p66p-jrh5\">https://github.com/advisories/GHSA-rjh8-p66p-jrh5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rjh8-p66p-jrh5",
            "title": "[rusqlite] Data races in rusqlite",
            "date_modified": "2023-06-13T20:45:27.000Z",
            "date_published": "2021-08-25T20:46:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rjh8-p66p-jrh5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. create_window_function has a use-after-free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45715\">https://nvd.nist.gov/vuln/detail/CVE-2021-45715</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0128.html\">https://rustsec.org/advisories/RUSTSEC-2021-0128.html</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/issues/1048\">https://github.com/rusqlite/rusqlite/issues/1048</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-87xh-9q6h-r5cc\">https://github.com/advisories/GHSA-87xh-9q6h-r5cc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-87xh-9q6h-r5cc",
            "title": "[rusqlite] Use After Free in rusqlite",
            "date_modified": "2023-06-13T20:44:50.000Z",
            "date_published": "2022-01-06T22:00:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-87xh-9q6h-r5cc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. create_window_function has a use-after-free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45715\">https://nvd.nist.gov/vuln/detail/CVE-2021-45715</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0128.html\">https://rustsec.org/advisories/RUSTSEC-2021-0128.html</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/issues/1048\">https://github.com/rusqlite/rusqlite/issues/1048</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-87xh-9q6h-r5cc\">https://github.com/advisories/GHSA-87xh-9q6h-r5cc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-87xh-9q6h-r5cc",
            "title": "[rusqlite] Use After Free in rusqlite",
            "date_modified": "2023-06-13T20:44:50.000Z",
            "date_published": "2022-01-06T22:00:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-87xh-9q6h-r5cc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. create_aggregate_function has a use-after-free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45714\">https://nvd.nist.gov/vuln/detail/CVE-2021-45714</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0128.html\">https://rustsec.org/advisories/RUSTSEC-2021-0128.html</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/issues/1048\">https://github.com/rusqlite/rusqlite/issues/1048</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-f6f2-3w33-54r9\">https://github.com/advisories/GHSA-f6f2-3w33-54r9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-f6f2-3w33-54r9",
            "title": "[rusqlite] Use After Free in rusqlite",
            "date_modified": "2023-06-13T20:44:29.000Z",
            "date_published": "2022-01-06T22:02:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-f6f2-3w33-54r9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rusqlite crate 0.25.x before 0.25.4 and 0.26.x before 0.26.2 for Rust. create_aggregate_function has a use-after-free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45714\">https://nvd.nist.gov/vuln/detail/CVE-2021-45714</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/rusqlite/RUSTSEC-2021-0128.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0128.html\">https://rustsec.org/advisories/RUSTSEC-2021-0128.html</a></li>\n<li><a href=\"https://github.com/rusqlite/rusqlite/issues/1048\">https://github.com/rusqlite/rusqlite/issues/1048</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-f6f2-3w33-54r9\">https://github.com/advisories/GHSA-f6f2-3w33-54r9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-f6f2-3w33-54r9",
            "title": "[rusqlite] Use After Free in rusqlite",
            "date_modified": "2023-06-13T20:44:29.000Z",
            "date_published": "2022-01-06T22:02:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-f6f2-3w33-54r9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.</p>\n<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>\n<p>You are unaffected if you either</p>\n<ul>\n<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>\n<li>manually checked that your usage of the method is sound</li>\n<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>\n</ul>\n<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>\n<p>See the <a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">GitHub issue</a> for example \"exploit\" code and further discussion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0070.html\">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-969w-q74q-9j8v\">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v",
            "title": "[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code",
            "date_modified": "2023-06-13T20:43:58.000Z",
            "date_published": "2022-12-08T16:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.</p>\n<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>\n<p>You are unaffected if you either</p>\n<ul>\n<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>\n<li>manually checked that your usage of the method is sound</li>\n<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>\n</ul>\n<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>\n<p>See the <a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">GitHub issue</a> for example \"exploit\" code and further discussion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0070.html\">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-969w-q74q-9j8v\">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v",
            "title": "[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code",
            "date_modified": "2023-06-13T20:43:58.000Z",
            "date_published": "2022-12-08T16:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.</p>\n<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>\n<p>You are unaffected if you either</p>\n<ul>\n<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>\n<li>manually checked that your usage of the method is sound</li>\n<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>\n</ul>\n<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>\n<p>See the <a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">GitHub issue</a> for example \"exploit\" code and further discussion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0070.html\">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-969w-q74q-9j8v\">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v",
            "title": "[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code",
            "date_modified": "2023-06-13T20:43:58.000Z",
            "date_published": "2022-12-08T16:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}