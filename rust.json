{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>Affected versions contained a pair of use-after-free issues with the objects returned by the get_format_info and get_context methods of Stream objects. These objects were mistakenly being constructed without setting an important flag to prevent destruction of the underlying C objects they reference upon their own destruction.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-25028\">https://nvd.nist.gov/vuln/detail/CVE-2018-25028</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/libpulse-binding/RUSTSEC-2018-0021.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/libpulse-binding/RUSTSEC-2018-0021.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0021.html\">https://rustsec.org/advisories/RUSTSEC-2018-0021.html</a></li>\n<li><a href=\"https://github.com/jnqnfe/pulse-binding-rust/security/advisories/GHSA-ghpq-vjxw-ch5w\">https://github.com/jnqnfe/pulse-binding-rust/security/advisories/GHSA-ghpq-vjxw-ch5w</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jqpv-jm4m-86j9\">https://github.com/advisories/GHSA-jqpv-jm4m-86j9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jqpv-jm4m-86j9",
            "title": "[libpulse-binding] Use After Free in libpulse-binding",
            "date_modified": "2023-06-13T17:45:07.000Z",
            "date_published": "2022-01-06T22:17:50.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jqpv-jm4m-86j9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the libflate crate before 0.1.25 for Rust. MultiDecoder::read has a use-after-free, leading to arbitrary code execution.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15552\">https://nvd.nist.gov/vuln/detail/CVE-2019-15552</a></li>\n<li><a href=\"https://github.com/sile/libflate/issues/35\">https://github.com/sile/libflate/issues/35</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0010.html\">https://rustsec.org/advisories/RUSTSEC-2019-0010.html</a></li>\n<li><a href=\"https://github.com/sile/libflate/pull/37\">https://github.com/sile/libflate/pull/37</a></li>\n<li><a href=\"https://github.com/sile/libflate/commit/ffeff7c65deac5a6f886db2a59bcae4e420e4706\">https://github.com/sile/libflate/commit/ffeff7c65deac5a6f886db2a59bcae4e420e4706</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rpcm-whqc-jfw8\">https://github.com/advisories/GHSA-rpcm-whqc-jfw8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rpcm-whqc-jfw8",
            "title": "[libflate] Use after free in libflate",
            "date_modified": "2023-06-13T17:42:24.000Z",
            "date_published": "2021-08-25T20:44:53.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rpcm-whqc-jfw8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Affected versions of lettre allowed argument injection to the sendmail command. It was possible, using forged to addresses, to pass arbitrary arguments to the sendmail executable.</p>\n<p>Depending on the implementation (original sendmail, postfix, exim, etc.) it could be possible in some cases to write email data into abritrary files (using sendmail's logging features).</p>\n<p><em>NOTE</em>: This vulnerability only affects the sendmail transport. Others, including smtp, are not affected.</p>\n<h3 id=\"fix\">Fix</h3>\n<p>The flaw is corrected by modifying the executed command to stop parsing arguments before passing the destination addresses.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0069.html\">RUSTSEC-2020-0069</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-28247\">CVE-2020-28247</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/lettre/lettre/security/advisories/GHSA-vc2p-r46x-m3vx\">https://github.com/lettre/lettre/security/advisories/GHSA-vc2p-r46x-m3vx</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-28247\">https://nvd.nist.gov/vuln/detail/CVE-2020-28247</a></li>\n<li><a href=\"https://github.com/RustSec/advisory-db/pull/478/files\">https://github.com/RustSec/advisory-db/pull/478/files</a></li>\n<li><a href=\"https://github.com/lettre/lettre/pull/508/commits/bbe7cc5381c5380b54fb8bbb4f77a3725917ff0b\">https://github.com/lettre/lettre/pull/508/commits/bbe7cc5381c5380b54fb8bbb4f77a3725917ff0b</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0069.html\">https://rustsec.org/advisories/RUSTSEC-2020-0069.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vc2p-r46x-m3vx\">https://github.com/advisories/GHSA-vc2p-r46x-m3vx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vc2p-r46x-m3vx",
            "title": "[lettre] Argument injection in lettre",
            "date_modified": "2023-06-13T17:41:46.000Z",
            "date_published": "2021-08-25T20:56:48.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vc2p-r46x-m3vx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Serializing of headers to the socket did not filter the values for newline bytes (\\r or \\n), which allowed for header values to split a request or response. People would not likely include newlines in the headers in their own applications, so the way for most people to exploit this is if an application constructs headers based on unsanitized user input.</p>\n<p>This issue was fixed by replacing all newline characters with a space during serialization of a header value.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-18587\">https://nvd.nist.gov/vuln/detail/CVE-2017-18587</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2017-0002.html\">https://rustsec.org/advisories/RUSTSEC-2017-0002.html</a></li>\n<li><a href=\"https://github.com/hyperium/hyper/wiki/Security-001\">https://github.com/hyperium/hyper/wiki/Security-001</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q89x-f52w-6hj2\">https://github.com/advisories/GHSA-q89x-f52w-6hj2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q89x-f52w-6hj2",
            "title": "[hyper] Headers containing newline characters can split messages in hyper",
            "date_modified": "2023-06-13T17:39:47.000Z",
            "date_published": "2021-08-25T20:43:04.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q89x-f52w-6hj2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Serializing of headers to the socket did not filter the values for newline bytes (\\r or \\n), which allowed for header values to split a request or response. People would not likely include newlines in the headers in their own applications, so the way for most people to exploit this is if an application constructs headers based on unsanitized user input.</p>\n<p>This issue was fixed by replacing all newline characters with a space during serialization of a header value.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-18587\">https://nvd.nist.gov/vuln/detail/CVE-2017-18587</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2017-0002.html\">https://rustsec.org/advisories/RUSTSEC-2017-0002.html</a></li>\n<li><a href=\"https://github.com/hyperium/hyper/wiki/Security-001\">https://github.com/hyperium/hyper/wiki/Security-001</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q89x-f52w-6hj2\">https://github.com/advisories/GHSA-q89x-f52w-6hj2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q89x-f52w-6hj2",
            "title": "[hyper] Headers containing newline characters can split messages in hyper",
            "date_modified": "2023-06-13T17:39:47.000Z",
            "date_published": "2021-08-25T20:43:04.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q89x-f52w-6hj2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The implementation does not enforce alignment requirements on input slices while incorrectly assuming 4-byte alignment through an unsafe call to <code>std::slice::from_raw_parts_mut</code>, which breaks the contract and introduces undefined behavior.</p>\n<p>This affects Chacha20 encryption and decryption in crypto2.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/shadowsocks/crypto2/issues/27\">https://github.com/shadowsocks/crypto2/issues/27</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0121.html\">https://rustsec.org/advisories/RUSTSEC-2021-0121.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-pmcv-mgcf-rvxg\">https://github.com/advisories/GHSA-pmcv-mgcf-rvxg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-pmcv-mgcf-rvxg",
            "title": "[crypto2] Non-aligned u32 read in Chacha20 encryption and decryption",
            "date_modified": "2023-06-13T17:32:10.000Z",
            "date_published": "2022-06-16T23:51:32.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-pmcv-mgcf-rvxg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate passes an uninitialized buffer to a user-provided <code>Read</code> implementation (within <code>fn preamble_skipcount()</code>).</p>\n<p>Arbitrary <code>Read</code> implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jblondin/csv-sniffer/issues/1\">https://github.com/jblondin/csv-sniffer/issues/1</a></li>\n<li><a href=\"https://github.com/jblondin/csv-sniffer/pull/2\">https://github.com/jblondin/csv-sniffer/pull/2</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0088.html\">https://rustsec.org/advisories/RUSTSEC-2021-0088.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r67p-m7g9-gxw6\">https://github.com/advisories/GHSA-r67p-m7g9-gxw6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r67p-m7g9-gxw6",
            "title": "[csv-sniffer] `Read` on uninitialized memory may cause UB (fn preamble_skipcount())",
            "date_modified": "2023-06-13T17:31:37.000Z",
            "date_published": "2022-06-16T23:51:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r67p-m7g9-gxw6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Reference returned by some methods of <code>Ref</code> (and similar types) may outlive the <code>Ref</code> and escape the lock.\nThis causes undefined behavior and may result in a segfault.</p>\n<p>More information in <a href=\"https://github.com/xacrimon/dashmap/issues/167\"><code>dashmap#167</code></a> issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/xacrimon/dashmap/issues/167\">https://github.com/xacrimon/dashmap/issues/167</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0002.html\">https://rustsec.org/advisories/RUSTSEC-2022-0002.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mpg5-fvwp-42m2\">https://github.com/advisories/GHSA-mpg5-fvwp-42m2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mpg5-fvwp-42m2",
            "title": "[dashmap] Unsoundness in `dashmap` references",
            "date_modified": "2023-06-13T17:30:43.000Z",
            "date_published": "2022-06-16T23:52:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mpg5-fvwp-42m2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected version of this crate, which is a required dependency in com-impl, \nprovides a faulty implementation of the <code>IUnknown::QueryInterface</code> method.</p>\n<p><code>QueryInterface</code> implementation must call <code>IUnknown::AddRef</code> before returning the pointer,\nas describe in this documentation:\n<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)\">https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)</a></p>\n<p>As it is not incrementing the refcount as expected, the following calls to <code>IUnknown::Release</code> method \nwill cause WMI to drop reference to the interface, and can lead to invalid reference.</p>\n<p>This is documented in <a href=\"https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object#reference-counting\">https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object#reference-counting</a></p>\n<p>There is no simple workaround, as you can't know how many time QueryInterface will be called.\nThe only way to quick fix this is to use the macro expanded version of the code and modify \nthe QueryInterface method to add the AddRef call yourself.</p>\n<p>The issue was corrected in commit <code>9803f31fbd1717d482d848f041044d061fca6da7</code>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Connicpu/com-impl/issues/1\">https://github.com/Connicpu/com-impl/issues/1</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0083.html\">https://rustsec.org/advisories/RUSTSEC-2021-0083.html</a></li>\n<li><a href=\"https://github.com/Connicpu/com-impl/commit/9803f31fbd1717d482d848f041044d061fca6da7\">https://github.com/Connicpu/com-impl/commit/9803f31fbd1717d482d848f041044d061fca6da7</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9rg7-3j4f-cf4x\">https://github.com/advisories/GHSA-9rg7-3j4f-cf4x</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9rg7-3j4f-cf4x",
            "title": "[derive-com-impl] QueryInterface should call AddRef before returning pointer",
            "date_modified": "2023-06-13T17:29:15.000Z",
            "date_published": "2022-06-16T23:52:51.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9rg7-3j4f-cf4x"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Methods of NSString for conversion to a string may return a partial result. Since they call CStr::from_ptr on a pointer to the string buffer, the string is terminated at the first null byte, which might not be the end of the string.</p>\n<p>In addition to the vulnerable functions listed for this issue, the implementations of Display, PartialEq, PartialOrd, and ToString for NSString are also affected, since they call those functions.</p>\n<p>Since NSString is commonly used as the type for paths by the Foundation framework, null byte truncation might allow for easily bypassing file extension checks. For example, if a file name is provided by a user and validated to have one of a specific set of extensions, with validation taking place before truncation, an attacker can add an accepted extension after a null byte (e.g., file.exe\\0.txt). After truncation, the file name used by the application would be file.exe.</p>\n<p>It would be better to generate unique names for files, instead of using user-provided names, but not all applications take this approach.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-43620\">https://nvd.nist.gov/vuln/detail/CVE-2021-43620</a></li>\n<li><a href=\"https://github.com/nvzqz/fruity/issues/14\">https://github.com/nvzqz/fruity/issues/14</a></li>\n<li><a href=\"https://github.com/rustsec/advisory-db/pull/1102\">https://github.com/rustsec/advisory-db/pull/1102</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0123.html\">https://rustsec.org/advisories/RUSTSEC-2021-0123.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-h352-g5vw-3926\">https://github.com/advisories/GHSA-h352-g5vw-3926</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-h352-g5vw-3926",
            "title": "[fruity] Improper Input Validation in fruity",
            "date_modified": "2023-06-13T17:27:03.000Z",
            "date_published": "2021-11-16T17:26:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-h352-g5vw-3926"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of the crate did not properly implement a 'static lifetime bound on the waker function. This resulted in a use-after-free if Waker::wake() is called after original data had been dropped.</p>\n<p>The flaw was corrected by adding 'static lifetime bound to the data waker takes.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35906\">https://nvd.nist.gov/vuln/detail/CVE-2020-35906</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0060.html\">https://rustsec.org/advisories/RUSTSEC-2020-0060.html</a></li>\n<li><a href=\"https://github.com/rust-lang/futures-rs/pull/2206\">https://github.com/rust-lang/futures-rs/pull/2206</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r93v-9p5q-vhpf\">https://github.com/advisories/GHSA-r93v-9p5q-vhpf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r93v-9p5q-vhpf",
            "title": "[futures-task] futures_task::waker may cause a use-after-free if used on a type that isn't 'static",
            "date_modified": "2023-06-13T17:25:42.000Z",
            "date_published": "2022-05-24T17:37:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r93v-9p5q-vhpf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of the crate used a UnsafeCell in thread-local storage to return a noop waker reference, assuming that the reference would never be returned from another thread.</p>\n<p>This resulted in a segmentation fault crash if Waker::wake_by_ref() was called on a waker returned from another thread due to it attempting to dereference a pointer that wasn't accessible from the main thread.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35907\">https://nvd.nist.gov/vuln/detail/CVE-2020-35907</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0061.html\">https://rustsec.org/advisories/RUSTSEC-2020-0061.html</a></li>\n<li><a href=\"https://github.com/rust-lang/futures-rs/issues/2091\">https://github.com/rust-lang/futures-rs/issues/2091</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-p9m5-3hj7-cp5r\">https://github.com/advisories/GHSA-p9m5-3hj7-cp5r</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-p9m5-3hj7-cp5r",
            "title": "[futures-task] futures_task::noop_waker_ref can segfault due to dereferencing a NULL pointer",
            "date_modified": "2023-06-13T17:24:57.000Z",
            "date_published": "2022-05-24T17:37:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-p9m5-3hj7-cp5r"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of the crate had a Send/Sync implementation for MappedMutexGuard that only considered variance on T, while MappedMutexGuard dereferenced to U.</p>\n<p>This could of led to data races in safe Rust code when a closure used in MutexGuard::map() returns U that is unrelated to T.</p>\n<p>The issue was fixed by fixing Send and Sync implementations, and by adding a PhantomData&lt;&amp;'a mut U&gt; marker to the MappedMutexGuard type to tell the compiler that the guard is over U too.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35905\">https://nvd.nist.gov/vuln/detail/CVE-2020-35905</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0059.html\">https://rustsec.org/advisories/RUSTSEC-2020-0059.html</a></li>\n<li><a href=\"https://github.com/rust-lang/futures-rs/issues/2239\">https://github.com/rust-lang/futures-rs/issues/2239</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rh4w-94hh-9943\">https://github.com/advisories/GHSA-rh4w-94hh-9943</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rh4w-94hh-9943",
            "title": "[futures-util] MutexGuard::map can cause a data race in safe code",
            "date_modified": "2023-06-13T17:24:14.000Z",
            "date_published": "2022-05-24T17:37:49.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rh4w-94hh-9943"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The implementation does not enforce alignment requirements on input slices while incorrectly assuming 4-byte alignment through an unsafe call to std::slice::from_raw_parts_mut, which breaks the contract and introduces undefined behavior.</p>\n<p>This affects Chacha20 encryption and decryption in crypto2.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45709\">https://nvd.nist.gov/vuln/detail/CVE-2021-45709</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/crypto2/RUSTSEC-2021-0121.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/crypto2/RUSTSEC-2021-0121.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0121.html\">https://rustsec.org/advisories/RUSTSEC-2021-0121.html</a></li>\n<li><a href=\"https://github.com/shadowsocks/crypto2/issues/27\">https://github.com/shadowsocks/crypto2/issues/27</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9hfg-pxr6-q4vp\">https://github.com/advisories/GHSA-9hfg-pxr6-q4vp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9hfg-pxr6-q4vp",
            "title": "[crypto2] Use of a Broken or Risky Cryptographic Algorithm in crypto2",
            "date_modified": "2023-06-13T17:23:04.000Z",
            "date_published": "2022-01-06T22:04:51.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9hfg-pxr6-q4vp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate passes an uninitialized buffer to a user-provided Read implementation (within fn preamble_skipcount()).</p>\n<p>Arbitrary Read implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer. Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45686\">https://nvd.nist.gov/vuln/detail/CVE-2021-45686</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/csv-sniffer/RUSTSEC-2021-0088.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/csv-sniffer/RUSTSEC-2021-0088.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0088.html\">https://rustsec.org/advisories/RUSTSEC-2021-0088.html</a></li>\n<li><a href=\"https://github.com/jblondin/csv-sniffer/pull/2\">https://github.com/jblondin/csv-sniffer/pull/2</a></li>\n<li><a href=\"https://github.com/jblondin/csv-sniffer/issues/1\">https://github.com/jblondin/csv-sniffer/issues/1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9783-42pm-x5jq\">https://github.com/advisories/GHSA-9783-42pm-x5jq</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9783-42pm-x5jq",
            "title": "[csv-sniffer] Use of Uninitialized Resource in csv-sniffer.",
            "date_modified": "2023-06-13T17:22:24.000Z",
            "date_published": "2022-01-06T22:13:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9783-42pm-x5jq"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the derive-com-impl crate before 0.1.2 for Rust. An invalid reference (and memory corruption) can occur because AddRef might not be called before returning a pointer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45681\">https://nvd.nist.gov/vuln/detail/CVE-2021-45681</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/derive-com-impl/RUSTSEC-2021-0083.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/derive-com-impl/RUSTSEC-2021-0083.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0083.html\">https://rustsec.org/advisories/RUSTSEC-2021-0083.html</a></li>\n<li><a href=\"https://github.com/Connicpu/com-impl/issues/1\">https://github.com/Connicpu/com-impl/issues/1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-w4cc-pc2h-whcj\">https://github.com/advisories/GHSA-w4cc-pc2h-whcj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-w4cc-pc2h-whcj",
            "title": "[derive-com-impl] Out-of-bounds Write in derive-com-impl",
            "date_modified": "2023-06-13T17:21:56.000Z",
            "date_published": "2022-01-06T22:16:10.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-w4cc-pc2h-whcj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the flatbuffers crate through 2020-04-11 for Rust. read_scalar (and read_scalar_at) can transmute values without unsafe blocks.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35864\">https://nvd.nist.gov/vuln/detail/CVE-2020-35864</a></li>\n<li><a href=\"https://github.com/google/flatbuffers/issues/5825\">https://github.com/google/flatbuffers/issues/5825</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0009.html\">https://rustsec.org/advisories/RUSTSEC-2020-0009.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c9h5-hf8r-m97x\">https://github.com/advisories/GHSA-c9h5-hf8r-m97x</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c9h5-hf8r-m97x",
            "title": "[flatbuffers] Dangling reference in flatbuffers",
            "date_modified": "2023-06-13T17:18:26.000Z",
            "date_published": "2021-08-25T20:47:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c9h5-hf8r-m97x"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The affected version of this crate's the bounded channel incorrectly assumes that Vec::from_iter has allocated capacity that same as the number of iterator elements. Vec::from_iter does not actually guarantee that and may allocate extra memory. The destructor of the bounded channel reconstructs Vec from the raw pointer based on the incorrect assumes described above. This is unsound and causing deallocation with the incorrect capacity when Vec::from_iter has allocated different sizes with the number of iterator elements.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35904\">https://nvd.nist.gov/vuln/detail/CVE-2020-35904</a></li>\n<li><a href=\"https://github.com/crossbeam-rs/crossbeam/pull/533\">https://github.com/crossbeam-rs/crossbeam/pull/533</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0052.html\">https://rustsec.org/advisories/RUSTSEC-2020-0052.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m8h8-v6jh-c762\">https://github.com/advisories/GHSA-m8h8-v6jh-c762</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m8h8-v6jh-c762",
            "title": "[crossbeam-channel] Incorrect buffer size in crossbeam-channel",
            "date_modified": "2023-06-13T17:12:10.000Z",
            "date_published": "2021-08-25T20:49:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m8h8-v6jh-c762"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Even if an element is popped from a queue, crossbeam would run its destructor inside the epoch-based garbage collector. This is a source of double frees.</p>\n<p>The flaw was corrected by wrapping elements inside queues in a ManuallyDrop.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-20996\">https://nvd.nist.gov/vuln/detail/CVE-2018-20996</a></li>\n<li><a href=\"https://github.com/crossbeam-rs/crossbeam-epoch/issues/82\">https://github.com/crossbeam-rs/crossbeam-epoch/issues/82</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0009.html\">https://rustsec.org/advisories/RUSTSEC-2018-0009.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c3cw-c387-pj65\">https://github.com/advisories/GHSA-c3cw-c387-pj65</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c3cw-c387-pj65",
            "title": "[crossbeam] Double free in crossbeam",
            "date_modified": "2023-06-13T17:11:25.000Z",
            "date_published": "2021-08-25T20:43:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c3cw-c387-pj65"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Prior to 0.10.0 it was possible to have both decoding functions panic unexpectedly, by supplying tokens with an incorrect base62 encoding.\nThe documentation stated that an error should have been reported instead.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35918\">https://nvd.nist.gov/vuln/detail/CVE-2020-35918</a></li>\n<li><a href=\"https://github.com/return/branca/issues/24\">https://github.com/return/branca/issues/24</a></li>\n<li><a href=\"https://github.com/tuupola/branca-spec/issues/22\">https://github.com/tuupola/branca-spec/issues/22</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0075.html\">https://rustsec.org/advisories/RUSTSEC-2020-0075.html</a></li>\n<li><a href=\"https://github.com/return/branca/commit/7da3274bd99b05dce9c3f9b4b129d0145c71820b\">https://github.com/return/branca/commit/7da3274bd99b05dce9c3f9b4b129d0145c71820b</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c9rv-3jmq-527w\">https://github.com/advisories/GHSA-c9rv-3jmq-527w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c9rv-3jmq-527w",
            "title": "[branca] Unexpected panic when decoding tokens in branca",
            "date_modified": "2023-06-13T17:09:35.000Z",
            "date_published": "2021-08-25T20:49:50.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c9rv-3jmq-527w"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}