{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>If a tokio::sync::oneshot channel is closed (via the oneshot::Receiver::close method), a data race may occur if the oneshot::Sender::send method is called while the corresponding oneshot::Receiver is awaited or calling try_recv.</p>\n<p>When these methods are called concurrently on a closed channel, the two halves of the channel can concurrently access a shared memory location, resulting in a data race. This has been observed to cause memory corruption.</p>\n<p>Note that the race only occurs when both halves of the channel are used after the Receiver half has called close. Code where close is not used, or where the Receiver is not awaited and try_recv is not called after calling close, is not affected.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45710\">https://nvd.nist.gov/vuln/detail/CVE-2021-45710</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0124.html\">https://rustsec.org/advisories/RUSTSEC-2021-0124.html</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/issues/4225\">https://github.com/tokio-rs/tokio/issues/4225</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fg7r-2g4j-5cgr\">https://github.com/advisories/GHSA-fg7r-2g4j-5cgr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fg7r-2g4j-5cgr",
            "title": "[tokio] Race Condition in tokio",
            "date_modified": "2023-06-13T22:01:00.000Z",
            "date_published": "2022-01-06T22:04:37.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fg7r-2g4j-5cgr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>If a tokio::sync::oneshot channel is closed (via the oneshot::Receiver::close method), a data race may occur if the oneshot::Sender::send method is called while the corresponding oneshot::Receiver is awaited or calling try_recv.</p>\n<p>When these methods are called concurrently on a closed channel, the two halves of the channel can concurrently access a shared memory location, resulting in a data race. This has been observed to cause memory corruption.</p>\n<p>Note that the race only occurs when both halves of the channel are used after the Receiver half has called close. Code where close is not used, or where the Receiver is not awaited and try_recv is not called after calling close, is not affected.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45710\">https://nvd.nist.gov/vuln/detail/CVE-2021-45710</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0124.html\">https://rustsec.org/advisories/RUSTSEC-2021-0124.html</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/issues/4225\">https://github.com/tokio-rs/tokio/issues/4225</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fg7r-2g4j-5cgr\">https://github.com/advisories/GHSA-fg7r-2g4j-5cgr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fg7r-2g4j-5cgr",
            "title": "[tokio] Race Condition in tokio",
            "date_modified": "2023-06-13T22:01:00.000Z",
            "date_published": "2022-01-06T22:04:37.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fg7r-2g4j-5cgr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>When inserting rows from an iterator at a particular index, toodee would shift items over, duplicating their ownership. The space reserved for the new elements was based on the len() returned by the ExactSizeIterator.</p>\n<p>This could result in elements in the array being freed twice if the iterator panics. Uninitialized or previously freed elements could also be exposed if the len() didn't match the number of elements.</p>\n<p>These issues were fixed in commit <code>ced70c17</code> by temporarily setting the length of the array smaller while processing it and adding assertions on the number of elements returned by the iterator.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-28028\">https://nvd.nist.gov/vuln/detail/CVE-2021-28028</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0028.html\">https://rustsec.org/advisories/RUSTSEC-2021-0028.html</a></li>\n<li><a href=\"https://github.com/antonmarsden/toodee/issues/13\">https://github.com/antonmarsden/toodee/issues/13</a></li>\n<li><a href=\"https://github.com/antonmarsden/toodee/commit/ced70c172486fb4827c172cd8238053df3d1dcdb\">https://github.com/antonmarsden/toodee/commit/ced70c172486fb4827c172cd8238053df3d1dcdb</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wcvp-r8j8-47pc\">https://github.com/advisories/GHSA-wcvp-r8j8-47pc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wcvp-r8j8-47pc",
            "title": "[toodee] Double free in toodee",
            "date_modified": "2023-06-13T21:58:19.000Z",
            "date_published": "2021-09-01T18:30:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wcvp-r8j8-47pc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Token comparison was not constant time, and could theorically be used to guess value of an TOTP token, and thus reuse it in the same time window. The attacker would have to know the password beforehand nonetheless.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Library now used constant-time comparison.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>No.</p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Open an issue in <a href=\"https://github.com/constantoine/totp-rs\">totp-rs</a></li>\n<li>Email us at <a href=\"mailto:cleo.rebert@gmail.com\">cleo.rebert@gmail.com</a></li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/constantoine/totp-rs/security/advisories/GHSA-8vxv-2g8p-2249\">https://github.com/constantoine/totp-rs/security/advisories/GHSA-8vxv-2g8p-2249</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-29185\">https://nvd.nist.gov/vuln/detail/CVE-2022-29185</a></li>\n<li><a href=\"https://github.com/constantoine/totp-rs/issues/13\">https://github.com/constantoine/totp-rs/issues/13</a></li>\n<li><a href=\"https://github.com/constantoine/totp-rs/releases/tag/v1.1.0\">https://github.com/constantoine/totp-rs/releases/tag/v1.1.0</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0018.html\">https://rustsec.org/advisories/RUSTSEC-2022-0018.html</a></li>\n<li><a href=\"https://github.com/constantoine/totp-rs/commit/1f1e1a6fe722deb1656f483b1367ea4be978db5b\">https://github.com/constantoine/totp-rs/commit/1f1e1a6fe722deb1656f483b1367ea4be978db5b</a></li>\n<li><a href=\"https://github.com/constantoine/totp-rs/compare/v1.0...v1.1.0\">https://github.com/constantoine/totp-rs/compare/v1.0...v1.1.0</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8vxv-2g8p-2249\">https://github.com/advisories/GHSA-8vxv-2g8p-2249</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8vxv-2g8p-2249",
            "title": "[totp-rs] Observable Timing Discrepancy in totp-rs",
            "date_modified": "2023-06-13T21:57:38.000Z",
            "date_published": "2022-05-24T21:33:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8vxv-2g8p-2249"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate did not clone contained strings when an interner is cloned. Interners have raw pointers to the contained strings, and they keep pointing the strings which the old interner owns, after the interner is cloned. If a new cloned interner is alive and the old original interner is dead, the new interner has dangling pointers to the old interner's storage, which is already dropped.</p>\n<p>This allows an attacker to read the already freed memory. The dangling pointers are used by the interners to check a string is already interned. An attacker can do brute force attack to get the data pointed by the dangling pointer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-16882\">https://nvd.nist.gov/vuln/detail/CVE-2019-16882</a></li>\n<li><a href=\"https://github.com/Robbepop/string-interner/issues/9\">https://github.com/Robbepop/string-interner/issues/9</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0023.html\">https://rustsec.org/advisories/RUSTSEC-2019-0023.html</a></li>\n<li><a href=\"https://github.com/Robbepop/string-interner/commit/d91dac0cfe42512526879cdfaac0b81beff54089\">https://github.com/Robbepop/string-interner/commit/d91dac0cfe42512526879cdfaac0b81beff54089</a></li>\n<li><a href=\"https://github.com/Robbepop/string-interner/pull/10\">https://github.com/Robbepop/string-interner/pull/10</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-49fq-pw77-6qxj\">https://github.com/advisories/GHSA-49fq-pw77-6qxj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-49fq-pw77-6qxj",
            "title": "[string-interner] Use after free in string-interner",
            "date_modified": "2023-06-13T21:55:42.000Z",
            "date_published": "2021-08-25T20:44:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-49fq-pw77-6qxj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate did not clone contained strings when an interner is cloned. Interners have raw pointers to the contained strings, and they keep pointing the strings which the old interner owns, after the interner is cloned. If a new cloned interner is alive and the old original interner is dead, the new interner has dangling pointers to the old interner's storage, which is already dropped.</p>\n<p>This allows an attacker to read the already freed memory. The dangling pointers are used by the interners to check a string is already interned. An attacker can do brute force attack to get the data pointed by the dangling pointer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-16882\">https://nvd.nist.gov/vuln/detail/CVE-2019-16882</a></li>\n<li><a href=\"https://github.com/Robbepop/string-interner/issues/9\">https://github.com/Robbepop/string-interner/issues/9</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0023.html\">https://rustsec.org/advisories/RUSTSEC-2019-0023.html</a></li>\n<li><a href=\"https://github.com/Robbepop/string-interner/commit/d91dac0cfe42512526879cdfaac0b81beff54089\">https://github.com/Robbepop/string-interner/commit/d91dac0cfe42512526879cdfaac0b81beff54089</a></li>\n<li><a href=\"https://github.com/Robbepop/string-interner/pull/10\">https://github.com/Robbepop/string-interner/pull/10</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-49fq-pw77-6qxj\">https://github.com/advisories/GHSA-49fq-pw77-6qxj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-49fq-pw77-6qxj",
            "title": "[string-interner] Use after free in string-interner",
            "date_modified": "2023-06-13T21:55:42.000Z",
            "date_published": "2021-08-25T20:44:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-49fq-pw77-6qxj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Unix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.</p>\n<p>The affected functions from time 0.2.7 through 0.2.22 are:</p>\n<ul>\n<li><code>time::UtcOffset::local_offset_at</code></li>\n<li><code>time::UtcOffset::try_local_offset_at</code></li>\n<li><code>time::UtcOffset::current_local_offset</code></li>\n<li><code>time::UtcOffset::try_current_local_offset</code></li>\n<li><code>time::OffsetDateTime::now_local</code></li>\n<li><code>time::OffsetDateTime::try_now_local</code></li>\n</ul>\n<p>The affected functions in time 0.1 (all versions) are:</p>\n<ul>\n<li><code>at</code></li>\n<li><code>at_utc</code></li>\n<li><code>now</code></li>\n</ul>\n<p>Non-Unix targets (including Windows and wasm) are unaffected.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>In some versions of <code>time</code>, the internal method that determines the local offset has been modified to always return <code>None</code> on the affected operating systems. This has the effect of returning an <code>Err</code> on the <code>try_*</code> methods and <code>UTC</code> on the non-<code>try_*</code> methods. In later versions, <code>time</code> will attempt to determine the number of threads running in the process. If the process is single-threaded, the call will proceed as its safety invariant is upheld.</p>\n<p>Users and library authors with time in their dependency tree must perform <code>cargo update</code>, which will pull in the updated, unaffected code.</p>\n<p>Users of time 0.1 do not have a patch and must upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Library authors must ensure that the program only has one running thread at the time of calling any affected method. Binary authors may do the same and/or ensure that no other thread is actively mutating the environment.</p>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://github.com/time-rs/time/issues/293\">time-rs/time#293</a>.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396\">https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-26235\">https://nvd.nist.gov/vuln/detail/CVE-2020-26235</a></li>\n<li><a href=\"https://github.com/time-rs/time/issues/293\">https://github.com/time-rs/time/issues/293</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0071.html\">https://rustsec.org/advisories/RUSTSEC-2020-0071.html</a></li>\n<li><a href=\"https://crates.io/crates/time/0.2.23\">https://crates.io/crates/time/0.2.23</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wcg3-cvx6-7396\">https://github.com/advisories/GHSA-wcg3-cvx6-7396</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wcg3-cvx6-7396",
            "title": "[time] Segmentation fault in time",
            "date_modified": "2023-06-13T21:51:23.000Z",
            "date_published": "2021-08-25T20:56:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wcg3-cvx6-7396"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate maintains references to memory that might have been freed already.\nIf affects the following two <code>tremor-script</code> language constructs:</p>\n<ul>\n<li>A <a href=\"https://www.tremor.rs/docs/tremor-script/index#merge\">Merge</a> where we assign the result back to the target expression\nand the expression to be merged needs to reference the <code>event</code>:</li>\n</ul>\n<pre><code>let state = merge state of event end;\n</code></pre>\n<ul>\n<li>A <a href=\"https://www.tremor.rs/docs/tremor-script/index#patch\">Patch</a> where we assign the result back to the target expression\nand the patch operations used need to reference the <code>event</code>:</li>\n</ul>\n<pre><code>let state = patch state of insert event.key =&gt; event.value end;\n</code></pre>\n<p>For constructs like this (it doesnt matter what is references in the expression to be merged or the patch operations) an optimization\nwas applied to manipulate the target value in-place, instead of cloning it.</p>\n<p>Our <code>Value</code> struct which underpins all event data in <code>tremor-script</code>, is representing as borrowed strings <code>beef::Cow&lt;'lifetime, str&gt;</code> \nthat reference the actual <code>Vec&lt;u8&gt;</code> the event is based upon. We keep the raw byte-array next to the event structure inside our <code>Event</code> struct as a self-referential struct,\nso we make sure that the structured <code>Value</code> and its references are valid across its whole lifetime.</p>\n<p>The optimization was considered safe as long as it was only possible to merge or patche <code>event</code> data or static data.\nWhen <code>state</code> was introduced to <code>tremor-script</code> a new possibility existed, to keep <code>Value</code> data around for longer than the lifetime of an event.\nIf <code>event</code> data is merged or patched into <code>state</code> without cloning <code>state</code> first, it can still reference keys or values from\nthe previous event, which will now be invalid. This allows access to those already freed regions of memory and to get their content out over the wire.</p>\n<h2 id=\"workaround\">Workaround</h2>\n<p>If an upgrade is not possible, a possible workaround is to avoid the optimization\nby introducing a temporary variable and not immediately reassigning to <code>state</code>:</p>\n<pre><code>let tmp = merge state of event end;\nlet state = tmp\n</code></pre>\n<h2 id=\"fix\">Fix</h2>\n<p>The flaw was corrected in <code>tremor-script</code> version 0.11.6 via commit <a href=\"https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e\">1a2efcd</a> by removing the optimization\nand always clone the target expression of a <a href=\"https://www.tremor.rs/docs/tremor-script/index#merge\">Merge</a> or [Patch](<a href=\"https://www.tremor.rs/docs/tremor-script/index#patch\">https://www.tremor.rs/docs/tremor-script/index#patch</a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tremor-rs/tremor-runtime/pull/1217\">https://github.com/tremor-rs/tremor-runtime/pull/1217</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0111.html\">https://rustsec.org/advisories/RUSTSEC-2021-0111.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3pp4-64mp-9cg9\">https://github.com/advisories/GHSA-3pp4-64mp-9cg9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3pp4-64mp-9cg9",
            "title": "[tremor-script] Memory Safety Issue when using `patch` or `merge` on `state` and assign the result back to `state`",
            "date_modified": "2023-06-13T21:47:20.000Z",
            "date_published": "2022-06-17T00:27:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3pp4-64mp-9cg9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the tremor-script crate before 0.11.6 for Rust. A merge operation may result in a use-after-free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45702\">https://nvd.nist.gov/vuln/detail/CVE-2021-45702</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tremor-script/RUSTSEC-2021-0111.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tremor-script/RUSTSEC-2021-0111.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0111.html\">https://rustsec.org/advisories/RUSTSEC-2021-0111.html</a></li>\n<li><a href=\"https://github.com/tremor-rs/tremor-runtime/pull/1217\">https://github.com/tremor-rs/tremor-runtime/pull/1217</a></li>\n<li><a href=\"https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e\">https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9qvw-46gf-4fv8\">https://github.com/advisories/GHSA-9qvw-46gf-4fv8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9qvw-46gf-4fv8",
            "title": "[tremor-script] Use After Free in tremor-script",
            "date_modified": "2023-06-13T21:46:57.000Z",
            "date_published": "2022-01-06T22:09:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9qvw-46gf-4fv8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Attempting to call grow on a spilled SmallVec with a value less than the current capacity causes corruption of memory allocator data structures. An attacker that controls the value passed to grow may exploit this flaw to obtain memory contents or gain remote code execution.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15554\">https://nvd.nist.gov/vuln/detail/CVE-2019-15554</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/149\">https://github.com/servo/rust-smallvec/issues/149</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0012.html\">https://rustsec.org/advisories/RUSTSEC-2019-0012.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-69gw-hgj3-45m7\">https://github.com/advisories/GHSA-69gw-hgj3-45m7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-69gw-hgj3-45m7",
            "title": "[smallvec] Memory corruption in smallvec",
            "date_modified": "2023-06-13T21:37:37.000Z",
            "date_published": "2021-08-25T20:43:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-69gw-hgj3-45m7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate switched the length and capacity arguments in the Vec::from_raw_parts() constructor, which could lead to memory corruption or data leakage.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-21000\">https://nvd.nist.gov/vuln/detail/CVE-2018-21000</a></li>\n<li><a href=\"https://github.com/nabijaczleweli/safe-transmute-rs/pull/36\">https://github.com/nabijaczleweli/safe-transmute-rs/pull/36</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0013.html\">https://rustsec.org/advisories/RUSTSEC-2018-0013.html</a></li>\n<li><a href=\"https://github.com/nabijaczleweli/safe-transmute-rs/commit/a134e06d740f9d7c287f74c0af2cd06206774364\">https://github.com/nabijaczleweli/safe-transmute-rs/commit/a134e06d740f9d7c287f74c0af2cd06206774364</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2v78-j59h-fmpf\">https://github.com/advisories/GHSA-2v78-j59h-fmpf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2v78-j59h-fmpf",
            "title": "[safe-transmute] Heap overflow or corruption in safe-transmute",
            "date_modified": "2023-06-13T21:04:33.000Z",
            "date_published": "2021-08-25T20:43:23.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2v78-j59h-fmpf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate did not properly check for recursion while deserializing aliases. This allows an attacker to make a YAML file with an alias referring to itself causing an abort. The flaw was corrected by checking the recursion depth.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dtolnay/serde-yaml/pull/105\">https://github.com/dtolnay/serde-yaml/pull/105</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0005.html\">https://rustsec.org/advisories/RUSTSEC-2018-0005.html</a></li>\n<li><a href=\"https://github.com/dtolnay/serde-yaml/commit/b93aff6e904cffbbfd1f421b82f6dcc5ca19a4fd\">https://github.com/dtolnay/serde-yaml/commit/b93aff6e904cffbbfd1f421b82f6dcc5ca19a4fd</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-39vw-qp34-rmwf\">https://github.com/advisories/GHSA-39vw-qp34-rmwf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-39vw-qp34-rmwf",
            "title": "[serde_yaml] Uncontrolled recursion leads to abort in deserialization",
            "date_modified": "2023-06-13T21:03:37.000Z",
            "date_published": "2021-08-25T21:00:18.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-39vw-qp34-rmwf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The affected version of this crate did not guard against accessing memory beyond the range of its input data. A pointer cast to read the data into a 256-bit register could lead to a segmentation fault when the end plus the 32 bytes (256 bit) read would overlap into the next page during string parsing. This allows an attacker to eventually crash a service. The flaw was corrected by using a padding buffer for the last read from the input. So that we are we never read over the boundary of the input data.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15550\">https://nvd.nist.gov/vuln/detail/CVE-2019-15550</a></li>\n<li><a href=\"https://github.com/Licenser/simdjson-rs/pull/27\">https://github.com/Licenser/simdjson-rs/pull/27</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0008.html\">https://rustsec.org/advisories/RUSTSEC-2019-0008.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-gwfj-pw2x-h6c2\">https://github.com/advisories/GHSA-gwfj-pw2x-h6c2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-gwfj-pw2x-h6c2",
            "title": "[simd-json] Out of bounds read in simd-json",
            "date_modified": "2023-06-13T21:01:36.000Z",
            "date_published": "2021-08-25T20:43:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-gwfj-pw2x-h6c2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>If an iterator passed to SmallVec::insert_many panicked in Iterator::next, destructors were run during unwinding while the vector was in an inconsistent state, possibly causing a double free (a destructor running on two copies of the same value).</p>\n<p>This is fixed in smallvec 0.6.3 by ensuring that the vector's length is not updated to include moved items until they have been removed from their original positions. Items may now be leaked if Iterator::next panics, but they will not be dropped more than once.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-20991\">https://nvd.nist.gov/vuln/detail/CVE-2018-20991</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/96\">https://github.com/servo/rust-smallvec/issues/96</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0003.html\">https://rustsec.org/advisories/RUSTSEC-2018-0003.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rxr4-x558-x7hw\">https://github.com/advisories/GHSA-rxr4-x558-x7hw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rxr4-x558-x7hw",
            "title": "[smallvec] Double free in smallvec",
            "date_modified": "2023-06-13T20:58:32.000Z",
            "date_published": "2021-08-25T20:42:54.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rxr4-x558-x7hw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Attempting to call grow on a spilled SmallVec with a value equal to the current capacity causes it to free the existing data. This performs a double free immediately and may lead to use-after-free on subsequent accesses to the SmallVec contents. An attacker that controls the value passed to grow may exploit this flaw to obtain memory contents or gain remote code execution.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15551\">https://nvd.nist.gov/vuln/detail/CVE-2019-15551</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/148\">https://github.com/servo/rust-smallvec/issues/148</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0009.html\">https://rustsec.org/advisories/RUSTSEC-2019-0009.html</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/149\">https://github.com/servo/rust-smallvec/issues/149</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/commit/c20cfa8584e649f00dc0767ab6fad63a3f59a296\">https://github.com/servo/rust-smallvec/commit/c20cfa8584e649f00dc0767ab6fad63a3f59a296</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/commit/f96322b9243405cc82701cc73f1b19313b413ab4\">https://github.com/servo/rust-smallvec/commit/f96322b9243405cc82701cc73f1b19313b413ab4</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mm7v-vpv8-xfc3\">https://github.com/advisories/GHSA-mm7v-vpv8-xfc3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mm7v-vpv8-xfc3",
            "title": "[smallvec] Double free in smallvec",
            "date_modified": "2023-06-13T20:57:37.000Z",
            "date_published": "2021-08-25T20:44:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mm7v-vpv8-xfc3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p><code>Slock&lt;T&gt;</code> unconditionally implements <code>Send</code>/<code>Sync</code>.</p>\n<p>Affected versions of this crate allows sending non-Send types to other threads,\nwhich can lead to data races and memory corruption due to the data race.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/BrokenLamp/slock-rs/issues/2\">https://github.com/BrokenLamp/slock-rs/issues/2</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0135.html\">https://rustsec.org/advisories/RUSTSEC-2020-0135.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-83r8-p8v6-6gfm\">https://github.com/advisories/GHSA-83r8-p8v6-6gfm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-83r8-p8v6-6gfm",
            "title": "[slock] Slock<T> allows sending non-Send types across thread boundaries",
            "date_modified": "2023-06-13T20:56:17.000Z",
            "date_published": "2021-08-25T21:00:20.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-83r8-p8v6-6gfm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the spin crate before 0.5.2 for Rust, when RwLock is used. Because memory ordering is mishandled, two writers can acquire the lock at the same time, violating mutual exclusion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-16137\">https://nvd.nist.gov/vuln/detail/CVE-2019-16137</a></li>\n<li><a href=\"https://github.com/mvdnes/spin-rs/issues/65\">https://github.com/mvdnes/spin-rs/issues/65</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0013.html\">https://rustsec.org/advisories/RUSTSEC-2019-0013.html</a></li>\n<li><a href=\"https://github.com/mvdnes/spin-rs/pull/66\">https://github.com/mvdnes/spin-rs/pull/66</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hv7x-f3pv-gpwr\">https://github.com/advisories/GHSA-hv7x-f3pv-gpwr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hv7x-f3pv-gpwr",
            "title": "[spin] Wrong memory orderings violates mutual exclusion in spin",
            "date_modified": "2023-06-13T20:55:22.000Z",
            "date_published": "2021-08-25T20:44:46.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hv7x-f3pv-gpwr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of stack_dst used a push_inner function that increased the internal length of the array and then called val.clone(). If the val.clone() call panics, the stack could drop an already dropped element or drop uninitialized memory. This issue was fixed in <code>2a4d538</code> by increasing the length of the array after elements are cloned.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-28034\">https://nvd.nist.gov/vuln/detail/CVE-2021-28034</a></li>\n<li><a href=\"https://github.com/thepowersgang/stack_dst-rs/commit/2a4d53809e3000f40085f2b229b6b1a33759881d\">https://github.com/thepowersgang/stack_dst-rs/commit/2a4d53809e3000f40085f2b229b6b1a33759881d</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0033.html\">https://rustsec.org/advisories/RUSTSEC-2021-0033.html</a></li>\n<li><a href=\"https://github.com/thepowersgang/stack_dst-rs/issues/5\">https://github.com/thepowersgang/stack_dst-rs/issues/5</a></li>\n<li><a href=\"https://github.com/thepowersgang/stack_dst-rs/commit/2a4d538\">https://github.com/thepowersgang/stack_dst-rs/commit/2a4d538</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8mjx-h23h-w2pg\">https://github.com/advisories/GHSA-8mjx-h23h-w2pg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8mjx-h23h-w2pg",
            "title": "[stack_dst] Double free in stack_dst",
            "date_modified": "2023-06-13T20:52:44.000Z",
            "date_published": "2021-09-01T18:30:44.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8mjx-h23h-w2pg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A bug in the SmallVec::insert_many method caused it to allocate a buffer that was smaller than needed. It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap. This bug was only triggered if the iterator passed to insert_many yielded more items than the lower bound returned from its size_hint method.</p>\n<p>The flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted. The fix also simplified the implementation of insert_many to use less unsafe code, so it is easier to verify its correctness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-25900\">https://nvd.nist.gov/vuln/detail/CVE-2021-25900</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0003.html\">https://rustsec.org/advisories/RUSTSEC-2021-0003.html</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/252\">https://github.com/servo/rust-smallvec/issues/252</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-43w2-9j62-hq99\">https://github.com/advisories/GHSA-43w2-9j62-hq99</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-43w2-9j62-hq99",
            "title": "[smallvec] Buffer overflow in SmallVec::insert_many",
            "date_modified": "2023-06-13T20:51:42.000Z",
            "date_published": "2022-05-24T17:40:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-43w2-9j62-hq99"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A bug in the SmallVec::insert_many method caused it to allocate a buffer that was smaller than needed. It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap. This bug was only triggered if the iterator passed to insert_many yielded more items than the lower bound returned from its size_hint method.</p>\n<p>The flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted. The fix also simplified the implementation of insert_many to use less unsafe code, so it is easier to verify its correctness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-25900\">https://nvd.nist.gov/vuln/detail/CVE-2021-25900</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0003.html\">https://rustsec.org/advisories/RUSTSEC-2021-0003.html</a></li>\n<li><a href=\"https://github.com/servo/rust-smallvec/issues/252\">https://github.com/servo/rust-smallvec/issues/252</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-43w2-9j62-hq99\">https://github.com/advisories/GHSA-43w2-9j62-hq99</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-43w2-9j62-hq99",
            "title": "[smallvec] Buffer overflow in SmallVec::insert_many",
            "date_modified": "2023-06-13T20:51:42.000Z",
            "date_published": "2022-05-24T17:40:21.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-43w2-9j62-hq99"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}