{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>When configuring a Windows named pipe server, setting <code>pipe_mode</code> will reset <code>reject_remote_clients</code> to <code>false</code>. If the application has previously configured <code>reject_remote_clients</code> to <code>true</code>, this effectively undoes the configuration. This also applies if <code>reject_remote_clients</code> is not explicitly set as this is the default configuration and is cleared by calling <code>pipe_mode</code>.</p>\n<p>Remote clients may only access the named pipe if the named pipe's associated path is accessible via a publically shared folder (SMB).</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The following versions have been patched:</p>\n<ul>\n<li>1.23.1</li>\n<li>1.20.3</li>\n<li>1.18.4</li>\n</ul>\n<p>The fix will also be present in all releases starting from version 1.24.0.</p>\n<p>Named pipes were introduced to Tokio in version 1.7.0, so releases older than 1.7.0 are not affected.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Ensure that <code>pipe_mode</code> is set <strong>first</strong> after initializing a <code>ServerOptions</code>. For example:</p>\n<pre><code class=\"language-rust\">let mut opts = ServerOptions::new();\nopts.pipe_mode(PipeMode::Message);\nopts.reject_remote_clients(true);\n</code></pre>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients\">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tokio-rs/tokio/security/advisories/GHSA-7rrj-xr53-82p7\">https://github.com/tokio-rs/tokio/security/advisories/GHSA-7rrj-xr53-82p7</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-22466\">https://nvd.nist.gov/vuln/detail/CVE-2023-22466</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/pull/5336\">https://github.com/tokio-rs/tokio/pull/5336</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/releases/tag/tokio-1.23.1\">https://github.com/tokio-rs/tokio/releases/tag/tokio-1.23.1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients\">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7rrj-xr53-82p7\">https://github.com/advisories/GHSA-7rrj-xr53-82p7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7rrj-xr53-82p7",
            "title": "[tokio] Tokio reject_remote_clients configuration may get dropped when creating a Windows named pipe",
            "date_modified": "2023-01-06T21:41:00.000Z",
            "date_published": "2023-01-06T21:40:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7rrj-xr53-82p7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>When configuring a Windows named pipe server, setting <code>pipe_mode</code> will reset <code>reject_remote_clients</code> to <code>false</code>. If the application has previously configured <code>reject_remote_clients</code> to <code>true</code>, this effectively undoes the configuration. This also applies if <code>reject_remote_clients</code> is not explicitly set as this is the default configuration and is cleared by calling <code>pipe_mode</code>.</p>\n<p>Remote clients may only access the named pipe if the named pipe's associated path is accessible via a publically shared folder (SMB).</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The following versions have been patched:</p>\n<ul>\n<li>1.23.1</li>\n<li>1.20.3</li>\n<li>1.18.4</li>\n</ul>\n<p>The fix will also be present in all releases starting from version 1.24.0.</p>\n<p>Named pipes were introduced to Tokio in version 1.7.0, so releases older than 1.7.0 are not affected.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Ensure that <code>pipe_mode</code> is set <strong>first</strong> after initializing a <code>ServerOptions</code>. For example:</p>\n<pre><code class=\"language-rust\">let mut opts = ServerOptions::new();\nopts.pipe_mode(PipeMode::Message);\nopts.reject_remote_clients(true);\n</code></pre>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients\">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tokio-rs/tokio/security/advisories/GHSA-7rrj-xr53-82p7\">https://github.com/tokio-rs/tokio/security/advisories/GHSA-7rrj-xr53-82p7</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-22466\">https://nvd.nist.gov/vuln/detail/CVE-2023-22466</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/pull/5336\">https://github.com/tokio-rs/tokio/pull/5336</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/releases/tag/tokio-1.23.1\">https://github.com/tokio-rs/tokio/releases/tag/tokio-1.23.1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients\">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7rrj-xr53-82p7\">https://github.com/advisories/GHSA-7rrj-xr53-82p7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7rrj-xr53-82p7",
            "title": "[tokio] Tokio reject_remote_clients configuration may get dropped when creating a Windows named pipe",
            "date_modified": "2023-01-06T21:41:00.000Z",
            "date_published": "2023-01-06T21:40:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7rrj-xr53-82p7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>When configuring a Windows named pipe server, setting <code>pipe_mode</code> will reset <code>reject_remote_clients</code> to <code>false</code>. If the application has previously configured <code>reject_remote_clients</code> to <code>true</code>, this effectively undoes the configuration. This also applies if <code>reject_remote_clients</code> is not explicitly set as this is the default configuration and is cleared by calling <code>pipe_mode</code>.</p>\n<p>Remote clients may only access the named pipe if the named pipe's associated path is accessible via a publically shared folder (SMB).</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The following versions have been patched:</p>\n<ul>\n<li>1.23.1</li>\n<li>1.20.3</li>\n<li>1.18.4</li>\n</ul>\n<p>The fix will also be present in all releases starting from version 1.24.0.</p>\n<p>Named pipes were introduced to Tokio in version 1.7.0, so releases older than 1.7.0 are not affected.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Ensure that <code>pipe_mode</code> is set <strong>first</strong> after initializing a <code>ServerOptions</code>. For example:</p>\n<pre><code class=\"language-rust\">let mut opts = ServerOptions::new();\nopts.pipe_mode(PipeMode::Message);\nopts.reject_remote_clients(true);\n</code></pre>\n<h3 id=\"references\">References</h3>\n<p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients\">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tokio-rs/tokio/security/advisories/GHSA-7rrj-xr53-82p7\">https://github.com/tokio-rs/tokio/security/advisories/GHSA-7rrj-xr53-82p7</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-22466\">https://nvd.nist.gov/vuln/detail/CVE-2023-22466</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/pull/5336\">https://github.com/tokio-rs/tokio/pull/5336</a></li>\n<li><a href=\"https://github.com/tokio-rs/tokio/releases/tag/tokio-1.23.1\">https://github.com/tokio-rs/tokio/releases/tag/tokio-1.23.1</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients\">https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea#pipe_reject_remote_clients</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7rrj-xr53-82p7\">https://github.com/advisories/GHSA-7rrj-xr53-82p7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7rrj-xr53-82p7",
            "title": "[tokio] Tokio reject_remote_clients configuration may get dropped when creating a Windows named pipe",
            "date_modified": "2023-01-06T21:41:00.000Z",
            "date_published": "2023-01-06T21:40:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7rrj-xr53-82p7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>SWHKD 1.1.5 unsafely uses the /tmp/swhkd.sock pathname. There can be an information leak or denial of service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-27818\">https://nvd.nist.gov/vuln/detail/CVE-2022-27818</a></li>\n<li><a href=\"https://github.com/waycrate/swhkd/commit/f70b99dd575fab79d8a942111a6980431f006818\">https://github.com/waycrate/swhkd/commit/f70b99dd575fab79d8a942111a6980431f006818</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2022/04/14/1\">http://www.openwall.com/lists/oss-security/2022/04/14/1</a></li>\n<li><a href=\"https://github.com/waycrate/swhkd/releases/tag/1.2.0\">https://github.com/waycrate/swhkd/releases/tag/1.2.0</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r3r5-jhw6-4634\">https://github.com/advisories/GHSA-r3r5-jhw6-4634</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r3r5-jhw6-4634",
            "title": "[Simple-Wayland-HotKey-Daemon] Insecure temporary file usage in SWHKD",
            "date_modified": "2023-01-05T11:52:03.000Z",
            "date_published": "2022-04-08T00:00:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r3r5-jhw6-4634"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>In function <code>Table::as_ref</code>, a reference of vector is force cast to slice. There are multiple problems here:</p>\n<ol>\n<li>To guarantee the size is correct, we have to first do <code>Vec::shrink_to_fit</code>. The function requires a mutable reference, so we have to force cast from immutable to mutable, which is undefined behavior (UB).</li>\n<li>Even if (1) is sound, <code>&amp;Vec&lt;T&gt;</code> and <code>&amp;[T]</code> still might not have the same layout. Treating them equally may lead to undefinted behavior (UB).</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/phsym/prettytable-rs/issues/145\">https://github.com/phsym/prettytable-rs/issues/145</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0074.html\">https://rustsec.org/advisories/RUSTSEC-2022-0074.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-gfgm-chr3-x6px\">https://github.com/advisories/GHSA-gfgm-chr3-x6px</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-gfgm-chr3-x6px",
            "title": "[prettytable-rs] prettytable-rs: Force cast a &Vec<T> to &[T] may lead to undefined behavior",
            "date_modified": "2022-12-30T17:48:31.000Z",
            "date_published": "2022-12-30T17:48:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-gfgm-chr3-x6px"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>When <code>hyper-staticfile</code> performs a redirect for a directory request (e.g. a request for <code>/dir</code> that redirects to <code>/dir/</code>), the <code>Location</code> header value was derived from user input (the request path), simply appending a slash. The intent was to perform an origin-relative redirect, but specific inputs allowed performing a scheme-relative redirect instead.</p>\n<p>An attacker could craft a special URL that would appear to be for the correct domain, but immediately redirects to a malicious domain. Such a URL can benefit phishing attacks, for example an innocent looking link in an email.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/stephank/hyper-staticfile/commit/4db4afb811c553bc3d54a01a9985b9e6dfc5a115\">https://github.com/stephank/hyper-staticfile/commit/4db4afb811c553bc3d54a01a9985b9e6dfc5a115</a></li>\n<li><a href=\"https://github.com/stephank/hyper-staticfile/commit/f12cadc6666c6f555d29725f5bc45da2103f24ea\">https://github.com/stephank/hyper-staticfile/commit/f12cadc6666c6f555d29725f5bc45da2103f24ea</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0072.html\">https://rustsec.org/advisories/RUSTSEC-2022-0072.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5wvv-q5fv-2388\">https://github.com/advisories/GHSA-5wvv-q5fv-2388</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5wvv-q5fv-2388",
            "title": "[hyper-staticfile] hyper-staticfile's location header incorporates user input, allowing open redirect",
            "date_modified": "2022-12-30T16:57:29.000Z",
            "date_published": "2022-12-30T16:57:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5wvv-q5fv-2388"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>When <code>hyper-staticfile</code> performs a redirect for a directory request (e.g. a request for <code>/dir</code> that redirects to <code>/dir/</code>), the <code>Location</code> header value was derived from user input (the request path), simply appending a slash. The intent was to perform an origin-relative redirect, but specific inputs allowed performing a scheme-relative redirect instead.</p>\n<p>An attacker could craft a special URL that would appear to be for the correct domain, but immediately redirects to a malicious domain. Such a URL can benefit phishing attacks, for example an innocent looking link in an email.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/stephank/hyper-staticfile/commit/4db4afb811c553bc3d54a01a9985b9e6dfc5a115\">https://github.com/stephank/hyper-staticfile/commit/4db4afb811c553bc3d54a01a9985b9e6dfc5a115</a></li>\n<li><a href=\"https://github.com/stephank/hyper-staticfile/commit/f12cadc6666c6f555d29725f5bc45da2103f24ea\">https://github.com/stephank/hyper-staticfile/commit/f12cadc6666c6f555d29725f5bc45da2103f24ea</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0072.html\">https://rustsec.org/advisories/RUSTSEC-2022-0072.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5wvv-q5fv-2388\">https://github.com/advisories/GHSA-5wvv-q5fv-2388</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5wvv-q5fv-2388",
            "title": "[hyper-staticfile] hyper-staticfile's location header incorporates user input, allowing open redirect",
            "date_modified": "2022-12-30T16:57:29.000Z",
            "date_published": "2022-12-30T16:57:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5wvv-q5fv-2388"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The filesystem glob pattern wildcards <code>*</code>, <code>?</code>, and <code>[...]</code> match file path literals and leading dots by default, which unintentionally exposes sub folder content of allowed paths.</p>\n<p>Example: The <code>fs</code> scope <code>$HOME/*.key</code> would also allow <code>$HOME/.ssh/secret.key</code> to be read even though it is in a sub directory of <code>$HOME</code> and is inside a hidden folder.</p>\n<p>Scopes without the wildcards are not affected. As <code>**</code> allows for sub directories the behavior there is also as expected.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue has been patched in the latest release and was backported into the currently supported 1.x branches.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>No workaround is known at the time of publication.</p>\n<h3 id=\"references\">References</h3>\n<p>The original report contained information that the <code>dialog.open</code> component automatically allows one sub directory to be read, regardless of the <code>recursive</code> option.</p>\n<p>Imagine a file system looking like</p>\n<pre><code> o ../\n o documents/\n    - file.txt\n    - deeper/\n       o deep_file.txt\n</code></pre>\n<p>Reproduction steps:</p>\n<ol>\n<li>Trying to load “file.txt” or “deep_file.txt” doesn’t work. Expected</li>\n<li>Select “documents” as folder to open(ie. with window.<strong>TAURI</strong>.dialog.open)</li>\n<li>Trying to load “file.txt” works. Expected</li>\n<li>Trying to load “deep_file.txt” also works, which isn’t expected</li>\n</ol>\n<p>The recursive flag is used in <a href=\"https://github.com/tauri-apps/tauri/blob/cd8c074ae6592303d3f6844a4fb6d262eae913b2/core/tauri/src/scope/fs.rs#L154\">https://github.com/tauri-apps/tauri/blob/cd8c074ae6592303d3f6844a4fb6d262eae913b2/core/tauri/src/scope/fs.rs#L154</a> to scope the filesystem access to either files in the folder or to also include sub directories.</p>\n<p>The original issue was replicated and further investigated.</p>\n<p>The root cause was triaged to the <code>glob</code> crate facilitating defaults, which allow the <code>*</code> and <code>[...]</code> to also match path literals.</p>\n<pre><code class=\"language-rust\">MatchOptions {\n    case_sensitive: true,\n    require_literal_separator: false,\n    require_literal_leading_dot: false\n}\n</code></pre>\n<p>This implicated that not only the <code>dialog.open</code> component was affected but rather all <code>fs</code> scopes containing the <code>*</code> or <code>[...]</code> glob.\nDuring this investigation it became obvious that the current glob matches would also match hidden folder (e.g: <code>.ssh</code>) content by default, without explicitly allowing hidden folders to be matched. This is not commonly expected behavior in comparison to for example <code>bash</code>.</p>\n<p>The new default  Match options are:</p>\n<pre><code class=\"language-rust\">MatchOptions {\n    case_sensitive: true,\n    require_literal_separator: true,\n    require_literal_leading_dot: true\n}\n</code></pre>\n<blockquote>\n<p>Another note security relevant for developers building applications interacting with case sensitive filesystems is, that the <code>case_sensitive</code> option only affects ASCII file paths and is not valid in Unicode based paths. This is considered a known risk until the <code>glob</code> crate supports non-ASCII file paths for this type of case sensitive matching.</p>\n</blockquote>\n<h3 id=\"for-more-information\">For more Information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<p>Open an issue in tauri\nEmail us at <a href=\"mailto:security@tauri.app\">security@tauri.app</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tauri-apps/tauri/security/advisories/GHSA-6mv3-wm7j-h4w5\">https://github.com/tauri-apps/tauri/security/advisories/GHSA-6mv3-wm7j-h4w5</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/14d567f7ecb25a6d1024cf3d796f86aee89d0dd4\">https://github.com/tauri-apps/tauri/commit/14d567f7ecb25a6d1024cf3d796f86aee89d0dd4</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/72389b00d7b495ffd7750eb1e75a3b8537d07cf3\">https://github.com/tauri-apps/tauri/commit/72389b00d7b495ffd7750eb1e75a3b8537d07cf3</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-46171\">https://nvd.nist.gov/vuln/detail/CVE-2022-46171</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/f0602e7c294245ab6ef6fbf2a976ef398340ef58\">https://github.com/tauri-apps/tauri/commit/f0602e7c294245ab6ef6fbf2a976ef398340ef58</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6mv3-wm7j-h4w5\">https://github.com/advisories/GHSA-6mv3-wm7j-h4w5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6mv3-wm7j-h4w5",
            "title": "[tauri] Tauri Filesystem Scope Glob Pattern is too Permissive",
            "date_modified": "2022-12-23T18:01:56.000Z",
            "date_published": "2022-12-22T20:03:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6mv3-wm7j-h4w5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The filesystem glob pattern wildcards <code>*</code>, <code>?</code>, and <code>[...]</code> match file path literals and leading dots by default, which unintentionally exposes sub folder content of allowed paths.</p>\n<p>Example: The <code>fs</code> scope <code>$HOME/*.key</code> would also allow <code>$HOME/.ssh/secret.key</code> to be read even though it is in a sub directory of <code>$HOME</code> and is inside a hidden folder.</p>\n<p>Scopes without the wildcards are not affected. As <code>**</code> allows for sub directories the behavior there is also as expected.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue has been patched in the latest release and was backported into the currently supported 1.x branches.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>No workaround is known at the time of publication.</p>\n<h3 id=\"references\">References</h3>\n<p>The original report contained information that the <code>dialog.open</code> component automatically allows one sub directory to be read, regardless of the <code>recursive</code> option.</p>\n<p>Imagine a file system looking like</p>\n<pre><code> o ../\n o documents/\n    - file.txt\n    - deeper/\n       o deep_file.txt\n</code></pre>\n<p>Reproduction steps:</p>\n<ol>\n<li>Trying to load “file.txt” or “deep_file.txt” doesn’t work. Expected</li>\n<li>Select “documents” as folder to open(ie. with window.<strong>TAURI</strong>.dialog.open)</li>\n<li>Trying to load “file.txt” works. Expected</li>\n<li>Trying to load “deep_file.txt” also works, which isn’t expected</li>\n</ol>\n<p>The recursive flag is used in <a href=\"https://github.com/tauri-apps/tauri/blob/cd8c074ae6592303d3f6844a4fb6d262eae913b2/core/tauri/src/scope/fs.rs#L154\">https://github.com/tauri-apps/tauri/blob/cd8c074ae6592303d3f6844a4fb6d262eae913b2/core/tauri/src/scope/fs.rs#L154</a> to scope the filesystem access to either files in the folder or to also include sub directories.</p>\n<p>The original issue was replicated and further investigated.</p>\n<p>The root cause was triaged to the <code>glob</code> crate facilitating defaults, which allow the <code>*</code> and <code>[...]</code> to also match path literals.</p>\n<pre><code class=\"language-rust\">MatchOptions {\n    case_sensitive: true,\n    require_literal_separator: false,\n    require_literal_leading_dot: false\n}\n</code></pre>\n<p>This implicated that not only the <code>dialog.open</code> component was affected but rather all <code>fs</code> scopes containing the <code>*</code> or <code>[...]</code> glob.\nDuring this investigation it became obvious that the current glob matches would also match hidden folder (e.g: <code>.ssh</code>) content by default, without explicitly allowing hidden folders to be matched. This is not commonly expected behavior in comparison to for example <code>bash</code>.</p>\n<p>The new default  Match options are:</p>\n<pre><code class=\"language-rust\">MatchOptions {\n    case_sensitive: true,\n    require_literal_separator: true,\n    require_literal_leading_dot: true\n}\n</code></pre>\n<blockquote>\n<p>Another note security relevant for developers building applications interacting with case sensitive filesystems is, that the <code>case_sensitive</code> option only affects ASCII file paths and is not valid in Unicode based paths. This is considered a known risk until the <code>glob</code> crate supports non-ASCII file paths for this type of case sensitive matching.</p>\n</blockquote>\n<h3 id=\"for-more-information\">For more Information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<p>Open an issue in tauri\nEmail us at <a href=\"mailto:security@tauri.app\">security@tauri.app</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tauri-apps/tauri/security/advisories/GHSA-6mv3-wm7j-h4w5\">https://github.com/tauri-apps/tauri/security/advisories/GHSA-6mv3-wm7j-h4w5</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/14d567f7ecb25a6d1024cf3d796f86aee89d0dd4\">https://github.com/tauri-apps/tauri/commit/14d567f7ecb25a6d1024cf3d796f86aee89d0dd4</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/72389b00d7b495ffd7750eb1e75a3b8537d07cf3\">https://github.com/tauri-apps/tauri/commit/72389b00d7b495ffd7750eb1e75a3b8537d07cf3</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-46171\">https://nvd.nist.gov/vuln/detail/CVE-2022-46171</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/f0602e7c294245ab6ef6fbf2a976ef398340ef58\">https://github.com/tauri-apps/tauri/commit/f0602e7c294245ab6ef6fbf2a976ef398340ef58</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6mv3-wm7j-h4w5\">https://github.com/advisories/GHSA-6mv3-wm7j-h4w5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6mv3-wm7j-h4w5",
            "title": "[tauri] Tauri Filesystem Scope Glob Pattern is too Permissive",
            "date_modified": "2022-12-23T18:01:56.000Z",
            "date_published": "2022-12-22T20:03:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6mv3-wm7j-h4w5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The filesystem glob pattern wildcards <code>*</code>, <code>?</code>, and <code>[...]</code> match file path literals and leading dots by default, which unintentionally exposes sub folder content of allowed paths.</p>\n<p>Example: The <code>fs</code> scope <code>$HOME/*.key</code> would also allow <code>$HOME/.ssh/secret.key</code> to be read even though it is in a sub directory of <code>$HOME</code> and is inside a hidden folder.</p>\n<p>Scopes without the wildcards are not affected. As <code>**</code> allows for sub directories the behavior there is also as expected.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue has been patched in the latest release and was backported into the currently supported 1.x branches.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>No workaround is known at the time of publication.</p>\n<h3 id=\"references\">References</h3>\n<p>The original report contained information that the <code>dialog.open</code> component automatically allows one sub directory to be read, regardless of the <code>recursive</code> option.</p>\n<p>Imagine a file system looking like</p>\n<pre><code> o ../\n o documents/\n    - file.txt\n    - deeper/\n       o deep_file.txt\n</code></pre>\n<p>Reproduction steps:</p>\n<ol>\n<li>Trying to load “file.txt” or “deep_file.txt” doesn’t work. Expected</li>\n<li>Select “documents” as folder to open(ie. with window.<strong>TAURI</strong>.dialog.open)</li>\n<li>Trying to load “file.txt” works. Expected</li>\n<li>Trying to load “deep_file.txt” also works, which isn’t expected</li>\n</ol>\n<p>The recursive flag is used in <a href=\"https://github.com/tauri-apps/tauri/blob/cd8c074ae6592303d3f6844a4fb6d262eae913b2/core/tauri/src/scope/fs.rs#L154\">https://github.com/tauri-apps/tauri/blob/cd8c074ae6592303d3f6844a4fb6d262eae913b2/core/tauri/src/scope/fs.rs#L154</a> to scope the filesystem access to either files in the folder or to also include sub directories.</p>\n<p>The original issue was replicated and further investigated.</p>\n<p>The root cause was triaged to the <code>glob</code> crate facilitating defaults, which allow the <code>*</code> and <code>[...]</code> to also match path literals.</p>\n<pre><code class=\"language-rust\">MatchOptions {\n    case_sensitive: true,\n    require_literal_separator: false,\n    require_literal_leading_dot: false\n}\n</code></pre>\n<p>This implicated that not only the <code>dialog.open</code> component was affected but rather all <code>fs</code> scopes containing the <code>*</code> or <code>[...]</code> glob.\nDuring this investigation it became obvious that the current glob matches would also match hidden folder (e.g: <code>.ssh</code>) content by default, without explicitly allowing hidden folders to be matched. This is not commonly expected behavior in comparison to for example <code>bash</code>.</p>\n<p>The new default  Match options are:</p>\n<pre><code class=\"language-rust\">MatchOptions {\n    case_sensitive: true,\n    require_literal_separator: true,\n    require_literal_leading_dot: true\n}\n</code></pre>\n<blockquote>\n<p>Another note security relevant for developers building applications interacting with case sensitive filesystems is, that the <code>case_sensitive</code> option only affects ASCII file paths and is not valid in Unicode based paths. This is considered a known risk until the <code>glob</code> crate supports non-ASCII file paths for this type of case sensitive matching.</p>\n</blockquote>\n<h3 id=\"for-more-information\">For more Information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<p>Open an issue in tauri\nEmail us at <a href=\"mailto:security@tauri.app\">security@tauri.app</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tauri-apps/tauri/security/advisories/GHSA-6mv3-wm7j-h4w5\">https://github.com/tauri-apps/tauri/security/advisories/GHSA-6mv3-wm7j-h4w5</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/14d567f7ecb25a6d1024cf3d796f86aee89d0dd4\">https://github.com/tauri-apps/tauri/commit/14d567f7ecb25a6d1024cf3d796f86aee89d0dd4</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/72389b00d7b495ffd7750eb1e75a3b8537d07cf3\">https://github.com/tauri-apps/tauri/commit/72389b00d7b495ffd7750eb1e75a3b8537d07cf3</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-46171\">https://nvd.nist.gov/vuln/detail/CVE-2022-46171</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/f0602e7c294245ab6ef6fbf2a976ef398340ef58\">https://github.com/tauri-apps/tauri/commit/f0602e7c294245ab6ef6fbf2a976ef398340ef58</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6mv3-wm7j-h4w5\">https://github.com/advisories/GHSA-6mv3-wm7j-h4w5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6mv3-wm7j-h4w5",
            "title": "[tauri] Tauri Filesystem Scope Glob Pattern is too Permissive",
            "date_modified": "2022-12-23T18:01:56.000Z",
            "date_published": "2022-12-22T20:03:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6mv3-wm7j-h4w5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The filesystem glob pattern wildcards <code>*</code>, <code>?</code>, and <code>[...]</code> match file path literals and leading dots by default, which unintentionally exposes sub folder content of allowed paths.</p>\n<p>Example: The <code>fs</code> scope <code>$HOME/*.key</code> would also allow <code>$HOME/.ssh/secret.key</code> to be read even though it is in a sub directory of <code>$HOME</code> and is inside a hidden folder.</p>\n<p>Scopes without the wildcards are not affected. As <code>**</code> allows for sub directories the behavior there is also as expected.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue has been patched in the latest release and was backported into the currently supported 1.x branches.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>No workaround is known at the time of publication.</p>\n<h3 id=\"references\">References</h3>\n<p>The original report contained information that the <code>dialog.open</code> component automatically allows one sub directory to be read, regardless of the <code>recursive</code> option.</p>\n<p>Imagine a file system looking like</p>\n<pre><code> o ../\n o documents/\n    - file.txt\n    - deeper/\n       o deep_file.txt\n</code></pre>\n<p>Reproduction steps:</p>\n<ol>\n<li>Trying to load “file.txt” or “deep_file.txt” doesn’t work. Expected</li>\n<li>Select “documents” as folder to open(ie. with window.<strong>TAURI</strong>.dialog.open)</li>\n<li>Trying to load “file.txt” works. Expected</li>\n<li>Trying to load “deep_file.txt” also works, which isn’t expected</li>\n</ol>\n<p>The recursive flag is used in <a href=\"https://github.com/tauri-apps/tauri/blob/cd8c074ae6592303d3f6844a4fb6d262eae913b2/core/tauri/src/scope/fs.rs#L154\">https://github.com/tauri-apps/tauri/blob/cd8c074ae6592303d3f6844a4fb6d262eae913b2/core/tauri/src/scope/fs.rs#L154</a> to scope the filesystem access to either files in the folder or to also include sub directories.</p>\n<p>The original issue was replicated and further investigated.</p>\n<p>The root cause was triaged to the <code>glob</code> crate facilitating defaults, which allow the <code>*</code> and <code>[...]</code> to also match path literals.</p>\n<pre><code class=\"language-rust\">MatchOptions {\n    case_sensitive: true,\n    require_literal_separator: false,\n    require_literal_leading_dot: false\n}\n</code></pre>\n<p>This implicated that not only the <code>dialog.open</code> component was affected but rather all <code>fs</code> scopes containing the <code>*</code> or <code>[...]</code> glob.\nDuring this investigation it became obvious that the current glob matches would also match hidden folder (e.g: <code>.ssh</code>) content by default, without explicitly allowing hidden folders to be matched. This is not commonly expected behavior in comparison to for example <code>bash</code>.</p>\n<p>The new default  Match options are:</p>\n<pre><code class=\"language-rust\">MatchOptions {\n    case_sensitive: true,\n    require_literal_separator: true,\n    require_literal_leading_dot: true\n}\n</code></pre>\n<blockquote>\n<p>Another note security relevant for developers building applications interacting with case sensitive filesystems is, that the <code>case_sensitive</code> option only affects ASCII file paths and is not valid in Unicode based paths. This is considered a known risk until the <code>glob</code> crate supports non-ASCII file paths for this type of case sensitive matching.</p>\n</blockquote>\n<h3 id=\"for-more-information\">For more Information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<p>Open an issue in tauri\nEmail us at <a href=\"mailto:security@tauri.app\">security@tauri.app</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tauri-apps/tauri/security/advisories/GHSA-6mv3-wm7j-h4w5\">https://github.com/tauri-apps/tauri/security/advisories/GHSA-6mv3-wm7j-h4w5</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/14d567f7ecb25a6d1024cf3d796f86aee89d0dd4\">https://github.com/tauri-apps/tauri/commit/14d567f7ecb25a6d1024cf3d796f86aee89d0dd4</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/72389b00d7b495ffd7750eb1e75a3b8537d07cf3\">https://github.com/tauri-apps/tauri/commit/72389b00d7b495ffd7750eb1e75a3b8537d07cf3</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-46171\">https://nvd.nist.gov/vuln/detail/CVE-2022-46171</a></li>\n<li><a href=\"https://github.com/tauri-apps/tauri/commit/f0602e7c294245ab6ef6fbf2a976ef398340ef58\">https://github.com/tauri-apps/tauri/commit/f0602e7c294245ab6ef6fbf2a976ef398340ef58</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6mv3-wm7j-h4w5\">https://github.com/advisories/GHSA-6mv3-wm7j-h4w5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6mv3-wm7j-h4w5",
            "title": "[tauri] Tauri Filesystem Scope Glob Pattern is too Permissive",
            "date_modified": "2022-12-23T18:01:56.000Z",
            "date_published": "2022-12-22T20:03:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6mv3-wm7j-h4w5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Anyone using the <code>tendermint-light-client</code> and related packages to perform light client verification (e.g. IBC-rs, Hermes).</p>\n<p>At present, the light client does not check that the chain IDs of the trusted and untrusted headers match, resulting in a possible attack vector where someone who finds a header from an untrusted chain that satisfies all other verification conditions (e.g. enough overlapping validator signatures) could fool a light client.</p>\n<p>The attack vector is currently theoretical, and no proof-of-concept exists yet to exploit it on live networks.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users of the light client-related crates can currently upgrade to <code>v0.28.0</code>.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tendermint/tendermint/tree/main/spec/light-client\">Light Client specification</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18\">https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23507\">https://nvd.nist.gov/vuln/detail/CVE-2022-23507</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5",
            "title": "[tendermint-light-client-js] Tendermint light client verification not taking into account chain ID",
            "date_modified": "2022-12-15T22:00:22.000Z",
            "date_published": "2022-12-14T21:35:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Anyone using the <code>tendermint-light-client</code> and related packages to perform light client verification (e.g. IBC-rs, Hermes).</p>\n<p>At present, the light client does not check that the chain IDs of the trusted and untrusted headers match, resulting in a possible attack vector where someone who finds a header from an untrusted chain that satisfies all other verification conditions (e.g. enough overlapping validator signatures) could fool a light client.</p>\n<p>The attack vector is currently theoretical, and no proof-of-concept exists yet to exploit it on live networks.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users of the light client-related crates can currently upgrade to <code>v0.28.0</code>.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tendermint/tendermint/tree/main/spec/light-client\">Light Client specification</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18\">https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23507\">https://nvd.nist.gov/vuln/detail/CVE-2022-23507</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5",
            "title": "[tendermint-light-client] Tendermint light client verification not taking into account chain ID",
            "date_modified": "2022-12-15T22:00:22.000Z",
            "date_published": "2022-12-14T21:35:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Anyone using the <code>tendermint-light-client</code> and related packages to perform light client verification (e.g. IBC-rs, Hermes).</p>\n<p>At present, the light client does not check that the chain IDs of the trusted and untrusted headers match, resulting in a possible attack vector where someone who finds a header from an untrusted chain that satisfies all other verification conditions (e.g. enough overlapping validator signatures) could fool a light client.</p>\n<p>The attack vector is currently theoretical, and no proof-of-concept exists yet to exploit it on live networks.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Users of the light client-related crates can currently upgrade to <code>v0.28.0</code>.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tendermint/tendermint/tree/main/spec/light-client\">Light Client specification</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/informalsystems/tendermint-rs/security/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n<li><a href=\"https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18\">https://github.com/informalsystems/tendermint-rs/commit/5c32f31b97ac3172775699fe0d4ba6003ca4fb18</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23507\">https://nvd.nist.gov/vuln/detail/CVE-2022-23507</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xqqc-c5gw-c5r5\">https://github.com/advisories/GHSA-xqqc-c5gw-c5r5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5",
            "title": "[tendermint-light-client-verifier] Tendermint light client verification not taking into account chain ID",
            "date_modified": "2022-12-15T22:00:22.000Z",
            "date_published": "2022-12-14T21:35:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xqqc-c5gw-c5r5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The linux-loader crate used the offsets and sizes provided in the ELF headers to determine the offsets to read from. If those offsets pointed beyond the end of the file this could lead to an infinite loop. Virtual Machine Monitors using the <code>linux-loader</code> crate could enter an infinite loop if the ELF header of the kernel they are loading was modified in a malicious manner.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue has been addressed in 0.8.1</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The issue can be mitigated by ensuring that only trusted kernel images are loaded or by verifying that the headers to not point beyond the end of the file.</p>\n<h3 id=\"references\">References</h3>\n<p>See: <a href=\"https://github.com/rust-vmm/linux-loader/pull/125\">https://github.com/rust-vmm/linux-loader/pull/125</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-vmm/linux-loader/security/advisories/GHSA-52h2-m2cf-9jh6\">https://github.com/rust-vmm/linux-loader/security/advisories/GHSA-52h2-m2cf-9jh6</a></li>\n<li><a href=\"https://github.com/rust-vmm/linux-loader/commit/a44f152da4f38c538ed492b1efa8515be2047db2\">https://github.com/rust-vmm/linux-loader/commit/a44f152da4f38c538ed492b1efa8515be2047db2</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-23523\">https://nvd.nist.gov/vuln/detail/CVE-2022-23523</a></li>\n<li><a href=\"https://github.com/rust-vmm/linux-loader/pull/125\">https://github.com/rust-vmm/linux-loader/pull/125</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-52h2-m2cf-9jh6\">https://github.com/advisories/GHSA-52h2-m2cf-9jh6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-52h2-m2cf-9jh6",
            "title": "[linux-loader] linux-loader reading beyond EOF could lead to infinite loop",
            "date_modified": "2022-12-15T22:00:47.000Z",
            "date_published": "2022-12-12T22:35:41.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-52h2-m2cf-9jh6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A problem with Candy Machine V2 allow minting NFTs to an arbitrary collection due to a missing check.</p>\n<p>Here is a description of the exploit:\nDetails:\nHere is the tx/ix to exploit:\nTransaction:\nIx 1: candy_machine v2, mint_nft, passing in empty metadata -1\nIx 2: custom handler, 0\n        cpi A --&gt; token_metadata create_metadata_account, creates NFT\n        cpi B --&gt; candy_machine v2, set_collection_during_mint\nIx 1 passes our first check for empty metadata, but eventually will hit a bot tax and return Ok.  We do have a CPI check in this function but even if we hit that or moved it to the top, it returns Ok as a bot tax and still enables the issue.\nIx 2, cpi A is Ok and mints an arbitrary NFT.\nIx 2, cpi B checks the previous instruction using index_relative_to_current-1.  This turns out to be Ix 1 which was Ok, so then your newly minted arbitrary NFT is successfully added to the collection.\nConclusion:\nCandy machine could be out of NFTs and it still works.  If the CM is closed, (we think?) it doesn't get to the check.\nThe fix needs to be in set_collection_during_mint that current program ID id candy_machine_v2.  It checks previous program ID but doesn't check current.</p>\n<p>NOTE: THIS DOES NOT AFFECT Cmv3</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-9v25-r5q2-2p6w\">https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-9v25-r5q2-2p6w</a></li>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/commit/e6b3aff603ac06236bf77c2ec21ead93c6836dce\">https://github.com/metaplex-foundation/metaplex-program-library/commit/e6b3aff603ac06236bf77c2ec21ead93c6836dce</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9v25-r5q2-2p6w\">https://github.com/advisories/GHSA-9v25-r5q2-2p6w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9v25-r5q2-2p6w",
            "title": "[mpl-candy-machine] Candy Machine Set Collection During Mint Missing Check",
            "date_modified": "2022-12-12T22:03:21.000Z",
            "date_published": "2022-12-12T22:03:19.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9v25-r5q2-2p6w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>This was an error found by @metamania01 of the Audit Company Solshield.</p>\n<p>It allowed one to verify a creator that did not sign by making use of a provision in Token Metadata that allows Creators who have signed compressed nfts to allow them to decompress with verified creators.</p>\n<p>The issue is now patched.\nFor more info see.\n<a href=\"https://twitter.com/thehasheddude/status/1601642138143375360\">https://twitter.com/thehasheddude/status/1601642138143375360</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-8r76-fr72-j32w\">https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-8r76-fr72-j32w</a></li>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/commit/c18591a7ce9bb561940cb94df4b7c35ef9cc0f57\">https://github.com/metaplex-foundation/metaplex-program-library/commit/c18591a7ce9bb561940cb94df4b7c35ef9cc0f57</a></li>\n<li><a href=\"https://twitter.com/thehasheddude/status/1601642138143375360\">https://twitter.com/thehasheddude/status/1601642138143375360</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8r76-fr72-j32w\">https://github.com/advisories/GHSA-8r76-fr72-j32w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8r76-fr72-j32w",
            "title": "[mpl-token-metadata] Creator Verification Error when Bubblegum Activate",
            "date_modified": "2022-12-12T22:02:45.000Z",
            "date_published": "2022-12-12T22:02:42.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8r76-fr72-j32w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>This was an error found by @metamania01 of the Audit Company Solshield.</p>\n<p>It allowed one to verify a creator that did not sign by making use of a provision in Token Metadata that allows Creators who have signed compressed nfts to allow them to decompress with verified creators.</p>\n<p>The issue is now patched.\nFor more info see.\n<a href=\"https://twitter.com/thehasheddude/status/1601642138143375360\">https://twitter.com/thehasheddude/status/1601642138143375360</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-8r76-fr72-j32w\">https://github.com/metaplex-foundation/metaplex-program-library/security/advisories/GHSA-8r76-fr72-j32w</a></li>\n<li><a href=\"https://github.com/metaplex-foundation/metaplex-program-library/commit/c18591a7ce9bb561940cb94df4b7c35ef9cc0f57\">https://github.com/metaplex-foundation/metaplex-program-library/commit/c18591a7ce9bb561940cb94df4b7c35ef9cc0f57</a></li>\n<li><a href=\"https://twitter.com/thehasheddude/status/1601642138143375360\">https://twitter.com/thehasheddude/status/1601642138143375360</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8r76-fr72-j32w\">https://github.com/advisories/GHSA-8r76-fr72-j32w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8r76-fr72-j32w",
            "title": "[mpl-bubblegum] Creator Verification Error when Bubblegum Activate",
            "date_modified": "2022-12-12T22:02:45.000Z",
            "date_published": "2022-12-12T22:02:42.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8r76-fr72-j32w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.</p>\n<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>\n<p>You are unaffected if you either</p>\n<ul>\n<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>\n<li>manually checked that your usage of the method is sound</li>\n<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>\n</ul>\n<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>\n<p>See the <a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">GitHub issue</a> for example \"exploit\" code and further discussion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0070.html\">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-969w-q74q-9j8v\">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v",
            "title": "[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code",
            "date_modified": "2022-12-08T16:00:29.000Z",
            "date_published": "2022-12-08T16:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to \"free\" memory not allocated by the appropriate allocator.</p>\n<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to \"deallocate\" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>\n<p>You are unaffected if you either</p>\n<ul>\n<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>\n<li>manually checked that your usage of the method is sound</li>\n<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>\n</ul>\n<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>\n<p>See the <a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">GitHub issue</a> for example \"exploit\" code and further discussion.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-bitcoin/rust-secp256k1/issues/543\">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0070.html\">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-969w-q74q-9j8v\">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v",
            "title": "[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code",
            "date_modified": "2022-12-08T16:00:29.000Z",
            "date_published": "2022-12-08T16:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-969w-q74q-9j8v"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}