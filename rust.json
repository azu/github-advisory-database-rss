{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>Lru crate has use after free vulnerability.</p>\n<p>Lru crate has two functions for getting an iterator. Both iterators give\nreferences to key and value. Calling specific functions, like pop(), will remove\nand free the value, and but it's still possible to access the reference of value\nwhich is already dropped causing use after free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jeromefroe/lru-rs/issues/120\">https://github.com/jeromefroe/lru-rs/issues/120</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0130.html\">https://rustsec.org/advisories/RUSTSEC-2021-0130.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-qqmc-hwqp-8g2w\">https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-qqmc-hwqp-8g2w",
            "title": "[lru] Use after free in lru crate",
            "date_modified": "2023-06-13T18:40:06.000Z",
            "date_published": "2022-06-17T00:11:13.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-qqmc-hwqp-8g2w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Lru crate has two functions for getting an iterator. Both iterators give references to key and value. Calling specific functions, like pop(), will remove and free the value, and but it's still possible to access the reference of value which is already dropped causing use after free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45720\">https://nvd.nist.gov/vuln/detail/CVE-2021-45720</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/lru/RUSTSEC-2021-0130.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/lru/RUSTSEC-2021-0130.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0130.html\">https://rustsec.org/advisories/RUSTSEC-2021-0130.html</a></li>\n<li><a href=\"https://github.com/jeromefroe/lru-rs/issues/120\">https://github.com/jeromefroe/lru-rs/issues/120</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-v362-2895-h9r2\">https://github.com/advisories/GHSA-v362-2895-h9r2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-v362-2895-h9r2",
            "title": "[lru] Use After Free in lru",
            "date_modified": "2023-06-13T18:38:44.000Z",
            "date_published": "2022-01-07T22:37:01.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-v362-2895-h9r2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the nanorand crate before 0.6.1 for Rust. There can be multiple mutable references to the same object because the TlsWyRand Deref implementation dereferences a raw pointer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45705\">https://nvd.nist.gov/vuln/detail/CVE-2021-45705</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nanorand/RUSTSEC-2021-0114.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nanorand/RUSTSEC-2021-0114.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0114.html\">https://rustsec.org/advisories/RUSTSEC-2021-0114.html</a></li>\n<li><a href=\"https://github.com/Absolucy/nanorand-rs/issues/28\">https://github.com/Absolucy/nanorand-rs/issues/28</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r57r-j98g-587f\">https://github.com/advisories/GHSA-r57r-j98g-587f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r57r-j98g-587f",
            "title": "[nanorand] Pointer dereference in nanorand",
            "date_modified": "2023-06-13T18:38:09.000Z",
            "date_published": "2022-01-06T22:08:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r57r-j98g-587f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p><code>TlsWyRand</code>'s implementation of <code>Deref</code> unconditionally dereferences a raw pointer, and returns \nmultiple mutable references to the same object, which is undefined behavior.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Absolucy/nanorand-rs/issues/28\">https://github.com/Absolucy/nanorand-rs/issues/28</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0114.html\">https://rustsec.org/advisories/RUSTSEC-2021-0114.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-p6gj-gpc8-f8xw\">https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-p6gj-gpc8-f8xw",
            "title": "[nanorand] Aliased mutable references from `tls_rand` & `TlsWyRand`",
            "date_modified": "2023-06-13T18:37:41.000Z",
            "date_published": "2022-06-17T00:13:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-p6gj-gpc8-f8xw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Neon provides functionality for creating JavaScript <code>ArrayBuffer</code> (and the <code>Buffer</code> subtype) instances backed by bytes allocated outside of V8/Node. The <a href=\"https://docs.rs/neon/0.10.0/neon/types/struct.JsArrayBuffer.html#method.external\"><code>JsArrayBuffer::external</code></a> and <a href=\"https://docs.rs/neon/0.10.0/neon/types/struct.JsBuffer.html#method.external\"><code>JsBuffer::external</code></a> did not require <code>T: 'static</code> prior to Neon <code>0.10.1</code>. This allowed creating an externally backed buffer from types that may be freed while they are still referenced by a JavaScript <code>ArrayBuffer</code>.</p>\n<p>The following example demonstrates use after free. It compiles on versions <code>&lt;0.10.1</code> and fails to compile afterward.</p>\n<pre><code class=\"language-rust\">pub fn soundness_hole(mut cx: FunctionContext) -&gt; JsResult&lt;JsArrayBuffer&gt; {\n    let mut data = vec![0u8, 1, 2, 3];\n    \n    // Creating an external from `&amp;mut [u8]` instead of `Vec&lt;u8&gt;` since there is a blanket impl\n    // of `AsMut&lt;T&gt; for &amp;mut T`\n    let buf = JsArrayBuffer::external(&amp;mut cx, data.as_mut_slice());\n\n    // `buf` is still holding a reference to `data`!\n    drop(data);\n\n    Ok(buf)\n}\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/neon-bindings/neon/issues/896\">https://github.com/neon-bindings/neon/issues/896</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0028.html\">https://rustsec.org/advisories/RUSTSEC-2022-0028.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8mj7-wxmc-f424\">https://github.com/advisories/GHSA-8mj7-wxmc-f424</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8mj7-wxmc-f424",
            "title": "[neon] Use after free in Neon external buffers",
            "date_modified": "2023-06-13T18:37:13.000Z",
            "date_published": "2022-06-17T00:13:40.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8mj7-wxmc-f424"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2023-06-13T18:36:31.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2023-06-13T18:36:31.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2023-06-13T18:36:31.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2023-06-13T18:32:57.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2023-06-13T18:32:57.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2023-06-13T18:32:57.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>ncurses exposes functions from the ncurses library which:</p>\n<ul>\n<li>Pass buffers without length to C functions that may write an arbitrary amount of data, leading to a buffer overflow. (instr, mvwinstr, etc)</li>\n<li>Passes rust &amp;str to strings expecting C format arguments, allowing hostile input to execute a format string attack, which trivially allows writing arbitrary data to stack memory (functions in the printw family).</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15547\">https://nvd.nist.gov/vuln/detail/CVE-2019-15547</a></li>\n<li><a href=\"https://github.com/RustSec/advisory-db/issues/106\">https://github.com/RustSec/advisory-db/issues/106</a></li>\n<li><a href=\"https://github.com/jeaye/ncurses-rs/issues/172\">https://github.com/jeaye/ncurses-rs/issues/172</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0006.html\">https://rustsec.org/advisories/RUSTSEC-2019-0006.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-32v7-ghpr-c8hg\">https://github.com/advisories/GHSA-32v7-ghpr-c8hg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-32v7-ghpr-c8hg",
            "title": "[ncurses] Mishandling of format strings in ncurses",
            "date_modified": "2023-06-13T18:30:36.000Z",
            "date_published": "2021-08-25T20:58:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-32v7-ghpr-c8hg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedMutexGuard unsoundness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35910\">https://nvd.nist.gov/vuln/detail/CVE-2020-35910</a></li>\n<li><a href=\"https://github.com/Amanieu/parking_lot/pull/262\">https://github.com/Amanieu/parking_lot/pull/262</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0070.html\">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-ppj3-7jw3-8vc4\">https://github.com/advisories/GHSA-ppj3-7jw3-8vc4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-ppj3-7jw3-8vc4",
            "title": "[lock_api] Data races in lock_api",
            "date_modified": "2023-06-13T18:25:53.000Z",
            "date_published": "2021-08-25T20:49:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-ppj3-7jw3-8vc4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedRwLockReadGuard unsoundness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35911\">https://nvd.nist.gov/vuln/detail/CVE-2020-35911</a></li>\n<li><a href=\"https://github.com/Amanieu/parking_lot/pull/262\">https://github.com/Amanieu/parking_lot/pull/262</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0070.html\">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vh4p-6j7g-f4j9\">https://github.com/advisories/GHSA-vh4p-6j7g-f4j9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vh4p-6j7g-f4j9",
            "title": "[lock_api] Data races in lock_api",
            "date_modified": "2023-06-13T18:24:43.000Z",
            "date_published": "2021-08-25T20:49:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vh4p-6j7g-f4j9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of RwLockReadGuard unsoundness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35913\">https://nvd.nist.gov/vuln/detail/CVE-2020-35913</a></li>\n<li><a href=\"https://github.com/Amanieu/parking_lot/pull/262\">https://github.com/Amanieu/parking_lot/pull/262</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0070.html\">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hj9h-wrgg-hgmx\">https://github.com/advisories/GHSA-hj9h-wrgg-hgmx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hj9h-wrgg-hgmx",
            "title": "[lock_api] Data races in lock_api",
            "date_modified": "2023-06-13T18:24:18.000Z",
            "date_published": "2021-08-25T20:50:02.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hj9h-wrgg-hgmx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of RwLockWriteGuard unsoundness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35914\">https://nvd.nist.gov/vuln/detail/CVE-2020-35914</a></li>\n<li><a href=\"https://github.com/Amanieu/parking_lot/pull/262\">https://github.com/Amanieu/parking_lot/pull/262</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0070.html\">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-gmv4-vmx3-x9f3\">https://github.com/advisories/GHSA-gmv4-vmx3-x9f3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-gmv4-vmx3-x9f3",
            "title": "[lock_api] Data races in lock_api",
            "date_modified": "2023-06-13T18:23:50.000Z",
            "date_published": "2021-08-25T20:49:37.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-gmv4-vmx3-x9f3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>HeaderMap::reserve() used usize::next_power_of_two() to calculate the increased capacity. However, next_power_of_two() silently overflows to 0 if given a sufficiently large number in release mode.</p>\n<p>If the map was not empty when the overflow happens, the library will invoke self.grow(0) and start infinite probing. This allows an attacker who controls the argument to reserve() to cause a potential denial of service (DoS).</p>\n<p>The flaw was corrected in 0.1.20 release of http crate.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-25574\">https://nvd.nist.gov/vuln/detail/CVE-2020-25574</a></li>\n<li><a href=\"https://github.com/hyperium/http/issues/352\">https://github.com/hyperium/http/issues/352</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0033.html\">https://rustsec.org/advisories/RUSTSEC-2019-0033.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-x7vr-c387-8w57\">https://github.com/advisories/GHSA-x7vr-c387-8w57</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-x7vr-c387-8w57",
            "title": "[http] Integer Overflow/Infinite Loop in the http crate",
            "date_modified": "2023-06-13T18:21:10.000Z",
            "date_published": "2021-08-25T21:01:31.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-x7vr-c387-8w57"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>HeaderMap::reserve() used usize::next_power_of_two() to calculate the increased capacity. However, next_power_of_two() silently overflows to 0 if given a sufficiently large number in release mode.</p>\n<p>If the map was not empty when the overflow happens, the library will invoke self.grow(0) and start infinite probing. This allows an attacker who controls the argument to reserve() to cause a potential denial of service (DoS).</p>\n<p>The flaw was corrected in 0.1.20 release of http crate.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-25008\">https://nvd.nist.gov/vuln/detail/CVE-2019-25008</a></li>\n<li><a href=\"https://github.com/hyperium/http/issues/352\">https://github.com/hyperium/http/issues/352</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0033.html\">https://rustsec.org/advisories/RUSTSEC-2019-0033.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xvc9-xwgj-4cq9\">https://github.com/advisories/GHSA-xvc9-xwgj-4cq9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xvc9-xwgj-4cq9",
            "title": "[http] Integer Overflow in HeaderMap::reserve() can cause Denial of Service",
            "date_modified": "2023-06-13T18:20:44.000Z",
            "date_published": "2022-06-16T23:08:02.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xvc9-xwgj-4cq9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate would call Vec::set_len on an uninitialized vector with user-provided type parameter, in an interface of the HDR image format decoder. They would then also call other code that could panic before initializing all instances.</p>\n<p>This could run Drop implementations on uninitialized types, equivalent to use-after-free, and allow an attacker arbitrary code execution.</p>\n<p>Two different fixes were applied. It is possible to conserve the interface by ensuring proper initialization before calling Vec::set_len. Drop is no longer called in case of panic, though.</p>\n<p>Starting from version 0.22, a breaking change to the interface requires callers to pre-allocate the output buffer and pass a mutable slice instead, avoiding all unsafe code.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-16138\">https://nvd.nist.gov/vuln/detail/CVE-2019-16138</a></li>\n<li><a href=\"https://github.com/image-rs/image/pull/985\">https://github.com/image-rs/image/pull/985</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0014.html\">https://rustsec.org/advisories/RUSTSEC-2019-0014.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m2pf-hprp-3vqm\">https://github.com/advisories/GHSA-m2pf-hprp-3vqm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m2pf-hprp-3vqm",
            "title": "[image] Use after free in image",
            "date_modified": "2023-06-13T18:18:17.000Z",
            "date_published": "2021-08-25T20:44:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m2pf-hprp-3vqm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lazy-init crate through 2021-01-17 for Rust. Lazy lacks a Send bound, leading to a data race.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-25901\">https://nvd.nist.gov/vuln/detail/CVE-2021-25901</a></li>\n<li><a href=\"https://github.com/khuey/lazy-init/issues/9\">https://github.com/khuey/lazy-init/issues/9</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0004.html\">https://rustsec.org/advisories/RUSTSEC-2021-0004.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-w47j-hqpf-qw9w\">https://github.com/advisories/GHSA-w47j-hqpf-qw9w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-w47j-hqpf-qw9w",
            "title": "[lazy-init] Out of bounds read in lazy-init",
            "date_modified": "2023-06-13T18:15:14.000Z",
            "date_published": "2021-08-25T20:52:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-w47j-hqpf-qw9w"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}