{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>Affected versions of this crate did not properly calculate secret shares requirements.</p>\n<p>This reduces the security of the algorithm by restricting the crate to always\nusing a threshold value of three, rather than a configurable limit.</p>\n<p>The flaw was corrected by correctly configuring the threshold.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Nebulosus/shamir/issues/3\">https://github.com/Nebulosus/shamir/issues/3</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0160.html\">https://rustsec.org/advisories/RUSTSEC-2020-0160.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-978j-88f3-p5j3\">https://github.com/advisories/GHSA-978j-88f3-p5j3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-978j-88f3-p5j3",
            "title": "[shamir] Threshold value is ignored (all shares are n=3)",
            "date_modified": "2022-06-17T00:18:44.000Z",
            "date_published": "2022-06-17T00:18:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-978j-88f3-p5j3"
            }
        },
        {
            "content_html": "<p>When parsing JSON using <code>json::Json::from_str</code>, there is no limit to the depth of the stack, therefore deeply nested objects can cause a stack overflow, which aborts the process.</p>\n<p>Example code that triggers the vulnerability is</p>\n<pre><code class=\"language-rust\">fn main() {\n    let _ = rustc_serialize::json::Json::from_str(&amp;\"[0,[\".repeat(10000));\n}\n</code></pre>\n<p><a href=\"https://crates.io/crates/serde\">serde</a> is recommended as a replacement to rustc_serialize.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-lang-deprecated/rustc-serialize\">https://github.com/rust-lang-deprecated/rustc-serialize</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0004.html\">https://rustsec.org/advisories/RUSTSEC-2022-0004.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2226-4v3c-cff8\">https://github.com/advisories/GHSA-2226-4v3c-cff8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2226-4v3c-cff8",
            "title": "[rustc-serialize] Stack overflow in rustc_serialize when parsing deeply nested JSON",
            "date_modified": "2022-06-17T00:18:27.000Z",
            "date_published": "2022-06-17T00:18:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2226-4v3c-cff8"
            }
        },
        {
            "content_html": "<p>When running in debug mode and the <code>debug-embed</code> (off by default) feature is\nnot enabled, the generated <code>get</code> method does not check that the input path is\na child of the folder given. </p>\n<p>This allows attackers to read arbitrary files in the file system if they have\ncontrol over the filename given. The following code will print the contents of\nyour <code>/etc/passwd</code> if adjusted with a correct number of <code>../</code>s depending on\nwhere it is run from.</p>\n<pre><code class=\"language-rust\">#[derive(rust_embed::RustEmbed)]\n#[folder = \"src/\"]\npub struct Asset;\n\nfn main() {\n    let d = Asset::get(\"../../../etc/passwd\").unwrap().data;\n    println!(\"{}\", String::from_utf8_lossy(&amp;d));\n}\n</code></pre>\n<p>The flaw was corrected by canonicalizing the input filename and ensuring that\nit starts with the canonicalized folder path.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/pyros2097/rust-embed/issues/159\">https://github.com/pyros2097/rust-embed/issues/159</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0126.html\">https://rustsec.org/advisories/RUSTSEC-2021-0126.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cgw6-f3mj-h742\">https://github.com/advisories/GHSA-cgw6-f3mj-h742</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cgw6-f3mj-h742",
            "title": "[rust-embed] RustEmbed generated `get` method allows for directory traversal when reading files from disk",
            "date_modified": "2022-06-17T00:18:09.000Z",
            "date_published": "2022-06-17T00:18:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cgw6-f3mj-h742"
            }
        },
        {
            "content_html": "<p>The following Rust program demonstrates some strangeness in AES encryption - if you have an immutable key slice and then operate on that slice, you get different encryption output than if you operate on a copy of that key.</p>\n<p>For these functions, we expect that extending a 16 byte key to a 32 byte key by repeating it gives the same encrypted data, because the underlying rust-crypto functions repeat key data up to the necessary key size for the cipher.</p>\n<pre><code class=\"language-rust\">use crypto::{\n    aes, blockmodes, buffer,\n    buffer::{BufferResult, ReadBuffer, WriteBuffer},\n    symmetriccipher,\n};\n\nfn encrypt(\n    key: &amp;[u8],\n    iv: &amp;[u8],\n    data: &amp;str,\n) -&gt; Result&lt;String, symmetriccipher::SymmetricCipherError&gt; {\n    let mut encryptor =\n        aes::cbc_encryptor(aes::KeySize::KeySize256, key, iv, blockmodes::PkcsPadding);\n\n    let mut encrypted_data = Vec::&lt;u8&gt;::new();\n    let mut read_buffer = buffer::RefReadBuffer::new(data.as_bytes());\n    let mut buffer = [0; 4096];\n    let mut write_buffer = buffer::RefWriteBuffer::new(&amp;mut buffer);\n\n    loop {\n        let result = encryptor.encrypt(&amp;mut read_buffer, &amp;mut write_buffer, true)?;\n\n        encrypted_data.extend(\n            write_buffer\n                .take_read_buffer()\n                .take_remaining()\n                .iter()\n                .copied(),\n        );\n\n        match result {\n            BufferResult::BufferUnderflow =&gt; break,\n            BufferResult::BufferOverflow =&gt; {}\n        }\n    }\n\n    Ok(hex::encode(encrypted_data))\n}\n\nfn working() {\n    let data = \"data\";\n    let iv = [\n        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,\n        0xFF,\n    ];\n    let key = [\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F,\n    ];\n    // The copy here makes the code work.\n    let key_copy = key;\n    let key2: Vec&lt;u8&gt; = key_copy.iter().cycle().take(32).copied().collect();\n    println!(\"key1:{} key2: {}\", hex::encode(&amp;key), hex::encode(&amp;key2));\n\n    let x1 = encrypt(&amp;key, &amp;iv, data).unwrap();\n    println!(\"X1: {}\", x1);\n\n    let x2 = encrypt(&amp;key2, &amp;iv, data).unwrap();\n    println!(\"X2: {}\", x2);\n\n    assert_eq!(x1, x2);\n}\n\nfn broken() {\n    let data = \"data\";\n    let iv = [\n        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,\n        0xFF,\n    ];\n    let key = [\n        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,\n        0x0F,\n    ];\n    // This operation shouldn't affect the contents of key at all.\n    let key2: Vec&lt;u8&gt; = key.iter().cycle().take(32).copied().collect();\n    println!(\"key1:{} key2: {}\", hex::encode(&amp;key), hex::encode(&amp;key2));\n\n    let x1 = encrypt(&amp;key, &amp;iv, data).unwrap();\n    println!(\"X1: {}\", x1);\n\n    let x2 = encrypt(&amp;key2, &amp;iv, data).unwrap();\n    println!(\"X2: {}\", x2);\n\n    assert_eq!(x1, x2);\n}\n\nfn main() {\n    working();\n    broken();\n}\n</code></pre>\n<p>The output from this program:</p>\n<pre><code class=\"language-shell\">     Running `target/host/debug/rust-crypto-test`\nkey1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f\nX1: 90462bbe32965c8e7ea0addbbed4cddb\nX2: 90462bbe32965c8e7ea0addbbed4cddb\nkey1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f\nX1: 26e847e5e7df1947bf82a650548a7d5b\nX2: 90462bbe32965c8e7ea0addbbed4cddb\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `\"26e847e5e7df1947bf82a650548a7d5b\"`,\n right: `\"90462bbe32965c8e7ea0addbbed4cddb\"`', src/main.rs:83:5\n</code></pre>\n<p>Notably, the X1 key in the <code>broken()</code> test changes every time after rerunning the program.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/DaGenix/rust-crypto/issues/476\">https://github.com/DaGenix/rust-crypto/issues/476</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0011.html\">https://rustsec.org/advisories/RUSTSEC-2022-0011.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jp3w-3q88-34cf\">https://github.com/advisories/GHSA-jp3w-3q88-34cf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jp3w-3q88-34cf",
            "title": "[rust-crypto] Miscomputation when performing AES encryption in rust-crypto",
            "date_modified": "2022-06-17T00:17:09.000Z",
            "date_published": "2022-06-17T00:17:08.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jp3w-3q88-34cf"
            }
        },
        {
            "content_html": "<p>The lifetime bound on several closure-accepting <code>rusqlite</code> functions (specifically, functions which register a callback to be later invoked by SQLite) was too relaxed. If a closure referencing borrowed values on the stack is was passed to one of these functions, it could allow Rust code to access objects on the stack after they have been dropped.</p>\n<p>The impacted functions are:</p>\n<ul>\n<li>Under <code>cfg(feature = \"functions\")</code>: <code>Connection::create_scalar_function</code>, <code>Connection::create_aggregate_function</code> and <code>Connection::create_window_function</code>.</li>\n<li>Under <code>cfg(feature = \"hooks\")</code>: <code>Connection::commit_hook</code>, <code>Connection::rollback_hook</code> and <code>Connection::update_hook</code>.</li>\n<li>Under <code>cfg(feature = \"collation\")</code>: <code>Connection::create_collation</code>.</li>\n</ul>\n<p>The issue exists in all <code>0.25.*</code> versions prior to <code>0.25.4</code>, and all <code>0.26.*</code> versions prior to 0.26.2 (specifically: <code>0.25.0</code>, <code>0.25.1</code>, <code>0.25.2</code>, <code>0.25.3</code>, <code>0.26.0</code>, and <code>0.26.1</code>).</p>\n<p>The fix is available in versions <code>0.26.2</code> and newer, and also has been back-ported to <code>0.25.4</code>. As it does not exist in <code>0.24.*</code>, all affected versions should have an upgrade path to a semver-compatible release.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rusqlite/rusqlite/issues/1048\">https://github.com/rusqlite/rusqlite/issues/1048</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0128.html\">https://rustsec.org/advisories/RUSTSEC-2021-0128.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q89g-4vhh-mvvm\">https://github.com/advisories/GHSA-q89g-4vhh-mvvm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q89g-4vhh-mvvm",
            "title": "[rusqlite] Incorrect Lifetime Bounds on Closures in `rusqlite`",
            "date_modified": "2022-06-17T00:16:49.000Z",
            "date_published": "2022-06-17T00:16:48.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q89g-4vhh-mvvm"
            }
        },
        {
            "content_html": "<p>The lifetime bound on several closure-accepting <code>rusqlite</code> functions (specifically, functions which register a callback to be later invoked by SQLite) was too relaxed. If a closure referencing borrowed values on the stack is was passed to one of these functions, it could allow Rust code to access objects on the stack after they have been dropped.</p>\n<p>The impacted functions are:</p>\n<ul>\n<li>Under <code>cfg(feature = \"functions\")</code>: <code>Connection::create_scalar_function</code>, <code>Connection::create_aggregate_function</code> and <code>Connection::create_window_function</code>.</li>\n<li>Under <code>cfg(feature = \"hooks\")</code>: <code>Connection::commit_hook</code>, <code>Connection::rollback_hook</code> and <code>Connection::update_hook</code>.</li>\n<li>Under <code>cfg(feature = \"collation\")</code>: <code>Connection::create_collation</code>.</li>\n</ul>\n<p>The issue exists in all <code>0.25.*</code> versions prior to <code>0.25.4</code>, and all <code>0.26.*</code> versions prior to 0.26.2 (specifically: <code>0.25.0</code>, <code>0.25.1</code>, <code>0.25.2</code>, <code>0.25.3</code>, <code>0.26.0</code>, and <code>0.26.1</code>).</p>\n<p>The fix is available in versions <code>0.26.2</code> and newer, and also has been back-ported to <code>0.25.4</code>. As it does not exist in <code>0.24.*</code>, all affected versions should have an upgrade path to a semver-compatible release.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rusqlite/rusqlite/issues/1048\">https://github.com/rusqlite/rusqlite/issues/1048</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0128.html\">https://rustsec.org/advisories/RUSTSEC-2021-0128.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q89g-4vhh-mvvm\">https://github.com/advisories/GHSA-q89g-4vhh-mvvm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q89g-4vhh-mvvm",
            "title": "[rusqlite] Incorrect Lifetime Bounds on Closures in `rusqlite`",
            "date_modified": "2022-06-17T00:16:49.000Z",
            "date_published": "2022-06-17T00:16:48.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q89g-4vhh-mvvm"
            }
        },
        {
            "content_html": "<p>When activating the non-default feature <code>serialize</code>, most structs implement\n<code>serde::Deserialize</code> without sufficient validation. This allows breaking\ninvariants in safe code, leading to:</p>\n<ul>\n<li>Undefined behavior in <code>as_string()</code> methods (which use\n<code>std::str::from_utf8_unchecked()</code> internally).</li>\n<li>Panics due to failed assertions.</li>\n</ul>\n<p>See <a href=\"https://github.com/gz/rust-cpuid/issues/43\">https://github.com/gz/rust-cpuid/issues/43</a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/gz/rust-cpuid/issues/43\">https://github.com/gz/rust-cpuid/issues/43</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0089.html\">https://rustsec.org/advisories/RUSTSEC-2021-0089.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jf5h-cf95-w759\">https://github.com/advisories/GHSA-jf5h-cf95-w759</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jf5h-cf95-w759",
            "title": "[raw-cpuid] Optional `Deserialize` implementations lacking validation",
            "date_modified": "2022-06-17T00:16:27.000Z",
            "date_published": "2022-06-17T00:16:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jf5h-cf95-w759"
            }
        },
        {
            "content_html": "<p>This is impossible to do by accident, but by carefully constructing\nmarker types to be covariant, a malicious coder can cheat the\nsingleton check in <code>TCellOwner</code> and <code>TLCellOwner</code>, giving unsound\naccess to cell memory.  This could take the form of getting two\nmutable references to the same memory, or a mutable reference and an\nimmutable reference.</p>\n<p>The fix is for the crate to internally force the marker type to be\ninvariant.  This blocks the conversion between covariant types which\nRust normally allows.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/uazu/qcell/issues/20\">https://github.com/uazu/qcell/issues/20</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0007.html\">https://rustsec.org/advisories/RUSTSEC-2022-0007.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9c9f-7x9p-4wqp\">https://github.com/advisories/GHSA-9c9f-7x9p-4wqp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9c9f-7x9p-4wqp",
            "title": "[qcell] A malicious coder can get unsound access to TCell or TLCell memory",
            "date_modified": "2022-06-17T00:16:12.000Z",
            "date_published": "2022-06-17T00:16:11.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9c9f-7x9p-4wqp"
            }
        },
        {
            "content_html": "<p>An issue was discovered in the qwutils crate before 0.3.1 for Rust. When a Clone panic occurs, insert_slice_clone can perform a double drop.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-26954\">https://nvd.nist.gov/vuln/detail/CVE-2021-26954</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0018.html\">https://rustsec.org/advisories/RUSTSEC-2021-0018.html</a></li>\n<li><a href=\"https://github.com/qwertz19281/rust_utils/issues/3\">https://github.com/qwertz19281/rust_utils/issues/3</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-68p4-pjpf-xwcq\">https://github.com/advisories/GHSA-68p4-pjpf-xwcq</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-68p4-pjpf-xwcq",
            "title": "[qwutils] insert_slice_clone can double drop if Clone panics.",
            "date_modified": "2022-06-17T00:14:34.000Z",
            "date_published": "2022-05-24T17:41:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-68p4-pjpf-xwcq"
            }
        },
        {
            "content_html": "<p><code>rdiff</code> performs a diff of two provided strings or files. As part of its reading\ncode it uses the return value of a <code>Read</code> instance to set the length of\nits internal character vector.</p>\n<p>If the <code>Read</code> implementation claims that it has read more bytes than the length\nof the provided buffer, the length of the vector will be set to longer than its\ncapacity. This causes <code>rdiff</code> APIs to return uninitialized memory in its API\nmethods.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/dyule/rdiff/issues/3\">https://github.com/dyule/rdiff/issues/3</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0094.html\">https://rustsec.org/advisories/RUSTSEC-2021-0094.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q579-9wp9-gfp2\">https://github.com/advisories/GHSA-q579-9wp9-gfp2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q579-9wp9-gfp2",
            "title": "[rdiff] Window can read out of bounds if Read instance returns more bytes than buffer size",
            "date_modified": "2022-06-17T00:14:19.000Z",
            "date_published": "2022-06-17T00:14:18.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q579-9wp9-gfp2"
            }
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2022-06-17T00:14:02.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            }
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2022-06-17T00:14:02.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            }
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2022-06-17T00:14:02.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            }
        },
        {
            "content_html": "<p>Neon provides functionality for creating JavaScript <code>ArrayBuffer</code> (and the <code>Buffer</code> subtype) instances backed by bytes allocated outside of V8/Node. The <a href=\"https://docs.rs/neon/0.10.0/neon/types/struct.JsArrayBuffer.html#method.external\"><code>JsArrayBuffer::external</code></a> and <a href=\"https://docs.rs/neon/0.10.0/neon/types/struct.JsBuffer.html#method.external\"><code>JsBuffer::external</code></a> did not require <code>T: 'static</code> prior to Neon <code>0.10.1</code>. This allowed creating an externally backed buffer from types that may be freed while they are still referenced by a JavaScript <code>ArrayBuffer</code>.</p>\n<p>The following example demonstrates use after free. It compiles on versions <code>&lt;0.10.1</code> and fails to compile afterward.</p>\n<pre><code class=\"language-rust\">pub fn soundness_hole(mut cx: FunctionContext) -&gt; JsResult&lt;JsArrayBuffer&gt; {\n    let mut data = vec![0u8, 1, 2, 3];\n    \n    // Creating an external from `&amp;mut [u8]` instead of `Vec&lt;u8&gt;` since there is a blanket impl\n    // of `AsMut&lt;T&gt; for &amp;mut T`\n    let buf = JsArrayBuffer::external(&amp;mut cx, data.as_mut_slice());\n\n    // `buf` is still holding a reference to `data`!\n    drop(data);\n\n    Ok(buf)\n}\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/neon-bindings/neon/issues/896\">https://github.com/neon-bindings/neon/issues/896</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0028.html\">https://rustsec.org/advisories/RUSTSEC-2022-0028.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8mj7-wxmc-f424\">https://github.com/advisories/GHSA-8mj7-wxmc-f424</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8mj7-wxmc-f424",
            "title": "[neon] Use after free in Neon external buffers",
            "date_modified": "2022-06-17T00:13:42.000Z",
            "date_published": "2022-06-17T00:13:40.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8mj7-wxmc-f424"
            }
        },
        {
            "content_html": "<p><code>TlsWyRand</code>'s implementation of <code>Deref</code> unconditionally dereferences a raw pointer, and returns \nmultiple mutable references to the same object, which is undefined behavior.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Absolucy/nanorand-rs/issues/28\">https://github.com/Absolucy/nanorand-rs/issues/28</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0114.html\">https://rustsec.org/advisories/RUSTSEC-2021-0114.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-p6gj-gpc8-f8xw\">https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-p6gj-gpc8-f8xw",
            "title": "[nanorand] Aliased mutable references from `tls_rand` & `TlsWyRand`",
            "date_modified": "2022-06-17T00:13:27.000Z",
            "date_published": "2022-06-17T00:13:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-p6gj-gpc8-f8xw"
            }
        },
        {
            "content_html": "<p>In the affected versions of the crate, <code>AtomicBucket&lt;T&gt;</code> unconditionally implements <code>Send</code>/<code>Sync</code> traits. Therefore, users can create a data race to the inner\n<code>T: !Sync</code> by using the <code>AtomicBucket::data_with()</code> API.\nSuch data races can potentially cause memory corruption or other undefined behavior.</p>\n<p>The flaw was fixed in commit 8e6daab by adding appropriate Send/Sync bounds to the Send/Sync impl of struct <code>Block&lt;T&gt;</code> (which is a data type contained inside <code>AtomicBucket&lt;T&gt;</code>).</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/metrics-rs/metrics/issues/190\">https://github.com/metrics-rs/metrics/issues/190</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0113.html\">https://rustsec.org/advisories/RUSTSEC-2021-0113.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3hxh-7jxm-59x4\">https://github.com/advisories/GHSA-3hxh-7jxm-59x4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3hxh-7jxm-59x4",
            "title": "[metrics-util] AtomicBucket<T> unconditionally implements Send/Sync",
            "date_modified": "2022-06-17T00:13:07.000Z",
            "date_published": "2022-06-17T00:13:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3hxh-7jxm-59x4"
            }
        },
        {
            "content_html": "<p>The <code>mopa</code> crate redefines the deprecated <code>TraitObject</code> struct from <code>core::raw</code> like so:</p>\n<pre><code class=\"language-rust\">#[repr(C)]\n#[derive(Copy, Clone)]\n#[doc(hidden)]\npub struct TraitObject {\n    pub data: *mut (),\n    pub vtable: *mut (),\n}\n</code></pre>\n<p>This is done to then transmute a reference to a trait object (<code>&amp;dyn Trait</code> for any trait <code>Trait</code>) into this struct and retrieve the <code>data</code> field for the purpose of downcasting. This is used to implement <code>downcast_ref_unchecked()</code>, in terms of which <code>downcast_ref()</code> is also implemented. Same goes for mutable reference downcasting and <code>Box</code> downcasting.</p>\n<p>The Rust compiler explicitly reserves the right to change the memory layout of <code>&amp;dyn Trait</code> for any trait <code>Trait</code>. The worst case scenario is that it swaps <code>data</code> and <code>vtable</code>, making an executable location breach and compromisation of ASLR possible, since reads from <code>data</code> would read <code>vtable</code> instead. Likewise, arbitrary code execution is also theoretically possible if reads of <code>vtable</code> generated by the compiler read <code>data</code> instead.</p>\n<p>While, as of Rust 1.52, this unsound assumption still holds true, updating the compiler may silently create UB in a crate which previously compiled and run without issues, compromising the security of builds which are believed to be reproducible.</p>\n<p>A potential strategy to resolve this has already been suggested in an issue on the GitHub repository of the crate.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/chris-morgan/mopa/issues/13\">https://github.com/chris-morgan/mopa/issues/13</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0095.html\">https://rustsec.org/advisories/RUSTSEC-2021-0095.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8mv5-7x95-7wcf\">https://github.com/advisories/GHSA-8mv5-7x95-7wcf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8mv5-7x95-7wcf",
            "title": "[mopa] `mopa` is technically unsound",
            "date_modified": "2022-06-17T00:12:36.000Z",
            "date_published": "2022-06-17T00:12:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8mv5-7x95-7wcf"
            }
        },
        {
            "content_html": "<p>Affected versions of this crate passed an uninitialized buffer to a\nuser-provided <code>Read</code> instance in:</p>\n<ul>\n<li><code>deserialize_binary</code></li>\n<li><code>deserialize_string</code></li>\n<li><code>deserialize_extension_others</code></li>\n<li><code>deserialize_string_primitive</code></li>\n</ul>\n<p>This can result in safe <code>Read</code> implementations reading from the uninitialized\nbuffer leading to undefined behavior.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/otake84/messagepack-rs/issues/2\">https://github.com/otake84/messagepack-rs/issues/2</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0092.html\">https://rustsec.org/advisories/RUSTSEC-2021-0092.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m325-rxjv-pwph\">https://github.com/advisories/GHSA-m325-rxjv-pwph</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m325-rxjv-pwph",
            "title": "[messagepack-rs] Deserialization functions pass uninitialized memory to user-provided Read",
            "date_modified": "2022-06-17T00:11:41.000Z",
            "date_published": "2022-06-17T00:11:41.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m325-rxjv-pwph"
            }
        },
        {
            "content_html": "<p>Lru crate has use after free vulnerability.</p>\n<p>Lru crate has two functions for getting an iterator. Both iterators give\nreferences to key and value. Calling specific functions, like pop(), will remove\nand free the value, and but it's still possible to access the reference of value\nwhich is already dropped causing use after free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jeromefroe/lru-rs/issues/120\">https://github.com/jeromefroe/lru-rs/issues/120</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0130.html\">https://rustsec.org/advisories/RUSTSEC-2021-0130.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-qqmc-hwqp-8g2w\">https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-qqmc-hwqp-8g2w",
            "title": "[lru] Use after free in lru crate",
            "date_modified": "2022-06-17T00:11:13.000Z",
            "date_published": "2022-06-17T00:11:13.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-qqmc-hwqp-8g2w"
            }
        },
        {
            "content_html": "<p>ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL's own \"d2i\" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the \"data\" and \"length\" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the \"data\" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-3712\">https://nvd.nist.gov/vuln/detail/CVE-2021-3712</a></li>\n<li><a href=\"https://cert-portal.siemens.com/productcert/pdf/ssa-244969.pdf\">https://cert-portal.siemens.com/productcert/pdf/ssa-244969.pdf</a></li>\n<li><a href=\"https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf\">https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf</a></li>\n<li><a href=\"https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=94d23fcff9b2a7a8368dfe52214d5c2569882c11\">https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=94d23fcff9b2a7a8368dfe52214d5c2569882c11</a></li>\n<li><a href=\"https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=ccb0a11145ee72b042d10593a64eaf9e8a55ec12\">https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=ccb0a11145ee72b042d10593a64eaf9e8a55ec12</a></li>\n<li><a href=\"https://kc.mcafee.com/corporate/index?page=content&amp;id=SB10366\">https://kc.mcafee.com/corporate/index?page=content&amp;id=SB10366</a></li>\n<li><a href=\"https://lists.apache.org/thread.html/r18995de860f0e63635f3008fd2a6aca82394249476d21691e7c59c9e@%3Cdev.tomcat.apache.org%3E\">https://lists.apache.org/thread.html/r18995de860f0e63635f3008fd2a6aca82394249476d21691e7c59c9e@%3Cdev.tomcat.apache.org%3E</a></li>\n<li><a href=\"https://lists.apache.org/thread.html/rad5d9f83f0d11fb3f8bb148d179b8a9ad7c6a17f18d70e5805a713d1@%3Cdev.tomcat.apache.org%3E\">https://lists.apache.org/thread.html/rad5d9f83f0d11fb3f8bb148d179b8a9ad7c6a17f18d70e5805a713d1@%3Cdev.tomcat.apache.org%3E</a></li>\n<li><a href=\"https://lists.debian.org/debian-lts-announce/2021/09/msg00014.html\">https://lists.debian.org/debian-lts-announce/2021/09/msg00014.html</a></li>\n<li><a href=\"https://lists.debian.org/debian-lts-announce/2021/09/msg00021.html\">https://lists.debian.org/debian-lts-announce/2021/09/msg00021.html</a></li>\n<li><a href=\"https://security.netapp.com/advisory/ntap-20210827-0010/\">https://security.netapp.com/advisory/ntap-20210827-0010/</a></li>\n<li><a href=\"https://www.debian.org/security/2021/dsa-4963\">https://www.debian.org/security/2021/dsa-4963</a></li>\n<li><a href=\"https://www.openssl.org/news/secadv/20210824.txt\">https://www.openssl.org/news/secadv/20210824.txt</a></li>\n<li><a href=\"https://www.oracle.com/security-alerts/cpuapr2022.html\">https://www.oracle.com/security-alerts/cpuapr2022.html</a></li>\n<li><a href=\"https://www.oracle.com/security-alerts/cpujan2022.html\">https://www.oracle.com/security-alerts/cpujan2022.html</a></li>\n<li><a href=\"https://www.oracle.com/security-alerts/cpuoct2021.html\">https://www.oracle.com/security-alerts/cpuoct2021.html</a></li>\n<li><a href=\"https://www.tenable.com/security/tns-2021-16\">https://www.tenable.com/security/tns-2021-16</a></li>\n<li><a href=\"https://www.tenable.com/security/tns-2022-02\">https://www.tenable.com/security/tns-2022-02</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2021/08/26/2\">http://www.openwall.com/lists/oss-security/2021/08/26/2</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0098.html\">https://rustsec.org/advisories/RUSTSEC-2021-0098.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q9wj-f4qw-6vfj\">https://github.com/advisories/GHSA-q9wj-f4qw-6vfj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q9wj-f4qw-6vfj",
            "title": "[openssl-src] Read buffer overruns processing ASN.1 strings",
            "date_modified": "2022-06-17T00:10:48.000Z",
            "date_published": "2022-05-24T19:12:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q9wj-f4qw-6vfj"
            }
        }
    ]
}