{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p><code>&lt;bytes::Bytes as axum_core::extract::FromRequest&gt;::from_request</code> would not, by default, set a limit for the size of the request body. That meant if a malicious peer would send a very large (or infinite) body your server might run out of memory and crash.</p>\n<p>This also applies to these extractors which used <code>Bytes::from_request</code> internally:</p>\n<ul>\n<li><code>axum::extract::Form</code></li>\n<li><code>axum::extract::Json</code></li>\n<li><code>String</code></li>\n</ul>\n<p>The fix is also in <code>axum-core</code> <code>0.3.0.rc.2</code> but <code>0.3.0.rc.1</code> <em>is</em> vulnerable.</p>\n<p>Because <code>axum</code> depends on <code>axum-core</code> it is vulnerable as well. The vulnerable versions of <code>axum</code> are <code>&lt;= 0.5.15</code> and <code>0.6.0.rc.1</code>. <code>axum</code> <code>&gt;= 0.5.16</code> and <code>&gt;= 0.6.0.rc.2</code> does have the fix and are not vulnerable.</p>\n<p>The patched versions will set a 2 MB limit by default.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tokio-rs/axum/pull/1346\">https://github.com/tokio-rs/axum/pull/1346</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0055.html\">https://rustsec.org/advisories/RUSTSEC-2022-0055.html</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-3212\">https://nvd.nist.gov/vuln/detail/CVE-2022-3212</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m77f-652q-wwp4\">https://github.com/advisories/GHSA-m77f-652q-wwp4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m77f-652q-wwp4",
            "title": "[axum-core] axum-core has no default limit put on request bodies",
            "date_modified": "2022-09-15T17:25:08.000Z",
            "date_published": "2022-09-15T03:25:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m77f-652q-wwp4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p><code>&lt;bytes::Bytes as axum_core::extract::FromRequest&gt;::from_request</code> would not, by default, set a limit for the size of the request body. That meant if a malicious peer would send a very large (or infinite) body your server might run out of memory and crash.</p>\n<p>This also applies to these extractors which used <code>Bytes::from_request</code> internally:</p>\n<ul>\n<li><code>axum::extract::Form</code></li>\n<li><code>axum::extract::Json</code></li>\n<li><code>String</code></li>\n</ul>\n<p>The fix is also in <code>axum-core</code> <code>0.3.0.rc.2</code> but <code>0.3.0.rc.1</code> <em>is</em> vulnerable.</p>\n<p>Because <code>axum</code> depends on <code>axum-core</code> it is vulnerable as well. The vulnerable versions of <code>axum</code> are <code>&lt;= 0.5.15</code> and <code>0.6.0.rc.1</code>. <code>axum</code> <code>&gt;= 0.5.16</code> and <code>&gt;= 0.6.0.rc.2</code> does have the fix and are not vulnerable.</p>\n<p>The patched versions will set a 2 MB limit by default.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/tokio-rs/axum/pull/1346\">https://github.com/tokio-rs/axum/pull/1346</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0055.html\">https://rustsec.org/advisories/RUSTSEC-2022-0055.html</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-3212\">https://nvd.nist.gov/vuln/detail/CVE-2022-3212</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-m77f-652q-wwp4\">https://github.com/advisories/GHSA-m77f-652q-wwp4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-m77f-652q-wwp4",
            "title": "[axum-core] axum-core has no default limit put on request bodies",
            "date_modified": "2022-09-15T17:25:08.000Z",
            "date_published": "2022-09-15T03:25:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-m77f-652q-wwp4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>Several vulnerabilities have been reported in the <code>time</code> and <code>chrono</code> crates related to handling of calls to <code>localtime_r</code>. You can follow some of the discussions <a href=\"https://github.com/chronotope/chrono/issues/602\">here</a> and <a href=\"https://github.com/time-rs/time/issues/293\">here</a>, and the associated CVE <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-26235\">here</a>. In our case, the issue with the dependency was flagged by our nightly CI build running <a href=\"https://github.com/parallaxsecond/parsec/issues/544\"><code>cargo-audit</code></a>. </p>\n<p>The vulnerability leads to a segfault in specific circumstances - namely, when one of a number of functions in the <code>time</code> crate is called while any other thread is setting an environment variable. Given that in the case of the Parsec service this affects the SPIFFE authenticator, Parsec service users can encounter the issue only when the JWT SVID authenticator is enabled and being used. We have not undergone any manual tracing to understand if the vulnerable methods are called anywhere in our stack, however it seems reasonable to expect that if that were to be the case, the issue would lie in JWT validation (i.e. when handling the dates found within a Json Web Token). JWT validation could thus fail, bringing down the thread in which the request happens. The rest of the threads continue to work. Since the threadpool implementation that we use <a href=\"https://docs.rs/threadpool/latest/threadpool/\">continues replenishing the pool</a> when one thread panics, the impact on the service should be minimal.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>No current patches exist as the problems lie in a number of dependencies that are not under our control (see more details <a href=\"https://github.com/parallaxsecond/parsec/issues/544#issuecomment-1024185688\">here</a>).</p>\n<p>The issue tracking the required change in the <code>rust-spiffe</code> crate (through which the vulnerable dependencies are imported in Parsec) can be seen <a href=\"https://github.com/maxlambrecht/rust-spiffe/issues/17\">here</a>. Once updates happen in our dependency chain that allow us to update beyond the vulnerable versions of <code>time</code> and <code>chrono</code>, a new version of the Parsec service will be tagged and released with the appropriate notifications.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>The only complete workaround is to use a different type of authenticator with the Parsec service. </p>\n<h3 id=\"references\">References</h3>\n<p>As quoted in the initial paragraph, you can find out more information:</p>\n<ul>\n<li>in the <code>chrono</code> repo issue <a href=\"https://github.com/chronotope/chrono/issues/602\">here</a></li>\n<li>in the <code>time</code> repo issue <a href=\"https://github.com/time-rs/time/issues/293\">here</a></li>\n<li>in the official CVE report <a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-26235\">here</a></li>\n<li>in our tracking issue <a href=\"https://github.com/parallaxsecond/parsec/issues/544\">here</a></li>\n</ul>\n<h3 id=\"for-more-information\">For more information:</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Open an issue in <a href=\"https://github.com/parallaxsecond/parsec\">the Parsec service repo</a></li>\n<li>Email us at <a href=\"mailto:cncf-parsec-maintainers@lists.cncf.io\">cncf-parsec-maintainers@lists.cncf.io</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/parallaxsecond/parsec/security/advisories/GHSA-45w3-v3g4-54pm\">https://github.com/parallaxsecond/parsec/security/advisories/GHSA-45w3-v3g4-54pm</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-26235\">https://nvd.nist.gov/vuln/detail/CVE-2020-26235</a></li>\n<li><a href=\"https://github.com/chronotope/chrono/issues/602\">https://github.com/chronotope/chrono/issues/602</a></li>\n<li><a href=\"https://github.com/parallaxsecond/parsec/issues/544\">https://github.com/parallaxsecond/parsec/issues/544</a></li>\n<li><a href=\"https://github.com/parallaxsecond/parsec/issues/544#issuecomment-1024185688\">https://github.com/parallaxsecond/parsec/issues/544#issuecomment-1024185688</a></li>\n<li><a href=\"https://github.com/time-rs/time/issues/293\">https://github.com/time-rs/time/issues/293</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-45w3-v3g4-54pm\">https://github.com/advisories/GHSA-45w3-v3g4-54pm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-45w3-v3g4-54pm",
            "title": "[parsec-service] Chrono has potential segfault issue in SPIFFE authenticator",
            "date_modified": "2022-09-12T20:44:49.000Z",
            "date_published": "2022-02-11T19:11:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-45w3-v3g4-54pm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The <a href=\"https://crates.io/crates/os_socketaddr\"><code>os_socketaddr</code></a> crate has assumed <code>std::net::SocketAddrV4</code> and <code>std::net::SocketAddrV6</code> have the same memory layout as the system C representation <code>sockaddr</code>. It has simply casted the pointers to convert the socket addresses to the system representation.</p>\n<p>These layout were <a href=\"https://github.com/rust-lang/rust/pull/78802\">changed into idiomatic rust types</a> in nightly <code>std</code>. Starting from rustc 1.64 the affected versions of this crate will have undefined behaviour.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/a-ba/os_socketaddr/issues/3\">https://github.com/a-ba/os_socketaddr/issues/3</a></li>\n<li><a href=\"https://github.com/rust-lang/rust/pull/78802\">https://github.com/rust-lang/rust/pull/78802</a></li>\n<li><a href=\"https://github.com/a-ba/os_socketaddr/commit/1bc7f71d40de069727993a18fdada33eb0b4c94f\">https://github.com/a-ba/os_socketaddr/commit/1bc7f71d40de069727993a18fdada33eb0b4c94f</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0052.html\">https://rustsec.org/advisories/RUSTSEC-2022-0052.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c439-chv8-8g2j\">https://github.com/advisories/GHSA-c439-chv8-8g2j</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c439-chv8-8g2j",
            "title": "[os_socketaddr] `os_socketaddr` invalidly assumes the memory layout of std::net::SocketAddr",
            "date_modified": "2022-09-02T22:29:41.000Z",
            "date_published": "2022-09-02T22:29:41.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c439-chv8-8g2j"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>lz4-sys up to v1.9.3 bundles a version of liblz4 that is vulnerable to\n<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-3520\">CVE-2021-3520</a>.</p>\n<p>Attackers could craft a payload that triggers an integer overflow upon\ndecompression, causing an out-of-bounds write.</p>\n<p>The flaw has been corrected in version v1.9.4 of liblz4, which is included\nin lz4-sys 1.9.4.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/lz4/lz4/pull/972\">https://github.com/lz4/lz4/pull/972</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0051.html\">https://rustsec.org/advisories/RUSTSEC-2022-0051.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9q5j-jm53-v7vr\">https://github.com/advisories/GHSA-9q5j-jm53-v7vr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9q5j-jm53-v7vr",
            "title": "[lz4-sys] lz4-sys vulnerable to memory corruption via issue in liblz4",
            "date_modified": "2022-09-01T22:24:55.000Z",
            "date_published": "2022-09-01T22:24:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9q5j-jm53-v7vr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The package opcua from 0.0.0 until 0.11.0 is vulnerable to Denial of Service (DoS) via the ExtensionObjects and Variants objects, when it allows unlimited nesting levels, which could result in a stack overflow even if the message size is less than the maximum allowed.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-25903\">https://nvd.nist.gov/vuln/detail/CVE-2022-25903</a></li>\n<li><a href=\"https://github.com/locka99/opcua/pull/216\">https://github.com/locka99/opcua/pull/216</a></li>\n<li><a href=\"https://github.com/locka99/opcua/pull/216/commits/e75dada28a40c3fefc4aeee4cdc272e1b748f8dd\">https://github.com/locka99/opcua/pull/216/commits/e75dada28a40c3fefc4aeee4cdc272e1b748f8dd</a></li>\n<li><a href=\"https://security.snyk.io/vuln/SNYK-RUST-OPCUA-2988750\">https://security.snyk.io/vuln/SNYK-RUST-OPCUA-2988750</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hgxq-hcrm-c5pm\">https://github.com/advisories/GHSA-hgxq-hcrm-c5pm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hgxq-hcrm-c5pm",
            "title": "[opcua] opcua Vulnerable to Out-of-bounds Write",
            "date_modified": "2022-09-01T22:23:06.000Z",
            "date_published": "2022-08-25T00:00:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hgxq-hcrm-c5pm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The package opcua from 0.0.0 are vulnerable to Denial of Service (DoS) due to a missing limitation on the number of received chunks - per single session or in total for all concurrent sessions. An attacker can exploit this vulnerability by sending an unlimited number of huge chunks (e.g. 2GB each) without sending the Final closing chunk.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-25888\">https://nvd.nist.gov/vuln/detail/CVE-2022-25888</a></li>\n<li><a href=\"https://github.com/locka99/opcua/pull/216\">https://github.com/locka99/opcua/pull/216</a></li>\n<li><a href=\"https://github.com/locka99/opcua/pull/216/commits/6fb683c5fec46c6dd347824491c4d93a229da695\">https://github.com/locka99/opcua/pull/216/commits/6fb683c5fec46c6dd347824491c4d93a229da695</a></li>\n<li><a href=\"https://security.snyk.io/vuln/SNYK-RUST-OPCUA-2988751\">https://security.snyk.io/vuln/SNYK-RUST-OPCUA-2988751</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8mx2-gqx9-rm7f\">https://github.com/advisories/GHSA-8mx2-gqx9-rm7f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8mx2-gqx9-rm7f",
            "title": "[opcua] Uncontrolled Resource Consumption in opcua",
            "date_modified": "2022-08-30T20:50:36.000Z",
            "date_published": "2022-08-24T00:00:31.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8mx2-gqx9-rm7f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>It is possible for a Reader to consume memory beyond the allowed constraints and thus lead to out of memory on the system. This issue affects Rust applications using Apache Avro Rust SDK prior to 0.14.0 (previously known as avro-rs). Users should update to apache-avro version 0.14.0 which addresses this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-36124\">https://nvd.nist.gov/vuln/detail/CVE-2022-36124</a></li>\n<li><a href=\"https://lists.apache.org/thread/kj429rzo1xxjgz058qqqg0y7c0p512zo\">https://lists.apache.org/thread/kj429rzo1xxjgz058qqqg0y7c0p512zo</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wcm8-86x6-8mv3\">https://github.com/advisories/GHSA-wcm8-86x6-8mv3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wcm8-86x6-8mv3",
            "title": "[apache-avro] Apache Avro Rust SDK's Reader could consume memory beyond allowed constraints",
            "date_modified": "2022-08-30T20:05:09.000Z",
            "date_published": "2022-08-10T00:00:31.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wcm8-86x6-8mv3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>In iana-time-zone v0.1.43 a use-after-free bug in the MacOS / iOS implementation was introduced.</p>\n<p>The copied system time zone was released before its name was copied.\nIf the system time zone was changed between the call of <code>CFRelease</code> and <code>str::to_owned()</code>,\nrandom memory would be copied.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/strawlab/iana-time-zone/pull/54\">https://github.com/strawlab/iana-time-zone/pull/54</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0049.html\">https://rustsec.org/advisories/RUSTSEC-2022-0049.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3fg9-hcq5-vxrc\">https://github.com/advisories/GHSA-3fg9-hcq5-vxrc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3fg9-hcq5-vxrc",
            "title": "[iana-time-zone] iana-time-zone vulnerable to use after free in MacOS / iOS implementation",
            "date_modified": "2022-08-30T19:55:43.000Z",
            "date_published": "2022-08-30T19:55:41.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3fg9-hcq5-vxrc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate passes an uninitialized buffer to a user-provided <code>Read</code> \nimplementation.</p>\n<p>Arbitrary <code>Read</code> implementations can read from the uninitialized buffer (memory exposure)\nand also can return incorrect number of bytes written to the buffer.\nReading from uninitialized memory produces undefined values that can quickly invoke\nundefined behavior.</p>\n<p>Note: there is only UB in the case where a user provides a struct whose <code>Read</code>\nimplementation inspects the buffer passed to <code>read_exact</code> before writing to it.\nThis is an unidiomatic (albeit possible) <code>Read</code> implementation.</p>\n<p>See <a href=\"https://github.com/MaterializeInc/materialize/issues/8669\">https://github.com/MaterializeInc/materialize/issues/8669</a> for details.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/MaterializeInc/materialize/issues/8669\">https://github.com/MaterializeInc/materialize/issues/8669</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0138.html\">https://rustsec.org/advisories/RUSTSEC-2021-0138.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jwh2-vrr9-vcp2\">https://github.com/advisories/GHSA-jwh2-vrr9-vcp2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jwh2-vrr9-vcp2",
            "title": "[mz-avro] mz-avro's incorrect use of `set_len` allows for un-initialized memory",
            "date_modified": "2022-08-30T19:53:55.000Z",
            "date_published": "2022-08-30T19:53:54.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jwh2-vrr9-vcp2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>A low severity security issue was discovered affecting parsing of the RPC result of the exit reason in case of EVM reversion. In release build, this would cause the exit reason being incorrectly parsed and returned by RPC. In debug build, this would cause an overflow panic.</p>\n<p>No action is needed unless you have a bridge node that needs to distinguish different reversion exit reasons and you used RPC for this.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue is patched in <a href=\"https://github.com/paritytech/frontier/pull/820\">https://github.com/paritytech/frontier/pull/820</a></p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>None.</p>\n<h3 id=\"references\">References</h3>\n<p>PR <a href=\"https://github.com/paritytech/frontier/pull/820\">https://github.com/paritytech/frontier/pull/820</a></p>\n<h3 id=\"for-more-information\">For more information</h3>\n<p>If you have any questions or comments about this advisory:</p>\n<ul>\n<li>Email <a href=\"mailto:wei@that.world\">Wei Tang</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/paritytech/frontier/security/advisories/GHSA-mjvm-mhgc-q4gp\">https://github.com/paritytech/frontier/security/advisories/GHSA-mjvm-mhgc-q4gp</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/pull/820\">https://github.com/paritytech/frontier/pull/820</a></li>\n<li><a href=\"https://github.com/paritytech/frontier/commit/fff8cc43b7756ce3979a38fc473f38e6e24ac451\">https://github.com/paritytech/frontier/commit/fff8cc43b7756ce3979a38fc473f38e6e24ac451</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-36008\">https://nvd.nist.gov/vuln/detail/CVE-2022-36008</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mjvm-mhgc-q4gp\">https://github.com/advisories/GHSA-mjvm-mhgc-q4gp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mjvm-mhgc-q4gp",
            "title": "[frontier] Incorrect parsing of EVM reversion exit reason in RPC",
            "date_modified": "2022-08-26T19:23:17.000Z",
            "date_published": "2022-08-18T19:18:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mjvm-mhgc-q4gp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>It is possible to provide data to be read that leads the reader to loop in cycles endlessly, consuming CPU. This issue affects Rust applications using Apache Avro Rust SDK prior to 0.14.0 (previously known as avro-rs). Users should update to apache-avro version 0.14.0 which addresses this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-35724\">https://nvd.nist.gov/vuln/detail/CVE-2022-35724</a></li>\n<li><a href=\"https://lists.apache.org/thread/771z1nwrpkn1ovmyfb2fm65mchdxgy7p\">https://lists.apache.org/thread/771z1nwrpkn1ovmyfb2fm65mchdxgy7p</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-v456-chpw-6mmw\">https://github.com/advisories/GHSA-v456-chpw-6mmw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-v456-chpw-6mmw",
            "title": "[apache-avro] Apache Avro Rust SDK vulnerable to reader looping in cycle endlessly, consuming CPU",
            "date_modified": "2022-08-18T19:16:00.000Z",
            "date_published": "2022-08-10T00:00:31.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-v456-chpw-6mmw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>It is possible to crash (panic) an application by providing a corrupted data to be read. This issue affects Rust applications using Apache Avro Rust SDK prior to 0.14.0 (previously known as avro-rs). Users should update to apache-avro version 0.14.0 which addresses this issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-36125\">https://nvd.nist.gov/vuln/detail/CVE-2022-36125</a></li>\n<li><a href=\"https://lists.apache.org/thread/t1r5xz0pvhm4tosqopjpj6dz8zlsht07\">https://lists.apache.org/thread/t1r5xz0pvhm4tosqopjpj6dz8zlsht07</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3w5g-989p-35r8\">https://github.com/advisories/GHSA-3w5g-989p-35r8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3w5g-989p-35r8",
            "title": "[apache-avro] Apache Avro Rust SDK corrupted data read can cause crash",
            "date_modified": "2022-08-18T19:15:30.000Z",
            "date_published": "2022-08-10T00:00:31.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3w5g-989p-35r8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Ward Beullens found a practical key-recovery attack against Rainbow.\nThe level I parametersets are removed from liboqs starting from version <code>0.7.2</code>.\nFind the scientific details in <a href=\"https://eprint.iacr.org/2022/214\">Breaking Rainbow Takes a Weekend on a Laptop</a>.</p>\n<p>This means all the <code>oqs::sig::Algorithm::RainbowI*</code> variants are insecure.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/open-quantum-safe/liboqs-rust\">https://github.com/open-quantum-safe/liboqs-rust</a></li>\n<li><a href=\"https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/KFgw5_qCXiI?pli=1\">https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/KFgw5_qCXiI?pli=1</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0047.html\">https://rustsec.org/advisories/RUSTSEC-2022-0047.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-h864-m8vm-3xvj\">https://github.com/advisories/GHSA-h864-m8vm-3xvj</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-h864-m8vm-3xvj",
            "title": "[oqs] oqs's Post-Quantum Signature scheme Rainbow level I parametersets broken",
            "date_modified": "2022-08-18T19:06:40.000Z",
            "date_published": "2022-08-18T19:06:39.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-h864-m8vm-3xvj"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Wouter Castryck and Thomas Decru presented an efficient key recovery attack on the SIDH protocol.\nAs a result, the secret key of SIKEp751 can be recovered in a matter of hours.\nThe SIKE and SIDH schemes will be removed from oqs 0.7.2.</p>\n<p><a href=\"https://eprint.iacr.org/2022/975\">An efficient key recovery attack on SIDH (preliminary version)</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/open-quantum-safe/liboqs-rust/pull/151\">https://github.com/open-quantum-safe/liboqs-rust/pull/151</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0045.html\">https://rustsec.org/advisories/RUSTSEC-2022-0045.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hrjv-pf36-jpmr\">https://github.com/advisories/GHSA-hrjv-pf36-jpmr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hrjv-pf36-jpmr",
            "title": "[oqs] oqs's Post-Quantum Key Encapsulation Mechanism SIKE broken",
            "date_modified": "2022-08-18T19:01:17.000Z",
            "date_published": "2022-08-18T19:01:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hrjv-pf36-jpmr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate did substitute the array length provided by an user at compile-time multiple times.</p>\n<p>When an impure constant expression is passed as an array length (such as a result of an impure procedural macro), this can result in the initialization of an array with uninitialized types, which in turn can allow an attacker to execute arbitrary code.</p>\n<p>The flaw was corrected in commit <a href=\"https://github.com/xfix/array-macro/commit/d5b63f72090f3809c21ac28f9cfd84f12559bf7d\">d5b63f72</a> by making sure that array length is substituted just once.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rustsec/advisory-db/blob/main/crates/array-macro/RUSTSEC-2022-0017.md\">https://github.com/rustsec/advisory-db/blob/main/crates/array-macro/RUSTSEC-2022-0017.md</a></li>\n<li><a href=\"https://gitlab.com/KonradBorowski/array-macro/-/issues/5\">https://gitlab.com/KonradBorowski/array-macro/-/issues/5</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0017.html\">https://rustsec.org/advisories/RUSTSEC-2022-0017.html</a></li>\n<li><a href=\"https://github.com/xfix/array-macro/commit/d5b63f72090f3809c21ac28f9cfd84f12559bf7d\">https://github.com/xfix/array-macro/commit/d5b63f72090f3809c21ac28f9cfd84f12559bf7d</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7v4j-8wvr-v55r\">https://github.com/advisories/GHSA-7v4j-8wvr-v55r</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7v4j-8wvr-v55r",
            "title": "[array-macro] `array!` macro is unsound when its length is impure constant",
            "date_modified": "2022-08-15T03:06:41.000Z",
            "date_published": "2022-06-16T23:40:38.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7v4j-8wvr-v55r"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the heapless crate before 0.6.1 for Rust. The IntoIter Clone implementation clones an entire underlying Vec without considering whether it has already been partially consumed.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-36464\">https://nvd.nist.gov/vuln/detail/CVE-2020-36464</a></li>\n<li><a href=\"https://github.com/japaric/heapless/issues/181\">https://github.com/japaric/heapless/issues/181</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0145.html\">https://rustsec.org/advisories/RUSTSEC-2020-0145.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-qgwf-r2jj-2ccv\">https://github.com/advisories/GHSA-qgwf-r2jj-2ccv</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-qgwf-r2jj-2ccv",
            "title": "[heapless] Use after free in heapless",
            "date_modified": "2022-08-13T03:06:55.000Z",
            "date_published": "2021-08-25T20:56:09.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-qgwf-r2jj-2ccv"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the rulinalg crate through 2020-02-11 for Rust. There are incorrect lifetime-boundary definitions for RowMut::raw_slice and RowMut::raw_slice_mut.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35879\">https://nvd.nist.gov/vuln/detail/CVE-2020-35879</a></li>\n<li><a href=\"https://github.com/AtheMathmo/rulinalg/issues/201\">https://github.com/AtheMathmo/rulinalg/issues/201</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0023.html\">https://rustsec.org/advisories/RUSTSEC-2020-0023.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q2gj-9r85-p832\">https://github.com/advisories/GHSA-q2gj-9r85-p832</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q2gj-9r85-p832",
            "title": "[rulinalg] Data races in rulinalg",
            "date_modified": "2022-08-13T03:06:31.000Z",
            "date_published": "2021-08-25T20:48:09.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q2gj-9r85-p832"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Affected versions of this crate called the RocksDB C API\n<code>rocksdb_open_column_families_with_ttl()</code> with a pointer to a single integer\nTTL value, but one TTL value for each column family is expected.</p>\n<p>This is only relevant when using\n<code>rocksdb::DBWithThreadMode::open_cf_descriptors_with_ttl()</code> with multiple\ncolumn families.</p>\n<p>This bug has been fixed in v0.19.0.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/rust-rocksdb/rust-rocksdb/pull/616\">https://github.com/rust-rocksdb/rust-rocksdb/pull/616</a></li>\n<li><a href=\"https://github.com/rust-rocksdb/rust-rocksdb/releases/tag/v0.19.0\">https://github.com/rust-rocksdb/rust-rocksdb/releases/tag/v0.19.0</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0046.html\">https://rustsec.org/advisories/RUSTSEC-2022-0046.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xpp3-xrff-w6rh\">https://github.com/advisories/GHSA-xpp3-xrff-w6rh</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xpp3-xrff-w6rh",
            "title": "[rocksdb] rocksdb vulnerable to out-of-bounds read",
            "date_modified": "2022-08-12T15:31:11.000Z",
            "date_published": "2022-08-12T15:31:10.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xpp3-xrff-w6rh"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Uninit memory is used as a RNG seed in temporary. This has been resolved in the 0.6.4 release. The crate is not intended to be used outside of a testing environment. For a general purpose crate to create temporary directories, <a href=\"https://crates.io/crates/tempfile\"><code>tempfile</code></a> is an alternative for this crate.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/stainless-steel/temporary/issues/2\">https://github.com/stainless-steel/temporary/issues/2</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0022.html\">https://rustsec.org/advisories/RUSTSEC-2018-0022.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2jq9-6xx7-3h29\">https://github.com/advisories/GHSA-2jq9-6xx7-3h29</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2jq9-6xx7-3h29",
            "title": "[temporary] `temporary` makes use of uninitialized memory",
            "date_modified": "2022-08-11T18:10:53.000Z",
            "date_published": "2022-08-11T18:10:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2jq9-6xx7-3h29"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}