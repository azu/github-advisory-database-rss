{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Rust crates",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/rust.json",
    "description": "Security Advisory for Rust crates on GitHub",
    "items": [
        {
            "content_html": "<p>ncurses exposes functions from the ncurses library which:</p>\n<ul>\n<li>Pass buffers without length to C functions that may write an arbitrary amount of data, leading to a buffer overflow. (instr, mvwinstr, etc)</li>\n<li>Passes rust &amp;str to strings expecting C format arguments, allowing hostile input to execute a format string attack, which trivially allows writing arbitrary data to stack memory (functions in the printw family).</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15548\">https://nvd.nist.gov/vuln/detail/CVE-2019-15548</a></li>\n<li><a href=\"https://github.com/RustSec/advisory-db/issues/106\">https://github.com/RustSec/advisory-db/issues/106</a></li>\n<li><a href=\"https://github.com/jeaye/ncurses-rs/issues/172\">https://github.com/jeaye/ncurses-rs/issues/172</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0006.html\">https://rustsec.org/advisories/RUSTSEC-2019-0006.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-g7r5-x7cr-vm3v\">https://github.com/advisories/GHSA-g7r5-x7cr-vm3v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-g7r5-x7cr-vm3v",
            "title": "[ncurses] Buffer overflow and format vulnerabilities in ncurses",
            "date_modified": "2023-06-13T20:01:09.000Z",
            "date_published": "2021-08-25T20:58:29.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-g7r5-x7cr-vm3v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>If during the first dereference of Lazy the initialization function panics, subsequent dereferences will execute std::hints::unreachable_unchecked. Applications with panic = \"abort\" are not affected, as there will be no subsequent dereferences.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-16141\">https://nvd.nist.gov/vuln/detail/CVE-2019-16141</a></li>\n<li><a href=\"https://github.com/matklad/once_cell/issues/46\">https://github.com/matklad/once_cell/issues/46</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0017.html\">https://rustsec.org/advisories/RUSTSEC-2019-0017.html</a></li>\n<li><a href=\"https://github.com/matklad/once_cell/pull/47\">https://github.com/matklad/once_cell/pull/47</a></li>\n<li><a href=\"https://github.com/matklad/once_cell/commit/afcca95a05240ebd931ab20998c946f77ef1e284\">https://github.com/matklad/once_cell/commit/afcca95a05240ebd931ab20998c946f77ef1e284</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7j44-fv4x-79g9\">https://github.com/advisories/GHSA-7j44-fv4x-79g9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7j44-fv4x-79g9",
            "title": "[once_cell] Improper Input Validation in once_cell",
            "date_modified": "2023-06-13T19:58:13.000Z",
            "date_published": "2021-08-25T20:44:18.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7j44-fv4x-79g9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Server or client applications that call the SSL_check_chain() function during or after a TLS 1.3 handshake may crash due to a NULL pointer dereference as a result of incorrect handling of the \"signature_algorithms_cert\" TLS extension. The crash occurs if an invalid or unrecognised signature algorithm is received from the peer. This could be exploited by a malicious peer in a Denial of Service attack. OpenSSL version 1.1.1d, 1.1.1e, and 1.1.1f are affected by this issue. This issue did not affect OpenSSL versions prior to 1.1.1d. Fixed in OpenSSL 1.1.1g (Affected 1.1.1d-1.1.1f).</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-1967\">https://nvd.nist.gov/vuln/detail/CVE-2020-1967</a></li>\n<li><a href=\"https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=eb563247aef3e83dda7679c43f9649270462e5b1\">https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=eb563247aef3e83dda7679c43f9649270462e5b1</a></li>\n<li><a href=\"https://github.com/irsl/CVE-2020-1967\">https://github.com/irsl/CVE-2020-1967</a></li>\n<li><a href=\"https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44440\">https://kb.pulsesecure.net/articles/Pulse_Security_Advisories/SA44440</a></li>\n<li><a href=\"https://lists.apache.org/thread.html/r66ea9c436da150683432db5fbc8beb8ae01886c6459ac30c2cea7345@%3Cdev.tomcat.apache.org%3E\">https://lists.apache.org/thread.html/r66ea9c436da150683432db5fbc8beb8ae01886c6459ac30c2cea7345@%3Cdev.tomcat.apache.org%3E</a></li>\n<li><a href=\"https://lists.apache.org/thread.html/r94d6ac3f010a38fccf4f432b12180a13fa1cf303559bd805648c9064@%3Cdev.tomcat.apache.org%3E\">https://lists.apache.org/thread.html/r94d6ac3f010a38fccf4f432b12180a13fa1cf303559bd805648c9064@%3Cdev.tomcat.apache.org%3E</a></li>\n<li><a href=\"https://lists.apache.org/thread.html/r9a41e304992ce6aec6585a87842b4f2e692604f5c892c37e3b0587ee@%3Cdev.tomcat.apache.org%3E\">https://lists.apache.org/thread.html/r9a41e304992ce6aec6585a87842b4f2e692604f5c892c37e3b0587ee@%3Cdev.tomcat.apache.org%3E</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DDHOAATPWJCXRNFMJ2SASDBBNU5RJONY/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DDHOAATPWJCXRNFMJ2SASDBBNU5RJONY/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EXDDAOWSAIEFQNBHWYE6PPYFV4QXGMCD/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/EXDDAOWSAIEFQNBHWYE6PPYFV4QXGMCD/</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XVEP3LAK4JSPRXFO4QF4GG2IVXADV3SO/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XVEP3LAK4JSPRXFO4QF4GG2IVXADV3SO/</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0015.html\">https://rustsec.org/advisories/RUSTSEC-2020-0015.html</a></li>\n<li><a href=\"https://security.FreeBSD.org/advisories/FreeBSD-SA-20:11.openssl.asc\">https://security.FreeBSD.org/advisories/FreeBSD-SA-20:11.openssl.asc</a></li>\n<li><a href=\"https://security.gentoo.org/glsa/202004-10\">https://security.gentoo.org/glsa/202004-10</a></li>\n<li><a href=\"https://security.netapp.com/advisory/ntap-20200424-0003/\">https://security.netapp.com/advisory/ntap-20200424-0003/</a></li>\n<li><a href=\"https://security.netapp.com/advisory/ntap-20200717-0004/\">https://security.netapp.com/advisory/ntap-20200717-0004/</a></li>\n<li><a href=\"https://www.debian.org/security/2020/dsa-4661\">https://www.debian.org/security/2020/dsa-4661</a></li>\n<li><a href=\"https://www.openssl.org/news/secadv/20200421.txt\">https://www.openssl.org/news/secadv/20200421.txt</a></li>\n<li><a href=\"https://www.oracle.com/security-alerts/cpuApr2021.html\">https://www.oracle.com/security-alerts/cpuApr2021.html</a></li>\n<li><a href=\"https://www.oracle.com/security-alerts/cpujan2021.html\">https://www.oracle.com/security-alerts/cpujan2021.html</a></li>\n<li><a href=\"https://www.oracle.com/security-alerts/cpujul2020.html\">https://www.oracle.com/security-alerts/cpujul2020.html</a></li>\n<li><a href=\"https://www.oracle.com/security-alerts/cpuoct2020.html\">https://www.oracle.com/security-alerts/cpuoct2020.html</a></li>\n<li><a href=\"https://www.synology.com/security/advisory/Synology_SA_20_05\">https://www.synology.com/security/advisory/Synology_SA_20_05</a></li>\n<li><a href=\"https://www.synology.com/security/advisory/Synology_SA_20_05_OpenSSL\">https://www.synology.com/security/advisory/Synology_SA_20_05_OpenSSL</a></li>\n<li><a href=\"https://www.tenable.com/security/tns-2020-03\">https://www.tenable.com/security/tns-2020-03</a></li>\n<li><a href=\"https://www.tenable.com/security/tns-2020-04\">https://www.tenable.com/security/tns-2020-04</a></li>\n<li><a href=\"https://www.tenable.com/security/tns-2020-11\">https://www.tenable.com/security/tns-2020-11</a></li>\n<li><a href=\"https://www.tenable.com/security/tns-2021-10\">https://www.tenable.com/security/tns-2021-10</a></li>\n<li><a href=\"http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00004.html\">http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00004.html</a></li>\n<li><a href=\"http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00011.html\">http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00011.html</a></li>\n<li><a href=\"http://packetstormsecurity.com/files/157527/OpenSSL-signature_algorithms_cert-Denial-Of-Service.html\">http://packetstormsecurity.com/files/157527/OpenSSL-signature_algorithms_cert-Denial-Of-Service.html</a></li>\n<li><a href=\"http://seclists.org/fulldisclosure/2020/May/5\">http://seclists.org/fulldisclosure/2020/May/5</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2020/04/22/2\">http://www.openwall.com/lists/oss-security/2020/04/22/2</a></li>\n<li><a href=\"https://www.oracle.com//security-alerts/cpujul2021.html\">https://www.oracle.com//security-alerts/cpujul2021.html</a></li>\n<li><a href=\"https://www.oracle.com/security-alerts/cpuoct2021.html\">https://www.oracle.com/security-alerts/cpuoct2021.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jq65-29v4-4x35\">https://github.com/advisories/GHSA-jq65-29v4-4x35</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jq65-29v4-4x35",
            "title": "[openssl-src] Null pointer deference in openssl-src ",
            "date_modified": "2023-06-13T19:57:17.000Z",
            "date_published": "2021-08-25T20:45:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jq65-29v4-4x35"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the openssl crate before 0.10.9 for Rust. A use-after-free occurs in CMS Signing.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2018-20997\">https://nvd.nist.gov/vuln/detail/CVE-2018-20997</a></li>\n<li><a href=\"https://github.com/sfackler/rust-openssl/pull/942\">https://github.com/sfackler/rust-openssl/pull/942</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2018-0010.html\">https://rustsec.org/advisories/RUSTSEC-2018-0010.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xjxc-vfw2-cg96\">https://github.com/advisories/GHSA-xjxc-vfw2-cg96</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xjxc-vfw2-cg96",
            "title": "[openssl] Use after free in openssl",
            "date_modified": "2023-06-13T19:56:27.000Z",
            "date_published": "2021-08-25T20:43:45.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xjxc-vfw2-cg96"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Lru crate has use after free vulnerability.</p>\n<p>Lru crate has two functions for getting an iterator. Both iterators give\nreferences to key and value. Calling specific functions, like pop(), will remove\nand free the value, and but it's still possible to access the reference of value\nwhich is already dropped causing use after free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jeromefroe/lru-rs/issues/120\">https://github.com/jeromefroe/lru-rs/issues/120</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0130.html\">https://rustsec.org/advisories/RUSTSEC-2021-0130.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-qqmc-hwqp-8g2w\">https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-qqmc-hwqp-8g2w",
            "title": "[lru] Use after free in lru crate",
            "date_modified": "2023-06-13T18:40:06.000Z",
            "date_published": "2022-06-17T00:11:13.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-qqmc-hwqp-8g2w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Lru crate has two functions for getting an iterator. Both iterators give references to key and value. Calling specific functions, like pop(), will remove and free the value, and but it's still possible to access the reference of value which is already dropped causing use after free.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45720\">https://nvd.nist.gov/vuln/detail/CVE-2021-45720</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/lru/RUSTSEC-2021-0130.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/lru/RUSTSEC-2021-0130.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0130.html\">https://rustsec.org/advisories/RUSTSEC-2021-0130.html</a></li>\n<li><a href=\"https://github.com/jeromefroe/lru-rs/issues/120\">https://github.com/jeromefroe/lru-rs/issues/120</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-v362-2895-h9r2\">https://github.com/advisories/GHSA-v362-2895-h9r2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-v362-2895-h9r2",
            "title": "[lru] Use After Free in lru",
            "date_modified": "2023-06-13T18:38:44.000Z",
            "date_published": "2022-01-07T22:37:01.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-v362-2895-h9r2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the nanorand crate before 0.6.1 for Rust. There can be multiple mutable references to the same object because the TlsWyRand Deref implementation dereferences a raw pointer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45705\">https://nvd.nist.gov/vuln/detail/CVE-2021-45705</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nanorand/RUSTSEC-2021-0114.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nanorand/RUSTSEC-2021-0114.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0114.html\">https://rustsec.org/advisories/RUSTSEC-2021-0114.html</a></li>\n<li><a href=\"https://github.com/Absolucy/nanorand-rs/issues/28\">https://github.com/Absolucy/nanorand-rs/issues/28</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r57r-j98g-587f\">https://github.com/advisories/GHSA-r57r-j98g-587f</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r57r-j98g-587f",
            "title": "[nanorand] Pointer dereference in nanorand",
            "date_modified": "2023-06-13T18:38:09.000Z",
            "date_published": "2022-01-06T22:08:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r57r-j98g-587f"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p><code>TlsWyRand</code>'s implementation of <code>Deref</code> unconditionally dereferences a raw pointer, and returns \nmultiple mutable references to the same object, which is undefined behavior.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Absolucy/nanorand-rs/issues/28\">https://github.com/Absolucy/nanorand-rs/issues/28</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0114.html\">https://rustsec.org/advisories/RUSTSEC-2021-0114.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-p6gj-gpc8-f8xw\">https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-p6gj-gpc8-f8xw",
            "title": "[nanorand] Aliased mutable references from `tls_rand` & `TlsWyRand`",
            "date_modified": "2023-06-13T18:37:41.000Z",
            "date_published": "2022-06-17T00:13:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-p6gj-gpc8-f8xw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Neon provides functionality for creating JavaScript <code>ArrayBuffer</code> (and the <code>Buffer</code> subtype) instances backed by bytes allocated outside of V8/Node. The <a href=\"https://docs.rs/neon/0.10.0/neon/types/struct.JsArrayBuffer.html#method.external\"><code>JsArrayBuffer::external</code></a> and <a href=\"https://docs.rs/neon/0.10.0/neon/types/struct.JsBuffer.html#method.external\"><code>JsBuffer::external</code></a> did not require <code>T: 'static</code> prior to Neon <code>0.10.1</code>. This allowed creating an externally backed buffer from types that may be freed while they are still referenced by a JavaScript <code>ArrayBuffer</code>.</p>\n<p>The following example demonstrates use after free. It compiles on versions <code>&lt;0.10.1</code> and fails to compile afterward.</p>\n<pre><code class=\"language-rust\">pub fn soundness_hole(mut cx: FunctionContext) -&gt; JsResult&lt;JsArrayBuffer&gt; {\n    let mut data = vec![0u8, 1, 2, 3];\n    \n    // Creating an external from `&amp;mut [u8]` instead of `Vec&lt;u8&gt;` since there is a blanket impl\n    // of `AsMut&lt;T&gt; for &amp;mut T`\n    let buf = JsArrayBuffer::external(&amp;mut cx, data.as_mut_slice());\n\n    // `buf` is still holding a reference to `data`!\n    drop(data);\n\n    Ok(buf)\n}\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/neon-bindings/neon/issues/896\">https://github.com/neon-bindings/neon/issues/896</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2022-0028.html\">https://rustsec.org/advisories/RUSTSEC-2022-0028.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8mj7-wxmc-f424\">https://github.com/advisories/GHSA-8mj7-wxmc-f424</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8mj7-wxmc-f424",
            "title": "[neon] Use after free in Neon external buffers",
            "date_modified": "2023-06-13T18:37:13.000Z",
            "date_published": "2022-06-17T00:13:40.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8mj7-wxmc-f424"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2023-06-13T18:36:31.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2023-06-13T18:36:31.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the\n<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>\nfunction with a length parameter greater than the size of the buffer it\nprovides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>\nspecifying the size of the group buffer. When the buffer is too small to\nhold all of the reqested user's group memberships, some libc\nimplementations, including glibc and Solaris libc, will modify <code>ngroups</code>\nto indicate the actual number of groups for the user, in addition to\nreturning an error. The version of <code>nix::unistd::getgrouplist</code> in nix\n0.16.0 and up will resize the buffer to twice its size, but will not\nread or modify the <code>ngroups</code> variable. Thus, if the user has more than\ntwice as many groups as the initial buffer size of 8, the next call to\n<code>getgrouplist</code> will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually\nonly editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27",
            "title": "[nix] Out-of-bounds write in nix::unistd::getgrouplist",
            "date_modified": "2023-06-13T18:36:31.000Z",
            "date_published": "2022-06-17T00:13:59.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wgrg-5h56-jg27"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2023-06-13T18:32:57.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2023-06-13T18:32:57.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>\n<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>\n<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-45707\">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>\n<li><a href=\"https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md\">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2021-0119.html\">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wgrg-5h56-jg27\">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>\n<li><a href=\"https://github.com/nix-rust/nix/issues/1541\">https://github.com/nix-rust/nix/issues/1541</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-76w9-p8mg-j927\">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927",
            "title": "[nix] Out-of-bounds Write in nix",
            "date_modified": "2023-06-13T18:32:57.000Z",
            "date_published": "2022-01-06T22:07:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-76w9-p8mg-j927"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>ncurses exposes functions from the ncurses library which:</p>\n<ul>\n<li>Pass buffers without length to C functions that may write an arbitrary amount of data, leading to a buffer overflow. (instr, mvwinstr, etc)</li>\n<li>Passes rust &amp;str to strings expecting C format arguments, allowing hostile input to execute a format string attack, which trivially allows writing arbitrary data to stack memory (functions in the printw family).</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15547\">https://nvd.nist.gov/vuln/detail/CVE-2019-15547</a></li>\n<li><a href=\"https://github.com/RustSec/advisory-db/issues/106\">https://github.com/RustSec/advisory-db/issues/106</a></li>\n<li><a href=\"https://github.com/jeaye/ncurses-rs/issues/172\">https://github.com/jeaye/ncurses-rs/issues/172</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2019-0006.html\">https://rustsec.org/advisories/RUSTSEC-2019-0006.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-32v7-ghpr-c8hg\">https://github.com/advisories/GHSA-32v7-ghpr-c8hg</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-32v7-ghpr-c8hg",
            "title": "[ncurses] Mishandling of format strings in ncurses",
            "date_modified": "2023-06-13T18:30:36.000Z",
            "date_published": "2021-08-25T20:58:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-32v7-ghpr-c8hg"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedMutexGuard unsoundness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35910\">https://nvd.nist.gov/vuln/detail/CVE-2020-35910</a></li>\n<li><a href=\"https://github.com/Amanieu/parking_lot/pull/262\">https://github.com/Amanieu/parking_lot/pull/262</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0070.html\">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-ppj3-7jw3-8vc4\">https://github.com/advisories/GHSA-ppj3-7jw3-8vc4</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-ppj3-7jw3-8vc4",
            "title": "[lock_api] Data races in lock_api",
            "date_modified": "2023-06-13T18:25:53.000Z",
            "date_published": "2021-08-25T20:49:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-ppj3-7jw3-8vc4"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedRwLockReadGuard unsoundness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35911\">https://nvd.nist.gov/vuln/detail/CVE-2020-35911</a></li>\n<li><a href=\"https://github.com/Amanieu/parking_lot/pull/262\">https://github.com/Amanieu/parking_lot/pull/262</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0070.html\">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vh4p-6j7g-f4j9\">https://github.com/advisories/GHSA-vh4p-6j7g-f4j9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vh4p-6j7g-f4j9",
            "title": "[lock_api] Data races in lock_api",
            "date_modified": "2023-06-13T18:24:43.000Z",
            "date_published": "2021-08-25T20:49:56.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vh4p-6j7g-f4j9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of RwLockReadGuard unsoundness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35913\">https://nvd.nist.gov/vuln/detail/CVE-2020-35913</a></li>\n<li><a href=\"https://github.com/Amanieu/parking_lot/pull/262\">https://github.com/Amanieu/parking_lot/pull/262</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0070.html\">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hj9h-wrgg-hgmx\">https://github.com/advisories/GHSA-hj9h-wrgg-hgmx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hj9h-wrgg-hgmx",
            "title": "[lock_api] Data races in lock_api",
            "date_modified": "2023-06-13T18:24:18.000Z",
            "date_published": "2021-08-25T20:50:02.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hj9h-wrgg-hgmx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of RwLockWriteGuard unsoundness.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2020-35914\">https://nvd.nist.gov/vuln/detail/CVE-2020-35914</a></li>\n<li><a href=\"https://github.com/Amanieu/parking_lot/pull/262\">https://github.com/Amanieu/parking_lot/pull/262</a></li>\n<li><a href=\"https://rustsec.org/advisories/RUSTSEC-2020-0070.html\">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-gmv4-vmx3-x9f3\">https://github.com/advisories/GHSA-gmv4-vmx3-x9f3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-gmv4-vmx3-x9f3",
            "title": "[lock_api] Data races in lock_api",
            "date_modified": "2023-06-13T18:23:50.000Z",
            "date_published": "2021-08-25T20:49:37.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-gmv4-vmx3-x9f3"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}