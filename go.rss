<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/go.rss</id>
    <title>Security Advisory for Go modules</title>
    <updated>2023-11-24T22:01:23.073Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago"/>
    <subtitle>Security Advisory for Go modules on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[github.com/layer5io/meshery] SQL injection vulnerability in Meshery]]></title>
        <id>https://github.com/advisories/GHSA-9jjc-grg5-67gj</id>
        <link href="https://github.com/advisories/GHSA-9jjc-grg5-67gj"/>
        <updated>2023-11-24T19:01:38.000Z</updated>
        <content type="html"><![CDATA[<p>A SQL injection vulnerability in Meshery before 0.6.179 allows a remote attacker to obtain sensitive information and execute arbitrary code via the order parameter.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46575">https://nvd.nist.gov/vuln/detail/CVE-2023-46575</a></li>
<li><a href="https://github.com/meshery/meshery/pull/9372">https://github.com/meshery/meshery/pull/9372</a></li>
<li><a href="https://github.com/meshery/meshery/commit/ffe00967acfe4444a5db08ff3a4cafb9adf6013f">https://github.com/meshery/meshery/commit/ffe00967acfe4444a5db08ff3a4cafb9adf6013f</a></li>
<li><a href="https://github.com/meshery/meshery/compare/v0.6.178...v0.6.179">https://github.com/meshery/meshery/compare/v0.6.178...v0.6.179</a></li>
<li><a href="https://meshery.io">https://meshery.io</a></li>
<li><a href="https://github.com/advisories/GHSA-9jjc-grg5-67gj">https://github.com/advisories/GHSA-9jjc-grg5-67gj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9jjc-grg5-67gj</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-11-24T15:30:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/clastix/capsule-proxy] Capsule Proxy Authentication bypass using an empty token]]></title>
        <id>https://github.com/advisories/GHSA-fpvw-6m5v-hqfp</id>
        <link href="https://github.com/advisories/GHSA-fpvw-6m5v-hqfp"/>
        <updated>2023-11-24T16:53:26.000Z</updated>
        <content type="html"><![CDATA[<p>The privilege escalation is based on a missing check if the user is authenticated based on the <code>TokenReview</code> result.</p>
<p>All the clusters running with the <code>anonymous-auth</code> Kubernetes API Server setting disable (set to <code>false</code>) are affected since it would be possible to bypass the token review mechanism, interacting with the upper Kubernetes API Server.</p>
<h1 id="poc">PoC</h1>
<p>Start a KinD cluster with the <code>anonymous-auth</code> value to <code>false</code>. 
If it is true, it uses anonymous permissions which are very limited by default</p>
<pre><code class="language-yaml">kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  kubeadmConfigPatches:
  - |
    kind: ClusterConfiguration
    apiServer:
        extraArgs:
          anonymous-auth: "false"
</code></pre>
<p>Install <code>capsule</code> and <code>capsule-proxy</code></p>
<pre><code>k port-forward svc/capsule-proxy 9001    
Forwarding from 127.0.0.1:9001 -&gt; 9001
Forwarding from [::1]:9001 -&gt; 9001
Handling connection for 9001
</code></pre>
<p>Then query the proxy</p>
<pre><code>curl -g -k -H 'Authorization: Bearer   f' -X 'GET' 'https://localhost:9001/api/v1/namespaces'
</code></pre>
<h1 id="impact">Impact</h1>
<p>The whole cluster is exposed to unauthorised users.</p>
<p>This privilege escalation cannot be exploited if you're relying only on client certificates (SSL/TLS).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/projectcapsule/capsule-proxy/security/advisories/GHSA-fpvw-6m5v-hqfp">https://github.com/projectcapsule/capsule-proxy/security/advisories/GHSA-fpvw-6m5v-hqfp</a></li>
<li><a href="https://github.com/advisories/GHSA-fpvw-6m5v-hqfp">https://github.com/advisories/GHSA-fpvw-6m5v-hqfp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fpvw-6m5v-hqfp</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-11-24T16:53:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/projectcapsule/capsule-proxy] Capsule Proxy Authentication bypass using an empty token]]></title>
        <id>https://github.com/advisories/GHSA-fpvw-6m5v-hqfp</id>
        <link href="https://github.com/advisories/GHSA-fpvw-6m5v-hqfp"/>
        <updated>2023-11-24T16:53:26.000Z</updated>
        <content type="html"><![CDATA[<p>The privilege escalation is based on a missing check if the user is authenticated based on the <code>TokenReview</code> result.</p>
<p>All the clusters running with the <code>anonymous-auth</code> Kubernetes API Server setting disable (set to <code>false</code>) are affected since it would be possible to bypass the token review mechanism, interacting with the upper Kubernetes API Server.</p>
<h1 id="poc">PoC</h1>
<p>Start a KinD cluster with the <code>anonymous-auth</code> value to <code>false</code>. 
If it is true, it uses anonymous permissions which are very limited by default</p>
<pre><code class="language-yaml">kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  kubeadmConfigPatches:
  - |
    kind: ClusterConfiguration
    apiServer:
        extraArgs:
          anonymous-auth: "false"
</code></pre>
<p>Install <code>capsule</code> and <code>capsule-proxy</code></p>
<pre><code>k port-forward svc/capsule-proxy 9001    
Forwarding from 127.0.0.1:9001 -&gt; 9001
Forwarding from [::1]:9001 -&gt; 9001
Handling connection for 9001
</code></pre>
<p>Then query the proxy</p>
<pre><code>curl -g -k -H 'Authorization: Bearer   f' -X 'GET' 'https://localhost:9001/api/v1/namespaces'
</code></pre>
<h1 id="impact">Impact</h1>
<p>The whole cluster is exposed to unauthorised users.</p>
<p>This privilege escalation cannot be exploited if you're relying only on client certificates (SSL/TLS).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/projectcapsule/capsule-proxy/security/advisories/GHSA-fpvw-6m5v-hqfp">https://github.com/projectcapsule/capsule-proxy/security/advisories/GHSA-fpvw-6m5v-hqfp</a></li>
<li><a href="https://github.com/advisories/GHSA-fpvw-6m5v-hqfp">https://github.com/advisories/GHSA-fpvw-6m5v-hqfp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fpvw-6m5v-hqfp</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-11-24T16:53:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/square/go-jose] Decryption of malicious PBES2 JWE objects can consume unbounded system resources]]></title>
        <id>https://github.com/advisories/GHSA-2c7c-3mj9-8fqh</id>
        <link href="https://github.com/advisories/GHSA-2c7c-3mj9-8fqh"/>
        <updated>2023-11-21T22:17:21.000Z</updated>
        <content type="html"><![CDATA[<p>The go-jose package is subject to a "billion hashes attack" causing denial-of-service when decrypting JWE inputs. This occurs when an attacker can provide a PBES2 encrypted JWE blob with a very large p2c value that, when decrypted, produces a denial-of-service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/go-jose/go-jose/issues/64">https://github.com/go-jose/go-jose/issues/64</a></li>
<li><a href="https://github.com/go-jose/go-jose/commit/65351c27657d58960c2e6c9fbb2b00f818e50568">https://github.com/go-jose/go-jose/commit/65351c27657d58960c2e6c9fbb2b00f818e50568</a></li>
<li><a href="https://github.com/advisories/GHSA-2c7c-3mj9-8fqh">https://github.com/advisories/GHSA-2c7c-3mj9-8fqh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2c7c-3mj9-8fqh</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-21T22:17:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/go-jose/go-jose/v3] Decryption of malicious PBES2 JWE objects can consume unbounded system resources]]></title>
        <id>https://github.com/advisories/GHSA-2c7c-3mj9-8fqh</id>
        <link href="https://github.com/advisories/GHSA-2c7c-3mj9-8fqh"/>
        <updated>2023-11-21T22:17:21.000Z</updated>
        <content type="html"><![CDATA[<p>The go-jose package is subject to a "billion hashes attack" causing denial-of-service when decrypting JWE inputs. This occurs when an attacker can provide a PBES2 encrypted JWE blob with a very large p2c value that, when decrypted, produces a denial-of-service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/go-jose/go-jose/issues/64">https://github.com/go-jose/go-jose/issues/64</a></li>
<li><a href="https://github.com/go-jose/go-jose/commit/65351c27657d58960c2e6c9fbb2b00f818e50568">https://github.com/go-jose/go-jose/commit/65351c27657d58960c2e6c9fbb2b00f818e50568</a></li>
<li><a href="https://github.com/advisories/GHSA-2c7c-3mj9-8fqh">https://github.com/advisories/GHSA-2c7c-3mj9-8fqh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2c7c-3mj9-8fqh</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-21T22:17:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[https://pkg.go.dev/github.com/whilp/git-urls] Inefficient Regular Expression Complexity in git-urls]]></title>
        <id>https://github.com/advisories/GHSA-3f2q-6294-fmq5</id>
        <link href="https://github.com/advisories/GHSA-3f2q-6294-fmq5"/>
        <updated>2023-11-20T23:05:39.000Z</updated>
        <content type="html"><![CDATA[<p>git-urls version 1.0.1 is vulnerable to ReDOS (Regular Expression Denial of Service) in Go package.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46402">https://nvd.nist.gov/vuln/detail/CVE-2023-46402</a></li>
<li><a href="https://gist.github.com/6en6ar/7c2424c93e7fbf2b6fc44e7fb9acb95d">https://gist.github.com/6en6ar/7c2424c93e7fbf2b6fc44e7fb9acb95d</a></li>
<li><a href="https://github.com/advisories/GHSA-3f2q-6294-fmq5">https://github.com/advisories/GHSA-3f2q-6294-fmq5</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3f2q-6294-fmq5</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-18T00:30:17.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/free5gc/free5gc] Free5gc allows a local attacker to cause a denial of service via the free5gc-compose component]]></title>
        <id>https://github.com/advisories/GHSA-q27h-hw2v-x5jm</id>
        <link href="https://github.com/advisories/GHSA-q27h-hw2v-x5jm"/>
        <updated>2023-11-17T14:58:09.000Z</updated>
        <content type="html"><![CDATA[<p>An issue in Free5gc v.3.3.0 allows a local attacker to cause a denial of service via the free5gc-compose component.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47025">https://nvd.nist.gov/vuln/detail/CVE-2023-47025</a></li>
<li><a href="https://github.com/free5gc/free5gc/issues/501">https://github.com/free5gc/free5gc/issues/501</a></li>
<li><a href="https://github.com/advisories/GHSA-q27h-hw2v-x5jm">https://github.com/advisories/GHSA-q27h-hw2v-x5jm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q27h-hw2v-x5jm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-17T00:31:06.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/pydio/cells/v4] Abstrium Pydio Cells Resource Injection vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-j327-c69h-4gh8</id>
        <link href="https://github.com/advisories/GHSA-j327-c69h-4gh8"/>
        <updated>2023-11-16T21:03:52.000Z</updated>
        <content type="html"><![CDATA[<p>A vulnerability classified as critical was found in Abstrium Pydio Cells 4.2.0. This vulnerability affects unknown code of the component User Creation Handler. The manipulation leads to improper control of resource identifiers. The attack can be initiated remotely. Upgrading to version 4.2.1 is able to address this issue. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-230212.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-2980">https://nvd.nist.gov/vuln/detail/CVE-2023-2980</a></li>
<li><a href="https://pydio.com/en/community/releases/pydio-cells/pydio-cells-enterprise-421">https://pydio.com/en/community/releases/pydio-cells/pydio-cells-enterprise-421</a></li>
<li><a href="https://vuldb.com/?ctiid.230212">https://vuldb.com/?ctiid.230212</a></li>
<li><a href="https://vuldb.com/?id.230212">https://vuldb.com/?id.230212</a></li>
<li><a href="https://popalltheshells.medium.com/multiple-cves-affecting-pydio-cells-4-2-0-321e7e4712be">https://popalltheshells.medium.com/multiple-cves-affecting-pydio-cells-4-2-0-321e7e4712be</a></li>
<li><a href="https://github.com/advisories/GHSA-j327-c69h-4gh8">https://github.com/advisories/GHSA-j327-c69h-4gh8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j327-c69h-4gh8</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-05-30T15:30:27.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/free5gc/free5gc] free5gc Buffer Overflow vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-6944-6pmv-6mp2</id>
        <link href="https://github.com/advisories/GHSA-6944-6pmv-6mp2"/>
        <updated>2023-11-21T19:40:09.000Z</updated>
        <content type="html"><![CDATA[<p>Buffer Overflow vulnerability in free5gc 3.3.0 allows attackers to cause a denial of service via crafted PFCP message with malformed PFCP Heartbeat message whose Recovery Time Stamp IE length is mutated to zero.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47345">https://nvd.nist.gov/vuln/detail/CVE-2023-47345</a></li>
<li><a href="https://github.com/free5gc/free5gc/issues/483">https://github.com/free5gc/free5gc/issues/483</a></li>
<li><a href="https://github.com/advisories/GHSA-6944-6pmv-6mp2">https://github.com/advisories/GHSA-6944-6pmv-6mp2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6944-6pmv-6mp2</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-16T00:30:55.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/pydio/cells] go package pydio cells vulnerable to cross-site scripting ]]></title>
        <id>https://github.com/advisories/GHSA-wmfc-g86p-fjvr</id>
        <link href="https://github.com/advisories/GHSA-wmfc-g86p-fjvr"/>
        <updated>2023-11-15T18:10:05.000Z</updated>
        <content type="html"><![CDATA[<p>A vulnerability, which was classified as problematic, has been found in Abstrium Pydio Cells 4.2.0. This issue affects some unknown processing of the component Chat. The manipulation leads to basic cross site scripting. The attack may be initiated remotely. Upgrading to version 4.2.1 is able to address this issue. It is recommended to upgrade the affected component. The identifier VDB-230213 was assigned to this vulnerability.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-2981">https://nvd.nist.gov/vuln/detail/CVE-2023-2981</a></li>
<li><a href="https://pydio.com/en/community/releases/pydio-cells/pydio-cells-enterprise-421">https://pydio.com/en/community/releases/pydio-cells/pydio-cells-enterprise-421</a></li>
<li><a href="https://vuldb.com/?ctiid.230213">https://vuldb.com/?ctiid.230213</a></li>
<li><a href="https://vuldb.com/?id.230213">https://vuldb.com/?id.230213</a></li>
<li><a href="https://popalltheshells.medium.com/multiple-cves-affecting-pydio-cells-4-2-0-321e7e4712be">https://popalltheshells.medium.com/multiple-cves-affecting-pydio-cells-4-2-0-321e7e4712be</a></li>
<li><a href="https://github.com/advisories/GHSA-wmfc-g86p-fjvr">https://github.com/advisories/GHSA-wmfc-g86p-fjvr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wmfc-g86p-fjvr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-05-30T15:30:27.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Kubernetes Improper Input Validation vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-hq6q-c2x6-hmch</id>
        <link href="https://github.com/advisories/GHSA-hq6q-c2x6-hmch"/>
        <updated>2023-11-14T22:25:08.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a user that can create pods and persistent volumes on Windows nodes may be able to escalate to admin privileges on those nodes. Kubernetes clusters are only affected if they are using an in-tree storage plugin for Windows nodes.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-5528">https://nvd.nist.gov/vuln/detail/CVE-2023-5528</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/121879">https://github.com/kubernetes/kubernetes/issues/121879</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA">https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121881">https://github.com/kubernetes/kubernetes/pull/121881</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121882">https://github.com/kubernetes/kubernetes/pull/121882</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121883">https://github.com/kubernetes/kubernetes/pull/121883</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121884">https://github.com/kubernetes/kubernetes/pull/121884</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121885">https://github.com/kubernetes/kubernetes/pull/121885</a></li>
<li><a href="https://github.com/advisories/GHSA-hq6q-c2x6-hmch">https://github.com/advisories/GHSA-hq6q-c2x6-hmch</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hq6q-c2x6-hmch</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T21:31:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Kubernetes Improper Input Validation vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-hq6q-c2x6-hmch</id>
        <link href="https://github.com/advisories/GHSA-hq6q-c2x6-hmch"/>
        <updated>2023-11-14T22:25:08.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a user that can create pods and persistent volumes on Windows nodes may be able to escalate to admin privileges on those nodes. Kubernetes clusters are only affected if they are using an in-tree storage plugin for Windows nodes.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-5528">https://nvd.nist.gov/vuln/detail/CVE-2023-5528</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/121879">https://github.com/kubernetes/kubernetes/issues/121879</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA">https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121881">https://github.com/kubernetes/kubernetes/pull/121881</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121882">https://github.com/kubernetes/kubernetes/pull/121882</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121883">https://github.com/kubernetes/kubernetes/pull/121883</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121884">https://github.com/kubernetes/kubernetes/pull/121884</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121885">https://github.com/kubernetes/kubernetes/pull/121885</a></li>
<li><a href="https://github.com/advisories/GHSA-hq6q-c2x6-hmch">https://github.com/advisories/GHSA-hq6q-c2x6-hmch</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hq6q-c2x6-hmch</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T21:31:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Kubernetes Improper Input Validation vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-hq6q-c2x6-hmch</id>
        <link href="https://github.com/advisories/GHSA-hq6q-c2x6-hmch"/>
        <updated>2023-11-14T22:25:08.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a user that can create pods and persistent volumes on Windows nodes may be able to escalate to admin privileges on those nodes. Kubernetes clusters are only affected if they are using an in-tree storage plugin for Windows nodes.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-5528">https://nvd.nist.gov/vuln/detail/CVE-2023-5528</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/121879">https://github.com/kubernetes/kubernetes/issues/121879</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA">https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121881">https://github.com/kubernetes/kubernetes/pull/121881</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121882">https://github.com/kubernetes/kubernetes/pull/121882</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121883">https://github.com/kubernetes/kubernetes/pull/121883</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121884">https://github.com/kubernetes/kubernetes/pull/121884</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121885">https://github.com/kubernetes/kubernetes/pull/121885</a></li>
<li><a href="https://github.com/advisories/GHSA-hq6q-c2x6-hmch">https://github.com/advisories/GHSA-hq6q-c2x6-hmch</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hq6q-c2x6-hmch</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T21:31:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[k8s.io/kubernetes] Kubernetes Improper Input Validation vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-hq6q-c2x6-hmch</id>
        <link href="https://github.com/advisories/GHSA-hq6q-c2x6-hmch"/>
        <updated>2023-11-14T22:25:08.000Z</updated>
        <content type="html"><![CDATA[<p>A security issue was discovered in Kubernetes where a user that can create pods and persistent volumes on Windows nodes may be able to escalate to admin privileges on those nodes. Kubernetes clusters are only affected if they are using an in-tree storage plugin for Windows nodes.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-5528">https://nvd.nist.gov/vuln/detail/CVE-2023-5528</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/issues/121879">https://github.com/kubernetes/kubernetes/issues/121879</a></li>
<li><a href="https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA">https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121881">https://github.com/kubernetes/kubernetes/pull/121881</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121882">https://github.com/kubernetes/kubernetes/pull/121882</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121883">https://github.com/kubernetes/kubernetes/pull/121883</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121884">https://github.com/kubernetes/kubernetes/pull/121884</a></li>
<li><a href="https://github.com/kubernetes/kubernetes/pull/121885">https://github.com/kubernetes/kubernetes/pull/121885</a></li>
<li><a href="https://github.com/advisories/GHSA-hq6q-c2x6-hmch">https://github.com/advisories/GHSA-hq6q-c2x6-hmch</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hq6q-c2x6-hmch</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T21:31:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/kyverno/kyverno] Attacker can cause Kyverno user to unintentionally consume insecure image]]></title>
        <id>https://github.com/advisories/GHSA-3hfq-cx9j-923w</id>
        <link href="https://github.com/advisories/GHSA-3hfq-cx9j-923w"/>
        <updated>2023-11-14T22:20:10.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was found in Kyverno that allowed an attacker to control the digest of images used by Kyverno users. The issue would require the attacker to compromise the registry that the Kyverno fetch their images from. The attacker could then return a vulnerable image to the the user and leverage that to further escalate their position. As such, the attacker would need to know which images the Kyverno user consumes and know of one of multiple exploitable vulnerabilities in previous digests of the images. Alternatively, if the attacker has compromised the registry, they could craft a malicious image with a different digest with intentionally placed vulnerabilities and deliver the image to the user. </p>
<p>An attacker was not be able to control other parameters of the image than the digest by exploiting this vulnerability.</p>
<p>Users pulling their images from trusted registries are not impacted by this vulnerability. There is no evidence of this being exploited in the wild.</p>
<p>The issue has been patched in 1.11.0. </p>
<p>The vulnerability was found during an ongoing security audit of Kyverno conducted by Ada Logics, facilitated by OSTIF and funded by the CNCF.</p>
<p>Members of the community have raised concerns over the similarity between this vulnerability and the one identified with CVE-2023-46737; They are two different issues with two different root causes and different levels of impact. Some differences are:</p>
<ul>
<li>The current advisory (GHSA-3hfq-cx9j-923w) has its root cause in Kyverno whereas the root cause of CVE-2023-46737 is in Cosigns code base. </li>
<li>The impact of the current advisory (GHSA-3hfq-cx9j-923w) is that an attacker can trick Kyverno into consuming a different image than the one the user requested; The impact of CVE-2023-46737 is an endless data attack resulting in a denial-of-service.</li>
<li>The fix of the current advisory (GHSA-3hfq-cx9j-923w) does not result in users being secure from CVE-2023-46737 and vice versa.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/kyverno/kyverno/security/advisories/GHSA-3hfq-cx9j-923w">https://github.com/kyverno/kyverno/security/advisories/GHSA-3hfq-cx9j-923w</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47630">https://nvd.nist.gov/vuln/detail/CVE-2023-47630</a></li>
<li><a href="https://github.com/kyverno/kyverno/releases/tag/v1.11.0">https://github.com/kyverno/kyverno/releases/tag/v1.11.0</a></li>
<li><a href="https://github.com/advisories/GHSA-3hfq-cx9j-923w">https://github.com/advisories/GHSA-3hfq-cx9j-923w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3hfq-cx9j-923w</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T22:20:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/juanfont/headscale] Headscale writes bearer tokens to info-level logs]]></title>
        <id>https://github.com/advisories/GHSA-wp76-cf2j-rqq7</id>
        <link href="https://github.com/advisories/GHSA-wp76-cf2j-rqq7"/>
        <updated>2023-11-20T22:06:54.000Z</updated>
        <content type="html"><![CDATA[<p>Headscale through 0.22.3 writes bearer tokens to info-level logs.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47390">https://nvd.nist.gov/vuln/detail/CVE-2023-47390</a></li>
<li><a href="https://github.com/juanfont/headscale/issues/1259">https://github.com/juanfont/headscale/issues/1259</a></li>
<li><a href="https://github.com/advisories/GHSA-wp76-cf2j-rqq7">https://github.com/advisories/GHSA-wp76-cf2j-rqq7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wp76-cf2j-rqq7</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-11T18:30:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/sigstore/gitsign] Gitsign's Rekor public keys fetched from upstream API instead of local TUF client.]]></title>
        <id>https://github.com/advisories/GHSA-xvrc-2wvh-49vc</id>
        <link href="https://github.com/advisories/GHSA-xvrc-2wvh-49vc"/>
        <updated>2023-11-14T20:31:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>In certain versions of gitsign, Rekor public keys were fetched via the Rekor API, instead of through the local TUF client. If the upstream Rekor server happened to be compromised, gitsign clients could potentially be tricked into trusting incorrect signatures.</p>
<p>There is no known compromise the default public good instance (<code>rekor.sigstore.dev</code>) - anyone using this instance is unlikely to be affected.</p>
<h3 id="patches">Patches</h3>
<p>This was fixed in v0.8.0 via <a href="https://github.com/sigstore/gitsign/pull/399">https://github.com/sigstore/gitsign/pull/399</a></p>
<h3 id="workarounds">Workarounds</h3>
<p>n/a</p>
<h3 id="references">References</h3>
<p><em>Are there any links users can visit to find out more?</em></p>
<p><a href="https://docs.sigstore.dev/about/threat-model/#sigstore-threat-model">https://docs.sigstore.dev/about/threat-model/#sigstore-threat-model</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/sigstore/gitsign/security/advisories/GHSA-xvrc-2wvh-49vc">https://github.com/sigstore/gitsign/security/advisories/GHSA-xvrc-2wvh-49vc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47122">https://nvd.nist.gov/vuln/detail/CVE-2023-47122</a></li>
<li><a href="https://github.com/sigstore/gitsign/pull/399">https://github.com/sigstore/gitsign/pull/399</a></li>
<li><a href="https://github.com/sigstore/gitsign/commit/cd66ccb03c86a3600955f0c15f6bfeb75f697236">https://github.com/sigstore/gitsign/commit/cd66ccb03c86a3600955f0c15f6bfeb75f697236</a></li>
<li><a href="https://docs.sigstore.dev/about/threat-model/#sigstore-threat-model">https://docs.sigstore.dev/about/threat-model/#sigstore-threat-model</a></li>
<li><a href="https://github.com/advisories/GHSA-xvrc-2wvh-49vc">https://github.com/advisories/GHSA-xvrc-2wvh-49vc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xvrc-2wvh-49vc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-14T20:31:23.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/hyperledger/fabric] Fabric vulnerable to crosslinking transaction attack]]></title>
        <id>https://github.com/advisories/GHSA-v9w2-543f-h69m</id>
        <link href="https://github.com/advisories/GHSA-v9w2-543f-h69m"/>
        <updated>2023-11-14T21:37:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="short-summary">Short summary</h1>
<p>Combining two molecules to one another, called "cross-linking" results in a molecule with a chemical formula that is composed of all atoms of the original two molecules. </p>
<p>In Fabric, one can take a block of transactions and cross-link the transactions in a way that alters the way the peers parse the transactions. If a first peer receives a block <code>B</code> and a second peer receives a block identical to <code>B</code> but with the transactions being cross-linked, the second peer will parse transactions in a different way and thus its world state will deviate from the first peer. </p>
<p>Orderers or peers cannot detect that a block has its transactions cross-linked, because there is a vulnerability in the way Fabric hashes the transactions of blocks. It simply and naively concatenates them, which is insecure and lets an adversary craft a "cross-linked block" (block with cross-linked transactions) which alters the way peers process transactions. 
For example, it is possible to select a transaction and manipulate a peer to completely avoid processing it, without changing the computed hash of the block.</p>
<p>Additional validations have been added in v2.2.14 and v2.5.5 to detect potential cross-linking issues before processing blocks.</p>
<h2 id="impact">Impact</h2>
<p>In V1 and V2, we only have a crash fault tolerant orderer and as such, the security model Fabric operates in is that the orderer is honest,
but peers may be malicious. As such, a peer that replicates a block from a malicious peer can have a state fork.</p>
<p>In V3 which we did not a release a GA yet (only a preview), we have a byzantine fault tolerant orderering service, so the security model that Fabric operates in such a case includes malicious orderers. If the orderer is malicious, it can cause state forks for peers, and can infect non-malicious orderers with cross-linked blocks.</p>
<h1 id="long-summary">Long summary</h1>
<p>In order to create a signature on a big chunk of data  such as a block, the data needs to be "compressed" first to the input size of the signature algorithm.</p>
<p>In Fabric's case, we use a hash function which compressed a Fabric block from arbitrary size to a 32 byte string.</p>
<p>In order to understand the problem we need to be more specific: The block structure has three parts to it: (1) Header, (2) Transactions, and (3) Metadata.</p>
<p>When hashing the block, the header and metadata are stitched together and then hashed, and this hash of the header and the metadata is what signed (it's a simplification but let's not get into details)</p>
<p>However, the transactions of the block are not part of the above hash. Instead, the header contains a hash, called the "Data hash" and despite the fact that in the comments it is said: "// The hash of the BlockData, by MerkleTree", actually it is far from being the case, and that is where our problem lies.</p>
<p>The problem is that the way the transactions are hashed gives an attacker some freedom in manipulating the data. </p>
<p>To create the Data Hash, the transactions in the block are concatenated to one another, creating a big long byte array and then this big long byte array is hashed, and this is essentially the Data Hash.</p>
<p>The transactions in the block are a list of raw byte arrays, and when they are concatenated they look like this:</p>
<p><code>|$$$$$$$$$$$$|*************|@@@@@@@@@@@@|%%%%%%%%%|</code>  (The vertical lines " | " represent how transactions are separated in a block.)</p>
<p>When the transactions are concatenated in order to be hashed, the payload that is hashed is: 
<code>$$$$$$$$$$$$*************@@@@@@@@@@@@%%%%%%%%%</code></p>
<p>An adversary can't change the bytes of the concatenation, however what it can do, is to modify how transactions are encoded in the block:</p>
<p>For example, consider an adversary wants to manipulate a peer to skip the second transaction (******).</p>
<p>It can then create a block with the transactions as follows:</p>
<p><code>|$$$$$$$$$$$$*************|@@@@@@@@@@@@|%%%%%%%%%| </code></p>
<p>Notice that a block with the above transactions has the same concatenation of bytes as the original block, but the block has one less transaction - the first transaction is a concatenation of the first and second transactions in the original block.</p>
<p>When the peer receives this block, it looks at the first transaction and when it parses it, it completely ignores the ***** bytes, (we will see why soon), and so, an adversary can create a block with the same hash but different transactions and this would create a fork in the network.</p>
<p>I made a small PoC where I created a block with 2 transactions (by invoking two chaincodes at the same time) with a Raft orderer:</p>
<pre><code>    [e][OrdererOrg.orderer] 2023-10-14 23:07:34.076 CEST 0079 INFO [orderer.consensus.etcdraft] propose -&gt; Created block [10] with 2 transactions, there are 0 blocks in flight channel=testchannel node=1
</code></pre>
<p>But right after creating the block, I just modified only its transaction content (without modifying the block hash) and then the peers only detect a single transaction inside that block:</p>
<pre><code>    [e][Org2.peer0] 2023-10-14 23:07:34.079 CEST 0099 INFO [kvledger] commit -&gt; [testchannel] Committed block [10] with 1 transaction(s) in 0ms (state_validation=0ms block_and_pvtdata_commit=0ms state_commit=0ms) commitHash=[c5ecca818da9319af2f276dd01cd1337938f20c3535dd23f95a33933a114fe84]
</code></pre>
<p>The important takeaway from this experiment is that the peer does not detect any tempering was done to the block. If an attacker performs this attack, the network can be forked silently and no one will notice the network was forked until it's too late.</p>
<h1 id="patches">Patches</h1>
<p>Here is the patch I propose (the explanation is further below): </p>
<pre><code>diff --git a/internal/peer/gossip/mcs.go b/internal/peer/gossip/mcs.go
index b46df8b6a..9c3b5c8fd 100644
--- a/internal/peer/gossip/mcs.go
+++ b/internal/peer/gossip/mcs.go
@@ -150,6 +150,10 @@ func (s *MSPMessageCryptoService) VerifyBlock(chainID common.ChannelID, seqNum u
         return fmt.Errorf("Block with id [%d] on channel [%s] does not have metadata. Block not valid.", block.Header.Number, chainID)
     }
 
+	if err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {
+		return err
+	}
+
     // - Verify that Header.DataHash is equal to the hash of block.Data
     // This is to ensure that the header is consistent with the data carried by this block
     if !bytes.Equal(protoutil.BlockDataHash(block.Data), block.Header.DataHash) {
diff --git a/orderer/common/cluster/util.go b/orderer/common/cluster/util.go
index e229bebfc..05b1bfaa9 100644
--- a/orderer/common/cluster/util.go
+++ b/orderer/common/cluster/util.go
@@ -260,6 +260,9 @@ func VerifyBlockHash(indexInBuffer int, blockBuff []*common.Block) error {
     if block.Header == nil {
         return errors.New("missing block header")
     }
+	if err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {
+		return err
+	}
     seq := block.Header.Number
     dataHash := protoutil.BlockDataHash(block.Data)
     // Verify data hash matches the hash in the header
diff --git a/orderer/consensus/smartbft/verifier.go b/orderer/consensus/smartbft/verifier.go
index 2b9fdfc4c..f232a1eae 100644
--- a/orderer/consensus/smartbft/verifier.go
+++ b/orderer/consensus/smartbft/verifier.go
@@ -237,6 +237,10 @@ func verifyHashChain(block *cb.Block, prevHeaderHash string) error {
         return errors.Errorf("previous header hash is %s but expected %s", thisHdrHashOfPrevHdr, prevHeaderHash)
     }
 
+	if err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {
+		return err
+	}
+
     dataHash := hex.EncodeToString(block.Header.DataHash)
     actualHashOfData := hex.EncodeToString(protoutil.BlockDataHash(block.Data))
     if dataHash != actualHashOfData {
diff --git a/protoutil/blockutils.go b/protoutil/blockutils.go
index 8527869e4..fca3c386f 100644
--- a/protoutil/blockutils.go
+++ b/protoutil/blockutils.go
@@ -10,6 +10,7 @@ import (
     "bytes"
     "crypto/sha256"
     "encoding/asn1"
+	"encoding/base64"
     "fmt"
     "math/big"
 
@@ -298,3 +299,35 @@ func searchConsenterIdentityByID(consenters []*cb.Consenter, identifier uint32)
     }
     return nil
 }
+
+func VerifyTransactionsAreWellFormed(block *cb.Block) error {
+	if block == nil || block.Data == nil || len(block.Data.Data) == 0 {
+		return nil
+	}
+
+	for i, rawTx := range block.Data.Data {
+		env := &amp;cb.Envelope{}
+		if err := proto.Unmarshal(rawTx, env); err != nil {
+			return fmt.Errorf("transaction %d is invalid: %v", i, err)
+		}
+
+		if len(env.Payload) == 0 {
+			return fmt.Errorf("transaction %d has no payload", i)
+		}
+
+		if len(env.Signature) == 0 {
+			return fmt.Errorf("transaction %d has no signature", i)
+		}
+
+		expected := MarshalOrPanic(env)
+		if len(expected) &lt; len(rawTx) {
+			return fmt.Errorf("transaction %d has %d trailing bytes", i, len(rawTx)-len(expected))
+		}
+		if !bytes.Equal(expected, rawTx) {
+			return fmt.Errorf("transaction %d (%s) does not match its raw form (%s)", i,
+				base64.StdEncoding.EncodeToString(expected), base64.StdEncoding.EncodeToString(rawTx))
+		}
+	}
+
+	return nil
+}
diff --git a/protoutil/blockutils_test.go b/protoutil/blockutils_test.go
index b2159da9f..2871483f1 100644
--- a/protoutil/blockutils_test.go
+++ b/protoutil/blockutils_test.go
@@ -489,3 +489,109 @@ func TestBlockSignatureVerifierByCreator(t *testing.T) {
     require.Len(t, signatureSet, 1)
     require.Equal(t, []byte("creator1"), signatureSet[0].Identity)
 }
+
+func TestVerifyTransactionsAreWellFormed(t *testing.T) {
+	originalBlock := &amp;cb.Block{
+		Data: &amp;cb.BlockData{
+			Data: [][]byte{
+				marshalOrPanic(&amp;cb.Envelope{
+					Payload:   []byte{1, 2, 3},
+					Signature: []byte{4, 5, 6},
+				}),
+				marshalOrPanic(&amp;cb.Envelope{
+					Payload:   []byte{7, 8, 9},
+					Signature: []byte{10, 11, 12},
+				}),
+			},
+		},
+	}
+
+	forgedBlock := proto.Clone(originalBlock).(*cb.Block)
+	tmp := make([]byte, len(forgedBlock.Data.Data[0])+len(forgedBlock.Data.Data[1]))
+	copy(tmp, forgedBlock.Data.Data[0])
+	copy(tmp[len(forgedBlock.Data.Data[0]):], forgedBlock.Data.Data[1])
+	forgedBlock.Data.Data = [][]byte{tmp} // Replace transactions {0,1} with transaction {0 || 1}
+
+	for _, tst := range []struct {
+		name          string
+		expectedError string
+		block         *cb.Block
+	}{
+		{
+			name: "empty block",
+		},
+		{
+			name:  "no block data",
+			block: &amp;cb.Block{},
+		},
+		{
+			name:  "no transactions",
+			block: &amp;cb.Block{Data: &amp;cb.BlockData{}},
+		},
+		{
+			name: "single transaction",
+			block: &amp;cb.Block{Data: &amp;cb.BlockData{Data: [][]byte{marshalOrPanic(&amp;cb.Envelope{
+				Payload:   []byte{1, 2, 3},
+				Signature: []byte{4, 5, 6},
+			})}}},
+		},
+		{
+			name:  "good block",
+			block: originalBlock,
+		},
+		{
+			name:          "forged block",
+			block:         forgedBlock,
+			expectedError: "transaction 0 has 10 trailing bytes",
+		},
+		{
+			name:          "no signature",
+			expectedError: "transaction 0 has no signature",
+			block: &amp;cb.Block{
+				Data: &amp;cb.BlockData{
+					Data: [][]byte{
+						marshalOrPanic(&amp;cb.Envelope{
+							Payload: []byte{1, 2, 3},
+						}),
+					},
+				},
+			},
+		},
+		{
+			name:          "no payload",
+			expectedError: "transaction 0 has no payload",
+			block: &amp;cb.Block{
+				Data: &amp;cb.BlockData{
+					Data: [][]byte{
+						marshalOrPanic(&amp;cb.Envelope{
+							Signature: []byte{4, 5, 6},
+						}),
+					},
+				},
+			},
+		},
+		{
+			name:          "transaction invalid",
+			expectedError: "transaction 0 is invalid: proto: cannot parse invalid wire-format data",
+			block: &amp;cb.Block{
+				Data: &amp;cb.BlockData{
+					Data: [][]byte{
+						marshalOrPanic(&amp;cb.Envelope{
+							Payload:   []byte{1, 2, 3},
+							Signature: []byte{4, 5, 6},
+						})[9:],
+					},
+				},
+			},
+		},
+	} {
+		t.Run(tst.name, func(t *testing.T) {
+			err := protoutil.VerifyTransactionsAreWellFormed(tst.block)
+			if tst.expectedError == "" {
+				require.NoError(t, err)
+			} else {
+				require.EqualError(t, err, tst.expectedError)
+			}
+		})
+	}
+}
</code></pre>
<p>The idea is as follows:</p>
<p>When we validate that the block's transactions match the hash in the header, we not only hash the transactions are earlier, </p>
<p>but also ensure that if the transactions in the block are encoded into bytes, they re-create the exact split in the original block: <code>|$$$$$$$$$$$$|***********|@@@@@@@@@|%%%%%%%%%%%|</code></p>
<p>More specifically, each transaction in the block is parsed and then re-encoded to bytes, and we check that the original encoding of a transaction is as the second encoding after parsing the original bytes of the transaction.</p>
<p>This fix keeps the legacy way of hashing transactions to create the block data hash, but also aims to check if some manipulation was done.</p>
<p>To understand why the fix works, we need to understand how protobuf, the wire protocol that Fabric uses to encode transactions (and almost anything it sends over the wire or writes to disk) encodes a transaction.</p>
<p>A transaction is a protobuf message with two fields of bytes: (1) Payload and (2) Signature.</p>
<p>When encoding a field of bytes, protobuf first writes a tag for the field (a byte) and then writes the length of the field in variable-length encoding, and then the bytes themselves.</p>
<p>For example, to encode a transaction, protobuf writes 10 (the tag for payload), then two bytes for the length of the payload, then the payload, and then 18, the tag for the signature, and then a single byte for the length of the signature, and finally the signature.</p>
<p>Now, we can understand a proof sketch of why my solution works:</p>
<p>Assume in contradiction that an adversary takes a block of transactions and changes the split of the concatenation in a way that changes the transactions for a peer:</p>
<p>From <code>|$$$$$$$$$$$$|************|@@@@@@@@@@@|...|%%%%%%%|</code> to (for example): From <code>|$$$$$$$$$$$$************|@@@@@@@@@@@|...|%%%%%%%|</code> </p>
<p>Since this split is not identical to the original split, there exists at least one transaction index of different size between the two splits. Let's look at the first transaction that is of different size.</p>
<p>For example, for the split:</p>
<p><code>|$$$$$$$$$$$$|************|@@@@@@@@@@@|...|%%%%%%%|</code>  we have two options:</p>
<ol>
<li><p>The first transaction of different size is smaller in the new split:  <code>|$$$$$$$$$$$$|*****|*******|@@@@@@@@@@@|...|%%%%%%%|</code>  In such a case, it must contain both a payload and a signature, so it needs two fields (we can say we will return an error if one of the two is missing). If the protobuf parser detects it lacks bytes to parse a payload, it will fail with an error. Else, it has enough bytes to parse the payload, and then the signature is parsed. If the signature field is too short then we also error similarly.</p>
</li>
<li><p>The first transaction of different size is bigger in the new split: <code>|$$$$$$$$$$$$|************@@@@|@@@@@@@|...|%%%%%%%|</code> 
In that case, once this transaction is parsed, the extra bytes are skipped, so encoding the transaction to bytes yields a shorter byte array, and we detect a tempering.</p>
</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hyperledger/fabric/security/advisories/GHSA-v9w2-543f-h69m">https://github.com/hyperledger/fabric/security/advisories/GHSA-v9w2-543f-h69m</a></li>
<li><a href="https://github.com/hyperledger/fabric/pull/4503">https://github.com/hyperledger/fabric/pull/4503</a></li>
<li><a href="https://github.com/hyperledger/fabric/pull/4504">https://github.com/hyperledger/fabric/pull/4504</a></li>
<li><a href="https://github.com/hyperledger/fabric/commit/389b2e66de9a6fbc6043216d554c97bbbdf0e008">https://github.com/hyperledger/fabric/commit/389b2e66de9a6fbc6043216d554c97bbbdf0e008</a></li>
<li><a href="https://github.com/hyperledger/fabric/commit/93bef10bd3ce3c54d7f3b064f765dbde61da7def">https://github.com/hyperledger/fabric/commit/93bef10bd3ce3c54d7f3b064f765dbde61da7def</a></li>
<li><a href="https://github.com/hyperledger/fabric/releases/tag/v2.2.14">https://github.com/hyperledger/fabric/releases/tag/v2.2.14</a></li>
<li><a href="https://github.com/hyperledger/fabric/releases/tag/v2.5.5">https://github.com/hyperledger/fabric/releases/tag/v2.5.5</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46132">https://nvd.nist.gov/vuln/detail/CVE-2023-46132</a></li>
<li><a href="https://github.com/advisories/GHSA-v9w2-543f-h69m">https://github.com/advisories/GHSA-v9w2-543f-h69m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v9w2-543f-h69m</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T20:28:34.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/hyperledger/fabric] Fabric vulnerable to crosslinking transaction attack]]></title>
        <id>https://github.com/advisories/GHSA-v9w2-543f-h69m</id>
        <link href="https://github.com/advisories/GHSA-v9w2-543f-h69m"/>
        <updated>2023-11-14T21:37:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="short-summary">Short summary</h1>
<p>Combining two molecules to one another, called "cross-linking" results in a molecule with a chemical formula that is composed of all atoms of the original two molecules. </p>
<p>In Fabric, one can take a block of transactions and cross-link the transactions in a way that alters the way the peers parse the transactions. If a first peer receives a block <code>B</code> and a second peer receives a block identical to <code>B</code> but with the transactions being cross-linked, the second peer will parse transactions in a different way and thus its world state will deviate from the first peer. </p>
<p>Orderers or peers cannot detect that a block has its transactions cross-linked, because there is a vulnerability in the way Fabric hashes the transactions of blocks. It simply and naively concatenates them, which is insecure and lets an adversary craft a "cross-linked block" (block with cross-linked transactions) which alters the way peers process transactions. 
For example, it is possible to select a transaction and manipulate a peer to completely avoid processing it, without changing the computed hash of the block.</p>
<p>Additional validations have been added in v2.2.14 and v2.5.5 to detect potential cross-linking issues before processing blocks.</p>
<h2 id="impact">Impact</h2>
<p>In V1 and V2, we only have a crash fault tolerant orderer and as such, the security model Fabric operates in is that the orderer is honest,
but peers may be malicious. As such, a peer that replicates a block from a malicious peer can have a state fork.</p>
<p>In V3 which we did not a release a GA yet (only a preview), we have a byzantine fault tolerant orderering service, so the security model that Fabric operates in such a case includes malicious orderers. If the orderer is malicious, it can cause state forks for peers, and can infect non-malicious orderers with cross-linked blocks.</p>
<h1 id="long-summary">Long summary</h1>
<p>In order to create a signature on a big chunk of data  such as a block, the data needs to be "compressed" first to the input size of the signature algorithm.</p>
<p>In Fabric's case, we use a hash function which compressed a Fabric block from arbitrary size to a 32 byte string.</p>
<p>In order to understand the problem we need to be more specific: The block structure has three parts to it: (1) Header, (2) Transactions, and (3) Metadata.</p>
<p>When hashing the block, the header and metadata are stitched together and then hashed, and this hash of the header and the metadata is what signed (it's a simplification but let's not get into details)</p>
<p>However, the transactions of the block are not part of the above hash. Instead, the header contains a hash, called the "Data hash" and despite the fact that in the comments it is said: "// The hash of the BlockData, by MerkleTree", actually it is far from being the case, and that is where our problem lies.</p>
<p>The problem is that the way the transactions are hashed gives an attacker some freedom in manipulating the data. </p>
<p>To create the Data Hash, the transactions in the block are concatenated to one another, creating a big long byte array and then this big long byte array is hashed, and this is essentially the Data Hash.</p>
<p>The transactions in the block are a list of raw byte arrays, and when they are concatenated they look like this:</p>
<p><code>|$$$$$$$$$$$$|*************|@@@@@@@@@@@@|%%%%%%%%%|</code>  (The vertical lines " | " represent how transactions are separated in a block.)</p>
<p>When the transactions are concatenated in order to be hashed, the payload that is hashed is: 
<code>$$$$$$$$$$$$*************@@@@@@@@@@@@%%%%%%%%%</code></p>
<p>An adversary can't change the bytes of the concatenation, however what it can do, is to modify how transactions are encoded in the block:</p>
<p>For example, consider an adversary wants to manipulate a peer to skip the second transaction (******).</p>
<p>It can then create a block with the transactions as follows:</p>
<p><code>|$$$$$$$$$$$$*************|@@@@@@@@@@@@|%%%%%%%%%| </code></p>
<p>Notice that a block with the above transactions has the same concatenation of bytes as the original block, but the block has one less transaction - the first transaction is a concatenation of the first and second transactions in the original block.</p>
<p>When the peer receives this block, it looks at the first transaction and when it parses it, it completely ignores the ***** bytes, (we will see why soon), and so, an adversary can create a block with the same hash but different transactions and this would create a fork in the network.</p>
<p>I made a small PoC where I created a block with 2 transactions (by invoking two chaincodes at the same time) with a Raft orderer:</p>
<pre><code>    [e][OrdererOrg.orderer] 2023-10-14 23:07:34.076 CEST 0079 INFO [orderer.consensus.etcdraft] propose -&gt; Created block [10] with 2 transactions, there are 0 blocks in flight channel=testchannel node=1
</code></pre>
<p>But right after creating the block, I just modified only its transaction content (without modifying the block hash) and then the peers only detect a single transaction inside that block:</p>
<pre><code>    [e][Org2.peer0] 2023-10-14 23:07:34.079 CEST 0099 INFO [kvledger] commit -&gt; [testchannel] Committed block [10] with 1 transaction(s) in 0ms (state_validation=0ms block_and_pvtdata_commit=0ms state_commit=0ms) commitHash=[c5ecca818da9319af2f276dd01cd1337938f20c3535dd23f95a33933a114fe84]
</code></pre>
<p>The important takeaway from this experiment is that the peer does not detect any tempering was done to the block. If an attacker performs this attack, the network can be forked silently and no one will notice the network was forked until it's too late.</p>
<h1 id="patches">Patches</h1>
<p>Here is the patch I propose (the explanation is further below): </p>
<pre><code>diff --git a/internal/peer/gossip/mcs.go b/internal/peer/gossip/mcs.go
index b46df8b6a..9c3b5c8fd 100644
--- a/internal/peer/gossip/mcs.go
+++ b/internal/peer/gossip/mcs.go
@@ -150,6 +150,10 @@ func (s *MSPMessageCryptoService) VerifyBlock(chainID common.ChannelID, seqNum u
         return fmt.Errorf("Block with id [%d] on channel [%s] does not have metadata. Block not valid.", block.Header.Number, chainID)
     }
 
+	if err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {
+		return err
+	}
+
     // - Verify that Header.DataHash is equal to the hash of block.Data
     // This is to ensure that the header is consistent with the data carried by this block
     if !bytes.Equal(protoutil.BlockDataHash(block.Data), block.Header.DataHash) {
diff --git a/orderer/common/cluster/util.go b/orderer/common/cluster/util.go
index e229bebfc..05b1bfaa9 100644
--- a/orderer/common/cluster/util.go
+++ b/orderer/common/cluster/util.go
@@ -260,6 +260,9 @@ func VerifyBlockHash(indexInBuffer int, blockBuff []*common.Block) error {
     if block.Header == nil {
         return errors.New("missing block header")
     }
+	if err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {
+		return err
+	}
     seq := block.Header.Number
     dataHash := protoutil.BlockDataHash(block.Data)
     // Verify data hash matches the hash in the header
diff --git a/orderer/consensus/smartbft/verifier.go b/orderer/consensus/smartbft/verifier.go
index 2b9fdfc4c..f232a1eae 100644
--- a/orderer/consensus/smartbft/verifier.go
+++ b/orderer/consensus/smartbft/verifier.go
@@ -237,6 +237,10 @@ func verifyHashChain(block *cb.Block, prevHeaderHash string) error {
         return errors.Errorf("previous header hash is %s but expected %s", thisHdrHashOfPrevHdr, prevHeaderHash)
     }
 
+	if err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {
+		return err
+	}
+
     dataHash := hex.EncodeToString(block.Header.DataHash)
     actualHashOfData := hex.EncodeToString(protoutil.BlockDataHash(block.Data))
     if dataHash != actualHashOfData {
diff --git a/protoutil/blockutils.go b/protoutil/blockutils.go
index 8527869e4..fca3c386f 100644
--- a/protoutil/blockutils.go
+++ b/protoutil/blockutils.go
@@ -10,6 +10,7 @@ import (
     "bytes"
     "crypto/sha256"
     "encoding/asn1"
+	"encoding/base64"
     "fmt"
     "math/big"
 
@@ -298,3 +299,35 @@ func searchConsenterIdentityByID(consenters []*cb.Consenter, identifier uint32)
     }
     return nil
 }
+
+func VerifyTransactionsAreWellFormed(block *cb.Block) error {
+	if block == nil || block.Data == nil || len(block.Data.Data) == 0 {
+		return nil
+	}
+
+	for i, rawTx := range block.Data.Data {
+		env := &amp;cb.Envelope{}
+		if err := proto.Unmarshal(rawTx, env); err != nil {
+			return fmt.Errorf("transaction %d is invalid: %v", i, err)
+		}
+
+		if len(env.Payload) == 0 {
+			return fmt.Errorf("transaction %d has no payload", i)
+		}
+
+		if len(env.Signature) == 0 {
+			return fmt.Errorf("transaction %d has no signature", i)
+		}
+
+		expected := MarshalOrPanic(env)
+		if len(expected) &lt; len(rawTx) {
+			return fmt.Errorf("transaction %d has %d trailing bytes", i, len(rawTx)-len(expected))
+		}
+		if !bytes.Equal(expected, rawTx) {
+			return fmt.Errorf("transaction %d (%s) does not match its raw form (%s)", i,
+				base64.StdEncoding.EncodeToString(expected), base64.StdEncoding.EncodeToString(rawTx))
+		}
+	}
+
+	return nil
+}
diff --git a/protoutil/blockutils_test.go b/protoutil/blockutils_test.go
index b2159da9f..2871483f1 100644
--- a/protoutil/blockutils_test.go
+++ b/protoutil/blockutils_test.go
@@ -489,3 +489,109 @@ func TestBlockSignatureVerifierByCreator(t *testing.T) {
     require.Len(t, signatureSet, 1)
     require.Equal(t, []byte("creator1"), signatureSet[0].Identity)
 }
+
+func TestVerifyTransactionsAreWellFormed(t *testing.T) {
+	originalBlock := &amp;cb.Block{
+		Data: &amp;cb.BlockData{
+			Data: [][]byte{
+				marshalOrPanic(&amp;cb.Envelope{
+					Payload:   []byte{1, 2, 3},
+					Signature: []byte{4, 5, 6},
+				}),
+				marshalOrPanic(&amp;cb.Envelope{
+					Payload:   []byte{7, 8, 9},
+					Signature: []byte{10, 11, 12},
+				}),
+			},
+		},
+	}
+
+	forgedBlock := proto.Clone(originalBlock).(*cb.Block)
+	tmp := make([]byte, len(forgedBlock.Data.Data[0])+len(forgedBlock.Data.Data[1]))
+	copy(tmp, forgedBlock.Data.Data[0])
+	copy(tmp[len(forgedBlock.Data.Data[0]):], forgedBlock.Data.Data[1])
+	forgedBlock.Data.Data = [][]byte{tmp} // Replace transactions {0,1} with transaction {0 || 1}
+
+	for _, tst := range []struct {
+		name          string
+		expectedError string
+		block         *cb.Block
+	}{
+		{
+			name: "empty block",
+		},
+		{
+			name:  "no block data",
+			block: &amp;cb.Block{},
+		},
+		{
+			name:  "no transactions",
+			block: &amp;cb.Block{Data: &amp;cb.BlockData{}},
+		},
+		{
+			name: "single transaction",
+			block: &amp;cb.Block{Data: &amp;cb.BlockData{Data: [][]byte{marshalOrPanic(&amp;cb.Envelope{
+				Payload:   []byte{1, 2, 3},
+				Signature: []byte{4, 5, 6},
+			})}}},
+		},
+		{
+			name:  "good block",
+			block: originalBlock,
+		},
+		{
+			name:          "forged block",
+			block:         forgedBlock,
+			expectedError: "transaction 0 has 10 trailing bytes",
+		},
+		{
+			name:          "no signature",
+			expectedError: "transaction 0 has no signature",
+			block: &amp;cb.Block{
+				Data: &amp;cb.BlockData{
+					Data: [][]byte{
+						marshalOrPanic(&amp;cb.Envelope{
+							Payload: []byte{1, 2, 3},
+						}),
+					},
+				},
+			},
+		},
+		{
+			name:          "no payload",
+			expectedError: "transaction 0 has no payload",
+			block: &amp;cb.Block{
+				Data: &amp;cb.BlockData{
+					Data: [][]byte{
+						marshalOrPanic(&amp;cb.Envelope{
+							Signature: []byte{4, 5, 6},
+						}),
+					},
+				},
+			},
+		},
+		{
+			name:          "transaction invalid",
+			expectedError: "transaction 0 is invalid: proto: cannot parse invalid wire-format data",
+			block: &amp;cb.Block{
+				Data: &amp;cb.BlockData{
+					Data: [][]byte{
+						marshalOrPanic(&amp;cb.Envelope{
+							Payload:   []byte{1, 2, 3},
+							Signature: []byte{4, 5, 6},
+						})[9:],
+					},
+				},
+			},
+		},
+	} {
+		t.Run(tst.name, func(t *testing.T) {
+			err := protoutil.VerifyTransactionsAreWellFormed(tst.block)
+			if tst.expectedError == "" {
+				require.NoError(t, err)
+			} else {
+				require.EqualError(t, err, tst.expectedError)
+			}
+		})
+	}
+}
</code></pre>
<p>The idea is as follows:</p>
<p>When we validate that the block's transactions match the hash in the header, we not only hash the transactions are earlier, </p>
<p>but also ensure that if the transactions in the block are encoded into bytes, they re-create the exact split in the original block: <code>|$$$$$$$$$$$$|***********|@@@@@@@@@|%%%%%%%%%%%|</code></p>
<p>More specifically, each transaction in the block is parsed and then re-encoded to bytes, and we check that the original encoding of a transaction is as the second encoding after parsing the original bytes of the transaction.</p>
<p>This fix keeps the legacy way of hashing transactions to create the block data hash, but also aims to check if some manipulation was done.</p>
<p>To understand why the fix works, we need to understand how protobuf, the wire protocol that Fabric uses to encode transactions (and almost anything it sends over the wire or writes to disk) encodes a transaction.</p>
<p>A transaction is a protobuf message with two fields of bytes: (1) Payload and (2) Signature.</p>
<p>When encoding a field of bytes, protobuf first writes a tag for the field (a byte) and then writes the length of the field in variable-length encoding, and then the bytes themselves.</p>
<p>For example, to encode a transaction, protobuf writes 10 (the tag for payload), then two bytes for the length of the payload, then the payload, and then 18, the tag for the signature, and then a single byte for the length of the signature, and finally the signature.</p>
<p>Now, we can understand a proof sketch of why my solution works:</p>
<p>Assume in contradiction that an adversary takes a block of transactions and changes the split of the concatenation in a way that changes the transactions for a peer:</p>
<p>From <code>|$$$$$$$$$$$$|************|@@@@@@@@@@@|...|%%%%%%%|</code> to (for example): From <code>|$$$$$$$$$$$$************|@@@@@@@@@@@|...|%%%%%%%|</code> </p>
<p>Since this split is not identical to the original split, there exists at least one transaction index of different size between the two splits. Let's look at the first transaction that is of different size.</p>
<p>For example, for the split:</p>
<p><code>|$$$$$$$$$$$$|************|@@@@@@@@@@@|...|%%%%%%%|</code>  we have two options:</p>
<ol>
<li><p>The first transaction of different size is smaller in the new split:  <code>|$$$$$$$$$$$$|*****|*******|@@@@@@@@@@@|...|%%%%%%%|</code>  In such a case, it must contain both a payload and a signature, so it needs two fields (we can say we will return an error if one of the two is missing). If the protobuf parser detects it lacks bytes to parse a payload, it will fail with an error. Else, it has enough bytes to parse the payload, and then the signature is parsed. If the signature field is too short then we also error similarly.</p>
</li>
<li><p>The first transaction of different size is bigger in the new split: <code>|$$$$$$$$$$$$|************@@@@|@@@@@@@|...|%%%%%%%|</code> 
In that case, once this transaction is parsed, the extra bytes are skipped, so encoding the transaction to bytes yields a shorter byte array, and we detect a tempering.</p>
</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/hyperledger/fabric/security/advisories/GHSA-v9w2-543f-h69m">https://github.com/hyperledger/fabric/security/advisories/GHSA-v9w2-543f-h69m</a></li>
<li><a href="https://github.com/hyperledger/fabric/pull/4503">https://github.com/hyperledger/fabric/pull/4503</a></li>
<li><a href="https://github.com/hyperledger/fabric/pull/4504">https://github.com/hyperledger/fabric/pull/4504</a></li>
<li><a href="https://github.com/hyperledger/fabric/commit/389b2e66de9a6fbc6043216d554c97bbbdf0e008">https://github.com/hyperledger/fabric/commit/389b2e66de9a6fbc6043216d554c97bbbdf0e008</a></li>
<li><a href="https://github.com/hyperledger/fabric/commit/93bef10bd3ce3c54d7f3b064f765dbde61da7def">https://github.com/hyperledger/fabric/commit/93bef10bd3ce3c54d7f3b064f765dbde61da7def</a></li>
<li><a href="https://github.com/hyperledger/fabric/releases/tag/v2.2.14">https://github.com/hyperledger/fabric/releases/tag/v2.2.14</a></li>
<li><a href="https://github.com/hyperledger/fabric/releases/tag/v2.5.5">https://github.com/hyperledger/fabric/releases/tag/v2.5.5</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46132">https://nvd.nist.gov/vuln/detail/CVE-2023-46132</a></li>
<li><a href="https://github.com/advisories/GHSA-v9w2-543f-h69m">https://github.com/advisories/GHSA-v9w2-543f-h69m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v9w2-543f-h69m</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T20:28:34.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[github.com/consensys/gnark] gnark's range checker gadget allows wider inputs up to word alignment]]></title>
        <id>https://github.com/advisories/GHSA-rjjm-x32p-m3f7</id>
        <link href="https://github.com/advisories/GHSA-rjjm-x32p-m3f7"/>
        <updated>2023-11-12T15:56:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>gnark provides a gadget in the standard library to allow optimized checking of the bitwidth of the inputs. The gadget works by constructing a fixed lookup table containing all valid entries, partitioning the input and checking that all parts are inside the lookup table. The range checker gadget did not take into account that the highest partition may be less than the width limit, allowing the inputs to be up to 16 bits wider than checked.</p>
<p>Range checking gadget is extensively used in field emulation. Users using any dependant gadget (ECDSA verification, proof recursion etc.) is impacted.</p>
<p>We consider the impact of the vulnerability being low as the number of attacker-modifiable bits is significantly smaller compared to the bit-width of scalar field modulus and it won't be possible to construct inputs which would allow to overflow the scalar field.</p>
<h3 id="patches">Patches</h3>
<p>The issue has been patched in the stable branch of gnark. </p>
<p>Due to low severity of the issue no emergency release will be issued and we follow the existing release plan. Versions v0.9.2 and higher are patched.</p>
<h3 id="workarounds">Workarounds</h3>
<p>We consider the issue very hard to exploit and do not recommend manual remediation. However, it is possible to perform manual bit decomposition using <code>std/math/bits</code> gadget.</p>
<h3 id="references">References</h3>
<p>Initial issue <a href="https://github.com/Consensys/gnark/issues/897">https://github.com/Consensys/gnark/issues/897</a></p>
<h3 id="acknowledgement">Acknowledgement</h3>
<p>The issue was reported by <a href="https://github.com/ultrainstinct30">@ultrainstinct30</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/Consensys/gnark/security/advisories/GHSA-rjjm-x32p-m3f7">https://github.com/Consensys/gnark/security/advisories/GHSA-rjjm-x32p-m3f7</a></li>
<li><a href="https://github.com/Consensys/gnark/issues/897">https://github.com/Consensys/gnark/issues/897</a></li>
<li><a href="https://github.com/Consensys/gnark/commit/f528807119e9443df94b8c01fe8ee65abe3c75d8">https://github.com/Consensys/gnark/commit/f528807119e9443df94b8c01fe8ee65abe3c75d8</a></li>
<li><a href="https://github.com/advisories/GHSA-rjjm-x32p-m3f7">https://github.com/advisories/GHSA-rjjm-x32p-m3f7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rjjm-x32p-m3f7</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-11-12T15:56:48.000Z</published>
    </entry>
</feed>