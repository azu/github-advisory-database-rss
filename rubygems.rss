<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rubygems.rss</id>
    <title>Security Advisory for Ruby gems hosted at RubyGems.org</title>
    <updated>2022-01-19T02:06:20.482Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arubygems"/>
    <subtitle>Security Advisory for Ruby gems hosted at RubyGems.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <entry>
        <title type="html"><![CDATA[[google-protobuf] A potential Denial of Service issue in protobuf-java]]></title>
        <id>https://github.com/advisories/GHSA-wrvw-hg22-4m67</id>
        <link href="https://github.com/advisories/GHSA-wrvw-hg22-4m67"/>
        <updated>2022-01-18T22:38:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>A potential Denial of Service issue in protobuf-java was discovered in the parsing procedure for binary data.</p>
<p>Reporter: <a href="https://github.com/google/oss-fuzz">OSS-Fuzz</a></p>
<p>Affected versions: All versions of Java Protobufs (including Kotlin and JRuby) prior to the versions listed below. Protobuf "javalite" users (typically Android) are not affected.</p>
<h2 id="severity">Severity</h2>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22569">CVE-2021-22569</a> <strong>High</strong> - CVSS Score: 7.5,  An implementation weakness in how unknown fields are parsed in Java. A small (~800 KB) malicious payload can occupy the parser for several minutes by creating large numbers of short-lived objects that cause frequent, repeated GC pauses.</p>
<h2 id="proof-of-concept">Proof of Concept</h2>
<p>For reproduction details, please refer to the oss-fuzz issue that identifies the specific inputs that exercise this parsing weakness.</p>
<h2 id="remediation-and-mitigation">Remediation and Mitigation</h2>
<p>Please update to the latest available versions of the following packages:</p>
<ul>
<li>protobuf-java (3.16.1, 3.18.2, 3.19.2) </li>
<li>protobuf-kotlin (3.18.2, 3.19.2)</li>
<li>google-protobuf [JRuby  gem only] (3.19.2)</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67">https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-22569">https://nvd.nist.gov/vuln/detail/CVE-2021-22569</a></li>
<li><a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39330">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39330</a></li>
<li><a href="https://cloud.google.com/support/bulletins#gcp-2022-001">https://cloud.google.com/support/bulletins#gcp-2022-001</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2022/01/12/4">http://www.openwall.com/lists/oss-security/2022/01/12/4</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2022/01/12/7">http://www.openwall.com/lists/oss-security/2022/01/12/7</a></li>
<li><a href="https://github.com/advisories/GHSA-wrvw-hg22-4m67">https://github.com/advisories/GHSA-wrvw-hg22-4m67</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wrvw-hg22-4m67</uri>
        </author>
        <published>2022-01-07T22:31:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_frontend] CSRF forgery protection bypass in solidus_frontend]]></title>
        <id>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</id>
        <link href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m"/>
        <updated>2022-01-06T18:33:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>CSRF vulnerability that allows a malicious site to add an item to the user's cart without their knowledge.</p>
<p>All <code>solidus_frontend</code> versions are affected. If you're using your own storefront, please, follow along to make sure you're not affected.</p>
<p>To reproduce the issue:</p>
<ul>
<li><p>Pick the id for a variant with available stock. From the rails console:</p>
<pre><code class="language-ruby">Spree::Variant.in_stock.pluck(:id)
</code></pre>
<p>Say we pick variant id <code>2</code>.</p>
</li>
<li><p>Launch your application, for instance, on <code>http://localhost:3000</code>:</p>
<pre><code class="language-bash">bin/rails server
</code></pre>
</li>
<li><p>Open your browser dev tools.</p>
</li>
<li><p>Click on whatever link in your store.</p>
</li>
<li><p>Copy the value of the <code>Cookie</code> request header sent for the previous request from your browser dev tools.</p>
</li>
<li><p>Execute the following, using your previously selected variant id and the value of the <code>Cookie</code> header (notice how it doesn't contain any authentication token):</p>
<pre><code class="language-bash">curl -X POST -d "variant_id=2&amp;quantity=1" -H "Cookie: guest_token=eyJfcmFpbHMiOnsibWVzc2FnZSI6IklrWlRVMWRQWnpKMVZVdFNXRzlPVW1aaWJHTjZZa0VpIiwiZXhwIjpudWxsLCJwdXIiOiJjb29raWUuZ3Vlc3RfdG9rZW4ifX0%3D--5006ba5d346f621c760a29b6a797bf351d17d1b8; _sandbox_session=vhutu5%2FL9NmWrUpGc3DxrFA%2FFsQD1dHn1cNsD7nvE84zcjWf17Af4%2F%2F2Vab3md71b6KTb9NP6WktdXktpwH4eU01jEGIBXG5%2BMzW5nL0nb4W269qk1io4LYljvoOg8%2BZVll7oJCVkJLKKh0sSoS0Kg8j%2FCHHs%2BsShohP%2BGnA%2Bfr9Ub8H6HofpSmloSpsfHHygmX0ho03fEgzHJ4DD5wJctaNKwg7NhVikHh5kgIPPHl84OGCgv3p2oe9jR19HTxOKq7BtyvDd7XZsecWhkcfS8BPnvDDUWZG6qpAEFI5kWo81KkpSJ%2Bp6Q1HOo8%3D--n3G2vgaDG7VS%2B%2FhF--ZTjxBAkfGG3hpr4GRQ2S1Q%3D%3D; __profilin=p%3Dt" http://localhost:3000/orders/populate
</code></pre>
</li>
<li><p>Reload your browser and look at how your cart got updated.</p>
</li>
</ul>
<h3 id="patches">Patches</h3>
<p>Please, upgrade <code>solidus</code> to versions <code>3.1.5</code>, <code>3.0.5</code> or <code>2.11.14</code>.</p>
<p>After upgrading, make sure you read the "Upgrade notes"  section below.</p>
<h3 id="upgrade-notes">Upgrade notes</h3>
<p>The patch adds CSRF token verification to the "Add to cart" action. Adding forgery protection to a form that missed it can have some side effects.</p>
<h4 id="invalidauthenticitytoken-errors"><code>InvalidAuthenticityToken</code> errors</h4>
<p>If you're using the <code>:exception</code> strategy, it's likely that after upgrading, you'll see more <code>ActionController::InvalidAuthenticityToken</code> errors popping out in your logs. Due to browser-side cache, a form can be re-rendered and sent without any attached request cookie (for instance, when re-opening a mobile browser). That will cause an authentication error, as the sent token won't match with the one in the session (none in this case). That's a known problem in the Rails community (see <a href="https://github.com/rails/rails/issues/21948">https://github.com/rails/rails/issues/21948</a>), and, at this point, there's no perfect solution.</p>
<p>Any attempt to mitigate the issue should be seen at the application level. For an excellent survey of all the available options, take a look at <a href="https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md">https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md</a>. The latter is a third-party link. As the information is relevant here, we're going to copy it below, but it should be clear that all the credit goes to @kemenaran:</p>
<blockquote>
<h1 id="protecting-against-request-forgery-using-crsf-tokens">Protecting against request forgery using CRSF tokens</h1>
<h2 id="context">Context</h2>
<p>Rails has CSRF protection enabled by default, to protect against POST-based CSRF attacks.</p>
<p>To protect from this, Rails stores two copies of a random token (the so-named CSRF token) on each request:</p>
<ul>
<li>one copy embedded in each HTML page,</li>
<li>another copy in the user session.</li>
</ul>
<p>When performing a POST request, Rails checks that the two copies match – and otherwise denies the request. This protects against an attacker that would generate a form secretly pointing to our website: the attacker can't read the token in the session, and so can't post a form with a valid token.</p>
<p>The problem is that, much more often, this has false positives. There are several cases for that, including:</p>
<ol>
<li><p>The web browser (often mobile) loads a page containing a form, then is closed by the user. Later, when the browser is re-opened, it restores the page from the cache. But the session cookie has expired, and so is not restored – so the copy of the CSRF token stored in the session is missing. When the user submits the form, they get an "InvalidAuthenticityToken" exception.</p>
</li>
<li><p>The user attempts to fill a form, and gets an error message (usually in response to a POST request). They close the browser. When the browser is re-opened, it attempts to restore the page. On Chrome this is blocked by the browser, because the browser denies retrying a (probably non-idempotent) POST request. Safari however happily retries the POST request – but without sending any cookies (in an attempt to avoid having unexpected side-effects). So the copy of the CSRF token in the session is missing (because no cookie was sent), and the user get an "InvalidAuthenticityToken" exception.</p>
</li>
</ol>
<h2 id="options-considered">Options considered</h2>
<h3 id="extend-the-session-cookie-duration">Extend the session cookie duration</h3>
<p>We can configure the session cookie to be valid for a longer time (like 2 weeks).</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the browser restores the page, the session cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Users would be signed-in for a much longer time by default, which has unacceptable security implications.</li>
<li>It doesn't solve 2. (because Safari doesn't send any cookie when restoring a page from a POST request)</li>
</ul>
<h3 id="change-the-cache-parameters">Change the cache parameters</h3>
<p>We can send a HTTP cache header stating 'Cache-Control: no-store, no-cache'. This instructs the browser to never keep any copy of the page, and to always make a request to the server to restore it.</p>
<p>This solution was attempted during a year in production, and solved 1. – but also introduced another type of InvalidAuthenticityToken errors. In that scenario, the user attempts to fill a form, and gets an error message (usually in response to a POST request). They then navigate on another domain (like France Connect), then hit the "Back" button. Crossing back the domain boundary may cause the browser to either block the request or retry an invalid POST request.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because on relaunch the browser requests a fresh page again (instead of serving it from its cache), thus retrieving a fresh session and a fresh matching CSRF token.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2.</li>
<li>It causes another type of InvalidAuthenticityToken errors.</li>
</ul>
<h3 id="using-a-null-session-strategy">Using a null-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :null_session. This makes the current request use an empty session for the request duration.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>The user is asked to sign-in only after filling and submitting the form, losing their time and data</li>
<li>The user will not be redirected to their original page after signing-in</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
</ul>
<h3 id="using-a-reset-session-strategy">Using a reset-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :reset_session. This clears the user session permanently, logging them out until they log in again.</p>
<p>Pros: </p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>A forgery error in a browser tab will disconnect the user in all its open tabs</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
<li>It allows an attacker to disconnect an user on demand, which is not only inconvenient, but also has security implication (the attacker could then log the user on it's own attacker account, pretending to be the user account)</li>
</ul>
<h3 id="redirect-to-login-form">Redirect to login form</h3>
<p>When a forgery error occurs, we can instead redirect to the login form.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted (but the user data is lost).</li>
<li>It kind of solves 2., by redirecting to a "Please sign-in" page when a previously POSTed form is reloaded.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not all forms require authentication – so for public forms there is no point redirecting to the login form. </li>
<li>The user will not be redirected to their original page after signing-in (because setting the redirect path is a state-changing action, and it is dangerous to let an unauthorized request changing the state – an attacker could control the path where an user is automatically redirected to.)</li>
<li>The implementation is finicky, and may introduce security errors. For instance, a naive implementation that catches the exception and redirect_to the sign-in page will prevent Devise from running a cleanup code – which means the user will still be logged, and the CSRF protection is bypassed. However a well-tested implementation that lets Devise code run should avoid these pittfalls.</li>
</ul>
<h3 id="using-a-long-lived-cookie-for-csrf-tokens">Using a long-lived cookie for CSRF tokens</h3>
<p>Instead of storing the CSRF token in the session cookie (which is deleted when the browser is closed), we can instead store it in a longer-lived cookie. For this we need to patch Rails.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the user submits a stale form, even if the session cookie because stale, the long-lived CSRF cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2., because when Safari retries a POST request, it sends none of the cookies (not even long-lived ones).</li>
<li>Patching Rails may introduce security issues (now or in the future)</li>
</ul>
</blockquote>
<h4 id="broken-behavior-due-to-session-expiration--template-cache">Broken behavior due to session expiration + template cache</h4>
<p>Although pretty unlikely, you should make sure that your current setup for cache/session expiration is compatible. The upgrade can break the addition of products to the cart if both:</p>
<ul>
<li><p>The "Add to cart" form is being cached (usually along with the variant information).</p>
</li>
<li><p>A user session is reset at every or every few requests.</p>
</li>
</ul>
<p>The token validation depends on the issuing and consuming sessions being the same. If a product page is cached with the token in it, it can become stale on a subsequent rendering if the session changes.</p>
<p>To check that you're safe, after having upgraded locally, go through the following steps:</p>
<ul>
<li><p>Enable cache on dev mode:</p>
<pre><code class="language-bash">bin/rails dev:cache
</code></pre>
</li>
<li><p>Visit the page for a variant with stock.</p>
</li>
<li><p>Reload that page several times.</p>
</li>
<li><p>Click on the "Add to cart"  button.</p>
</li>
<li><p>Remember to rerun <code>bin/rails dev:cache</code> to turn off cache again.</p>
</li>
</ul>
<p>No error or session reset should happen.</p>
<p>Otherwise, you can try with:</p>
<ul>
<li>Revisiting how your session gets expired.</li>
<li>Changing the caching strategy to exclude the token.</li>
</ul>
<h4 id="using-weaker-csrf-protection-strategies">Using weaker CSRF protection strategies</h4>
<p>It's also important to understand that a complete fix will only be in place when using the <code>:exception</code> forgery protection strategy. The <code>solidus_frontend</code> engine can't do pretty much anything otherwise. Using weaker CSRF strategies should be an informed and limited decision made by the application team. After the upgrade:</p>
<ul>
<li><p>An app using <code>:null_session</code> should also be safe, but there will be side effects. That strategy runs with a null object session. As such, no order and no user is found on it. A new <code>cart</code> state order is created in the database, associated with no user. Next time the user visits the site, they won't find any difference in its cart state.</p>
</li>
<li><p>An app using <code>:reset_session</code> is not entirely safe. That strategy resets the session. That means that registered users will be logged out. Next time a user visits, they'll see the cart with the items added during the CSRF attack, although it won't be associated with their account in the case of registered users.</p>
</li>
</ul>
<h4 id="reversing-the-update">Reversing the update</h4>
<p>If you still want to deploy the upgraded version before changing your application code (if the latter is needed), you can add the following workaround to your <code>config/application.rb</code> (however, take into account that you'll keep being vulnerable):</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.skip_before_action :verify_authenticity_token, only: [:populate]
end
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If an upgrade is not an option, you can work around the issue by adding the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.protect_from_forgery with: ApplicationController.forgery_protection_strategy.name.demodulize.underscore.to_sym, only: [:populate]
end
</code></pre>
<p>However, go through the same safety check detailed on "Upgrade notes" above.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">CSRF on the Rails guides</a></li>
<li><a href="https://medium.com/rubyinside/a-deep-dive-into-csrf-protection-in-rails-19fa0a42c0ef">How CSRF tokens are generated and validated on Rails</a></li>
<li><a href="https://solidus.io/security/">Solidus security</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43846">https://nvd.nist.gov/vuln/detail/CVE-2021-43846</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81">https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6">https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6</a></li>
<li><a href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</uri>
        </author>
        <published>2022-01-06T18:33:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_frontend] CSRF forgery protection bypass in solidus_frontend]]></title>
        <id>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</id>
        <link href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m"/>
        <updated>2022-01-06T18:33:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>CSRF vulnerability that allows a malicious site to add an item to the user's cart without their knowledge.</p>
<p>All <code>solidus_frontend</code> versions are affected. If you're using your own storefront, please, follow along to make sure you're not affected.</p>
<p>To reproduce the issue:</p>
<ul>
<li><p>Pick the id for a variant with available stock. From the rails console:</p>
<pre><code class="language-ruby">Spree::Variant.in_stock.pluck(:id)
</code></pre>
<p>Say we pick variant id <code>2</code>.</p>
</li>
<li><p>Launch your application, for instance, on <code>http://localhost:3000</code>:</p>
<pre><code class="language-bash">bin/rails server
</code></pre>
</li>
<li><p>Open your browser dev tools.</p>
</li>
<li><p>Click on whatever link in your store.</p>
</li>
<li><p>Copy the value of the <code>Cookie</code> request header sent for the previous request from your browser dev tools.</p>
</li>
<li><p>Execute the following, using your previously selected variant id and the value of the <code>Cookie</code> header (notice how it doesn't contain any authentication token):</p>
<pre><code class="language-bash">curl -X POST -d "variant_id=2&amp;quantity=1" -H "Cookie: guest_token=eyJfcmFpbHMiOnsibWVzc2FnZSI6IklrWlRVMWRQWnpKMVZVdFNXRzlPVW1aaWJHTjZZa0VpIiwiZXhwIjpudWxsLCJwdXIiOiJjb29raWUuZ3Vlc3RfdG9rZW4ifX0%3D--5006ba5d346f621c760a29b6a797bf351d17d1b8; _sandbox_session=vhutu5%2FL9NmWrUpGc3DxrFA%2FFsQD1dHn1cNsD7nvE84zcjWf17Af4%2F%2F2Vab3md71b6KTb9NP6WktdXktpwH4eU01jEGIBXG5%2BMzW5nL0nb4W269qk1io4LYljvoOg8%2BZVll7oJCVkJLKKh0sSoS0Kg8j%2FCHHs%2BsShohP%2BGnA%2Bfr9Ub8H6HofpSmloSpsfHHygmX0ho03fEgzHJ4DD5wJctaNKwg7NhVikHh5kgIPPHl84OGCgv3p2oe9jR19HTxOKq7BtyvDd7XZsecWhkcfS8BPnvDDUWZG6qpAEFI5kWo81KkpSJ%2Bp6Q1HOo8%3D--n3G2vgaDG7VS%2B%2FhF--ZTjxBAkfGG3hpr4GRQ2S1Q%3D%3D; __profilin=p%3Dt" http://localhost:3000/orders/populate
</code></pre>
</li>
<li><p>Reload your browser and look at how your cart got updated.</p>
</li>
</ul>
<h3 id="patches">Patches</h3>
<p>Please, upgrade <code>solidus</code> to versions <code>3.1.5</code>, <code>3.0.5</code> or <code>2.11.14</code>.</p>
<p>After upgrading, make sure you read the "Upgrade notes"  section below.</p>
<h3 id="upgrade-notes">Upgrade notes</h3>
<p>The patch adds CSRF token verification to the "Add to cart" action. Adding forgery protection to a form that missed it can have some side effects.</p>
<h4 id="invalidauthenticitytoken-errors"><code>InvalidAuthenticityToken</code> errors</h4>
<p>If you're using the <code>:exception</code> strategy, it's likely that after upgrading, you'll see more <code>ActionController::InvalidAuthenticityToken</code> errors popping out in your logs. Due to browser-side cache, a form can be re-rendered and sent without any attached request cookie (for instance, when re-opening a mobile browser). That will cause an authentication error, as the sent token won't match with the one in the session (none in this case). That's a known problem in the Rails community (see <a href="https://github.com/rails/rails/issues/21948">https://github.com/rails/rails/issues/21948</a>), and, at this point, there's no perfect solution.</p>
<p>Any attempt to mitigate the issue should be seen at the application level. For an excellent survey of all the available options, take a look at <a href="https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md">https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md</a>. The latter is a third-party link. As the information is relevant here, we're going to copy it below, but it should be clear that all the credit goes to @kemenaran:</p>
<blockquote>
<h1 id="protecting-against-request-forgery-using-crsf-tokens">Protecting against request forgery using CRSF tokens</h1>
<h2 id="context">Context</h2>
<p>Rails has CSRF protection enabled by default, to protect against POST-based CSRF attacks.</p>
<p>To protect from this, Rails stores two copies of a random token (the so-named CSRF token) on each request:</p>
<ul>
<li>one copy embedded in each HTML page,</li>
<li>another copy in the user session.</li>
</ul>
<p>When performing a POST request, Rails checks that the two copies match – and otherwise denies the request. This protects against an attacker that would generate a form secretly pointing to our website: the attacker can't read the token in the session, and so can't post a form with a valid token.</p>
<p>The problem is that, much more often, this has false positives. There are several cases for that, including:</p>
<ol>
<li><p>The web browser (often mobile) loads a page containing a form, then is closed by the user. Later, when the browser is re-opened, it restores the page from the cache. But the session cookie has expired, and so is not restored – so the copy of the CSRF token stored in the session is missing. When the user submits the form, they get an "InvalidAuthenticityToken" exception.</p>
</li>
<li><p>The user attempts to fill a form, and gets an error message (usually in response to a POST request). They close the browser. When the browser is re-opened, it attempts to restore the page. On Chrome this is blocked by the browser, because the browser denies retrying a (probably non-idempotent) POST request. Safari however happily retries the POST request – but without sending any cookies (in an attempt to avoid having unexpected side-effects). So the copy of the CSRF token in the session is missing (because no cookie was sent), and the user get an "InvalidAuthenticityToken" exception.</p>
</li>
</ol>
<h2 id="options-considered">Options considered</h2>
<h3 id="extend-the-session-cookie-duration">Extend the session cookie duration</h3>
<p>We can configure the session cookie to be valid for a longer time (like 2 weeks).</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the browser restores the page, the session cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Users would be signed-in for a much longer time by default, which has unacceptable security implications.</li>
<li>It doesn't solve 2. (because Safari doesn't send any cookie when restoring a page from a POST request)</li>
</ul>
<h3 id="change-the-cache-parameters">Change the cache parameters</h3>
<p>We can send a HTTP cache header stating 'Cache-Control: no-store, no-cache'. This instructs the browser to never keep any copy of the page, and to always make a request to the server to restore it.</p>
<p>This solution was attempted during a year in production, and solved 1. – but also introduced another type of InvalidAuthenticityToken errors. In that scenario, the user attempts to fill a form, and gets an error message (usually in response to a POST request). They then navigate on another domain (like France Connect), then hit the "Back" button. Crossing back the domain boundary may cause the browser to either block the request or retry an invalid POST request.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because on relaunch the browser requests a fresh page again (instead of serving it from its cache), thus retrieving a fresh session and a fresh matching CSRF token.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2.</li>
<li>It causes another type of InvalidAuthenticityToken errors.</li>
</ul>
<h3 id="using-a-null-session-strategy">Using a null-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :null_session. This makes the current request use an empty session for the request duration.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>The user is asked to sign-in only after filling and submitting the form, losing their time and data</li>
<li>The user will not be redirected to their original page after signing-in</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
</ul>
<h3 id="using-a-reset-session-strategy">Using a reset-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :reset_session. This clears the user session permanently, logging them out until they log in again.</p>
<p>Pros: </p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>A forgery error in a browser tab will disconnect the user in all its open tabs</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
<li>It allows an attacker to disconnect an user on demand, which is not only inconvenient, but also has security implication (the attacker could then log the user on it's own attacker account, pretending to be the user account)</li>
</ul>
<h3 id="redirect-to-login-form">Redirect to login form</h3>
<p>When a forgery error occurs, we can instead redirect to the login form.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted (but the user data is lost).</li>
<li>It kind of solves 2., by redirecting to a "Please sign-in" page when a previously POSTed form is reloaded.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not all forms require authentication – so for public forms there is no point redirecting to the login form. </li>
<li>The user will not be redirected to their original page after signing-in (because setting the redirect path is a state-changing action, and it is dangerous to let an unauthorized request changing the state – an attacker could control the path where an user is automatically redirected to.)</li>
<li>The implementation is finicky, and may introduce security errors. For instance, a naive implementation that catches the exception and redirect_to the sign-in page will prevent Devise from running a cleanup code – which means the user will still be logged, and the CSRF protection is bypassed. However a well-tested implementation that lets Devise code run should avoid these pittfalls.</li>
</ul>
<h3 id="using-a-long-lived-cookie-for-csrf-tokens">Using a long-lived cookie for CSRF tokens</h3>
<p>Instead of storing the CSRF token in the session cookie (which is deleted when the browser is closed), we can instead store it in a longer-lived cookie. For this we need to patch Rails.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the user submits a stale form, even if the session cookie because stale, the long-lived CSRF cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2., because when Safari retries a POST request, it sends none of the cookies (not even long-lived ones).</li>
<li>Patching Rails may introduce security issues (now or in the future)</li>
</ul>
</blockquote>
<h4 id="broken-behavior-due-to-session-expiration--template-cache">Broken behavior due to session expiration + template cache</h4>
<p>Although pretty unlikely, you should make sure that your current setup for cache/session expiration is compatible. The upgrade can break the addition of products to the cart if both:</p>
<ul>
<li><p>The "Add to cart" form is being cached (usually along with the variant information).</p>
</li>
<li><p>A user session is reset at every or every few requests.</p>
</li>
</ul>
<p>The token validation depends on the issuing and consuming sessions being the same. If a product page is cached with the token in it, it can become stale on a subsequent rendering if the session changes.</p>
<p>To check that you're safe, after having upgraded locally, go through the following steps:</p>
<ul>
<li><p>Enable cache on dev mode:</p>
<pre><code class="language-bash">bin/rails dev:cache
</code></pre>
</li>
<li><p>Visit the page for a variant with stock.</p>
</li>
<li><p>Reload that page several times.</p>
</li>
<li><p>Click on the "Add to cart"  button.</p>
</li>
<li><p>Remember to rerun <code>bin/rails dev:cache</code> to turn off cache again.</p>
</li>
</ul>
<p>No error or session reset should happen.</p>
<p>Otherwise, you can try with:</p>
<ul>
<li>Revisiting how your session gets expired.</li>
<li>Changing the caching strategy to exclude the token.</li>
</ul>
<h4 id="using-weaker-csrf-protection-strategies">Using weaker CSRF protection strategies</h4>
<p>It's also important to understand that a complete fix will only be in place when using the <code>:exception</code> forgery protection strategy. The <code>solidus_frontend</code> engine can't do pretty much anything otherwise. Using weaker CSRF strategies should be an informed and limited decision made by the application team. After the upgrade:</p>
<ul>
<li><p>An app using <code>:null_session</code> should also be safe, but there will be side effects. That strategy runs with a null object session. As such, no order and no user is found on it. A new <code>cart</code> state order is created in the database, associated with no user. Next time the user visits the site, they won't find any difference in its cart state.</p>
</li>
<li><p>An app using <code>:reset_session</code> is not entirely safe. That strategy resets the session. That means that registered users will be logged out. Next time a user visits, they'll see the cart with the items added during the CSRF attack, although it won't be associated with their account in the case of registered users.</p>
</li>
</ul>
<h4 id="reversing-the-update">Reversing the update</h4>
<p>If you still want to deploy the upgraded version before changing your application code (if the latter is needed), you can add the following workaround to your <code>config/application.rb</code> (however, take into account that you'll keep being vulnerable):</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.skip_before_action :verify_authenticity_token, only: [:populate]
end
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If an upgrade is not an option, you can work around the issue by adding the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.protect_from_forgery with: ApplicationController.forgery_protection_strategy.name.demodulize.underscore.to_sym, only: [:populate]
end
</code></pre>
<p>However, go through the same safety check detailed on "Upgrade notes" above.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">CSRF on the Rails guides</a></li>
<li><a href="https://medium.com/rubyinside/a-deep-dive-into-csrf-protection-in-rails-19fa0a42c0ef">How CSRF tokens are generated and validated on Rails</a></li>
<li><a href="https://solidus.io/security/">Solidus security</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43846">https://nvd.nist.gov/vuln/detail/CVE-2021-43846</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81">https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6">https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6</a></li>
<li><a href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</uri>
        </author>
        <published>2022-01-06T18:33:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_frontend] CSRF forgery protection bypass in solidus_frontend]]></title>
        <id>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</id>
        <link href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m"/>
        <updated>2022-01-06T18:33:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>CSRF vulnerability that allows a malicious site to add an item to the user's cart without their knowledge.</p>
<p>All <code>solidus_frontend</code> versions are affected. If you're using your own storefront, please, follow along to make sure you're not affected.</p>
<p>To reproduce the issue:</p>
<ul>
<li><p>Pick the id for a variant with available stock. From the rails console:</p>
<pre><code class="language-ruby">Spree::Variant.in_stock.pluck(:id)
</code></pre>
<p>Say we pick variant id <code>2</code>.</p>
</li>
<li><p>Launch your application, for instance, on <code>http://localhost:3000</code>:</p>
<pre><code class="language-bash">bin/rails server
</code></pre>
</li>
<li><p>Open your browser dev tools.</p>
</li>
<li><p>Click on whatever link in your store.</p>
</li>
<li><p>Copy the value of the <code>Cookie</code> request header sent for the previous request from your browser dev tools.</p>
</li>
<li><p>Execute the following, using your previously selected variant id and the value of the <code>Cookie</code> header (notice how it doesn't contain any authentication token):</p>
<pre><code class="language-bash">curl -X POST -d "variant_id=2&amp;quantity=1" -H "Cookie: guest_token=eyJfcmFpbHMiOnsibWVzc2FnZSI6IklrWlRVMWRQWnpKMVZVdFNXRzlPVW1aaWJHTjZZa0VpIiwiZXhwIjpudWxsLCJwdXIiOiJjb29raWUuZ3Vlc3RfdG9rZW4ifX0%3D--5006ba5d346f621c760a29b6a797bf351d17d1b8; _sandbox_session=vhutu5%2FL9NmWrUpGc3DxrFA%2FFsQD1dHn1cNsD7nvE84zcjWf17Af4%2F%2F2Vab3md71b6KTb9NP6WktdXktpwH4eU01jEGIBXG5%2BMzW5nL0nb4W269qk1io4LYljvoOg8%2BZVll7oJCVkJLKKh0sSoS0Kg8j%2FCHHs%2BsShohP%2BGnA%2Bfr9Ub8H6HofpSmloSpsfHHygmX0ho03fEgzHJ4DD5wJctaNKwg7NhVikHh5kgIPPHl84OGCgv3p2oe9jR19HTxOKq7BtyvDd7XZsecWhkcfS8BPnvDDUWZG6qpAEFI5kWo81KkpSJ%2Bp6Q1HOo8%3D--n3G2vgaDG7VS%2B%2FhF--ZTjxBAkfGG3hpr4GRQ2S1Q%3D%3D; __profilin=p%3Dt" http://localhost:3000/orders/populate
</code></pre>
</li>
<li><p>Reload your browser and look at how your cart got updated.</p>
</li>
</ul>
<h3 id="patches">Patches</h3>
<p>Please, upgrade <code>solidus</code> to versions <code>3.1.5</code>, <code>3.0.5</code> or <code>2.11.14</code>.</p>
<p>After upgrading, make sure you read the "Upgrade notes"  section below.</p>
<h3 id="upgrade-notes">Upgrade notes</h3>
<p>The patch adds CSRF token verification to the "Add to cart" action. Adding forgery protection to a form that missed it can have some side effects.</p>
<h4 id="invalidauthenticitytoken-errors"><code>InvalidAuthenticityToken</code> errors</h4>
<p>If you're using the <code>:exception</code> strategy, it's likely that after upgrading, you'll see more <code>ActionController::InvalidAuthenticityToken</code> errors popping out in your logs. Due to browser-side cache, a form can be re-rendered and sent without any attached request cookie (for instance, when re-opening a mobile browser). That will cause an authentication error, as the sent token won't match with the one in the session (none in this case). That's a known problem in the Rails community (see <a href="https://github.com/rails/rails/issues/21948">https://github.com/rails/rails/issues/21948</a>), and, at this point, there's no perfect solution.</p>
<p>Any attempt to mitigate the issue should be seen at the application level. For an excellent survey of all the available options, take a look at <a href="https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md">https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md</a>. The latter is a third-party link. As the information is relevant here, we're going to copy it below, but it should be clear that all the credit goes to @kemenaran:</p>
<blockquote>
<h1 id="protecting-against-request-forgery-using-crsf-tokens">Protecting against request forgery using CRSF tokens</h1>
<h2 id="context">Context</h2>
<p>Rails has CSRF protection enabled by default, to protect against POST-based CSRF attacks.</p>
<p>To protect from this, Rails stores two copies of a random token (the so-named CSRF token) on each request:</p>
<ul>
<li>one copy embedded in each HTML page,</li>
<li>another copy in the user session.</li>
</ul>
<p>When performing a POST request, Rails checks that the two copies match – and otherwise denies the request. This protects against an attacker that would generate a form secretly pointing to our website: the attacker can't read the token in the session, and so can't post a form with a valid token.</p>
<p>The problem is that, much more often, this has false positives. There are several cases for that, including:</p>
<ol>
<li><p>The web browser (often mobile) loads a page containing a form, then is closed by the user. Later, when the browser is re-opened, it restores the page from the cache. But the session cookie has expired, and so is not restored – so the copy of the CSRF token stored in the session is missing. When the user submits the form, they get an "InvalidAuthenticityToken" exception.</p>
</li>
<li><p>The user attempts to fill a form, and gets an error message (usually in response to a POST request). They close the browser. When the browser is re-opened, it attempts to restore the page. On Chrome this is blocked by the browser, because the browser denies retrying a (probably non-idempotent) POST request. Safari however happily retries the POST request – but without sending any cookies (in an attempt to avoid having unexpected side-effects). So the copy of the CSRF token in the session is missing (because no cookie was sent), and the user get an "InvalidAuthenticityToken" exception.</p>
</li>
</ol>
<h2 id="options-considered">Options considered</h2>
<h3 id="extend-the-session-cookie-duration">Extend the session cookie duration</h3>
<p>We can configure the session cookie to be valid for a longer time (like 2 weeks).</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the browser restores the page, the session cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Users would be signed-in for a much longer time by default, which has unacceptable security implications.</li>
<li>It doesn't solve 2. (because Safari doesn't send any cookie when restoring a page from a POST request)</li>
</ul>
<h3 id="change-the-cache-parameters">Change the cache parameters</h3>
<p>We can send a HTTP cache header stating 'Cache-Control: no-store, no-cache'. This instructs the browser to never keep any copy of the page, and to always make a request to the server to restore it.</p>
<p>This solution was attempted during a year in production, and solved 1. – but also introduced another type of InvalidAuthenticityToken errors. In that scenario, the user attempts to fill a form, and gets an error message (usually in response to a POST request). They then navigate on another domain (like France Connect), then hit the "Back" button. Crossing back the domain boundary may cause the browser to either block the request or retry an invalid POST request.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because on relaunch the browser requests a fresh page again (instead of serving it from its cache), thus retrieving a fresh session and a fresh matching CSRF token.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2.</li>
<li>It causes another type of InvalidAuthenticityToken errors.</li>
</ul>
<h3 id="using-a-null-session-strategy">Using a null-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :null_session. This makes the current request use an empty session for the request duration.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>The user is asked to sign-in only after filling and submitting the form, losing their time and data</li>
<li>The user will not be redirected to their original page after signing-in</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
</ul>
<h3 id="using-a-reset-session-strategy">Using a reset-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :reset_session. This clears the user session permanently, logging them out until they log in again.</p>
<p>Pros: </p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>A forgery error in a browser tab will disconnect the user in all its open tabs</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
<li>It allows an attacker to disconnect an user on demand, which is not only inconvenient, but also has security implication (the attacker could then log the user on it's own attacker account, pretending to be the user account)</li>
</ul>
<h3 id="redirect-to-login-form">Redirect to login form</h3>
<p>When a forgery error occurs, we can instead redirect to the login form.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted (but the user data is lost).</li>
<li>It kind of solves 2., by redirecting to a "Please sign-in" page when a previously POSTed form is reloaded.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not all forms require authentication – so for public forms there is no point redirecting to the login form. </li>
<li>The user will not be redirected to their original page after signing-in (because setting the redirect path is a state-changing action, and it is dangerous to let an unauthorized request changing the state – an attacker could control the path where an user is automatically redirected to.)</li>
<li>The implementation is finicky, and may introduce security errors. For instance, a naive implementation that catches the exception and redirect_to the sign-in page will prevent Devise from running a cleanup code – which means the user will still be logged, and the CSRF protection is bypassed. However a well-tested implementation that lets Devise code run should avoid these pittfalls.</li>
</ul>
<h3 id="using-a-long-lived-cookie-for-csrf-tokens">Using a long-lived cookie for CSRF tokens</h3>
<p>Instead of storing the CSRF token in the session cookie (which is deleted when the browser is closed), we can instead store it in a longer-lived cookie. For this we need to patch Rails.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the user submits a stale form, even if the session cookie because stale, the long-lived CSRF cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2., because when Safari retries a POST request, it sends none of the cookies (not even long-lived ones).</li>
<li>Patching Rails may introduce security issues (now or in the future)</li>
</ul>
</blockquote>
<h4 id="broken-behavior-due-to-session-expiration--template-cache">Broken behavior due to session expiration + template cache</h4>
<p>Although pretty unlikely, you should make sure that your current setup for cache/session expiration is compatible. The upgrade can break the addition of products to the cart if both:</p>
<ul>
<li><p>The "Add to cart" form is being cached (usually along with the variant information).</p>
</li>
<li><p>A user session is reset at every or every few requests.</p>
</li>
</ul>
<p>The token validation depends on the issuing and consuming sessions being the same. If a product page is cached with the token in it, it can become stale on a subsequent rendering if the session changes.</p>
<p>To check that you're safe, after having upgraded locally, go through the following steps:</p>
<ul>
<li><p>Enable cache on dev mode:</p>
<pre><code class="language-bash">bin/rails dev:cache
</code></pre>
</li>
<li><p>Visit the page for a variant with stock.</p>
</li>
<li><p>Reload that page several times.</p>
</li>
<li><p>Click on the "Add to cart"  button.</p>
</li>
<li><p>Remember to rerun <code>bin/rails dev:cache</code> to turn off cache again.</p>
</li>
</ul>
<p>No error or session reset should happen.</p>
<p>Otherwise, you can try with:</p>
<ul>
<li>Revisiting how your session gets expired.</li>
<li>Changing the caching strategy to exclude the token.</li>
</ul>
<h4 id="using-weaker-csrf-protection-strategies">Using weaker CSRF protection strategies</h4>
<p>It's also important to understand that a complete fix will only be in place when using the <code>:exception</code> forgery protection strategy. The <code>solidus_frontend</code> engine can't do pretty much anything otherwise. Using weaker CSRF strategies should be an informed and limited decision made by the application team. After the upgrade:</p>
<ul>
<li><p>An app using <code>:null_session</code> should also be safe, but there will be side effects. That strategy runs with a null object session. As such, no order and no user is found on it. A new <code>cart</code> state order is created in the database, associated with no user. Next time the user visits the site, they won't find any difference in its cart state.</p>
</li>
<li><p>An app using <code>:reset_session</code> is not entirely safe. That strategy resets the session. That means that registered users will be logged out. Next time a user visits, they'll see the cart with the items added during the CSRF attack, although it won't be associated with their account in the case of registered users.</p>
</li>
</ul>
<h4 id="reversing-the-update">Reversing the update</h4>
<p>If you still want to deploy the upgraded version before changing your application code (if the latter is needed), you can add the following workaround to your <code>config/application.rb</code> (however, take into account that you'll keep being vulnerable):</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.skip_before_action :verify_authenticity_token, only: [:populate]
end
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If an upgrade is not an option, you can work around the issue by adding the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.protect_from_forgery with: ApplicationController.forgery_protection_strategy.name.demodulize.underscore.to_sym, only: [:populate]
end
</code></pre>
<p>However, go through the same safety check detailed on "Upgrade notes" above.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">CSRF on the Rails guides</a></li>
<li><a href="https://medium.com/rubyinside/a-deep-dive-into-csrf-protection-in-rails-19fa0a42c0ef">How CSRF tokens are generated and validated on Rails</a></li>
<li><a href="https://solidus.io/security/">Solidus security</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43846">https://nvd.nist.gov/vuln/detail/CVE-2021-43846</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81">https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6">https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6</a></li>
<li><a href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</uri>
        </author>
        <published>2022-01-06T18:33:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[message_bus] Path traversal when MessageBus::Diagnostics is enabled]]></title>
        <id>https://github.com/advisories/GHSA-xmgj-5fh3-xjmm</id>
        <link href="https://github.com/advisories/GHSA-xmgj-5fh3-xjmm"/>
        <updated>2022-01-03T15:46:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Users who deployed message bus with diagnostics features enabled (default off) were vulnerable to a path traversal bug, which could lead to disclosure of secret information on a machine if an unintended user were to gain access to the diagnostic route. The impact is also greater if there is no proxy for your web application as the number of steps up the directories is not bounded. For deployments which uses a proxy, the impact varies. For example, If a request goes through a proxy like Nginx with <code>merge_slashes</code> enabled, the number of steps up the directories that can be read is limited to 3 levels. </p>
<h3 id="patches">Patches</h3>
<p>Patched in 3.3.7.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Disable MessageBus::Diagnostics in production like environments. </p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/discourse/message_bus/security/advisories/GHSA-xmgj-5fh3-xjmm">https://github.com/discourse/message_bus/security/advisories/GHSA-xmgj-5fh3-xjmm</a></li>
<li><a href="https://github.com/discourse/message_bus/commit/9b6deee01ed474c7e9b5ff65a06bb0447b4db2ba">https://github.com/discourse/message_bus/commit/9b6deee01ed474c7e9b5ff65a06bb0447b4db2ba</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43840">https://nvd.nist.gov/vuln/detail/CVE-2021-43840</a></li>
<li><a href="https://github.com/advisories/GHSA-xmgj-5fh3-xjmm">https://github.com/advisories/GHSA-xmgj-5fh3-xjmm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xmgj-5fh3-xjmm</uri>
        </author>
        <published>2021-12-17T19:59:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cgi] Buffer overrun vulnerability in CGI]]></title>
        <id>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</id>
        <link href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv"/>
        <updated>2021-12-14T21:36:20.000Z</updated>
        <content type="html"><![CDATA[<p>A security vulnerability that causes buffer overflow when you pass a very large string (&gt; 700 MB) to CGI.escape_html on a platform where long type takes 4 bytes, typically, Windows.</p>
<p>Please update the cgi gem to version 0.3.1, 0.2,1, and 0.1,1 or later. You can use gem update cgi to update it. If you are using bundler, please add gem "cgi", "&gt;= 0.3.1" to your Gemfile. Alternatively, please update Ruby to 2.7.5 or 3.0.3.</p>
<p>This issue has been introduced since Ruby 2.7, so the cgi version bundled with Ruby 2.6 is not vulnerable.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-41816">https://nvd.nist.gov/vuln/detail/CVE-2021-41816</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c">https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c</a></li>
<li><a href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv">https://github.com/advisories/GHSA-5cqm-crxm-6qpv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</uri>
        </author>
        <published>2021-12-14T21:36:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cgi] Buffer overrun vulnerability in CGI]]></title>
        <id>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</id>
        <link href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv"/>
        <updated>2021-12-14T21:36:20.000Z</updated>
        <content type="html"><![CDATA[<p>A security vulnerability that causes buffer overflow when you pass a very large string (&gt; 700 MB) to CGI.escape_html on a platform where long type takes 4 bytes, typically, Windows.</p>
<p>Please update the cgi gem to version 0.3.1, 0.2,1, and 0.1,1 or later. You can use gem update cgi to update it. If you are using bundler, please add gem "cgi", "&gt;= 0.3.1" to your Gemfile. Alternatively, please update Ruby to 2.7.5 or 3.0.3.</p>
<p>This issue has been introduced since Ruby 2.7, so the cgi version bundled with Ruby 2.6 is not vulnerable.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-41816">https://nvd.nist.gov/vuln/detail/CVE-2021-41816</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c">https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c</a></li>
<li><a href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv">https://github.com/advisories/GHSA-5cqm-crxm-6qpv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</uri>
        </author>
        <published>2021-12-14T21:36:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cgi] Buffer overrun vulnerability in CGI]]></title>
        <id>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</id>
        <link href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv"/>
        <updated>2021-12-14T21:36:20.000Z</updated>
        <content type="html"><![CDATA[<p>A security vulnerability that causes buffer overflow when you pass a very large string (&gt; 700 MB) to CGI.escape_html on a platform where long type takes 4 bytes, typically, Windows.</p>
<p>Please update the cgi gem to version 0.3.1, 0.2,1, and 0.1,1 or later. You can use gem update cgi to update it. If you are using bundler, please add gem "cgi", "&gt;= 0.3.1" to your Gemfile. Alternatively, please update Ruby to 2.7.5 or 3.0.3.</p>
<p>This issue has been introduced since Ruby 2.7, so the cgi version bundled with Ruby 2.6 is not vulnerable.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-41816">https://nvd.nist.gov/vuln/detail/CVE-2021-41816</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c">https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c</a></li>
<li><a href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv">https://github.com/advisories/GHSA-5cqm-crxm-6qpv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</uri>
        </author>
        <published>2021-12-14T21:36:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Open Redirect in actionpack]]></title>
        <id>https://github.com/advisories/GHSA-qphc-hf5q-v8fc</id>
        <link href="https://github.com/advisories/GHSA-qphc-hf5q-v8fc"/>
        <updated>2022-01-18T22:37:46.000Z</updated>
        <content type="html"><![CDATA[<p>Specially crafted "X-Forwarded-Host" headers in combination with certain
"allowed host" formats can cause the Host Authorization middleware in Action
Pack to redirect users to a malicious website.</p>
<p>Impacted applications will have allowed hosts with a leading dot. For example,
configuration files that look like this:</p>
<pre><code>config.hosts &lt;&lt;  '.EXAMPLE.com'
</code></pre>
<p>When an allowed host contains a leading dot, a specially crafted Host header
can be used to redirect to a malicious website.</p>
<p>This vulnerability is similar to CVE-2021-22881 and CVE-2021-22942.</p>
<h2 id="releases">Releases</h2>
<p>The fixed releases are available at the normal locations.</p>
<h2 id="patches">Patches</h2>
<p>To aid users who aren't able to upgrade immediately we have provided patches for
the two supported release series. They are in git-am format and consist of a
single changeset.</p>
<ul>
<li>6-0-host-authorzation-open-redirect.patch - Patch for 6.0 series</li>
<li>6-1-host-authorzation-open-redirect.patch - Patch for 6.1 series</li>
<li>7-0-host-authorzation-open-redirect.patch - Patch for 7.0 series</li>
</ul>
<p>Please note that only the 6.1.Z, 6.0.Z, and 5.2.Z series are supported at
present. Users of earlier unsupported releases are advised to upgrade as soon
as possible as we cannot guarantee the continued availability of security
fixes for unsupported releases.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44528">https://nvd.nist.gov/vuln/detail/CVE-2021-44528</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/vG9gz3nk1pM/m/7-NU4MNrDAAJ?utm_medium=email&amp;utm_source=footer">https://groups.google.com/g/ruby-security-ann/c/vG9gz3nk1pM/m/7-NU4MNrDAAJ?utm_medium=email&amp;utm_source=footer</a></li>
<li><a href="https://github.com/rails/rails/commit/aecba3c301b80e9d5a63c30ea1b287bceaf2c107">https://github.com/rails/rails/commit/aecba3c301b80e9d5a63c30ea1b287bceaf2c107</a></li>
<li><a href="https://github.com/rails/rails/blob/v6.1.4.2/actionpack/CHANGELOG.md#rails-6142-december-14-2021">https://github.com/rails/rails/blob/v6.1.4.2/actionpack/CHANGELOG.md#rails-6142-december-14-2021</a></li>
<li><a href="https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815">https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815</a></li>
<li><a href="https://github.com/advisories/GHSA-qphc-hf5q-v8fc">https://github.com/advisories/GHSA-qphc-hf5q-v8fc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qphc-hf5q-v8fc</uri>
        </author>
        <published>2021-12-14T21:19:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Open Redirect in actionpack]]></title>
        <id>https://github.com/advisories/GHSA-qphc-hf5q-v8fc</id>
        <link href="https://github.com/advisories/GHSA-qphc-hf5q-v8fc"/>
        <updated>2022-01-18T22:37:46.000Z</updated>
        <content type="html"><![CDATA[<p>Specially crafted "X-Forwarded-Host" headers in combination with certain
"allowed host" formats can cause the Host Authorization middleware in Action
Pack to redirect users to a malicious website.</p>
<p>Impacted applications will have allowed hosts with a leading dot. For example,
configuration files that look like this:</p>
<pre><code>config.hosts &lt;&lt;  '.EXAMPLE.com'
</code></pre>
<p>When an allowed host contains a leading dot, a specially crafted Host header
can be used to redirect to a malicious website.</p>
<p>This vulnerability is similar to CVE-2021-22881 and CVE-2021-22942.</p>
<h2 id="releases">Releases</h2>
<p>The fixed releases are available at the normal locations.</p>
<h2 id="patches">Patches</h2>
<p>To aid users who aren't able to upgrade immediately we have provided patches for
the two supported release series. They are in git-am format and consist of a
single changeset.</p>
<ul>
<li>6-0-host-authorzation-open-redirect.patch - Patch for 6.0 series</li>
<li>6-1-host-authorzation-open-redirect.patch - Patch for 6.1 series</li>
<li>7-0-host-authorzation-open-redirect.patch - Patch for 7.0 series</li>
</ul>
<p>Please note that only the 6.1.Z, 6.0.Z, and 5.2.Z series are supported at
present. Users of earlier unsupported releases are advised to upgrade as soon
as possible as we cannot guarantee the continued availability of security
fixes for unsupported releases.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44528">https://nvd.nist.gov/vuln/detail/CVE-2021-44528</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/vG9gz3nk1pM/m/7-NU4MNrDAAJ?utm_medium=email&amp;utm_source=footer">https://groups.google.com/g/ruby-security-ann/c/vG9gz3nk1pM/m/7-NU4MNrDAAJ?utm_medium=email&amp;utm_source=footer</a></li>
<li><a href="https://github.com/rails/rails/commit/aecba3c301b80e9d5a63c30ea1b287bceaf2c107">https://github.com/rails/rails/commit/aecba3c301b80e9d5a63c30ea1b287bceaf2c107</a></li>
<li><a href="https://github.com/rails/rails/blob/v6.1.4.2/actionpack/CHANGELOG.md#rails-6142-december-14-2021">https://github.com/rails/rails/blob/v6.1.4.2/actionpack/CHANGELOG.md#rails-6142-december-14-2021</a></li>
<li><a href="https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815">https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815</a></li>
<li><a href="https://github.com/advisories/GHSA-qphc-hf5q-v8fc">https://github.com/advisories/GHSA-qphc-hf5q-v8fc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qphc-hf5q-v8fc</uri>
        </author>
        <published>2021-12-14T21:19:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[devise_masquerade] Improper Privilege Management in devise_masquerade]]></title>
        <id>https://github.com/advisories/GHSA-25f5-gc4h-hc22</id>
        <link href="https://github.com/advisories/GHSA-25f5-gc4h-hc22"/>
        <updated>2021-12-14T15:33:15.000Z</updated>
        <content type="html"><![CDATA[<p>The devise_masquerade gem before 1.3 allows certain attacks when a password's salt is unknown. An application that uses this gem to let administrators masquerade/impersonate users loses one layer of security protection compared to a situation where Devise (without this extension) is used. If the server-side secret_key_base value became publicly known (for instance if it is committed to a public repository by mistake), there are still other protections in place that prevent an attacker from impersonating any user on the site. When masquerading is not used in a plain Devise application, one must know the password salt of the target user if one wants to encrypt and sign a valid session cookie. When devise_masquerade is used, however, an attacker can decide which user the "back" action will go back to without knowing that user's password salt and simply knowing the user ID, by manipulating the session cookie and pretending that a user is already masqueraded by an administrator.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-28680">https://nvd.nist.gov/vuln/detail/CVE-2021-28680</a></li>
<li><a href="https://github.com/oivoodoo/devise_masquerade/issues/83">https://github.com/oivoodoo/devise_masquerade/issues/83</a></li>
<li><a href="https://labanskoller.se/blog/2021/03/23/the-devise-extension-that-peeled-off-one-layer-of-the-security-onion-cve-2021-28680/">https://labanskoller.se/blog/2021/03/23/the-devise-extension-that-peeled-off-one-layer-of-the-security-onion-cve-2021-28680/</a></li>
<li><a href="https://github.com/oivoodoo/devise_masquerade/pull/76">https://github.com/oivoodoo/devise_masquerade/pull/76</a></li>
<li><a href="https://github.com/oivoodoo/devise_masquerade/releases/tag/v1.3.1">https://github.com/oivoodoo/devise_masquerade/releases/tag/v1.3.1</a></li>
<li><a href="https://github.com/advisories/GHSA-25f5-gc4h-hc22">https://github.com/advisories/GHSA-25f5-gc4h-hc22</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-25f5-gc4h-hc22</uri>
        </author>
        <published>2021-12-08T19:55:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[bundler] Local Code Execution through Argument Injection via dash leading git url parameter in Gemfile.]]></title>
        <id>https://github.com/advisories/GHSA-fj7f-vq84-fh43</id>
        <link href="https://github.com/advisories/GHSA-fj7f-vq84-fh43"/>
        <updated>2021-12-14T15:31:09.000Z</updated>
        <content type="html"><![CDATA[<p>In <code>bundler</code> versions before 2.2.33, when working with untrusted and apparently harmless <code>Gemfile</code>'s, it is not expected that they lead to execution of external code, unless that's explicit in the ruby code inside the <code>Gemfile</code> itself. However, if the <code>Gemfile</code> includes <code>gem</code> entries that use the <code>git</code> option with invalid, but seemingly harmless, values with a leading dash, this can be false.</p>
<p>To handle dependencies that come from a Git repository instead of a registry, Bundler uses various commands, such as <code>git clone</code>. These commands are being constructed using user input (e.g. the repository URL). When building the
commands, Bundler versions before 2.2.33 correctly avoid Command Injection vulnerabilities by passing an array of arguments instead of a command string. However, there is the possibility that a user input starts with a dash (<code>-</code>) and is therefore treated as an optional argument instead of a positional one. This can lead to Code Execution because some of the commands have options that can be leveraged to run arbitrary executables.</p>
<p>Since this value comes from the <code>Gemfile</code> file, it can contain any character, including a leading dash.</p>
<h3 id="exploitation">Exploitation</h3>
<p>To exploit this vulnerability, an attacker has to craft a directory containing a <code>Gemfile</code> file that declares a dependency that is located in a Git repository. This dependency has to have a Git URL in the form of <code>-u./payload</code>. This URL
will be used to construct a Git clone command but will be interpreted as the <a href="https://git-scm.com/docs/git-clone#Documentation/git-clone.txt--ultupload-packgt">upload-pack</a> argument. Then this directory needs to be shared with the victim, who then needs to run a command that evaluates the Gemfile, such as <code>bundle lock</code>, inside.</p>
<h3 id="impact">Impact</h3>
<p>This vulnerability can lead to Arbitrary Code Execution, which could potentially lead to the takeover of the system. However, as explained above, the exploitability is very low, because it requires a lot of user interaction. It still could put developers at risk when dealing with untrusted files in a way they think is safe, because the exploit still works when the victim tries to make sure nothing can happen, e.g. by manually reviewing the <code>Gemfile</code> (although they would need the weird URL with a leading dash to not raise any flags).</p>
<p>This kind of attack vector <a href="https://www.cnbc.com/2021/01/26/north-korean-hackers-targeting-security-researchers-on-twitter.html">has been used in the past</a> to target security researchers by sending them projects to collaborate on.</p>
<h3 id="patches">Patches</h3>
<p>Bundler 2.2.33 has patched this problem by inserting <code>--</code> as an argument before any positional arguments to those Git commands that were affected by this issue.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Regardless of whether users can upgrade or not, they should review any untrustred <code>Gemfile</code>'s before running any <code>bundler</code> commands that may read them, since they can contain arbitrary ruby code.</p>
<h3 id="references">References</h3>
<p><a href="https://cwe.mitre.org/data/definitions/88.html">https://cwe.mitre.org/data/definitions/88.html</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/rubygems/rubygems/security/advisories/GHSA-fj7f-vq84-fh43">https://github.com/rubygems/rubygems/security/advisories/GHSA-fj7f-vq84-fh43</a></li>
<li><a href="https://github.com/rubygems/rubygems/pull/5142">https://github.com/rubygems/rubygems/pull/5142</a></li>
<li><a href="https://github.com/rubygems/rubygems/commit/0fad1ccfe9dd7a3c5b82c1496df3c2b4842870d3">https://github.com/rubygems/rubygems/commit/0fad1ccfe9dd7a3c5b82c1496df3c2b4842870d3</a></li>
<li><a href="https://github.com/rubygems/rubygems/commit/a4f2f8ac17e6ce81c689527a8b6f14381060d95f">https://github.com/rubygems/rubygems/commit/a4f2f8ac17e6ce81c689527a8b6f14381060d95f</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43809">https://nvd.nist.gov/vuln/detail/CVE-2021-43809</a></li>
<li><a href="https://github.com/advisories/GHSA-fj7f-vq84-fh43">https://github.com/advisories/GHSA-fj7f-vq84-fh43</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fj7f-vq84-fh43</uri>
        </author>
        <published>2021-12-08T19:51:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_core] ReDos vulnerability on guest checkout email validation]]></title>
        <id>https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</id>
        <link href="https://github.com/advisories/GHSA-qxmr-qxh6-2cc9"/>
        <updated>2021-12-08T19:29:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Denial of service vulnerability that could be exploited during a guest checkout. The regular expression used to validate a guest order's email was subject to exponential backtracking through a fragment like <code>a.a.</code>.</p>
<p>Before the patch, it can be reproduced in the console like this:</p>
<pre><code class="language-ruby">irb(main)&gt; Spree::EmailValidator::EMAIL_REGEXP.match "a@a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.@"
processing time: 54.293660s
=&gt; nil
</code></pre>
<p>To reproduce in the browser, fill in the "Customer Email" field with that fake email address during a guest checkout. Before that, you should open the browser dev tools and change the <code>type</code> attribute for that field from <code>email</code> to <code>text</code>. After entering a fake address and pressing the "Save &amp; Continue" button, the browser will take a long term to perform the request before showing an error message for the invalid address. Eventually, making the email string even longer could lead to the exhaustion of server resources.</p>
<h3 id="patches">Patches</h3>
<p>Versions 3.1.4, 3.0.4, and 2.11.13 have been patched to use a different regular expression.</p>
<p>There's an improbable chance that some orders in your system end up having associated an email address that is no longer valid. We've added a task to check precisely that:</p>
<pre><code class="language-bash">bin/rails solidus:check_orders_with_invalid_email
</code></pre>
<p>The above will print information for every affected order if any.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If a prompt upgrade is not an option, please, add the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::EmailValidator.send(:remove_const, :EMAIL_REGEXP)
  Spree::EmailValidator::EMAIL_REGEXP = URI::MailTo::EMAIL_REGEXP
end
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/ReDoS">https://en.wikipedia.org/wiki/ReDoS</a></li>
<li><a href="https://snyk.io/blog/redos-and-catastrophic-backtracking/">https://snyk.io/blog/redos-and-catastrophic-backtracking/</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-qxmr-qxh6-2cc9">https://github.com/solidusio/solidus/security/advisories/GHSA-qxmr-qxh6-2cc9</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/6be174c955fad84017ca67589c676526bc5ade71">https://github.com/solidusio/solidus/commit/6be174c955fad84017ca67589c676526bc5ade71</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43805">https://nvd.nist.gov/vuln/detail/CVE-2021-43805</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/9867153e01e3c3b898cdbcedd7b43375ea922401">https://github.com/solidusio/solidus/commit/9867153e01e3c3b898cdbcedd7b43375ea922401</a></li>
<li><a href="https://github.com/advisories/GHSA-qxmr-qxh6-2cc9">https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</uri>
        </author>
        <published>2021-12-07T22:01:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_core] ReDos vulnerability on guest checkout email validation]]></title>
        <id>https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</id>
        <link href="https://github.com/advisories/GHSA-qxmr-qxh6-2cc9"/>
        <updated>2021-12-08T19:29:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Denial of service vulnerability that could be exploited during a guest checkout. The regular expression used to validate a guest order's email was subject to exponential backtracking through a fragment like <code>a.a.</code>.</p>
<p>Before the patch, it can be reproduced in the console like this:</p>
<pre><code class="language-ruby">irb(main)&gt; Spree::EmailValidator::EMAIL_REGEXP.match "a@a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.@"
processing time: 54.293660s
=&gt; nil
</code></pre>
<p>To reproduce in the browser, fill in the "Customer Email" field with that fake email address during a guest checkout. Before that, you should open the browser dev tools and change the <code>type</code> attribute for that field from <code>email</code> to <code>text</code>. After entering a fake address and pressing the "Save &amp; Continue" button, the browser will take a long term to perform the request before showing an error message for the invalid address. Eventually, making the email string even longer could lead to the exhaustion of server resources.</p>
<h3 id="patches">Patches</h3>
<p>Versions 3.1.4, 3.0.4, and 2.11.13 have been patched to use a different regular expression.</p>
<p>There's an improbable chance that some orders in your system end up having associated an email address that is no longer valid. We've added a task to check precisely that:</p>
<pre><code class="language-bash">bin/rails solidus:check_orders_with_invalid_email
</code></pre>
<p>The above will print information for every affected order if any.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If a prompt upgrade is not an option, please, add the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::EmailValidator.send(:remove_const, :EMAIL_REGEXP)
  Spree::EmailValidator::EMAIL_REGEXP = URI::MailTo::EMAIL_REGEXP
end
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/ReDoS">https://en.wikipedia.org/wiki/ReDoS</a></li>
<li><a href="https://snyk.io/blog/redos-and-catastrophic-backtracking/">https://snyk.io/blog/redos-and-catastrophic-backtracking/</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-qxmr-qxh6-2cc9">https://github.com/solidusio/solidus/security/advisories/GHSA-qxmr-qxh6-2cc9</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/6be174c955fad84017ca67589c676526bc5ade71">https://github.com/solidusio/solidus/commit/6be174c955fad84017ca67589c676526bc5ade71</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43805">https://nvd.nist.gov/vuln/detail/CVE-2021-43805</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/9867153e01e3c3b898cdbcedd7b43375ea922401">https://github.com/solidusio/solidus/commit/9867153e01e3c3b898cdbcedd7b43375ea922401</a></li>
<li><a href="https://github.com/advisories/GHSA-qxmr-qxh6-2cc9">https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</uri>
        </author>
        <published>2021-12-07T22:01:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_core] ReDos vulnerability on guest checkout email validation]]></title>
        <id>https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</id>
        <link href="https://github.com/advisories/GHSA-qxmr-qxh6-2cc9"/>
        <updated>2021-12-08T19:29:35.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Denial of service vulnerability that could be exploited during a guest checkout. The regular expression used to validate a guest order's email was subject to exponential backtracking through a fragment like <code>a.a.</code>.</p>
<p>Before the patch, it can be reproduced in the console like this:</p>
<pre><code class="language-ruby">irb(main)&gt; Spree::EmailValidator::EMAIL_REGEXP.match "a@a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.@"
processing time: 54.293660s
=&gt; nil
</code></pre>
<p>To reproduce in the browser, fill in the "Customer Email" field with that fake email address during a guest checkout. Before that, you should open the browser dev tools and change the <code>type</code> attribute for that field from <code>email</code> to <code>text</code>. After entering a fake address and pressing the "Save &amp; Continue" button, the browser will take a long term to perform the request before showing an error message for the invalid address. Eventually, making the email string even longer could lead to the exhaustion of server resources.</p>
<h3 id="patches">Patches</h3>
<p>Versions 3.1.4, 3.0.4, and 2.11.13 have been patched to use a different regular expression.</p>
<p>There's an improbable chance that some orders in your system end up having associated an email address that is no longer valid. We've added a task to check precisely that:</p>
<pre><code class="language-bash">bin/rails solidus:check_orders_with_invalid_email
</code></pre>
<p>The above will print information for every affected order if any.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If a prompt upgrade is not an option, please, add the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::EmailValidator.send(:remove_const, :EMAIL_REGEXP)
  Spree::EmailValidator::EMAIL_REGEXP = URI::MailTo::EMAIL_REGEXP
end
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/ReDoS">https://en.wikipedia.org/wiki/ReDoS</a></li>
<li><a href="https://snyk.io/blog/redos-and-catastrophic-backtracking/">https://snyk.io/blog/redos-and-catastrophic-backtracking/</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-qxmr-qxh6-2cc9">https://github.com/solidusio/solidus/security/advisories/GHSA-qxmr-qxh6-2cc9</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/6be174c955fad84017ca67589c676526bc5ade71">https://github.com/solidusio/solidus/commit/6be174c955fad84017ca67589c676526bc5ade71</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43805">https://nvd.nist.gov/vuln/detail/CVE-2021-43805</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/9867153e01e3c3b898cdbcedd7b43375ea922401">https://github.com/solidusio/solidus/commit/9867153e01e3c3b898cdbcedd7b43375ea922401</a></li>
<li><a href="https://github.com/advisories/GHSA-qxmr-qxh6-2cc9">https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qxmr-qxh6-2cc9</uri>
        </author>
        <published>2021-12-07T22:01:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[activerecord] Moderate severity vulnerability that affects activerecord]]></title>
        <id>https://github.com/advisories/GHSA-7phj-gmgx-2r66</id>
        <link href="https://github.com/advisories/GHSA-7phj-gmgx-2r66"/>
        <updated>2021-12-03T14:24:44.000Z</updated>
        <content type="html"><![CDATA[<p>Withdrawn, accidental duplicate publish.</p>
<p>activerecord/lib/active_record/nested_attributes.rb in Active Record in Ruby on Rails 3.1.x and 3.2.x before 3.2.22.1, 4.0.x and 4.1.x before 4.1.14.1, 4.2.x before 4.2.5.1, and 5.x before 5.0.0.beta1.1 does not properly implement a certain destroy option, which allows remote attackers to bypass intended change restrictions by leveraging use of the nested attributes feature.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2015-7577">https://nvd.nist.gov/vuln/detail/CVE-2015-7577</a></li>
<li><a href="https://github.com/advisories/GHSA-7phj-gmgx-2r66">https://github.com/advisories/GHSA-7phj-gmgx-2r66</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7phj-gmgx-2r66</uri>
        </author>
        <published>2018-09-17T21:58:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[activerecord] Moderate severity vulnerability that affects activerecord]]></title>
        <id>https://github.com/advisories/GHSA-7phj-gmgx-2r66</id>
        <link href="https://github.com/advisories/GHSA-7phj-gmgx-2r66"/>
        <updated>2021-12-03T14:24:44.000Z</updated>
        <content type="html"><![CDATA[<p>Withdrawn, accidental duplicate publish.</p>
<p>activerecord/lib/active_record/nested_attributes.rb in Active Record in Ruby on Rails 3.1.x and 3.2.x before 3.2.22.1, 4.0.x and 4.1.x before 4.1.14.1, 4.2.x before 4.2.5.1, and 5.x before 5.0.0.beta1.1 does not properly implement a certain destroy option, which allows remote attackers to bypass intended change restrictions by leveraging use of the nested attributes feature.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2015-7577">https://nvd.nist.gov/vuln/detail/CVE-2015-7577</a></li>
<li><a href="https://github.com/advisories/GHSA-7phj-gmgx-2r66">https://github.com/advisories/GHSA-7phj-gmgx-2r66</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7phj-gmgx-2r66</uri>
        </author>
        <published>2018-09-17T21:58:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[activerecord] Moderate severity vulnerability that affects activerecord]]></title>
        <id>https://github.com/advisories/GHSA-7phj-gmgx-2r66</id>
        <link href="https://github.com/advisories/GHSA-7phj-gmgx-2r66"/>
        <updated>2021-12-03T14:24:44.000Z</updated>
        <content type="html"><![CDATA[<p>Withdrawn, accidental duplicate publish.</p>
<p>activerecord/lib/active_record/nested_attributes.rb in Active Record in Ruby on Rails 3.1.x and 3.2.x before 3.2.22.1, 4.0.x and 4.1.x before 4.1.14.1, 4.2.x before 4.2.5.1, and 5.x before 5.0.0.beta1.1 does not properly implement a certain destroy option, which allows remote attackers to bypass intended change restrictions by leveraging use of the nested attributes feature.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2015-7577">https://nvd.nist.gov/vuln/detail/CVE-2015-7577</a></li>
<li><a href="https://github.com/advisories/GHSA-7phj-gmgx-2r66">https://github.com/advisories/GHSA-7phj-gmgx-2r66</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7phj-gmgx-2r66</uri>
        </author>
        <published>2018-09-17T21:58:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Moderate severity vulnerability that affects actionpack]]></title>
        <id>https://github.com/advisories/GHSA-vwfg-qj3r-6v3r</id>
        <link href="https://github.com/advisories/GHSA-vwfg-qj3r-6v3r"/>
        <updated>2021-12-03T14:24:04.000Z</updated>
        <content type="html"><![CDATA[<p>Withdrawn, accidental duplicate publish.</p>
<p>The http_basic_authenticate_with method in actionpack/lib/action_controller/metal/http_authentication.rb in the Basic Authentication implementation in Action Controller in Ruby on Rails before 3.2.22.1, 4.0.x and 4.1.x before 4.1.14.1, 4.2.x before 4.2.5.1, and 5.x before 5.0.0.beta1.1 does not use a constant-time algorithm for verifying credentials, which makes it easier for remote attackers to bypass authentication by measuring timing differences.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2015-7576">https://nvd.nist.gov/vuln/detail/CVE-2015-7576</a></li>
<li><a href="https://github.com/advisories/GHSA-vwfg-qj3r-6v3r">https://github.com/advisories/GHSA-vwfg-qj3r-6v3r</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vwfg-qj3r-6v3r</uri>
        </author>
        <published>2018-09-17T21:57:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Moderate severity vulnerability that affects actionpack]]></title>
        <id>https://github.com/advisories/GHSA-vwfg-qj3r-6v3r</id>
        <link href="https://github.com/advisories/GHSA-vwfg-qj3r-6v3r"/>
        <updated>2021-12-03T14:24:04.000Z</updated>
        <content type="html"><![CDATA[<p>Withdrawn, accidental duplicate publish.</p>
<p>The http_basic_authenticate_with method in actionpack/lib/action_controller/metal/http_authentication.rb in the Basic Authentication implementation in Action Controller in Ruby on Rails before 3.2.22.1, 4.0.x and 4.1.x before 4.1.14.1, 4.2.x before 4.2.5.1, and 5.x before 5.0.0.beta1.1 does not use a constant-time algorithm for verifying credentials, which makes it easier for remote attackers to bypass authentication by measuring timing differences.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2015-7576">https://nvd.nist.gov/vuln/detail/CVE-2015-7576</a></li>
<li><a href="https://github.com/advisories/GHSA-vwfg-qj3r-6v3r">https://github.com/advisories/GHSA-vwfg-qj3r-6v3r</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vwfg-qj3r-6v3r</uri>
        </author>
        <published>2018-09-17T21:57:47.000Z</published>
    </entry>
</feed>