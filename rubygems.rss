<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rubygems.rss</id>
    <title>Security Advisory for Ruby gems hosted at RubyGems.org</title>
    <updated>2022-02-23T00:18:40.217Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arubygems"/>
    <subtitle>Security Advisory for Ruby gems hosted at RubyGems.org on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <entry>
        <title type="html"><![CDATA[[puma] Information Exposure with Puma when used with Rails]]></title>
        <id>https://github.com/advisories/GHSA-rmj8-8hhh-gv5h</id>
        <link href="https://github.com/advisories/GHSA-rmj8-8hhh-gv5h"/>
        <updated>2022-02-14T21:59:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Prior to <code>puma</code> version <code>5.6.2</code>, <code>puma</code> may not always call <code>close</code> on the response body. Rails, prior to version <code>7.0.2.2</code>, depended on the response body being closed in order for its <code>CurrentAttributes</code> implementation to work correctly.</p>
<p>From Rails:</p>
<blockquote>
<p>Under certain circumstances response bodies will not be closed, for example a bug in a webserver[1] or a bug in a Rack middleware. In the event a response is not notified of a close, ActionDispatch::Executor will not know to reset thread local state for the next request. This can lead to data being leaked to subsequent requests, especially when interacting with ActiveSupport::CurrentAttributes.</p>
</blockquote>
<p>The combination of these two behaviors (Puma not closing the body + Rails' Executor implementation) causes information leakage.</p>
<h3 id="patches">Patches</h3>
<p>This problem is fixed in Puma versions 5.6.2 and 4.3.11.</p>
<p>This problem is fixed in Rails versions 7.02.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2.</p>
<p>See: 
<a href="https://github.com/advisories/GHSA-wh98-p28r-vrc9">https://github.com/advisories/GHSA-wh98-p28r-vrc9</a> 
for details about the rails vulnerability</p>
<p>Upgrading to a patched Rails <em>or</em> Puma version fixes the vulnerability.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Upgrade to Rails versions 7.02.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2.</p>
<p>The <a href="https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&amp;utm_source=footer&amp;pli=1">Rails CVE</a> includes a middleware that can be used instead.</p>
<h3 id="references">References</h3>
<ul>
<li>Rails CVE: <a href="https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&amp;utm_source=footer&amp;pli=1">CVE-2022-23633</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an issue in <a href="https://github.com/puma/puma">puma</a></li>
<li>See our <a href="https://github.com/puma/puma/security/policy">security policy</a><h3 id="references-1">References</h3>
</li>
</ul>
<ul>
<li><a href="https://github.com/puma/puma/security/advisories/GHSA-rmj8-8hhh-gv5h">https://github.com/puma/puma/security/advisories/GHSA-rmj8-8hhh-gv5h</a></li>
<li><a href="https://github.com/puma/puma/commit/b70f451fe8abc0cff192c065d549778452e155bb">https://github.com/puma/puma/commit/b70f451fe8abc0cff192c065d549778452e155bb</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23634">https://nvd.nist.gov/vuln/detail/CVE-2022-23634</a></li>
<li><a href="https://github.com/advisories/GHSA-rmj8-8hhh-gv5h">https://github.com/advisories/GHSA-rmj8-8hhh-gv5h</a></li>
<li><a href="https://github.com/advisories/GHSA-wh98-p28r-vrc9">https://github.com/advisories/GHSA-wh98-p28r-vrc9</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&amp;utm_source=footer&amp;pli=1">https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&amp;utm_source=footer&amp;pli=1</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rmj8-8hhh-gv5h</uri>
        </author>
        <published>2022-02-11T21:33:23.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[puma] Information Exposure with Puma when used with Rails]]></title>
        <id>https://github.com/advisories/GHSA-rmj8-8hhh-gv5h</id>
        <link href="https://github.com/advisories/GHSA-rmj8-8hhh-gv5h"/>
        <updated>2022-02-14T21:59:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Prior to <code>puma</code> version <code>5.6.2</code>, <code>puma</code> may not always call <code>close</code> on the response body. Rails, prior to version <code>7.0.2.2</code>, depended on the response body being closed in order for its <code>CurrentAttributes</code> implementation to work correctly.</p>
<p>From Rails:</p>
<blockquote>
<p>Under certain circumstances response bodies will not be closed, for example a bug in a webserver[1] or a bug in a Rack middleware. In the event a response is not notified of a close, ActionDispatch::Executor will not know to reset thread local state for the next request. This can lead to data being leaked to subsequent requests, especially when interacting with ActiveSupport::CurrentAttributes.</p>
</blockquote>
<p>The combination of these two behaviors (Puma not closing the body + Rails' Executor implementation) causes information leakage.</p>
<h3 id="patches">Patches</h3>
<p>This problem is fixed in Puma versions 5.6.2 and 4.3.11.</p>
<p>This problem is fixed in Rails versions 7.02.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2.</p>
<p>See: 
<a href="https://github.com/advisories/GHSA-wh98-p28r-vrc9">https://github.com/advisories/GHSA-wh98-p28r-vrc9</a> 
for details about the rails vulnerability</p>
<p>Upgrading to a patched Rails <em>or</em> Puma version fixes the vulnerability.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Upgrade to Rails versions 7.02.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2.</p>
<p>The <a href="https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&amp;utm_source=footer&amp;pli=1">Rails CVE</a> includes a middleware that can be used instead.</p>
<h3 id="references">References</h3>
<ul>
<li>Rails CVE: <a href="https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&amp;utm_source=footer&amp;pli=1">CVE-2022-23633</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an issue in <a href="https://github.com/puma/puma">puma</a></li>
<li>See our <a href="https://github.com/puma/puma/security/policy">security policy</a><h3 id="references-1">References</h3>
</li>
</ul>
<ul>
<li><a href="https://github.com/puma/puma/security/advisories/GHSA-rmj8-8hhh-gv5h">https://github.com/puma/puma/security/advisories/GHSA-rmj8-8hhh-gv5h</a></li>
<li><a href="https://github.com/puma/puma/commit/b70f451fe8abc0cff192c065d549778452e155bb">https://github.com/puma/puma/commit/b70f451fe8abc0cff192c065d549778452e155bb</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23634">https://nvd.nist.gov/vuln/detail/CVE-2022-23634</a></li>
<li><a href="https://github.com/advisories/GHSA-rmj8-8hhh-gv5h">https://github.com/advisories/GHSA-rmj8-8hhh-gv5h</a></li>
<li><a href="https://github.com/advisories/GHSA-wh98-p28r-vrc9">https://github.com/advisories/GHSA-wh98-p28r-vrc9</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&amp;utm_source=footer&amp;pli=1">https://groups.google.com/g/ruby-security-ann/c/FkTM-_7zSNA/m/K2RiMJBlBAAJ?utm_medium=email&amp;utm_source=footer&amp;pli=1</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rmj8-8hhh-gv5h</uri>
        </author>
        <published>2022-02-11T21:33:23.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Possible exposure of information vulnerability in Action Pack]]></title>
        <id>https://github.com/advisories/GHSA-wh98-p28r-vrc9</id>
        <link href="https://github.com/advisories/GHSA-wh98-p28r-vrc9"/>
        <updated>2022-02-16T21:55:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain circumstances response bodies will not be closed, for example a <a href="https://github.com/puma/puma/pull/2812">bug in a webserver</a> or a bug in a Rack middleware.  In the event a response is <em>not</em> notified of a <code>close</code>, <code>ActionDispatch::Executor</code> will not know to reset thread local state for the next request.  This can lead to data being leaked to subsequent requests, especially when interacting with <code>ActiveSupport::CurrentAttributes</code>.</p>
<p>Upgrading to the FIXED versions of Rails will ensure mitigation of this issue even in the context of a buggy webserver or middleware implementation.</p>
<h3 id="patches">Patches</h3>
<p>This has been fixed in Rails 7.0.2.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Upgrading is highly recommended, but to work around this problem the following middleware can be used:</p>
<pre><code class="language-ruby">class GuardedExecutor &lt; ActionDispatch::Executor
  def call(env)
    ensure_completed!
    super
  end

  private

    def ensure_completed!
      @executor.new.complete! if @executor.active?
    end
end

# Ensure the guard is inserted before ActionDispatch::Executor
Rails.application.configure do
  config.middleware.swap ActionDispatch::Executor, GuardedExecutor, executor
end
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9">https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9</a></li>
<li><a href="https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da">https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da</a></li>
<li><a href="https://discuss.rubyonrails.org/t/cve-2022-23633-possible-exposure-of-information-vulnerability-in-action-pack/80016">https://discuss.rubyonrails.org/t/cve-2022-23633-possible-exposure-of-information-vulnerability-in-action-pack/80016</a></li>
<li><a href="https://rubyonrails.org/2022/2/11/Rails-7-0-2-2-6-1-4-6-6-0-4-6-and-5-2-6-2-have-been-released">https://rubyonrails.org/2022/2/11/Rails-7-0-2-2-6-1-4-6-6-0-4-6-and-5-2-6-2-have-been-released</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23633">https://nvd.nist.gov/vuln/detail/CVE-2022-23633</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2022/02/11/5">http://www.openwall.com/lists/oss-security/2022/02/11/5</a></li>
<li><a href="https://github.com/advisories/GHSA-wh98-p28r-vrc9">https://github.com/advisories/GHSA-wh98-p28r-vrc9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wh98-p28r-vrc9</uri>
        </author>
        <published>2022-02-11T20:49:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Possible exposure of information vulnerability in Action Pack]]></title>
        <id>https://github.com/advisories/GHSA-wh98-p28r-vrc9</id>
        <link href="https://github.com/advisories/GHSA-wh98-p28r-vrc9"/>
        <updated>2022-02-16T21:55:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain circumstances response bodies will not be closed, for example a <a href="https://github.com/puma/puma/pull/2812">bug in a webserver</a> or a bug in a Rack middleware.  In the event a response is <em>not</em> notified of a <code>close</code>, <code>ActionDispatch::Executor</code> will not know to reset thread local state for the next request.  This can lead to data being leaked to subsequent requests, especially when interacting with <code>ActiveSupport::CurrentAttributes</code>.</p>
<p>Upgrading to the FIXED versions of Rails will ensure mitigation of this issue even in the context of a buggy webserver or middleware implementation.</p>
<h3 id="patches">Patches</h3>
<p>This has been fixed in Rails 7.0.2.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Upgrading is highly recommended, but to work around this problem the following middleware can be used:</p>
<pre><code class="language-ruby">class GuardedExecutor &lt; ActionDispatch::Executor
  def call(env)
    ensure_completed!
    super
  end

  private

    def ensure_completed!
      @executor.new.complete! if @executor.active?
    end
end

# Ensure the guard is inserted before ActionDispatch::Executor
Rails.application.configure do
  config.middleware.swap ActionDispatch::Executor, GuardedExecutor, executor
end
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9">https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9</a></li>
<li><a href="https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da">https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da</a></li>
<li><a href="https://discuss.rubyonrails.org/t/cve-2022-23633-possible-exposure-of-information-vulnerability-in-action-pack/80016">https://discuss.rubyonrails.org/t/cve-2022-23633-possible-exposure-of-information-vulnerability-in-action-pack/80016</a></li>
<li><a href="https://rubyonrails.org/2022/2/11/Rails-7-0-2-2-6-1-4-6-6-0-4-6-and-5-2-6-2-have-been-released">https://rubyonrails.org/2022/2/11/Rails-7-0-2-2-6-1-4-6-6-0-4-6-and-5-2-6-2-have-been-released</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23633">https://nvd.nist.gov/vuln/detail/CVE-2022-23633</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2022/02/11/5">http://www.openwall.com/lists/oss-security/2022/02/11/5</a></li>
<li><a href="https://github.com/advisories/GHSA-wh98-p28r-vrc9">https://github.com/advisories/GHSA-wh98-p28r-vrc9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wh98-p28r-vrc9</uri>
        </author>
        <published>2022-02-11T20:49:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Possible exposure of information vulnerability in Action Pack]]></title>
        <id>https://github.com/advisories/GHSA-wh98-p28r-vrc9</id>
        <link href="https://github.com/advisories/GHSA-wh98-p28r-vrc9"/>
        <updated>2022-02-16T21:55:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain circumstances response bodies will not be closed, for example a <a href="https://github.com/puma/puma/pull/2812">bug in a webserver</a> or a bug in a Rack middleware.  In the event a response is <em>not</em> notified of a <code>close</code>, <code>ActionDispatch::Executor</code> will not know to reset thread local state for the next request.  This can lead to data being leaked to subsequent requests, especially when interacting with <code>ActiveSupport::CurrentAttributes</code>.</p>
<p>Upgrading to the FIXED versions of Rails will ensure mitigation of this issue even in the context of a buggy webserver or middleware implementation.</p>
<h3 id="patches">Patches</h3>
<p>This has been fixed in Rails 7.0.2.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Upgrading is highly recommended, but to work around this problem the following middleware can be used:</p>
<pre><code class="language-ruby">class GuardedExecutor &lt; ActionDispatch::Executor
  def call(env)
    ensure_completed!
    super
  end

  private

    def ensure_completed!
      @executor.new.complete! if @executor.active?
    end
end

# Ensure the guard is inserted before ActionDispatch::Executor
Rails.application.configure do
  config.middleware.swap ActionDispatch::Executor, GuardedExecutor, executor
end
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9">https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9</a></li>
<li><a href="https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da">https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da</a></li>
<li><a href="https://discuss.rubyonrails.org/t/cve-2022-23633-possible-exposure-of-information-vulnerability-in-action-pack/80016">https://discuss.rubyonrails.org/t/cve-2022-23633-possible-exposure-of-information-vulnerability-in-action-pack/80016</a></li>
<li><a href="https://rubyonrails.org/2022/2/11/Rails-7-0-2-2-6-1-4-6-6-0-4-6-and-5-2-6-2-have-been-released">https://rubyonrails.org/2022/2/11/Rails-7-0-2-2-6-1-4-6-6-0-4-6-and-5-2-6-2-have-been-released</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23633">https://nvd.nist.gov/vuln/detail/CVE-2022-23633</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2022/02/11/5">http://www.openwall.com/lists/oss-security/2022/02/11/5</a></li>
<li><a href="https://github.com/advisories/GHSA-wh98-p28r-vrc9">https://github.com/advisories/GHSA-wh98-p28r-vrc9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wh98-p28r-vrc9</uri>
        </author>
        <published>2022-02-11T20:49:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Possible exposure of information vulnerability in Action Pack]]></title>
        <id>https://github.com/advisories/GHSA-wh98-p28r-vrc9</id>
        <link href="https://github.com/advisories/GHSA-wh98-p28r-vrc9"/>
        <updated>2022-02-16T21:55:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain circumstances response bodies will not be closed, for example a <a href="https://github.com/puma/puma/pull/2812">bug in a webserver</a> or a bug in a Rack middleware.  In the event a response is <em>not</em> notified of a <code>close</code>, <code>ActionDispatch::Executor</code> will not know to reset thread local state for the next request.  This can lead to data being leaked to subsequent requests, especially when interacting with <code>ActiveSupport::CurrentAttributes</code>.</p>
<p>Upgrading to the FIXED versions of Rails will ensure mitigation of this issue even in the context of a buggy webserver or middleware implementation.</p>
<h3 id="patches">Patches</h3>
<p>This has been fixed in Rails 7.0.2.2, 6.1.4.6, 6.0.4.6, and 5.2.6.2.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Upgrading is highly recommended, but to work around this problem the following middleware can be used:</p>
<pre><code class="language-ruby">class GuardedExecutor &lt; ActionDispatch::Executor
  def call(env)
    ensure_completed!
    super
  end

  private

    def ensure_completed!
      @executor.new.complete! if @executor.active?
    end
end

# Ensure the guard is inserted before ActionDispatch::Executor
Rails.application.configure do
  config.middleware.swap ActionDispatch::Executor, GuardedExecutor, executor
end
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9">https://github.com/rails/rails/security/advisories/GHSA-wh98-p28r-vrc9</a></li>
<li><a href="https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da">https://github.com/rails/rails/commit/f9a2ad03943d5c2ba54e1d45f155442b519c75da</a></li>
<li><a href="https://discuss.rubyonrails.org/t/cve-2022-23633-possible-exposure-of-information-vulnerability-in-action-pack/80016">https://discuss.rubyonrails.org/t/cve-2022-23633-possible-exposure-of-information-vulnerability-in-action-pack/80016</a></li>
<li><a href="https://rubyonrails.org/2022/2/11/Rails-7-0-2-2-6-1-4-6-6-0-4-6-and-5-2-6-2-have-been-released">https://rubyonrails.org/2022/2/11/Rails-7-0-2-2-6-1-4-6-6-0-4-6-and-5-2-6-2-have-been-released</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23633">https://nvd.nist.gov/vuln/detail/CVE-2022-23633</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2022/02/11/5">http://www.openwall.com/lists/oss-security/2022/02/11/5</a></li>
<li><a href="https://github.com/advisories/GHSA-wh98-p28r-vrc9">https://github.com/advisories/GHSA-wh98-p28r-vrc9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wh98-p28r-vrc9</uri>
        </author>
        <published>2022-02-11T20:49:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[publify_core] Business Logic Errors in Publify]]></title>
        <id>https://github.com/advisories/GHSA-x3rq-r3cm-5vc4</id>
        <link href="https://github.com/advisories/GHSA-x3rq-r3cm-5vc4"/>
        <updated>2022-02-14T22:34:47.000Z</updated>
        <content type="html"><![CDATA[<p>Publify (formerly known as Typo) prior to version 9.2.7 is vulnerable to business logic errors.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-0524">https://nvd.nist.gov/vuln/detail/CVE-2022-0524</a></li>
<li><a href="https://github.com/publify/publify/commit/16fceecadbe80ab0ef846b62a12dc7bfff10b8c5">https://github.com/publify/publify/commit/16fceecadbe80ab0ef846b62a12dc7bfff10b8c5</a></li>
<li><a href="https://huntr.dev/bounties/bfffae58-b3cd-4e0e-b1f2-3db387a22c3d">https://huntr.dev/bounties/bfffae58-b3cd-4e0e-b1f2-3db387a22c3d</a></li>
<li><a href="https://github.com/publify/publify/releases/tag/v9.2.7">https://github.com/publify/publify/releases/tag/v9.2.7</a></li>
<li><a href="https://github.com/advisories/GHSA-x3rq-r3cm-5vc4">https://github.com/advisories/GHSA-x3rq-r3cm-5vc4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-x3rq-r3cm-5vc4</uri>
        </author>
        <published>2022-02-09T00:00:27.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[sidekiq] Denial of service in sidekiq]]></title>
        <id>https://github.com/advisories/GHSA-jrfj-98qg-qjgv</id>
        <link href="https://github.com/advisories/GHSA-jrfj-98qg-qjgv"/>
        <updated>2022-02-08T20:10:43.000Z</updated>
        <content type="html"><![CDATA[<p>In api.rb in Sidekiq before 6.4.0, there is no limit on the number of days when requesting stats for the graph. This overloads the system, affecting the Web UI, and makes it unavailable to users.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23837">https://nvd.nist.gov/vuln/detail/CVE-2022-23837</a></li>
<li><a href="https://github.com/mperham/sidekiq/commit/7785ac1399f1b28992adb56055f6acd88fd1d956">https://github.com/mperham/sidekiq/commit/7785ac1399f1b28992adb56055f6acd88fd1d956</a></li>
<li><a href="https://github.com/TUTUMSPACE/exploits/blob/main/sidekiq.md">https://github.com/TUTUMSPACE/exploits/blob/main/sidekiq.md</a></li>
<li><a href="https://github.com/rubysec/ruby-advisory-db/pull/495">https://github.com/rubysec/ruby-advisory-db/pull/495</a></li>
<li><a href="https://github.com/advisories/GHSA-jrfj-98qg-qjgv">https://github.com/advisories/GHSA-jrfj-98qg-qjgv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jrfj-98qg-qjgv</uri>
        </author>
        <published>2022-01-27T14:42:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cgi] Cookie prefix spoofing in CGI]]></title>
        <id>https://github.com/advisories/GHSA-4vf4-qmvg-mh7h</id>
        <link href="https://github.com/advisories/GHSA-4vf4-qmvg-mh7h"/>
        <updated>2022-02-14T22:21:20.000Z</updated>
        <content type="html"><![CDATA[<p>CGI::Cookie.parse in Ruby through 2.6.8 mishandles security prefixes in cookie names. This also affects the CGI gem through 0.3.0 for Ruby.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-41819">https://nvd.nist.gov/vuln/detail/CVE-2021-41819</a></li>
<li><a href="https://hackerone.com/reports/910552">https://hackerone.com/reports/910552</a></li>
<li><a href="https://www.ruby-lang.org/en/news/2021/11/24/cookie-prefix-spoofing-in-cgi-cookie-parse-cve-2021-41819/">https://www.ruby-lang.org/en/news/2021/11/24/cookie-prefix-spoofing-in-cgi-cookie-parse-cve-2021-41819/</a></li>
<li><a href="https://security.netapp.com/advisory/ntap-20220121-0003/">https://security.netapp.com/advisory/ntap-20220121-0003/</a></li>
<li><a href="https://github.com/advisories/GHSA-4vf4-qmvg-mh7h">https://github.com/advisories/GHSA-4vf4-qmvg-mh7h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4vf4-qmvg-mh7h</uri>
        </author>
        <published>2022-01-21T23:22:17.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[google-protobuf] A potential Denial of Service issue in protobuf-java]]></title>
        <id>https://github.com/advisories/GHSA-wrvw-hg22-4m67</id>
        <link href="https://github.com/advisories/GHSA-wrvw-hg22-4m67"/>
        <updated>2022-01-18T22:38:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="summary">Summary</h2>
<p>A potential Denial of Service issue in protobuf-java was discovered in the parsing procedure for binary data.</p>
<p>Reporter: <a href="https://github.com/google/oss-fuzz">OSS-Fuzz</a></p>
<p>Affected versions: All versions of Java Protobufs (including Kotlin and JRuby) prior to the versions listed below. Protobuf "javalite" users (typically Android) are not affected.</p>
<h2 id="severity">Severity</h2>
<p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-22569">CVE-2021-22569</a> <strong>High</strong> - CVSS Score: 7.5,  An implementation weakness in how unknown fields are parsed in Java. A small (~800 KB) malicious payload can occupy the parser for several minutes by creating large numbers of short-lived objects that cause frequent, repeated GC pauses.</p>
<h2 id="proof-of-concept">Proof of Concept</h2>
<p>For reproduction details, please refer to the oss-fuzz issue that identifies the specific inputs that exercise this parsing weakness.</p>
<h2 id="remediation-and-mitigation">Remediation and Mitigation</h2>
<p>Please update to the latest available versions of the following packages:</p>
<ul>
<li>protobuf-java (3.16.1, 3.18.2, 3.19.2) </li>
<li>protobuf-kotlin (3.18.2, 3.19.2)</li>
<li>google-protobuf [JRuby  gem only] (3.19.2)</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67">https://github.com/protocolbuffers/protobuf/security/advisories/GHSA-wrvw-hg22-4m67</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-22569">https://nvd.nist.gov/vuln/detail/CVE-2021-22569</a></li>
<li><a href="https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39330">https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=39330</a></li>
<li><a href="https://cloud.google.com/support/bulletins#gcp-2022-001">https://cloud.google.com/support/bulletins#gcp-2022-001</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2022/01/12/4">http://www.openwall.com/lists/oss-security/2022/01/12/4</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2022/01/12/7">http://www.openwall.com/lists/oss-security/2022/01/12/7</a></li>
<li><a href="https://github.com/advisories/GHSA-wrvw-hg22-4m67">https://github.com/advisories/GHSA-wrvw-hg22-4m67</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wrvw-hg22-4m67</uri>
        </author>
        <published>2022-01-07T22:31:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_frontend] CSRF forgery protection bypass in solidus_frontend]]></title>
        <id>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</id>
        <link href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m"/>
        <updated>2022-01-06T18:33:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>CSRF vulnerability that allows a malicious site to add an item to the user's cart without their knowledge.</p>
<p>All <code>solidus_frontend</code> versions are affected. If you're using your own storefront, please, follow along to make sure you're not affected.</p>
<p>To reproduce the issue:</p>
<ul>
<li><p>Pick the id for a variant with available stock. From the rails console:</p>
<pre><code class="language-ruby">Spree::Variant.in_stock.pluck(:id)
</code></pre>
<p>Say we pick variant id <code>2</code>.</p>
</li>
<li><p>Launch your application, for instance, on <code>http://localhost:3000</code>:</p>
<pre><code class="language-bash">bin/rails server
</code></pre>
</li>
<li><p>Open your browser dev tools.</p>
</li>
<li><p>Click on whatever link in your store.</p>
</li>
<li><p>Copy the value of the <code>Cookie</code> request header sent for the previous request from your browser dev tools.</p>
</li>
<li><p>Execute the following, using your previously selected variant id and the value of the <code>Cookie</code> header (notice how it doesn't contain any authentication token):</p>
<pre><code class="language-bash">curl -X POST -d "variant_id=2&amp;quantity=1" -H "Cookie: guest_token=eyJfcmFpbHMiOnsibWVzc2FnZSI6IklrWlRVMWRQWnpKMVZVdFNXRzlPVW1aaWJHTjZZa0VpIiwiZXhwIjpudWxsLCJwdXIiOiJjb29raWUuZ3Vlc3RfdG9rZW4ifX0%3D--5006ba5d346f621c760a29b6a797bf351d17d1b8; _sandbox_session=vhutu5%2FL9NmWrUpGc3DxrFA%2FFsQD1dHn1cNsD7nvE84zcjWf17Af4%2F%2F2Vab3md71b6KTb9NP6WktdXktpwH4eU01jEGIBXG5%2BMzW5nL0nb4W269qk1io4LYljvoOg8%2BZVll7oJCVkJLKKh0sSoS0Kg8j%2FCHHs%2BsShohP%2BGnA%2Bfr9Ub8H6HofpSmloSpsfHHygmX0ho03fEgzHJ4DD5wJctaNKwg7NhVikHh5kgIPPHl84OGCgv3p2oe9jR19HTxOKq7BtyvDd7XZsecWhkcfS8BPnvDDUWZG6qpAEFI5kWo81KkpSJ%2Bp6Q1HOo8%3D--n3G2vgaDG7VS%2B%2FhF--ZTjxBAkfGG3hpr4GRQ2S1Q%3D%3D; __profilin=p%3Dt" http://localhost:3000/orders/populate
</code></pre>
</li>
<li><p>Reload your browser and look at how your cart got updated.</p>
</li>
</ul>
<h3 id="patches">Patches</h3>
<p>Please, upgrade <code>solidus</code> to versions <code>3.1.5</code>, <code>3.0.5</code> or <code>2.11.14</code>.</p>
<p>After upgrading, make sure you read the "Upgrade notes"  section below.</p>
<h3 id="upgrade-notes">Upgrade notes</h3>
<p>The patch adds CSRF token verification to the "Add to cart" action. Adding forgery protection to a form that missed it can have some side effects.</p>
<h4 id="invalidauthenticitytoken-errors"><code>InvalidAuthenticityToken</code> errors</h4>
<p>If you're using the <code>:exception</code> strategy, it's likely that after upgrading, you'll see more <code>ActionController::InvalidAuthenticityToken</code> errors popping out in your logs. Due to browser-side cache, a form can be re-rendered and sent without any attached request cookie (for instance, when re-opening a mobile browser). That will cause an authentication error, as the sent token won't match with the one in the session (none in this case). That's a known problem in the Rails community (see <a href="https://github.com/rails/rails/issues/21948">https://github.com/rails/rails/issues/21948</a>), and, at this point, there's no perfect solution.</p>
<p>Any attempt to mitigate the issue should be seen at the application level. For an excellent survey of all the available options, take a look at <a href="https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md">https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md</a>. The latter is a third-party link. As the information is relevant here, we're going to copy it below, but it should be clear that all the credit goes to @kemenaran:</p>
<blockquote>
<h1 id="protecting-against-request-forgery-using-crsf-tokens">Protecting against request forgery using CRSF tokens</h1>
<h2 id="context">Context</h2>
<p>Rails has CSRF protection enabled by default, to protect against POST-based CSRF attacks.</p>
<p>To protect from this, Rails stores two copies of a random token (the so-named CSRF token) on each request:</p>
<ul>
<li>one copy embedded in each HTML page,</li>
<li>another copy in the user session.</li>
</ul>
<p>When performing a POST request, Rails checks that the two copies match – and otherwise denies the request. This protects against an attacker that would generate a form secretly pointing to our website: the attacker can't read the token in the session, and so can't post a form with a valid token.</p>
<p>The problem is that, much more often, this has false positives. There are several cases for that, including:</p>
<ol>
<li><p>The web browser (often mobile) loads a page containing a form, then is closed by the user. Later, when the browser is re-opened, it restores the page from the cache. But the session cookie has expired, and so is not restored – so the copy of the CSRF token stored in the session is missing. When the user submits the form, they get an "InvalidAuthenticityToken" exception.</p>
</li>
<li><p>The user attempts to fill a form, and gets an error message (usually in response to a POST request). They close the browser. When the browser is re-opened, it attempts to restore the page. On Chrome this is blocked by the browser, because the browser denies retrying a (probably non-idempotent) POST request. Safari however happily retries the POST request – but without sending any cookies (in an attempt to avoid having unexpected side-effects). So the copy of the CSRF token in the session is missing (because no cookie was sent), and the user get an "InvalidAuthenticityToken" exception.</p>
</li>
</ol>
<h2 id="options-considered">Options considered</h2>
<h3 id="extend-the-session-cookie-duration">Extend the session cookie duration</h3>
<p>We can configure the session cookie to be valid for a longer time (like 2 weeks).</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the browser restores the page, the session cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Users would be signed-in for a much longer time by default, which has unacceptable security implications.</li>
<li>It doesn't solve 2. (because Safari doesn't send any cookie when restoring a page from a POST request)</li>
</ul>
<h3 id="change-the-cache-parameters">Change the cache parameters</h3>
<p>We can send a HTTP cache header stating 'Cache-Control: no-store, no-cache'. This instructs the browser to never keep any copy of the page, and to always make a request to the server to restore it.</p>
<p>This solution was attempted during a year in production, and solved 1. – but also introduced another type of InvalidAuthenticityToken errors. In that scenario, the user attempts to fill a form, and gets an error message (usually in response to a POST request). They then navigate on another domain (like France Connect), then hit the "Back" button. Crossing back the domain boundary may cause the browser to either block the request or retry an invalid POST request.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because on relaunch the browser requests a fresh page again (instead of serving it from its cache), thus retrieving a fresh session and a fresh matching CSRF token.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2.</li>
<li>It causes another type of InvalidAuthenticityToken errors.</li>
</ul>
<h3 id="using-a-null-session-strategy">Using a null-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :null_session. This makes the current request use an empty session for the request duration.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>The user is asked to sign-in only after filling and submitting the form, losing their time and data</li>
<li>The user will not be redirected to their original page after signing-in</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
</ul>
<h3 id="using-a-reset-session-strategy">Using a reset-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :reset_session. This clears the user session permanently, logging them out until they log in again.</p>
<p>Pros: </p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>A forgery error in a browser tab will disconnect the user in all its open tabs</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
<li>It allows an attacker to disconnect an user on demand, which is not only inconvenient, but also has security implication (the attacker could then log the user on it's own attacker account, pretending to be the user account)</li>
</ul>
<h3 id="redirect-to-login-form">Redirect to login form</h3>
<p>When a forgery error occurs, we can instead redirect to the login form.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted (but the user data is lost).</li>
<li>It kind of solves 2., by redirecting to a "Please sign-in" page when a previously POSTed form is reloaded.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not all forms require authentication – so for public forms there is no point redirecting to the login form. </li>
<li>The user will not be redirected to their original page after signing-in (because setting the redirect path is a state-changing action, and it is dangerous to let an unauthorized request changing the state – an attacker could control the path where an user is automatically redirected to.)</li>
<li>The implementation is finicky, and may introduce security errors. For instance, a naive implementation that catches the exception and redirect_to the sign-in page will prevent Devise from running a cleanup code – which means the user will still be logged, and the CSRF protection is bypassed. However a well-tested implementation that lets Devise code run should avoid these pittfalls.</li>
</ul>
<h3 id="using-a-long-lived-cookie-for-csrf-tokens">Using a long-lived cookie for CSRF tokens</h3>
<p>Instead of storing the CSRF token in the session cookie (which is deleted when the browser is closed), we can instead store it in a longer-lived cookie. For this we need to patch Rails.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the user submits a stale form, even if the session cookie because stale, the long-lived CSRF cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2., because when Safari retries a POST request, it sends none of the cookies (not even long-lived ones).</li>
<li>Patching Rails may introduce security issues (now or in the future)</li>
</ul>
</blockquote>
<h4 id="broken-behavior-due-to-session-expiration--template-cache">Broken behavior due to session expiration + template cache</h4>
<p>Although pretty unlikely, you should make sure that your current setup for cache/session expiration is compatible. The upgrade can break the addition of products to the cart if both:</p>
<ul>
<li><p>The "Add to cart" form is being cached (usually along with the variant information).</p>
</li>
<li><p>A user session is reset at every or every few requests.</p>
</li>
</ul>
<p>The token validation depends on the issuing and consuming sessions being the same. If a product page is cached with the token in it, it can become stale on a subsequent rendering if the session changes.</p>
<p>To check that you're safe, after having upgraded locally, go through the following steps:</p>
<ul>
<li><p>Enable cache on dev mode:</p>
<pre><code class="language-bash">bin/rails dev:cache
</code></pre>
</li>
<li><p>Visit the page for a variant with stock.</p>
</li>
<li><p>Reload that page several times.</p>
</li>
<li><p>Click on the "Add to cart"  button.</p>
</li>
<li><p>Remember to rerun <code>bin/rails dev:cache</code> to turn off cache again.</p>
</li>
</ul>
<p>No error or session reset should happen.</p>
<p>Otherwise, you can try with:</p>
<ul>
<li>Revisiting how your session gets expired.</li>
<li>Changing the caching strategy to exclude the token.</li>
</ul>
<h4 id="using-weaker-csrf-protection-strategies">Using weaker CSRF protection strategies</h4>
<p>It's also important to understand that a complete fix will only be in place when using the <code>:exception</code> forgery protection strategy. The <code>solidus_frontend</code> engine can't do pretty much anything otherwise. Using weaker CSRF strategies should be an informed and limited decision made by the application team. After the upgrade:</p>
<ul>
<li><p>An app using <code>:null_session</code> should also be safe, but there will be side effects. That strategy runs with a null object session. As such, no order and no user is found on it. A new <code>cart</code> state order is created in the database, associated with no user. Next time the user visits the site, they won't find any difference in its cart state.</p>
</li>
<li><p>An app using <code>:reset_session</code> is not entirely safe. That strategy resets the session. That means that registered users will be logged out. Next time a user visits, they'll see the cart with the items added during the CSRF attack, although it won't be associated with their account in the case of registered users.</p>
</li>
</ul>
<h4 id="reversing-the-update">Reversing the update</h4>
<p>If you still want to deploy the upgraded version before changing your application code (if the latter is needed), you can add the following workaround to your <code>config/application.rb</code> (however, take into account that you'll keep being vulnerable):</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.skip_before_action :verify_authenticity_token, only: [:populate]
end
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If an upgrade is not an option, you can work around the issue by adding the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.protect_from_forgery with: ApplicationController.forgery_protection_strategy.name.demodulize.underscore.to_sym, only: [:populate]
end
</code></pre>
<p>However, go through the same safety check detailed on "Upgrade notes" above.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">CSRF on the Rails guides</a></li>
<li><a href="https://medium.com/rubyinside/a-deep-dive-into-csrf-protection-in-rails-19fa0a42c0ef">How CSRF tokens are generated and validated on Rails</a></li>
<li><a href="https://solidus.io/security/">Solidus security</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43846">https://nvd.nist.gov/vuln/detail/CVE-2021-43846</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81">https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6">https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6</a></li>
<li><a href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</uri>
        </author>
        <published>2022-01-06T18:33:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_frontend] CSRF forgery protection bypass in solidus_frontend]]></title>
        <id>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</id>
        <link href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m"/>
        <updated>2022-01-06T18:33:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>CSRF vulnerability that allows a malicious site to add an item to the user's cart without their knowledge.</p>
<p>All <code>solidus_frontend</code> versions are affected. If you're using your own storefront, please, follow along to make sure you're not affected.</p>
<p>To reproduce the issue:</p>
<ul>
<li><p>Pick the id for a variant with available stock. From the rails console:</p>
<pre><code class="language-ruby">Spree::Variant.in_stock.pluck(:id)
</code></pre>
<p>Say we pick variant id <code>2</code>.</p>
</li>
<li><p>Launch your application, for instance, on <code>http://localhost:3000</code>:</p>
<pre><code class="language-bash">bin/rails server
</code></pre>
</li>
<li><p>Open your browser dev tools.</p>
</li>
<li><p>Click on whatever link in your store.</p>
</li>
<li><p>Copy the value of the <code>Cookie</code> request header sent for the previous request from your browser dev tools.</p>
</li>
<li><p>Execute the following, using your previously selected variant id and the value of the <code>Cookie</code> header (notice how it doesn't contain any authentication token):</p>
<pre><code class="language-bash">curl -X POST -d "variant_id=2&amp;quantity=1" -H "Cookie: guest_token=eyJfcmFpbHMiOnsibWVzc2FnZSI6IklrWlRVMWRQWnpKMVZVdFNXRzlPVW1aaWJHTjZZa0VpIiwiZXhwIjpudWxsLCJwdXIiOiJjb29raWUuZ3Vlc3RfdG9rZW4ifX0%3D--5006ba5d346f621c760a29b6a797bf351d17d1b8; _sandbox_session=vhutu5%2FL9NmWrUpGc3DxrFA%2FFsQD1dHn1cNsD7nvE84zcjWf17Af4%2F%2F2Vab3md71b6KTb9NP6WktdXktpwH4eU01jEGIBXG5%2BMzW5nL0nb4W269qk1io4LYljvoOg8%2BZVll7oJCVkJLKKh0sSoS0Kg8j%2FCHHs%2BsShohP%2BGnA%2Bfr9Ub8H6HofpSmloSpsfHHygmX0ho03fEgzHJ4DD5wJctaNKwg7NhVikHh5kgIPPHl84OGCgv3p2oe9jR19HTxOKq7BtyvDd7XZsecWhkcfS8BPnvDDUWZG6qpAEFI5kWo81KkpSJ%2Bp6Q1HOo8%3D--n3G2vgaDG7VS%2B%2FhF--ZTjxBAkfGG3hpr4GRQ2S1Q%3D%3D; __profilin=p%3Dt" http://localhost:3000/orders/populate
</code></pre>
</li>
<li><p>Reload your browser and look at how your cart got updated.</p>
</li>
</ul>
<h3 id="patches">Patches</h3>
<p>Please, upgrade <code>solidus</code> to versions <code>3.1.5</code>, <code>3.0.5</code> or <code>2.11.14</code>.</p>
<p>After upgrading, make sure you read the "Upgrade notes"  section below.</p>
<h3 id="upgrade-notes">Upgrade notes</h3>
<p>The patch adds CSRF token verification to the "Add to cart" action. Adding forgery protection to a form that missed it can have some side effects.</p>
<h4 id="invalidauthenticitytoken-errors"><code>InvalidAuthenticityToken</code> errors</h4>
<p>If you're using the <code>:exception</code> strategy, it's likely that after upgrading, you'll see more <code>ActionController::InvalidAuthenticityToken</code> errors popping out in your logs. Due to browser-side cache, a form can be re-rendered and sent without any attached request cookie (for instance, when re-opening a mobile browser). That will cause an authentication error, as the sent token won't match with the one in the session (none in this case). That's a known problem in the Rails community (see <a href="https://github.com/rails/rails/issues/21948">https://github.com/rails/rails/issues/21948</a>), and, at this point, there's no perfect solution.</p>
<p>Any attempt to mitigate the issue should be seen at the application level. For an excellent survey of all the available options, take a look at <a href="https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md">https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md</a>. The latter is a third-party link. As the information is relevant here, we're going to copy it below, but it should be clear that all the credit goes to @kemenaran:</p>
<blockquote>
<h1 id="protecting-against-request-forgery-using-crsf-tokens">Protecting against request forgery using CRSF tokens</h1>
<h2 id="context">Context</h2>
<p>Rails has CSRF protection enabled by default, to protect against POST-based CSRF attacks.</p>
<p>To protect from this, Rails stores two copies of a random token (the so-named CSRF token) on each request:</p>
<ul>
<li>one copy embedded in each HTML page,</li>
<li>another copy in the user session.</li>
</ul>
<p>When performing a POST request, Rails checks that the two copies match – and otherwise denies the request. This protects against an attacker that would generate a form secretly pointing to our website: the attacker can't read the token in the session, and so can't post a form with a valid token.</p>
<p>The problem is that, much more often, this has false positives. There are several cases for that, including:</p>
<ol>
<li><p>The web browser (often mobile) loads a page containing a form, then is closed by the user. Later, when the browser is re-opened, it restores the page from the cache. But the session cookie has expired, and so is not restored – so the copy of the CSRF token stored in the session is missing. When the user submits the form, they get an "InvalidAuthenticityToken" exception.</p>
</li>
<li><p>The user attempts to fill a form, and gets an error message (usually in response to a POST request). They close the browser. When the browser is re-opened, it attempts to restore the page. On Chrome this is blocked by the browser, because the browser denies retrying a (probably non-idempotent) POST request. Safari however happily retries the POST request – but without sending any cookies (in an attempt to avoid having unexpected side-effects). So the copy of the CSRF token in the session is missing (because no cookie was sent), and the user get an "InvalidAuthenticityToken" exception.</p>
</li>
</ol>
<h2 id="options-considered">Options considered</h2>
<h3 id="extend-the-session-cookie-duration">Extend the session cookie duration</h3>
<p>We can configure the session cookie to be valid for a longer time (like 2 weeks).</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the browser restores the page, the session cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Users would be signed-in for a much longer time by default, which has unacceptable security implications.</li>
<li>It doesn't solve 2. (because Safari doesn't send any cookie when restoring a page from a POST request)</li>
</ul>
<h3 id="change-the-cache-parameters">Change the cache parameters</h3>
<p>We can send a HTTP cache header stating 'Cache-Control: no-store, no-cache'. This instructs the browser to never keep any copy of the page, and to always make a request to the server to restore it.</p>
<p>This solution was attempted during a year in production, and solved 1. – but also introduced another type of InvalidAuthenticityToken errors. In that scenario, the user attempts to fill a form, and gets an error message (usually in response to a POST request). They then navigate on another domain (like France Connect), then hit the "Back" button. Crossing back the domain boundary may cause the browser to either block the request or retry an invalid POST request.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because on relaunch the browser requests a fresh page again (instead of serving it from its cache), thus retrieving a fresh session and a fresh matching CSRF token.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2.</li>
<li>It causes another type of InvalidAuthenticityToken errors.</li>
</ul>
<h3 id="using-a-null-session-strategy">Using a null-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :null_session. This makes the current request use an empty session for the request duration.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>The user is asked to sign-in only after filling and submitting the form, losing their time and data</li>
<li>The user will not be redirected to their original page after signing-in</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
</ul>
<h3 id="using-a-reset-session-strategy">Using a reset-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :reset_session. This clears the user session permanently, logging them out until they log in again.</p>
<p>Pros: </p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>A forgery error in a browser tab will disconnect the user in all its open tabs</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
<li>It allows an attacker to disconnect an user on demand, which is not only inconvenient, but also has security implication (the attacker could then log the user on it's own attacker account, pretending to be the user account)</li>
</ul>
<h3 id="redirect-to-login-form">Redirect to login form</h3>
<p>When a forgery error occurs, we can instead redirect to the login form.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted (but the user data is lost).</li>
<li>It kind of solves 2., by redirecting to a "Please sign-in" page when a previously POSTed form is reloaded.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not all forms require authentication – so for public forms there is no point redirecting to the login form. </li>
<li>The user will not be redirected to their original page after signing-in (because setting the redirect path is a state-changing action, and it is dangerous to let an unauthorized request changing the state – an attacker could control the path where an user is automatically redirected to.)</li>
<li>The implementation is finicky, and may introduce security errors. For instance, a naive implementation that catches the exception and redirect_to the sign-in page will prevent Devise from running a cleanup code – which means the user will still be logged, and the CSRF protection is bypassed. However a well-tested implementation that lets Devise code run should avoid these pittfalls.</li>
</ul>
<h3 id="using-a-long-lived-cookie-for-csrf-tokens">Using a long-lived cookie for CSRF tokens</h3>
<p>Instead of storing the CSRF token in the session cookie (which is deleted when the browser is closed), we can instead store it in a longer-lived cookie. For this we need to patch Rails.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the user submits a stale form, even if the session cookie because stale, the long-lived CSRF cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2., because when Safari retries a POST request, it sends none of the cookies (not even long-lived ones).</li>
<li>Patching Rails may introduce security issues (now or in the future)</li>
</ul>
</blockquote>
<h4 id="broken-behavior-due-to-session-expiration--template-cache">Broken behavior due to session expiration + template cache</h4>
<p>Although pretty unlikely, you should make sure that your current setup for cache/session expiration is compatible. The upgrade can break the addition of products to the cart if both:</p>
<ul>
<li><p>The "Add to cart" form is being cached (usually along with the variant information).</p>
</li>
<li><p>A user session is reset at every or every few requests.</p>
</li>
</ul>
<p>The token validation depends on the issuing and consuming sessions being the same. If a product page is cached with the token in it, it can become stale on a subsequent rendering if the session changes.</p>
<p>To check that you're safe, after having upgraded locally, go through the following steps:</p>
<ul>
<li><p>Enable cache on dev mode:</p>
<pre><code class="language-bash">bin/rails dev:cache
</code></pre>
</li>
<li><p>Visit the page for a variant with stock.</p>
</li>
<li><p>Reload that page several times.</p>
</li>
<li><p>Click on the "Add to cart"  button.</p>
</li>
<li><p>Remember to rerun <code>bin/rails dev:cache</code> to turn off cache again.</p>
</li>
</ul>
<p>No error or session reset should happen.</p>
<p>Otherwise, you can try with:</p>
<ul>
<li>Revisiting how your session gets expired.</li>
<li>Changing the caching strategy to exclude the token.</li>
</ul>
<h4 id="using-weaker-csrf-protection-strategies">Using weaker CSRF protection strategies</h4>
<p>It's also important to understand that a complete fix will only be in place when using the <code>:exception</code> forgery protection strategy. The <code>solidus_frontend</code> engine can't do pretty much anything otherwise. Using weaker CSRF strategies should be an informed and limited decision made by the application team. After the upgrade:</p>
<ul>
<li><p>An app using <code>:null_session</code> should also be safe, but there will be side effects. That strategy runs with a null object session. As such, no order and no user is found on it. A new <code>cart</code> state order is created in the database, associated with no user. Next time the user visits the site, they won't find any difference in its cart state.</p>
</li>
<li><p>An app using <code>:reset_session</code> is not entirely safe. That strategy resets the session. That means that registered users will be logged out. Next time a user visits, they'll see the cart with the items added during the CSRF attack, although it won't be associated with their account in the case of registered users.</p>
</li>
</ul>
<h4 id="reversing-the-update">Reversing the update</h4>
<p>If you still want to deploy the upgraded version before changing your application code (if the latter is needed), you can add the following workaround to your <code>config/application.rb</code> (however, take into account that you'll keep being vulnerable):</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.skip_before_action :verify_authenticity_token, only: [:populate]
end
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If an upgrade is not an option, you can work around the issue by adding the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.protect_from_forgery with: ApplicationController.forgery_protection_strategy.name.demodulize.underscore.to_sym, only: [:populate]
end
</code></pre>
<p>However, go through the same safety check detailed on "Upgrade notes" above.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">CSRF on the Rails guides</a></li>
<li><a href="https://medium.com/rubyinside/a-deep-dive-into-csrf-protection-in-rails-19fa0a42c0ef">How CSRF tokens are generated and validated on Rails</a></li>
<li><a href="https://solidus.io/security/">Solidus security</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43846">https://nvd.nist.gov/vuln/detail/CVE-2021-43846</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81">https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6">https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6</a></li>
<li><a href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</uri>
        </author>
        <published>2022-01-06T18:33:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[solidus_frontend] CSRF forgery protection bypass in solidus_frontend]]></title>
        <id>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</id>
        <link href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m"/>
        <updated>2022-01-06T18:33:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>CSRF vulnerability that allows a malicious site to add an item to the user's cart without their knowledge.</p>
<p>All <code>solidus_frontend</code> versions are affected. If you're using your own storefront, please, follow along to make sure you're not affected.</p>
<p>To reproduce the issue:</p>
<ul>
<li><p>Pick the id for a variant with available stock. From the rails console:</p>
<pre><code class="language-ruby">Spree::Variant.in_stock.pluck(:id)
</code></pre>
<p>Say we pick variant id <code>2</code>.</p>
</li>
<li><p>Launch your application, for instance, on <code>http://localhost:3000</code>:</p>
<pre><code class="language-bash">bin/rails server
</code></pre>
</li>
<li><p>Open your browser dev tools.</p>
</li>
<li><p>Click on whatever link in your store.</p>
</li>
<li><p>Copy the value of the <code>Cookie</code> request header sent for the previous request from your browser dev tools.</p>
</li>
<li><p>Execute the following, using your previously selected variant id and the value of the <code>Cookie</code> header (notice how it doesn't contain any authentication token):</p>
<pre><code class="language-bash">curl -X POST -d "variant_id=2&amp;quantity=1" -H "Cookie: guest_token=eyJfcmFpbHMiOnsibWVzc2FnZSI6IklrWlRVMWRQWnpKMVZVdFNXRzlPVW1aaWJHTjZZa0VpIiwiZXhwIjpudWxsLCJwdXIiOiJjb29raWUuZ3Vlc3RfdG9rZW4ifX0%3D--5006ba5d346f621c760a29b6a797bf351d17d1b8; _sandbox_session=vhutu5%2FL9NmWrUpGc3DxrFA%2FFsQD1dHn1cNsD7nvE84zcjWf17Af4%2F%2F2Vab3md71b6KTb9NP6WktdXktpwH4eU01jEGIBXG5%2BMzW5nL0nb4W269qk1io4LYljvoOg8%2BZVll7oJCVkJLKKh0sSoS0Kg8j%2FCHHs%2BsShohP%2BGnA%2Bfr9Ub8H6HofpSmloSpsfHHygmX0ho03fEgzHJ4DD5wJctaNKwg7NhVikHh5kgIPPHl84OGCgv3p2oe9jR19HTxOKq7BtyvDd7XZsecWhkcfS8BPnvDDUWZG6qpAEFI5kWo81KkpSJ%2Bp6Q1HOo8%3D--n3G2vgaDG7VS%2B%2FhF--ZTjxBAkfGG3hpr4GRQ2S1Q%3D%3D; __profilin=p%3Dt" http://localhost:3000/orders/populate
</code></pre>
</li>
<li><p>Reload your browser and look at how your cart got updated.</p>
</li>
</ul>
<h3 id="patches">Patches</h3>
<p>Please, upgrade <code>solidus</code> to versions <code>3.1.5</code>, <code>3.0.5</code> or <code>2.11.14</code>.</p>
<p>After upgrading, make sure you read the "Upgrade notes"  section below.</p>
<h3 id="upgrade-notes">Upgrade notes</h3>
<p>The patch adds CSRF token verification to the "Add to cart" action. Adding forgery protection to a form that missed it can have some side effects.</p>
<h4 id="invalidauthenticitytoken-errors"><code>InvalidAuthenticityToken</code> errors</h4>
<p>If you're using the <code>:exception</code> strategy, it's likely that after upgrading, you'll see more <code>ActionController::InvalidAuthenticityToken</code> errors popping out in your logs. Due to browser-side cache, a form can be re-rendered and sent without any attached request cookie (for instance, when re-opening a mobile browser). That will cause an authentication error, as the sent token won't match with the one in the session (none in this case). That's a known problem in the Rails community (see <a href="https://github.com/rails/rails/issues/21948">https://github.com/rails/rails/issues/21948</a>), and, at this point, there's no perfect solution.</p>
<p>Any attempt to mitigate the issue should be seen at the application level. For an excellent survey of all the available options, take a look at <a href="https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md">https://github.com/betagouv/demarches-simplifiees.fr/blob/5b4f7f9ae9eaf0ac94008b62f7047e4714626cf9/doc/adr-csrf-forgery.md</a>. The latter is a third-party link. As the information is relevant here, we're going to copy it below, but it should be clear that all the credit goes to @kemenaran:</p>
<blockquote>
<h1 id="protecting-against-request-forgery-using-crsf-tokens">Protecting against request forgery using CRSF tokens</h1>
<h2 id="context">Context</h2>
<p>Rails has CSRF protection enabled by default, to protect against POST-based CSRF attacks.</p>
<p>To protect from this, Rails stores two copies of a random token (the so-named CSRF token) on each request:</p>
<ul>
<li>one copy embedded in each HTML page,</li>
<li>another copy in the user session.</li>
</ul>
<p>When performing a POST request, Rails checks that the two copies match – and otherwise denies the request. This protects against an attacker that would generate a form secretly pointing to our website: the attacker can't read the token in the session, and so can't post a form with a valid token.</p>
<p>The problem is that, much more often, this has false positives. There are several cases for that, including:</p>
<ol>
<li><p>The web browser (often mobile) loads a page containing a form, then is closed by the user. Later, when the browser is re-opened, it restores the page from the cache. But the session cookie has expired, and so is not restored – so the copy of the CSRF token stored in the session is missing. When the user submits the form, they get an "InvalidAuthenticityToken" exception.</p>
</li>
<li><p>The user attempts to fill a form, and gets an error message (usually in response to a POST request). They close the browser. When the browser is re-opened, it attempts to restore the page. On Chrome this is blocked by the browser, because the browser denies retrying a (probably non-idempotent) POST request. Safari however happily retries the POST request – but without sending any cookies (in an attempt to avoid having unexpected side-effects). So the copy of the CSRF token in the session is missing (because no cookie was sent), and the user get an "InvalidAuthenticityToken" exception.</p>
</li>
</ol>
<h2 id="options-considered">Options considered</h2>
<h3 id="extend-the-session-cookie-duration">Extend the session cookie duration</h3>
<p>We can configure the session cookie to be valid for a longer time (like 2 weeks).</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the browser restores the page, the session cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Users would be signed-in for a much longer time by default, which has unacceptable security implications.</li>
<li>It doesn't solve 2. (because Safari doesn't send any cookie when restoring a page from a POST request)</li>
</ul>
<h3 id="change-the-cache-parameters">Change the cache parameters</h3>
<p>We can send a HTTP cache header stating 'Cache-Control: no-store, no-cache'. This instructs the browser to never keep any copy of the page, and to always make a request to the server to restore it.</p>
<p>This solution was attempted during a year in production, and solved 1. – but also introduced another type of InvalidAuthenticityToken errors. In that scenario, the user attempts to fill a form, and gets an error message (usually in response to a POST request). They then navigate on another domain (like France Connect), then hit the "Back" button. Crossing back the domain boundary may cause the browser to either block the request or retry an invalid POST request.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because on relaunch the browser requests a fresh page again (instead of serving it from its cache), thus retrieving a fresh session and a fresh matching CSRF token.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2.</li>
<li>It causes another type of InvalidAuthenticityToken errors.</li>
</ul>
<h3 id="using-a-null-session-strategy">Using a null-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :null_session. This makes the current request use an empty session for the request duration.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>The user is asked to sign-in only after filling and submitting the form, losing their time and data</li>
<li>The user will not be redirected to their original page after signing-in</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
</ul>
<h3 id="using-a-reset-session-strategy">Using a reset-session strategy</h3>
<p>We can change the default protect_from_forgery strategy to :reset_session. This clears the user session permanently, logging them out until they log in again.</p>
<p>Pros: </p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted.</li>
</ul>
<p>Cons:</p>
<ul>
<li>A forgery error in a browser tab will disconnect the user in all its open tabs</li>
<li>It has potential security implications: as the (potentically malicious) request runs anyway, variables cached by a controller before the Null session is created may allow the form submission to succeed anyway (<a href="https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails">https://www.veracode.com/blog/managing-appsec/when-rails-protectfromforgery-fails</a>)</li>
<li>It allows an attacker to disconnect an user on demand, which is not only inconvenient, but also has security implication (the attacker could then log the user on it's own attacker account, pretending to be the user account)</li>
</ul>
<h3 id="redirect-to-login-form">Redirect to login form</h3>
<p>When a forgery error occurs, we can instead redirect to the login form.</p>
<p>Pros:</p>
<ul>
<li>It kind of solves 1., by redirecting to a "Please sign-in" page when a stale form is submitted (but the user data is lost).</li>
<li>It kind of solves 2., by redirecting to a "Please sign-in" page when a previously POSTed form is reloaded.</li>
</ul>
<p>Cons:</p>
<ul>
<li>Not all forms require authentication – so for public forms there is no point redirecting to the login form. </li>
<li>The user will not be redirected to their original page after signing-in (because setting the redirect path is a state-changing action, and it is dangerous to let an unauthorized request changing the state – an attacker could control the path where an user is automatically redirected to.)</li>
<li>The implementation is finicky, and may introduce security errors. For instance, a naive implementation that catches the exception and redirect_to the sign-in page will prevent Devise from running a cleanup code – which means the user will still be logged, and the CSRF protection is bypassed. However a well-tested implementation that lets Devise code run should avoid these pittfalls.</li>
</ul>
<h3 id="using-a-long-lived-cookie-for-csrf-tokens">Using a long-lived cookie for CSRF tokens</h3>
<p>Instead of storing the CSRF token in the session cookie (which is deleted when the browser is closed), we can instead store it in a longer-lived cookie. For this we need to patch Rails.</p>
<p>Pros:</p>
<ul>
<li>It solves 1., because when the user submits a stale form, even if the session cookie because stale, the long-lived CSRF cookie is still valid.</li>
</ul>
<p>Cons:</p>
<ul>
<li>It doesn't solve 2., because when Safari retries a POST request, it sends none of the cookies (not even long-lived ones).</li>
<li>Patching Rails may introduce security issues (now or in the future)</li>
</ul>
</blockquote>
<h4 id="broken-behavior-due-to-session-expiration--template-cache">Broken behavior due to session expiration + template cache</h4>
<p>Although pretty unlikely, you should make sure that your current setup for cache/session expiration is compatible. The upgrade can break the addition of products to the cart if both:</p>
<ul>
<li><p>The "Add to cart" form is being cached (usually along with the variant information).</p>
</li>
<li><p>A user session is reset at every or every few requests.</p>
</li>
</ul>
<p>The token validation depends on the issuing and consuming sessions being the same. If a product page is cached with the token in it, it can become stale on a subsequent rendering if the session changes.</p>
<p>To check that you're safe, after having upgraded locally, go through the following steps:</p>
<ul>
<li><p>Enable cache on dev mode:</p>
<pre><code class="language-bash">bin/rails dev:cache
</code></pre>
</li>
<li><p>Visit the page for a variant with stock.</p>
</li>
<li><p>Reload that page several times.</p>
</li>
<li><p>Click on the "Add to cart"  button.</p>
</li>
<li><p>Remember to rerun <code>bin/rails dev:cache</code> to turn off cache again.</p>
</li>
</ul>
<p>No error or session reset should happen.</p>
<p>Otherwise, you can try with:</p>
<ul>
<li>Revisiting how your session gets expired.</li>
<li>Changing the caching strategy to exclude the token.</li>
</ul>
<h4 id="using-weaker-csrf-protection-strategies">Using weaker CSRF protection strategies</h4>
<p>It's also important to understand that a complete fix will only be in place when using the <code>:exception</code> forgery protection strategy. The <code>solidus_frontend</code> engine can't do pretty much anything otherwise. Using weaker CSRF strategies should be an informed and limited decision made by the application team. After the upgrade:</p>
<ul>
<li><p>An app using <code>:null_session</code> should also be safe, but there will be side effects. That strategy runs with a null object session. As such, no order and no user is found on it. A new <code>cart</code> state order is created in the database, associated with no user. Next time the user visits the site, they won't find any difference in its cart state.</p>
</li>
<li><p>An app using <code>:reset_session</code> is not entirely safe. That strategy resets the session. That means that registered users will be logged out. Next time a user visits, they'll see the cart with the items added during the CSRF attack, although it won't be associated with their account in the case of registered users.</p>
</li>
</ul>
<h4 id="reversing-the-update">Reversing the update</h4>
<p>If you still want to deploy the upgraded version before changing your application code (if the latter is needed), you can add the following workaround to your <code>config/application.rb</code> (however, take into account that you'll keep being vulnerable):</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.skip_before_action :verify_authenticity_token, only: [:populate]
end
</code></pre>
<h3 id="workarounds">Workarounds</h3>
<p>If an upgrade is not an option, you can work around the issue by adding the following to <code>config/application.rb</code>:</p>
<pre><code class="language-ruby">config.after_initialize do
  Spree::OrdersController.protect_from_forgery with: ApplicationController.forgery_protection_strategy.name.demodulize.underscore.to_sym, only: [:populate]
end
</code></pre>
<p>However, go through the same safety check detailed on "Upgrade notes" above.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">CSRF on the Rails guides</a></li>
<li><a href="https://medium.com/rubyinside/a-deep-dive-into-csrf-protection-in-rails-19fa0a42c0ef">How CSRF tokens are generated and validated on Rails</a></li>
<li><a href="https://solidus.io/security/">Solidus security</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an <a href="https://github.com/solidusio/solidus/issues">issue</a> or a <a href="https://github.com/solidusio/solidus/discussions">discussion</a> in Solidus.</li>
<li>Email us at <a href="mailto:security@soliidus.io">security@solidus.io</a></li>
<li>Contact the core team on <a href="http://slack.solidus.io/">Slack</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/solidusio/solidus/security/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43846">https://nvd.nist.gov/vuln/detail/CVE-2021-43846</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81">https://github.com/solidusio/solidus/commit/4d17cacf066d9492fc04eb3a0b16084b47376d81</a></li>
<li><a href="https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6">https://github.com/solidusio/solidus/commit/a1b9bf7f24f9b8684fc4d943eacb02b1926c77c6</a></li>
<li><a href="https://github.com/advisories/GHSA-h3fg-h5v3-vf8m">https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h3fg-h5v3-vf8m</uri>
        </author>
        <published>2022-01-06T18:33:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[message_bus] Path traversal when MessageBus::Diagnostics is enabled]]></title>
        <id>https://github.com/advisories/GHSA-xmgj-5fh3-xjmm</id>
        <link href="https://github.com/advisories/GHSA-xmgj-5fh3-xjmm"/>
        <updated>2022-01-03T15:46:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Users who deployed message bus with diagnostics features enabled (default off) were vulnerable to a path traversal bug, which could lead to disclosure of secret information on a machine if an unintended user were to gain access to the diagnostic route. The impact is also greater if there is no proxy for your web application as the number of steps up the directories is not bounded. For deployments which uses a proxy, the impact varies. For example, If a request goes through a proxy like Nginx with <code>merge_slashes</code> enabled, the number of steps up the directories that can be read is limited to 3 levels. </p>
<h3 id="patches">Patches</h3>
<p>Patched in 3.3.7.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Disable MessageBus::Diagnostics in production like environments. </p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/discourse/message_bus/security/advisories/GHSA-xmgj-5fh3-xjmm">https://github.com/discourse/message_bus/security/advisories/GHSA-xmgj-5fh3-xjmm</a></li>
<li><a href="https://github.com/discourse/message_bus/commit/9b6deee01ed474c7e9b5ff65a06bb0447b4db2ba">https://github.com/discourse/message_bus/commit/9b6deee01ed474c7e9b5ff65a06bb0447b4db2ba</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43840">https://nvd.nist.gov/vuln/detail/CVE-2021-43840</a></li>
<li><a href="https://github.com/advisories/GHSA-xmgj-5fh3-xjmm">https://github.com/advisories/GHSA-xmgj-5fh3-xjmm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xmgj-5fh3-xjmm</uri>
        </author>
        <published>2021-12-17T19:59:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cgi] Buffer overrun vulnerability in CGI]]></title>
        <id>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</id>
        <link href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv"/>
        <updated>2022-02-16T21:57:48.000Z</updated>
        <content type="html"><![CDATA[<p>A security vulnerability that causes buffer overflow when you pass a very large string (&gt; 700 MB) to CGI.escape_html on a platform where long type takes 4 bytes, typically, Windows.</p>
<p>Please update the cgi gem to version 0.3.1, 0.2,1, and 0.1,1 or later. You can use gem update cgi to update it. If you are using bundler, please add gem "cgi", "&gt;= 0.3.1" to your Gemfile. Alternatively, please update Ruby to 2.7.5 or 3.0.3.</p>
<p>This issue has been introduced since Ruby 2.7, so the cgi version bundled with Ruby 2.6 is not vulnerable.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-41816">https://nvd.nist.gov/vuln/detail/CVE-2021-41816</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c">https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c</a></li>
<li><a href="https://hackerone.com/reports/1328463">https://hackerone.com/reports/1328463</a></li>
<li><a href="https://security-tracker.debian.org/tracker/CVE-2021-41816">https://security-tracker.debian.org/tracker/CVE-2021-41816</a></li>
<li><a href="https://www.ruby-lang.org/en/news/2021/11/24/buffer-overrun-in-cgi-escape_html-cve-2021-41816/">https://www.ruby-lang.org/en/news/2021/11/24/buffer-overrun-in-cgi-escape_html-cve-2021-41816/</a></li>
<li><a href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv">https://github.com/advisories/GHSA-5cqm-crxm-6qpv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</uri>
        </author>
        <published>2021-12-14T21:36:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cgi] Buffer overrun vulnerability in CGI]]></title>
        <id>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</id>
        <link href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv"/>
        <updated>2022-02-16T21:57:48.000Z</updated>
        <content type="html"><![CDATA[<p>A security vulnerability that causes buffer overflow when you pass a very large string (&gt; 700 MB) to CGI.escape_html on a platform where long type takes 4 bytes, typically, Windows.</p>
<p>Please update the cgi gem to version 0.3.1, 0.2,1, and 0.1,1 or later. You can use gem update cgi to update it. If you are using bundler, please add gem "cgi", "&gt;= 0.3.1" to your Gemfile. Alternatively, please update Ruby to 2.7.5 or 3.0.3.</p>
<p>This issue has been introduced since Ruby 2.7, so the cgi version bundled with Ruby 2.6 is not vulnerable.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-41816">https://nvd.nist.gov/vuln/detail/CVE-2021-41816</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c">https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c</a></li>
<li><a href="https://hackerone.com/reports/1328463">https://hackerone.com/reports/1328463</a></li>
<li><a href="https://security-tracker.debian.org/tracker/CVE-2021-41816">https://security-tracker.debian.org/tracker/CVE-2021-41816</a></li>
<li><a href="https://www.ruby-lang.org/en/news/2021/11/24/buffer-overrun-in-cgi-escape_html-cve-2021-41816/">https://www.ruby-lang.org/en/news/2021/11/24/buffer-overrun-in-cgi-escape_html-cve-2021-41816/</a></li>
<li><a href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv">https://github.com/advisories/GHSA-5cqm-crxm-6qpv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</uri>
        </author>
        <published>2021-12-14T21:36:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cgi] Buffer overrun vulnerability in CGI]]></title>
        <id>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</id>
        <link href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv"/>
        <updated>2022-02-16T21:57:48.000Z</updated>
        <content type="html"><![CDATA[<p>A security vulnerability that causes buffer overflow when you pass a very large string (&gt; 700 MB) to CGI.escape_html on a platform where long type takes 4 bytes, typically, Windows.</p>
<p>Please update the cgi gem to version 0.3.1, 0.2,1, and 0.1,1 or later. You can use gem update cgi to update it. If you are using bundler, please add gem "cgi", "&gt;= 0.3.1" to your Gemfile. Alternatively, please update Ruby to 2.7.5 or 3.0.3.</p>
<p>This issue has been introduced since Ruby 2.7, so the cgi version bundled with Ruby 2.6 is not vulnerable.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-41816">https://nvd.nist.gov/vuln/detail/CVE-2021-41816</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c">https://groups.google.com/g/ruby-security-ann/c/4MQ568ZG47c</a></li>
<li><a href="https://hackerone.com/reports/1328463">https://hackerone.com/reports/1328463</a></li>
<li><a href="https://security-tracker.debian.org/tracker/CVE-2021-41816">https://security-tracker.debian.org/tracker/CVE-2021-41816</a></li>
<li><a href="https://www.ruby-lang.org/en/news/2021/11/24/buffer-overrun-in-cgi-escape_html-cve-2021-41816/">https://www.ruby-lang.org/en/news/2021/11/24/buffer-overrun-in-cgi-escape_html-cve-2021-41816/</a></li>
<li><a href="https://github.com/advisories/GHSA-5cqm-crxm-6qpv">https://github.com/advisories/GHSA-5cqm-crxm-6qpv</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5cqm-crxm-6qpv</uri>
        </author>
        <published>2021-12-14T21:36:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Open Redirect in actionpack]]></title>
        <id>https://github.com/advisories/GHSA-qphc-hf5q-v8fc</id>
        <link href="https://github.com/advisories/GHSA-qphc-hf5q-v8fc"/>
        <updated>2022-01-18T22:37:46.000Z</updated>
        <content type="html"><![CDATA[<p>Specially crafted "X-Forwarded-Host" headers in combination with certain
"allowed host" formats can cause the Host Authorization middleware in Action
Pack to redirect users to a malicious website.</p>
<p>Impacted applications will have allowed hosts with a leading dot. For example,
configuration files that look like this:</p>
<pre><code>config.hosts &lt;&lt;  '.EXAMPLE.com'
</code></pre>
<p>When an allowed host contains a leading dot, a specially crafted Host header
can be used to redirect to a malicious website.</p>
<p>This vulnerability is similar to CVE-2021-22881 and CVE-2021-22942.</p>
<h2 id="releases">Releases</h2>
<p>The fixed releases are available at the normal locations.</p>
<h2 id="patches">Patches</h2>
<p>To aid users who aren't able to upgrade immediately we have provided patches for
the two supported release series. They are in git-am format and consist of a
single changeset.</p>
<ul>
<li>6-0-host-authorzation-open-redirect.patch - Patch for 6.0 series</li>
<li>6-1-host-authorzation-open-redirect.patch - Patch for 6.1 series</li>
<li>7-0-host-authorzation-open-redirect.patch - Patch for 7.0 series</li>
</ul>
<p>Please note that only the 6.1.Z, 6.0.Z, and 5.2.Z series are supported at
present. Users of earlier unsupported releases are advised to upgrade as soon
as possible as we cannot guarantee the continued availability of security
fixes for unsupported releases.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44528">https://nvd.nist.gov/vuln/detail/CVE-2021-44528</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/vG9gz3nk1pM/m/7-NU4MNrDAAJ?utm_medium=email&amp;utm_source=footer">https://groups.google.com/g/ruby-security-ann/c/vG9gz3nk1pM/m/7-NU4MNrDAAJ?utm_medium=email&amp;utm_source=footer</a></li>
<li><a href="https://github.com/rails/rails/commit/aecba3c301b80e9d5a63c30ea1b287bceaf2c107">https://github.com/rails/rails/commit/aecba3c301b80e9d5a63c30ea1b287bceaf2c107</a></li>
<li><a href="https://github.com/rails/rails/blob/v6.1.4.2/actionpack/CHANGELOG.md#rails-6142-december-14-2021">https://github.com/rails/rails/blob/v6.1.4.2/actionpack/CHANGELOG.md#rails-6142-december-14-2021</a></li>
<li><a href="https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815">https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815</a></li>
<li><a href="https://github.com/advisories/GHSA-qphc-hf5q-v8fc">https://github.com/advisories/GHSA-qphc-hf5q-v8fc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qphc-hf5q-v8fc</uri>
        </author>
        <published>2021-12-14T21:19:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[actionpack] Open Redirect in actionpack]]></title>
        <id>https://github.com/advisories/GHSA-qphc-hf5q-v8fc</id>
        <link href="https://github.com/advisories/GHSA-qphc-hf5q-v8fc"/>
        <updated>2022-01-18T22:37:46.000Z</updated>
        <content type="html"><![CDATA[<p>Specially crafted "X-Forwarded-Host" headers in combination with certain
"allowed host" formats can cause the Host Authorization middleware in Action
Pack to redirect users to a malicious website.</p>
<p>Impacted applications will have allowed hosts with a leading dot. For example,
configuration files that look like this:</p>
<pre><code>config.hosts &lt;&lt;  '.EXAMPLE.com'
</code></pre>
<p>When an allowed host contains a leading dot, a specially crafted Host header
can be used to redirect to a malicious website.</p>
<p>This vulnerability is similar to CVE-2021-22881 and CVE-2021-22942.</p>
<h2 id="releases">Releases</h2>
<p>The fixed releases are available at the normal locations.</p>
<h2 id="patches">Patches</h2>
<p>To aid users who aren't able to upgrade immediately we have provided patches for
the two supported release series. They are in git-am format and consist of a
single changeset.</p>
<ul>
<li>6-0-host-authorzation-open-redirect.patch - Patch for 6.0 series</li>
<li>6-1-host-authorzation-open-redirect.patch - Patch for 6.1 series</li>
<li>7-0-host-authorzation-open-redirect.patch - Patch for 7.0 series</li>
</ul>
<p>Please note that only the 6.1.Z, 6.0.Z, and 5.2.Z series are supported at
present. Users of earlier unsupported releases are advised to upgrade as soon
as possible as we cannot guarantee the continued availability of security
fixes for unsupported releases.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-44528">https://nvd.nist.gov/vuln/detail/CVE-2021-44528</a></li>
<li><a href="https://groups.google.com/g/ruby-security-ann/c/vG9gz3nk1pM/m/7-NU4MNrDAAJ?utm_medium=email&amp;utm_source=footer">https://groups.google.com/g/ruby-security-ann/c/vG9gz3nk1pM/m/7-NU4MNrDAAJ?utm_medium=email&amp;utm_source=footer</a></li>
<li><a href="https://github.com/rails/rails/commit/aecba3c301b80e9d5a63c30ea1b287bceaf2c107">https://github.com/rails/rails/commit/aecba3c301b80e9d5a63c30ea1b287bceaf2c107</a></li>
<li><a href="https://github.com/rails/rails/blob/v6.1.4.2/actionpack/CHANGELOG.md#rails-6142-december-14-2021">https://github.com/rails/rails/blob/v6.1.4.2/actionpack/CHANGELOG.md#rails-6142-december-14-2021</a></li>
<li><a href="https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815">https://github.com/rails/rails/commit/0fccfb9a3097a9c4260c791f1a40b128517e7815</a></li>
<li><a href="https://github.com/advisories/GHSA-qphc-hf5q-v8fc">https://github.com/advisories/GHSA-qphc-hf5q-v8fc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qphc-hf5q-v8fc</uri>
        </author>
        <published>2021-12-14T21:19:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[devise_masquerade] Improper Privilege Management in devise_masquerade]]></title>
        <id>https://github.com/advisories/GHSA-25f5-gc4h-hc22</id>
        <link href="https://github.com/advisories/GHSA-25f5-gc4h-hc22"/>
        <updated>2021-12-14T15:33:15.000Z</updated>
        <content type="html"><![CDATA[<p>The devise_masquerade gem before 1.3 allows certain attacks when a password's salt is unknown. An application that uses this gem to let administrators masquerade/impersonate users loses one layer of security protection compared to a situation where Devise (without this extension) is used. If the server-side secret_key_base value became publicly known (for instance if it is committed to a public repository by mistake), there are still other protections in place that prevent an attacker from impersonating any user on the site. When masquerading is not used in a plain Devise application, one must know the password salt of the target user if one wants to encrypt and sign a valid session cookie. When devise_masquerade is used, however, an attacker can decide which user the "back" action will go back to without knowing that user's password salt and simply knowing the user ID, by manipulating the session cookie and pretending that a user is already masqueraded by an administrator.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-28680">https://nvd.nist.gov/vuln/detail/CVE-2021-28680</a></li>
<li><a href="https://github.com/oivoodoo/devise_masquerade/issues/83">https://github.com/oivoodoo/devise_masquerade/issues/83</a></li>
<li><a href="https://labanskoller.se/blog/2021/03/23/the-devise-extension-that-peeled-off-one-layer-of-the-security-onion-cve-2021-28680/">https://labanskoller.se/blog/2021/03/23/the-devise-extension-that-peeled-off-one-layer-of-the-security-onion-cve-2021-28680/</a></li>
<li><a href="https://github.com/oivoodoo/devise_masquerade/pull/76">https://github.com/oivoodoo/devise_masquerade/pull/76</a></li>
<li><a href="https://github.com/oivoodoo/devise_masquerade/releases/tag/v1.3.1">https://github.com/oivoodoo/devise_masquerade/releases/tag/v1.3.1</a></li>
<li><a href="https://github.com/advisories/GHSA-25f5-gc4h-hc22">https://github.com/advisories/GHSA-25f5-gc4h-hc22</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-25f5-gc4h-hc22</uri>
        </author>
        <published>2021-12-08T19:55:30.000Z</published>
    </entry>
</feed>