<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2023-06-13T19:01:38.746Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[lru] Use after free in lru crate]]></title>
        <id>https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</id>
        <link href="https://github.com/advisories/GHSA-qqmc-hwqp-8g2w"/>
        <updated>2023-06-13T18:40:06.000Z</updated>
        <content type="html"><![CDATA[<p>Lru crate has use after free vulnerability.</p>
<p>Lru crate has two functions for getting an iterator. Both iterators give
references to key and value. Calling specific functions, like pop(), will remove
and free the value, and but it's still possible to access the reference of value
which is already dropped causing use after free.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jeromefroe/lru-rs/issues/120">https://github.com/jeromefroe/lru-rs/issues/120</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0130.html">https://rustsec.org/advisories/RUSTSEC-2021-0130.html</a></li>
<li><a href="https://github.com/advisories/GHSA-qqmc-hwqp-8g2w">https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-17T00:11:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lru] Use After Free in lru]]></title>
        <id>https://github.com/advisories/GHSA-v362-2895-h9r2</id>
        <link href="https://github.com/advisories/GHSA-v362-2895-h9r2"/>
        <updated>2023-06-13T18:38:44.000Z</updated>
        <content type="html"><![CDATA[<p>Lru crate has two functions for getting an iterator. Both iterators give references to key and value. Calling specific functions, like pop(), will remove and free the value, and but it's still possible to access the reference of value which is already dropped causing use after free.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45720">https://nvd.nist.gov/vuln/detail/CVE-2021-45720</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/lru/RUSTSEC-2021-0130.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/lru/RUSTSEC-2021-0130.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0130.html">https://rustsec.org/advisories/RUSTSEC-2021-0130.html</a></li>
<li><a href="https://github.com/jeromefroe/lru-rs/issues/120">https://github.com/jeromefroe/lru-rs/issues/120</a></li>
<li><a href="https://github.com/advisories/GHSA-v362-2895-h9r2">https://github.com/advisories/GHSA-v362-2895-h9r2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-v362-2895-h9r2</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-01-07T22:37:01.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nanorand] Pointer dereference in nanorand]]></title>
        <id>https://github.com/advisories/GHSA-r57r-j98g-587f</id>
        <link href="https://github.com/advisories/GHSA-r57r-j98g-587f"/>
        <updated>2023-06-13T18:38:09.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the nanorand crate before 0.6.1 for Rust. There can be multiple mutable references to the same object because the TlsWyRand Deref implementation dereferences a raw pointer.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45705">https://nvd.nist.gov/vuln/detail/CVE-2021-45705</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nanorand/RUSTSEC-2021-0114.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nanorand/RUSTSEC-2021-0114.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0114.html">https://rustsec.org/advisories/RUSTSEC-2021-0114.html</a></li>
<li><a href="https://github.com/Absolucy/nanorand-rs/issues/28">https://github.com/Absolucy/nanorand-rs/issues/28</a></li>
<li><a href="https://github.com/advisories/GHSA-r57r-j98g-587f">https://github.com/advisories/GHSA-r57r-j98g-587f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r57r-j98g-587f</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-01-06T22:08:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nanorand] Aliased mutable references from `tls_rand` & `TlsWyRand`]]></title>
        <id>https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</id>
        <link href="https://github.com/advisories/GHSA-p6gj-gpc8-f8xw"/>
        <updated>2023-06-13T18:37:41.000Z</updated>
        <content type="html"><![CDATA[<p><code>TlsWyRand</code>'s implementation of <code>Deref</code> unconditionally dereferences a raw pointer, and returns 
multiple mutable references to the same object, which is undefined behavior.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Absolucy/nanorand-rs/issues/28">https://github.com/Absolucy/nanorand-rs/issues/28</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0114.html">https://rustsec.org/advisories/RUSTSEC-2021-0114.html</a></li>
<li><a href="https://github.com/advisories/GHSA-p6gj-gpc8-f8xw">https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-06-17T00:13:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[neon] Use after free in Neon external buffers]]></title>
        <id>https://github.com/advisories/GHSA-8mj7-wxmc-f424</id>
        <link href="https://github.com/advisories/GHSA-8mj7-wxmc-f424"/>
        <updated>2023-06-13T18:37:13.000Z</updated>
        <content type="html"><![CDATA[<p>Neon provides functionality for creating JavaScript <code>ArrayBuffer</code> (and the <code>Buffer</code> subtype) instances backed by bytes allocated outside of V8/Node. The <a href="https://docs.rs/neon/0.10.0/neon/types/struct.JsArrayBuffer.html#method.external"><code>JsArrayBuffer::external</code></a> and <a href="https://docs.rs/neon/0.10.0/neon/types/struct.JsBuffer.html#method.external"><code>JsBuffer::external</code></a> did not require <code>T: 'static</code> prior to Neon <code>0.10.1</code>. This allowed creating an externally backed buffer from types that may be freed while they are still referenced by a JavaScript <code>ArrayBuffer</code>.</p>
<p>The following example demonstrates use after free. It compiles on versions <code>&lt;0.10.1</code> and fails to compile afterward.</p>
<pre><code class="language-rust">pub fn soundness_hole(mut cx: FunctionContext) -&gt; JsResult&lt;JsArrayBuffer&gt; {
    let mut data = vec![0u8, 1, 2, 3];
    
    // Creating an external from `&amp;mut [u8]` instead of `Vec&lt;u8&gt;` since there is a blanket impl
    // of `AsMut&lt;T&gt; for &amp;mut T`
    let buf = JsArrayBuffer::external(&amp;mut cx, data.as_mut_slice());

    // `buf` is still holding a reference to `data`!
    drop(data);

    Ok(buf)
}
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/neon-bindings/neon/issues/896">https://github.com/neon-bindings/neon/issues/896</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0028.html">https://rustsec.org/advisories/RUSTSEC-2022-0028.html</a></li>
<li><a href="https://github.com/advisories/GHSA-8mj7-wxmc-f424">https://github.com/advisories/GHSA-8mj7-wxmc-f424</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8mj7-wxmc-f424</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-17T00:13:40.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds write in nix::unistd::getgrouplist]]></title>
        <id>https://github.com/advisories/GHSA-wgrg-5h56-jg27</id>
        <link href="https://github.com/advisories/GHSA-wgrg-5h56-jg27"/>
        <updated>2023-06-13T18:36:31.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the
<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>
function with a length parameter greater than the size of the buffer it
provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>
specifying the size of the group buffer. When the buffer is too small to
hold all of the reqested user's group memberships, some libc
implementations, including glibc and Solaris libc, will modify <code>ngroups</code>
to indicate the actual number of groups for the user, in addition to
returning an error. The version of <code>nix::unistd::getgrouplist</code> in nix
0.16.0 and up will resize the buffer to twice its size, but will not
read or modify the <code>ngroups</code> variable. Thus, if the user has more than
twice as many groups as the initial buffer size of 8, the next call to
<code>getgrouplist</code> will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually
only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wgrg-5h56-jg27</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-17T00:13:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds write in nix::unistd::getgrouplist]]></title>
        <id>https://github.com/advisories/GHSA-wgrg-5h56-jg27</id>
        <link href="https://github.com/advisories/GHSA-wgrg-5h56-jg27"/>
        <updated>2023-06-13T18:36:31.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the
<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>
function with a length parameter greater than the size of the buffer it
provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>
specifying the size of the group buffer. When the buffer is too small to
hold all of the reqested user's group memberships, some libc
implementations, including glibc and Solaris libc, will modify <code>ngroups</code>
to indicate the actual number of groups for the user, in addition to
returning an error. The version of <code>nix::unistd::getgrouplist</code> in nix
0.16.0 and up will resize the buffer to twice its size, but will not
read or modify the <code>ngroups</code> variable. Thus, if the user has more than
twice as many groups as the initial buffer size of 8, the next call to
<code>getgrouplist</code> will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually
only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wgrg-5h56-jg27</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-17T00:13:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds write in nix::unistd::getgrouplist]]></title>
        <id>https://github.com/advisories/GHSA-wgrg-5h56-jg27</id>
        <link href="https://github.com/advisories/GHSA-wgrg-5h56-jg27"/>
        <updated>2023-06-13T18:36:31.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the
<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>
function with a length parameter greater than the size of the buffer it
provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>
specifying the size of the group buffer. When the buffer is too small to
hold all of the reqested user's group memberships, some libc
implementations, including glibc and Solaris libc, will modify <code>ngroups</code>
to indicate the actual number of groups for the user, in addition to
returning an error. The version of <code>nix::unistd::getgrouplist</code> in nix
0.16.0 and up will resize the buffer to twice its size, but will not
read or modify the <code>ngroups</code> variable. Thus, if the user has more than
twice as many groups as the initial buffer size of 8, the next call to
<code>getgrouplist</code> will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually
only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wgrg-5h56-jg27</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-17T00:13:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds Write in nix]]></title>
        <id>https://github.com/advisories/GHSA-76w9-p8mg-j927</id>
        <link href="https://github.com/advisories/GHSA-76w9-p8mg-j927"/>
        <updated>2023-06-13T18:32:57.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45707">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://github.com/advisories/GHSA-76w9-p8mg-j927">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-76w9-p8mg-j927</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-01-06T22:07:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds Write in nix]]></title>
        <id>https://github.com/advisories/GHSA-76w9-p8mg-j927</id>
        <link href="https://github.com/advisories/GHSA-76w9-p8mg-j927"/>
        <updated>2023-06-13T18:32:57.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45707">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://github.com/advisories/GHSA-76w9-p8mg-j927">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-76w9-p8mg-j927</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-01-06T22:07:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds Write in nix]]></title>
        <id>https://github.com/advisories/GHSA-76w9-p8mg-j927</id>
        <link href="https://github.com/advisories/GHSA-76w9-p8mg-j927"/>
        <updated>2023-06-13T18:32:57.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the nix::unistd::getgrouplist function will call the libc getgrouplist function with a length parameter greater than the size of the buffer it provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc getgrouplist function takes an in/out parameter ngroups specifying the size of the group buffer. When the buffer is too small to hold all of the requested user's group memberships, some libc implementations, including glibc and Solaris libc, will modify ngroups to indicate the actual number of groups for the user, in addition to returning an error. The version of nix::unistd::getgrouplist in nix 0.16.0 and up will resize the buffer to twice its size, but will not read or modify the ngroups variable. Thus, if the user has more than twice as many groups as the initial buffer size of 8, the next call to getgrouplist will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45707">https://nvd.nist.gov/vuln/detail/CVE-2021-45707</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/nix/RUSTSEC-2021-0119.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://github.com/advisories/GHSA-76w9-p8mg-j927">https://github.com/advisories/GHSA-76w9-p8mg-j927</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-76w9-p8mg-j927</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-01-06T22:07:14.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ncurses] Mishandling of format strings in ncurses]]></title>
        <id>https://github.com/advisories/GHSA-32v7-ghpr-c8hg</id>
        <link href="https://github.com/advisories/GHSA-32v7-ghpr-c8hg"/>
        <updated>2023-06-13T18:30:36.000Z</updated>
        <content type="html"><![CDATA[<p>ncurses exposes functions from the ncurses library which:</p>
<ul>
<li>Pass buffers without length to C functions that may write an arbitrary amount of data, leading to a buffer overflow. (instr, mvwinstr, etc)</li>
<li>Passes rust &amp;str to strings expecting C format arguments, allowing hostile input to execute a format string attack, which trivially allows writing arbitrary data to stack memory (functions in the printw family).</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-15547">https://nvd.nist.gov/vuln/detail/CVE-2019-15547</a></li>
<li><a href="https://github.com/RustSec/advisory-db/issues/106">https://github.com/RustSec/advisory-db/issues/106</a></li>
<li><a href="https://github.com/jeaye/ncurses-rs/issues/172">https://github.com/jeaye/ncurses-rs/issues/172</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0006.html">https://rustsec.org/advisories/RUSTSEC-2019-0006.html</a></li>
<li><a href="https://github.com/advisories/GHSA-32v7-ghpr-c8hg">https://github.com/advisories/GHSA-32v7-ghpr-c8hg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-32v7-ghpr-c8hg</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T20:58:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lock_api] Data races in lock_api]]></title>
        <id>https://github.com/advisories/GHSA-ppj3-7jw3-8vc4</id>
        <link href="https://github.com/advisories/GHSA-ppj3-7jw3-8vc4"/>
        <updated>2023-06-13T18:25:53.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedMutexGuard unsoundness.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35910">https://nvd.nist.gov/vuln/detail/CVE-2020-35910</a></li>
<li><a href="https://github.com/Amanieu/parking_lot/pull/262">https://github.com/Amanieu/parking_lot/pull/262</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0070.html">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-ppj3-7jw3-8vc4">https://github.com/advisories/GHSA-ppj3-7jw3-8vc4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-ppj3-7jw3-8vc4</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:49:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lock_api] Data races in lock_api]]></title>
        <id>https://github.com/advisories/GHSA-vh4p-6j7g-f4j9</id>
        <link href="https://github.com/advisories/GHSA-vh4p-6j7g-f4j9"/>
        <updated>2023-06-13T18:24:43.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of MappedRwLockReadGuard unsoundness.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35911">https://nvd.nist.gov/vuln/detail/CVE-2020-35911</a></li>
<li><a href="https://github.com/Amanieu/parking_lot/pull/262">https://github.com/Amanieu/parking_lot/pull/262</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0070.html">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-vh4p-6j7g-f4j9">https://github.com/advisories/GHSA-vh4p-6j7g-f4j9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vh4p-6j7g-f4j9</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:49:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lock_api] Data races in lock_api]]></title>
        <id>https://github.com/advisories/GHSA-hj9h-wrgg-hgmx</id>
        <link href="https://github.com/advisories/GHSA-hj9h-wrgg-hgmx"/>
        <updated>2023-06-13T18:24:18.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of RwLockReadGuard unsoundness.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35913">https://nvd.nist.gov/vuln/detail/CVE-2020-35913</a></li>
<li><a href="https://github.com/Amanieu/parking_lot/pull/262">https://github.com/Amanieu/parking_lot/pull/262</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0070.html">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-hj9h-wrgg-hgmx">https://github.com/advisories/GHSA-hj9h-wrgg-hgmx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hj9h-wrgg-hgmx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:50:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lock_api] Data races in lock_api]]></title>
        <id>https://github.com/advisories/GHSA-gmv4-vmx3-x9f3</id>
        <link href="https://github.com/advisories/GHSA-gmv4-vmx3-x9f3"/>
        <updated>2023-06-13T18:23:50.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the lock_api crate before 0.4.2 for Rust. A data race can occur because of RwLockWriteGuard unsoundness.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35914">https://nvd.nist.gov/vuln/detail/CVE-2020-35914</a></li>
<li><a href="https://github.com/Amanieu/parking_lot/pull/262">https://github.com/Amanieu/parking_lot/pull/262</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0070.html">https://rustsec.org/advisories/RUSTSEC-2020-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-gmv4-vmx3-x9f3">https://github.com/advisories/GHSA-gmv4-vmx3-x9f3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-gmv4-vmx3-x9f3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:49:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[http] Integer Overflow/Infinite Loop in the http crate]]></title>
        <id>https://github.com/advisories/GHSA-x7vr-c387-8w57</id>
        <link href="https://github.com/advisories/GHSA-x7vr-c387-8w57"/>
        <updated>2023-06-13T18:21:10.000Z</updated>
        <content type="html"><![CDATA[<p>HeaderMap::reserve() used usize::next_power_of_two() to calculate the increased capacity. However, next_power_of_two() silently overflows to 0 if given a sufficiently large number in release mode.</p>
<p>If the map was not empty when the overflow happens, the library will invoke self.grow(0) and start infinite probing. This allows an attacker who controls the argument to reserve() to cause a potential denial of service (DoS).</p>
<p>The flaw was corrected in 0.1.20 release of http crate.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-25574">https://nvd.nist.gov/vuln/detail/CVE-2020-25574</a></li>
<li><a href="https://github.com/hyperium/http/issues/352">https://github.com/hyperium/http/issues/352</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0033.html">https://rustsec.org/advisories/RUSTSEC-2019-0033.html</a></li>
<li><a href="https://github.com/advisories/GHSA-x7vr-c387-8w57">https://github.com/advisories/GHSA-x7vr-c387-8w57</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-x7vr-c387-8w57</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T21:01:31.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[http] Integer Overflow in HeaderMap::reserve() can cause Denial of Service]]></title>
        <id>https://github.com/advisories/GHSA-xvc9-xwgj-4cq9</id>
        <link href="https://github.com/advisories/GHSA-xvc9-xwgj-4cq9"/>
        <updated>2023-06-13T18:20:44.000Z</updated>
        <content type="html"><![CDATA[<p>HeaderMap::reserve() used usize::next_power_of_two() to calculate the increased capacity. However, next_power_of_two() silently overflows to 0 if given a sufficiently large number in release mode.</p>
<p>If the map was not empty when the overflow happens, the library will invoke self.grow(0) and start infinite probing. This allows an attacker who controls the argument to reserve() to cause a potential denial of service (DoS).</p>
<p>The flaw was corrected in 0.1.20 release of http crate.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-25008">https://nvd.nist.gov/vuln/detail/CVE-2019-25008</a></li>
<li><a href="https://github.com/hyperium/http/issues/352">https://github.com/hyperium/http/issues/352</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0033.html">https://rustsec.org/advisories/RUSTSEC-2019-0033.html</a></li>
<li><a href="https://github.com/advisories/GHSA-xvc9-xwgj-4cq9">https://github.com/advisories/GHSA-xvc9-xwgj-4cq9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xvc9-xwgj-4cq9</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-16T23:08:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[image] Use after free in image]]></title>
        <id>https://github.com/advisories/GHSA-m2pf-hprp-3vqm</id>
        <link href="https://github.com/advisories/GHSA-m2pf-hprp-3vqm"/>
        <updated>2023-06-13T18:18:17.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate would call Vec::set_len on an uninitialized vector with user-provided type parameter, in an interface of the HDR image format decoder. They would then also call other code that could panic before initializing all instances.</p>
<p>This could run Drop implementations on uninitialized types, equivalent to use-after-free, and allow an attacker arbitrary code execution.</p>
<p>Two different fixes were applied. It is possible to conserve the interface by ensuring proper initialization before calling Vec::set_len. Drop is no longer called in case of panic, though.</p>
<p>Starting from version 0.22, a breaking change to the interface requires callers to pre-allocate the output buffer and pass a mutable slice instead, avoiding all unsafe code.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-16138">https://nvd.nist.gov/vuln/detail/CVE-2019-16138</a></li>
<li><a href="https://github.com/image-rs/image/pull/985">https://github.com/image-rs/image/pull/985</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0014.html">https://rustsec.org/advisories/RUSTSEC-2019-0014.html</a></li>
<li><a href="https://github.com/advisories/GHSA-m2pf-hprp-3vqm">https://github.com/advisories/GHSA-m2pf-hprp-3vqm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m2pf-hprp-3vqm</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-08-25T20:44:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lazy-init] Out of bounds read in lazy-init]]></title>
        <id>https://github.com/advisories/GHSA-w47j-hqpf-qw9w</id>
        <link href="https://github.com/advisories/GHSA-w47j-hqpf-qw9w"/>
        <updated>2023-06-13T18:15:14.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the lazy-init crate through 2021-01-17 for Rust. Lazy lacks a Send bound, leading to a data race.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-25901">https://nvd.nist.gov/vuln/detail/CVE-2021-25901</a></li>
<li><a href="https://github.com/khuey/lazy-init/issues/9">https://github.com/khuey/lazy-init/issues/9</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0004.html">https://rustsec.org/advisories/RUSTSEC-2021-0004.html</a></li>
<li><a href="https://github.com/advisories/GHSA-w47j-hqpf-qw9w">https://github.com/advisories/GHSA-w47j-hqpf-qw9w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-w47j-hqpf-qw9w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:52:59.000Z</published>
    </entry>
</feed>