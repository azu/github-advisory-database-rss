<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2024-10-20T22:01:23.390Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[pyo3]  PyO3 has a risk of use-after-free in `borrowed` reads from Python weak references]]></title>
        <id>https://github.com/advisories/GHSA-6jgw-rgmm-7cv6</id>
        <link href="https://github.com/advisories/GHSA-6jgw-rgmm-7cv6"/>
        <updated>2024-10-15T17:04:56.000Z</updated>
        <content type="html"><![CDATA[<p>The family of functions to read "borrowed" values from Python weak references were fundamentally unsound, because the weak reference does itself not have ownership of the value. At any point the last strong reference could be cleared and the borrowed value would become dangling.</p>
<p>In PyO3 0.22.4 these functions have all been deprecated and patched to leak a strong reference as a mitigation. PyO3 0.23 will remove these functions entirely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-9979">https://nvd.nist.gov/vuln/detail/CVE-2024-9979</a></li>
<li><a href="https://github.com/PyO3/pyo3/pull/4590">https://github.com/PyO3/pyo3/pull/4590</a></li>
<li><a href="https://access.redhat.com/security/cve/CVE-2024-9979">https://access.redhat.com/security/cve/CVE-2024-9979</a></li>
<li><a href="https://bugzilla.redhat.com/show_bug.cgi?id=2318646">https://bugzilla.redhat.com/show_bug.cgi?id=2318646</a></li>
<li><a href="https://crates.io/crates/pyo3">https://crates.io/crates/pyo3</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0378.html">https://rustsec.org/advisories/RUSTSEC-2024-0378.html</a></li>
<li><a href="https://github.com/advisories/GHSA-6jgw-rgmm-7cv6">https://github.com/advisories/GHSA-6jgw-rgmm-7cv6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6jgw-rgmm-7cv6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-15T15:30:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[pyo3] Duplicate Advisory: PyO3 has a risk of use-after-free in `borrowed` reads from Python weak references]]></title>
        <id>https://github.com/advisories/GHSA-f8x4-f32r-w556</id>
        <link href="https://github.com/advisories/GHSA-f8x4-f32r-w556"/>
        <updated>2024-10-15T17:13:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="duplicate-advisory">Duplicate Advisory</h2>
<p>This advisory has been withdrawn because it is a duplicate of GHSA-6jgw-rgmm-7cv6. This link is maintained to preserve external references.</p>
<h2 id="original-advisory">Original Advisory</h2>
<p>The family of functions to read "borrowed" values from Python weak references were fundamentally unsound, because the weak reference does itself not have ownership of the value. At any point the last strong reference could be cleared and the borrowed value would become dangling.</p>
<p>In PyO3 0.22.4 these functions have all been deprecated and patched to leak a strong reference as a mitigation. PyO3 0.23 will remove these functions entirely.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/PyO3/pyo3/pull/4590">https://github.com/PyO3/pyo3/pull/4590</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0378.html">https://rustsec.org/advisories/RUSTSEC-2024-0378.html</a></li>
<li><a href="https://github.com/advisories/GHSA-f8x4-f32r-w556">https://github.com/advisories/GHSA-f8x4-f32r-w556</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-f8x4-f32r-w556</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-15T14:08:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations]]></title>
        <id>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</id>
        <link href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m"/>
        <updated>2024-10-09T19:14:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>
<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the "References" section below for a list of Wasmtime types-related APIs that are affected.</p>
<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see "References" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>
<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>
<table>
<thead>
<tr>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>decref(E) --&gt; 0</code></td>
</tr>
<tr>
<td></td>
<td><code>block_on(type registry lock)</code></td>
</tr>
<tr>
<td><code>register(E') == incref(E) --&gt; 1</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>decref(E) --&gt; 0</code></td>
<td></td>
</tr>
<tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>unregister(E)</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>acquire(type registry lock)</code></td>
</tr>
<tr>
<td></td>
<td><code>unregister(E)</code></td>
</tr>
</tbody></table>
<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>
<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>
<h3 id="patches">Patches</h3>
<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>
<ul>
<li>21.0.2</li>
<li>22.0.1</li>
<li>23.0.3</li>
<li>24.0.1</li>
<li>25.0.2</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>
<h3 id="references">References</h3>
<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new"><code>wasmtime::FuncType::new</code></a><ul>
<li>Also reachable from creation of <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html"><code>wasmtime::Func</code></a></li>
<li>Also reachable from <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new"><code>wasmtime::Linker::func_*</code></a></li>
</ul>
</li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new"><code>wasmtime::ArrayType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new"><code>wasmtime::StructType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty"><code>wasmtime::Func::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty"><code>wasmtime::Global::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty"><code>wasmtime::Table::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty"><code>wasmtime::Extern::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty"><code>wasmtime::Export::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty"><code>wasmtime::UnknownImportError::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty"><code>wasmtime::ImportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty"><code>wasmtime::ExportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty"><code>wasmtime::Val::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty"><code>wasmtime::Ref::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty"><code>wasmtime::AnyRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty"><code>wasmtime::EqRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty"><code>wasmtime::ArrayRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty"><code>wasmtime::StructRef::ty</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html"><code>wasmtime::FuncType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html"><code>wasmtime::ArrayType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html"><code>wasmtime::StructType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html"><code>wasmtime::ExternType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html"><code>wasmtime::GlobalType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html"><code>wasmtime::TableType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html"><code>wasmtime::ValType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html"><code>wasmtime::RefType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html"><code>wasmtime::HeapType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html"><code>wasmtime::UnknownImportError</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html"><code>wasmtime::Linker</code></a></li>
</ul>
<p>The change which introduced this bug was <a href="https://github.com/bytecodealliance/wasmtime/pull/7969">#7969</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47813">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/7969">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-10-09T19:14:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations]]></title>
        <id>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</id>
        <link href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m"/>
        <updated>2024-10-09T19:14:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>
<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the "References" section below for a list of Wasmtime types-related APIs that are affected.</p>
<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see "References" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>
<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>
<table>
<thead>
<tr>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>decref(E) --&gt; 0</code></td>
</tr>
<tr>
<td></td>
<td><code>block_on(type registry lock)</code></td>
</tr>
<tr>
<td><code>register(E') == incref(E) --&gt; 1</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>decref(E) --&gt; 0</code></td>
<td></td>
</tr>
<tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>unregister(E)</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>acquire(type registry lock)</code></td>
</tr>
<tr>
<td></td>
<td><code>unregister(E)</code></td>
</tr>
</tbody></table>
<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>
<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>
<h3 id="patches">Patches</h3>
<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>
<ul>
<li>21.0.2</li>
<li>22.0.1</li>
<li>23.0.3</li>
<li>24.0.1</li>
<li>25.0.2</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>
<h3 id="references">References</h3>
<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new"><code>wasmtime::FuncType::new</code></a><ul>
<li>Also reachable from creation of <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html"><code>wasmtime::Func</code></a></li>
<li>Also reachable from <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new"><code>wasmtime::Linker::func_*</code></a></li>
</ul>
</li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new"><code>wasmtime::ArrayType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new"><code>wasmtime::StructType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty"><code>wasmtime::Func::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty"><code>wasmtime::Global::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty"><code>wasmtime::Table::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty"><code>wasmtime::Extern::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty"><code>wasmtime::Export::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty"><code>wasmtime::UnknownImportError::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty"><code>wasmtime::ImportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty"><code>wasmtime::ExportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty"><code>wasmtime::Val::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty"><code>wasmtime::Ref::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty"><code>wasmtime::AnyRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty"><code>wasmtime::EqRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty"><code>wasmtime::ArrayRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty"><code>wasmtime::StructRef::ty</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html"><code>wasmtime::FuncType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html"><code>wasmtime::ArrayType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html"><code>wasmtime::StructType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html"><code>wasmtime::ExternType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html"><code>wasmtime::GlobalType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html"><code>wasmtime::TableType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html"><code>wasmtime::ValType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html"><code>wasmtime::RefType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html"><code>wasmtime::HeapType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html"><code>wasmtime::UnknownImportError</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html"><code>wasmtime::Linker</code></a></li>
</ul>
<p>The change which introduced this bug was <a href="https://github.com/bytecodealliance/wasmtime/pull/7969">#7969</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47813">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/7969">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-10-09T19:14:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations]]></title>
        <id>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</id>
        <link href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m"/>
        <updated>2024-10-09T19:14:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>
<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the "References" section below for a list of Wasmtime types-related APIs that are affected.</p>
<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see "References" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>
<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>
<table>
<thead>
<tr>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>decref(E) --&gt; 0</code></td>
</tr>
<tr>
<td></td>
<td><code>block_on(type registry lock)</code></td>
</tr>
<tr>
<td><code>register(E') == incref(E) --&gt; 1</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>decref(E) --&gt; 0</code></td>
<td></td>
</tr>
<tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>unregister(E)</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>acquire(type registry lock)</code></td>
</tr>
<tr>
<td></td>
<td><code>unregister(E)</code></td>
</tr>
</tbody></table>
<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>
<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>
<h3 id="patches">Patches</h3>
<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>
<ul>
<li>21.0.2</li>
<li>22.0.1</li>
<li>23.0.3</li>
<li>24.0.1</li>
<li>25.0.2</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>
<h3 id="references">References</h3>
<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new"><code>wasmtime::FuncType::new</code></a><ul>
<li>Also reachable from creation of <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html"><code>wasmtime::Func</code></a></li>
<li>Also reachable from <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new"><code>wasmtime::Linker::func_*</code></a></li>
</ul>
</li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new"><code>wasmtime::ArrayType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new"><code>wasmtime::StructType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty"><code>wasmtime::Func::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty"><code>wasmtime::Global::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty"><code>wasmtime::Table::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty"><code>wasmtime::Extern::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty"><code>wasmtime::Export::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty"><code>wasmtime::UnknownImportError::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty"><code>wasmtime::ImportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty"><code>wasmtime::ExportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty"><code>wasmtime::Val::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty"><code>wasmtime::Ref::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty"><code>wasmtime::AnyRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty"><code>wasmtime::EqRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty"><code>wasmtime::ArrayRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty"><code>wasmtime::StructRef::ty</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html"><code>wasmtime::FuncType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html"><code>wasmtime::ArrayType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html"><code>wasmtime::StructType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html"><code>wasmtime::ExternType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html"><code>wasmtime::GlobalType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html"><code>wasmtime::TableType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html"><code>wasmtime::ValType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html"><code>wasmtime::RefType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html"><code>wasmtime::HeapType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html"><code>wasmtime::UnknownImportError</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html"><code>wasmtime::Linker</code></a></li>
</ul>
<p>The change which introduced this bug was <a href="https://github.com/bytecodealliance/wasmtime/pull/7969">#7969</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47813">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/7969">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-10-09T19:14:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations]]></title>
        <id>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</id>
        <link href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m"/>
        <updated>2024-10-09T19:14:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>
<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the "References" section below for a list of Wasmtime types-related APIs that are affected.</p>
<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see "References" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>
<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>
<table>
<thead>
<tr>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>decref(E) --&gt; 0</code></td>
</tr>
<tr>
<td></td>
<td><code>block_on(type registry lock)</code></td>
</tr>
<tr>
<td><code>register(E') == incref(E) --&gt; 1</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>decref(E) --&gt; 0</code></td>
<td></td>
</tr>
<tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>unregister(E)</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>acquire(type registry lock)</code></td>
</tr>
<tr>
<td></td>
<td><code>unregister(E)</code></td>
</tr>
</tbody></table>
<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>
<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>
<h3 id="patches">Patches</h3>
<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>
<ul>
<li>21.0.2</li>
<li>22.0.1</li>
<li>23.0.3</li>
<li>24.0.1</li>
<li>25.0.2</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>
<h3 id="references">References</h3>
<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new"><code>wasmtime::FuncType::new</code></a><ul>
<li>Also reachable from creation of <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html"><code>wasmtime::Func</code></a></li>
<li>Also reachable from <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new"><code>wasmtime::Linker::func_*</code></a></li>
</ul>
</li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new"><code>wasmtime::ArrayType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new"><code>wasmtime::StructType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty"><code>wasmtime::Func::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty"><code>wasmtime::Global::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty"><code>wasmtime::Table::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty"><code>wasmtime::Extern::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty"><code>wasmtime::Export::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty"><code>wasmtime::UnknownImportError::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty"><code>wasmtime::ImportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty"><code>wasmtime::ExportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty"><code>wasmtime::Val::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty"><code>wasmtime::Ref::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty"><code>wasmtime::AnyRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty"><code>wasmtime::EqRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty"><code>wasmtime::ArrayRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty"><code>wasmtime::StructRef::ty</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html"><code>wasmtime::FuncType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html"><code>wasmtime::ArrayType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html"><code>wasmtime::StructType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html"><code>wasmtime::ExternType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html"><code>wasmtime::GlobalType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html"><code>wasmtime::TableType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html"><code>wasmtime::ValType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html"><code>wasmtime::RefType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html"><code>wasmtime::HeapType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html"><code>wasmtime::UnknownImportError</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html"><code>wasmtime::Linker</code></a></li>
</ul>
<p>The change which introduced this bug was <a href="https://github.com/bytecodealliance/wasmtime/pull/7969">#7969</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47813">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/7969">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-10-09T19:14:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime race condition could lead to WebAssembly control-flow integrity and type safety violations]]></title>
        <id>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</id>
        <link href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m"/>
        <updated>2024-10-09T19:14:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Under certain concurrent event orderings, a <code>wasmtime::Engine</code>'s internal type registry was susceptible to double-unregistration bugs due to a race condition, leading to panics and potentially type registry corruption. That registry corruption could, following an additional and particular sequence of concurrent events, lead to violations of WebAssembly's control-flow integrity (CFI) and type safety. Users that do not use <code>wasmtime::Engine</code> across multiple threads are not affected. Users that only create new modules across threads over time are additionally not affected.</p>
<p>Reproducing this bug requires creating and dropping multiple type instances (such as <code>wasmtime::FuncType</code> or <code>wasmtime::ArrayType</code>) concurrently on multiple threads, where all types are associated with the same <code>wasmtime::Engine</code>. <strong>Wasm guests cannot trigger this bug.</strong> See the "References" section below for a list of Wasmtime types-related APIs that are affected.</p>
<p>Wasmtime maintains an internal registry of types within a <code>wasmtime::Engine</code> and an engine is shareable across threads. Types can be created and referenced through creation of a <code>wasmtime::Module</code>, creation of <code>wasmtime::FuncType</code>, or a number of other APIs where the host creates a function (see "References" below). Each of these cases interacts with an engine to deduplicate type information and manage type indices that are used to implement type checks in WebAssembly's <code>call_indirect</code> function, for example. This bug is a race condition in this management where the internal type registry could be corrupted to trigger an assert or contain invalid state.</p>
<p>Wasmtime's internal representation of a type has individual types (e.g. one-per-host-function) maintain a registration count of how many time it's been used. Types additionally have state within an engine behind a read-write lock such as lookup/deduplication information. The race here is a time-of-check versus time-of-use (TOCTOU) bug where one thread atomically decrements a type entry's registration count, observes zero registrations, and then acquires a lock in order to unregister that entry. However, between when this first thread observed the zero-registration count and when it acquires that lock, another thread could perform the following sequence of events: re-register another copy of the type, which deduplicates to that same entry, resurrecting it and incrementing its registration count; then drop the type and decrement its registration count; observe that the registration count is now zero; acquire the type registry lock; and finally unregister the type. Now, when the original thread finally acquires the lock and unregisters the entry, it is the second time this entry has been unregistered.</p>
<table>
<thead>
<tr>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>decref(E) --&gt; 0</code></td>
</tr>
<tr>
<td></td>
<td><code>block_on(type registry lock)</code></td>
</tr>
<tr>
<td><code>register(E') == incref(E) --&gt; 1</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>decref(E) --&gt; 0</code></td>
<td></td>
</tr>
<tr>
<td><code>acquire(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td><code>unregister(E)</code></td>
<td></td>
</tr>
<tr>
<td><code>release(type registry lock)</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>acquire(type registry lock)</code></td>
</tr>
<tr>
<td></td>
<td><code>unregister(E)</code></td>
</tr>
</tbody></table>
<p>This double-unregistration could then lead to a WebAssembly CFI violation under the following conditions: a new WebAssembly module <code>X</code> was loaded into the engine before the second, buggy unregistration occurs; <code>X</code> defined a function type <code>F</code> that was allocated in the same type registry slot where the original entry was allocated; the second, buggy unregistration incorrectly unregistered <code>F</code>; another new WebAssembly module <code>Y</code> was loaded into the engine; <code>Y</code> defined a function type <code>G</code>, different from <code>F</code>, but which is also allocated in the same type registry slot; a <code>funcref</code> of type <code>G</code> is created, either by the host or by Wasm; that <code>funcref</code> is passed to a WebAssembly instance of module <code>X</code>; that instance performs a <code>call_indirect</code> to that <code>funcref</code>; the <code>call_indirect</code>'s dynamic type check, which preserves CFI, could incorrectly pass in this case, because <code>F</code> and <code>G</code> were assigned the same type registry slot. This would, ultimately, allow calling a function with too many, too few, or wrongly-typed arguments, violating CFI and type safety.</p>
<p>We were not able to reproduce this CFI violation in a vanilla Wasmtime build, although it remains theoretically possible. However, by modifying Wasmtime's source code to make losing the races described above more likely (by disabling certain assertions, inserting panic catches, and adding retry loops in a few places if we did <em>not</em> lose the race) we were able to incorrectly get a <code>funcref</code> to pass a type check that it should have failed, which would allow the CFI violation.</p>
<h3 id="patches">Patches</h3>
<p>This bug was originally introduced in Wasmtime 19's development of the WebAssembly GC proposal. This bug affects users who are not using the GC proposal, however, and affects Wasmtime in its default configuration even when the GC proposal is disabled. Wasmtime users using 19.0.0 and after are all affected by this issue. We have released the following Wasmtime versions, all of which have a fix for this bug:</p>
<ul>
<li>21.0.2</li>
<li>22.0.1</li>
<li>23.0.3</li>
<li>24.0.1</li>
<li>25.0.2</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>If your application creates and drops Wasmtime types on multiple threads concurrently, there are no known workarounds. Users are encouraged to upgrade to a patched release. </p>
<h3 id="references">References</h3>
<p>The following APIs create or drop types, and therefore are affected by this race condition if performed on multiple threads concurrently and are all associated with the same <code>wasmtime::Engine</code>:</p>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html#method.new"><code>wasmtime::FuncType::new</code></a><ul>
<li>Also reachable from creation of <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html"><code>wasmtime::Func</code></a></li>
<li>Also reachable from <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.func_new"><code>wasmtime::Linker::func_*</code></a></li>
</ul>
</li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html#method.new"><code>wasmtime::ArrayType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html#method.new"><code>wasmtime::StructType::new</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.ty"><code>wasmtime::Func::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.ty"><code>wasmtime::Global::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.ty"><code>wasmtime::Table::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Extern.html#method.ty"><code>wasmtime::Extern::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Export.html#method.ty"><code>wasmtime::Export::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html#method.ty"><code>wasmtime::UnknownImportError::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ImportType.html#method.ty"><code>wasmtime::ImportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExportType.html#method.ty"><code>wasmtime::ExportType::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Val.html#method.ty"><code>wasmtime::Val::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Ref.html#method.ty"><code>wasmtime::Ref::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.AnyRef.html#method.ty"><code>wasmtime::AnyRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.EqRef.html#method.ty"><code>wasmtime::EqRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayRef.html#method.ty"><code>wasmtime::ArrayRef::ty</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructRef.html#method.ty"><code>wasmtime::StructRef::ty</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.FuncType.html"><code>wasmtime::FuncType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ArrayType.html"><code>wasmtime::ArrayType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.StructType.html"><code>wasmtime::StructType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ExternType.html"><code>wasmtime::ExternType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.GlobalType.html"><code>wasmtime::GlobalType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.TableType.html"><code>wasmtime::TableType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.ValType.html"><code>wasmtime::ValType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.RefType.html"><code>wasmtime::RefType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.HeapType.html"><code>wasmtime::HeapType</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.UnknownImportError.html"><code>wasmtime::UnknownImportError</code></a></li>
<li>Dropping a <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html"><code>wasmtime::Linker</code></a></li>
</ul>
<p>The change which introduced this bug was <a href="https://github.com/bytecodealliance/wasmtime/pull/7969">#7969</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-7qmx-3fpx-r45m</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47813">https://nvd.nist.gov/vuln/detail/CVE-2024-47813</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/7969">https://github.com/bytecodealliance/wasmtime/pull/7969</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://github.com/advisories/GHSA-7qmx-3fpx-r45m">https://github.com/advisories/GHSA-7qmx-3fpx-r45m</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7qmx-3fpx-r45m</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2024-10-09T19:14:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports]]></title>
        <id>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</id>
        <link href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg"/>
        <updated>2024-10-09T19:14:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>
<p><a href="https://github.com/webassembly/tail-call">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href="https://github.com/WebAssembly/proposals/">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href="https://github.com/bytecodealliance/wasmtime/pull/8540">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>
<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>
<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern "C"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>
<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>
<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>
<h3 id="patches">Patches</h3>
<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>
<ul>
<li>21.0.x - patched in 21.0.2</li>
<li>22.0.x - patched in 22.0.1</li>
<li>23.0.x - patched in 23.0.3 </li>
<li>24.0.x - patched in 24.0.1</li>
<li>25.0.x - patched in 25.0.2</li>
</ul>
<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>
<h3 id="workarounds">Workarounds</h3>
<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">Wasmtime's initial implementation of tail calls</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">Enabling of tail calls in 21.0.0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Fully enabling tail calls in 22.0.0</a></li>
<li><a href="https://github.com/webassembly/tail-call">The WebAssembly's <code>tail-call</code> proposal</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47763">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>
<li><a href="https://github.com/WebAssembly/proposals">https://github.com/WebAssembly/proposals</a></li>
<li><a href="https://github.com/webassembly/tail-call">https://github.com/webassembly/tail-call</a></li>
<li><a href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-09T19:14:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports]]></title>
        <id>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</id>
        <link href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg"/>
        <updated>2024-10-09T19:14:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>
<p><a href="https://github.com/webassembly/tail-call">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href="https://github.com/WebAssembly/proposals/">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href="https://github.com/bytecodealliance/wasmtime/pull/8540">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>
<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>
<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern "C"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>
<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>
<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>
<h3 id="patches">Patches</h3>
<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>
<ul>
<li>21.0.x - patched in 21.0.2</li>
<li>22.0.x - patched in 22.0.1</li>
<li>23.0.x - patched in 23.0.3 </li>
<li>24.0.x - patched in 24.0.1</li>
<li>25.0.x - patched in 25.0.2</li>
</ul>
<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>
<h3 id="workarounds">Workarounds</h3>
<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">Wasmtime's initial implementation of tail calls</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">Enabling of tail calls in 21.0.0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Fully enabling tail calls in 22.0.0</a></li>
<li><a href="https://github.com/webassembly/tail-call">The WebAssembly's <code>tail-call</code> proposal</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47763">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>
<li><a href="https://github.com/WebAssembly/proposals">https://github.com/WebAssembly/proposals</a></li>
<li><a href="https://github.com/webassembly/tail-call">https://github.com/webassembly/tail-call</a></li>
<li><a href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-09T19:14:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports]]></title>
        <id>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</id>
        <link href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg"/>
        <updated>2024-10-09T19:14:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>
<p><a href="https://github.com/webassembly/tail-call">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href="https://github.com/WebAssembly/proposals/">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href="https://github.com/bytecodealliance/wasmtime/pull/8540">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>
<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>
<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern "C"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>
<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>
<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>
<h3 id="patches">Patches</h3>
<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>
<ul>
<li>21.0.x - patched in 21.0.2</li>
<li>22.0.x - patched in 22.0.1</li>
<li>23.0.x - patched in 23.0.3 </li>
<li>24.0.x - patched in 24.0.1</li>
<li>25.0.x - patched in 25.0.2</li>
</ul>
<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>
<h3 id="workarounds">Workarounds</h3>
<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">Wasmtime's initial implementation of tail calls</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">Enabling of tail calls in 21.0.0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Fully enabling tail calls in 22.0.0</a></li>
<li><a href="https://github.com/webassembly/tail-call">The WebAssembly's <code>tail-call</code> proposal</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47763">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>
<li><a href="https://github.com/WebAssembly/proposals">https://github.com/WebAssembly/proposals</a></li>
<li><a href="https://github.com/webassembly/tail-call">https://github.com/webassembly/tail-call</a></li>
<li><a href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-09T19:14:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports]]></title>
        <id>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</id>
        <link href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg"/>
        <updated>2024-10-09T19:14:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>
<p><a href="https://github.com/webassembly/tail-call">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href="https://github.com/WebAssembly/proposals/">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href="https://github.com/bytecodealliance/wasmtime/pull/8540">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>
<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>
<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern "C"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>
<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>
<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>
<h3 id="patches">Patches</h3>
<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>
<ul>
<li>21.0.x - patched in 21.0.2</li>
<li>22.0.x - patched in 22.0.1</li>
<li>23.0.x - patched in 23.0.3 </li>
<li>24.0.x - patched in 24.0.1</li>
<li>25.0.x - patched in 25.0.2</li>
</ul>
<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>
<h3 id="workarounds">Workarounds</h3>
<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">Wasmtime's initial implementation of tail calls</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">Enabling of tail calls in 21.0.0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Fully enabling tail calls in 22.0.0</a></li>
<li><a href="https://github.com/webassembly/tail-call">The WebAssembly's <code>tail-call</code> proposal</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47763">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>
<li><a href="https://github.com/WebAssembly/proposals">https://github.com/WebAssembly/proposals</a></li>
<li><a href="https://github.com/webassembly/tail-call">https://github.com/webassembly/tail-call</a></li>
<li><a href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-09T19:14:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime has a runtime crash when combining tail calls with trapping imports]]></title>
        <id>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</id>
        <link href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg"/>
        <updated>2024-10-09T19:14:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's implementation of WebAssembly tail calls combined with stack traces can result in a runtime crash in certain WebAssembly modules. The runtime crash may be undefined behavior if Wasmtime was compiled with Rust 1.80 or prior. The runtime crash is a deterministic process abort when Wasmtime is compiled with Rust 1.81 and later.</p>
<p><a href="https://github.com/webassembly/tail-call">WebAssembly tail calls</a> are a proposal which relatively recently reached stage 4 in the <a href="https://github.com/WebAssembly/proposals/">standardization process</a>. Wasmtime first enabled support for tail calls by default <a href="https://github.com/bytecodealliance/wasmtime/pull/8540">in Wasmtime 21.0.0</a>, although that release contained a bug where it was only on-by-default for some configurations. In <a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Wasmtime 22.0.0</a> tail calls were enabled by default for all configurations.</p>
<p>The specific crash happens when an exported function in a WebAssembly module (or component) performs a <code>return_call</code> (or <code>return_call_indirect</code> or <code>return_call_ref</code>) to an imported host function which captures a stack trace (for example, the host function raises a trap). In this situation, the stack-walking code previously assumed there was always at least one WebAssembly frame on the stack but with tail calls that is no longer true. With the tail-call proposal it's possible to have an entry trampoline appear as if it directly called the exit trampoline. This situation triggers an internal assert in the stack-walking code which raises a Rust <code>panic!()</code>.</p>
<p>When Wasmtime is compiled with Rust versions 1.80 and prior this means that an <code>extern "C"</code> function in Rust is raising a <code>panic!()</code>. This is technically undefined behavior and typically manifests as a process abort when the unwinder fails to unwind Cranelift-generated frames. When Wasmtime is compiled with Rust versions 1.81 and later this panic becomes a deterministic process abort.</p>
<p>Overall the impact of this issue is that this is a denial-of-service vector where a malicious WebAssembly module or component can cause the host to crash. There is no other impact at this time other than availability of a service as the result of the crash is always a crash and no more.</p>
<p>This issue was discovered by routine fuzzing performed by the Wasmtime project via Google's OSS-Fuzz infrastructure. We have no evidence that it has ever been exploited by an attacker in the wild.</p>
<h3 id="patches">Patches</h3>
<p>All versions of Wasmtime which have tail calls enabled by default have been patched:</p>
<ul>
<li>21.0.x - patched in 21.0.2</li>
<li>22.0.x - patched in 22.0.1</li>
<li>23.0.x - patched in 23.0.3 </li>
<li>24.0.x - patched in 24.0.1</li>
<li>25.0.x - patched in 25.0.2</li>
</ul>
<p>Wasmtime versions from 12.0.x (the first release with experimental tail call support) to 20.0.x (the last release with tail-calls off-by-default) have support for tail calls but the support is disabled by default. These versions are not affected in their default configurations, but users who explicitly enabled tail call support will need to either disable tail call support or upgrade to a patched version of Wasmtime.</p>
<h3 id="workarounds">Workarounds</h3>
<p>The main workaround for this issue is to disable tail support for tail calls in Wasmtime, for example with <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call"><code>Config::wasm_tail_call(false)</code></a>. Users are otherwise encouraged to upgrade to patched versions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">Wasmtime's initial implementation of tail calls</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">Enabling of tail calls in 21.0.0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">Fully enabling tail calls in 22.0.0</a></li>
<li><a href="https://github.com/webassembly/tail-call">The WebAssembly's <code>tail-call</code> proposal</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-q8hx-mm92-4wvg</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47763">https://nvd.nist.gov/vuln/detail/CVE-2024-47763</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/6774">https://github.com/bytecodealliance/wasmtime/pull/6774</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8540">https://github.com/bytecodealliance/wasmtime/pull/8540</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/8682">https://github.com/bytecodealliance/wasmtime/pull/8682</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba">https://github.com/bytecodealliance/wasmtime/commit/0ebe54d05f0e1f6c64b7c8bb48c9e9f6c95cacba</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_tail_call</a></li>
<li><a href="https://github.com/WebAssembly/proposals">https://github.com/WebAssembly/proposals</a></li>
<li><a href="https://github.com/webassembly/tail-call">https://github.com/webassembly/tail-call</a></li>
<li><a href="https://github.com/advisories/GHSA-q8hx-mm92-4wvg">https://github.com/advisories/GHSA-q8hx-mm92-4wvg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q8hx-mm92-4wvg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-09T19:14:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[dbn] Databento Binary Encoding (DBN) has a heap buffer overflow using c_chars_to_str function]]></title>
        <id>https://github.com/advisories/GHSA-pfr9-2p92-qrhq</id>
        <link href="https://github.com/advisories/GHSA-pfr9-2p92-qrhq"/>
        <updated>2024-10-09T14:34:25.000Z</updated>
        <content type="html"><![CDATA[<p>The <code>heap-buffer-overflow</code> is triggered in the <code>strlen()</code> function when handling the <code>c_chars_to_str</code> function in the dbn crate. This vulnerability occurs because the <code>CStr::from_ptr()</code> function in Rust assumes that the provided C string is null-terminated. However, there is no guarantee that the input chars array passed to the c_chars_to_str function is properly null-terminated.</p>
<p>If the chars array does not contain a null byte (\0), strlen() will continue to read beyond the bounds of the buffer in search of a null terminator. This results in an out-of-bounds memory read and can lead to a heap-buffer-overflow, potentially causing memory corruption or exposing sensitive information.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/databento/dbn/issues/67">https://github.com/databento/dbn/issues/67</a></li>
<li><a href="https://github.com/databento/dbn/commit/339efb90fdb980920a5e8829008abc1114f4bfdd">https://github.com/databento/dbn/commit/339efb90fdb980920a5e8829008abc1114f4bfdd</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2024-0377.html">https://rustsec.org/advisories/RUSTSEC-2024-0377.html</a></li>
<li><a href="https://github.com/advisories/GHSA-pfr9-2p92-qrhq">https://github.com/advisories/GHSA-pfr9-2p92-qrhq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pfr9-2p92-qrhq</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-09T14:34:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[surrealdb-core] Improper Authorization in Select Permissions]]></title>
        <id>https://github.com/advisories/GHSA-9722-9j67-vjcr</id>
        <link href="https://github.com/advisories/GHSA-9722-9j67-vjcr"/>
        <updated>2024-10-08T22:21:11.000Z</updated>
        <content type="html"><![CDATA[<p>Due to the order in which permissions were processed, some statements, filters and computations could lead to leaking field values or record contents to users without the required permissions. This behavior could be triggered in different scenarios:</p>
<ul>
<li><p>When performing a <code>SELECT</code> operation on a table, the values that would be returned were iterated over, field permissions would be validated and any unauthorized value would be removed from the result returned. However, performing a <code>SELECT VALUE</code> operation (e.g. <code>SELECT VALUE private FROM data</code>) would result in a non-iterable value, which would not be removed from the returned result.</p>
</li>
<li><p>When aliasing a field (e.g. <code>SELECT private AS public FROM data</code>) for which the user did not have <code>SELECT</code> permissions within a <code>SELECT</code> query, permissions would be checked against the field of the resulting document containing the aliased field instead of the original document containing the original field. As a consequence, the original field value would be returned as the returned field would not match the original field where permissions had been defined.</p>
</li>
<li><p>When calling a function in the context of a <code>SELECT</code> query and passing a field with permissions as an argument to the function (e.g. <code>SELECT string::lowercase(private) FROM data</code>), the function would receive the field value before it had been removed from the document due to <code>SELECT</code> permissions. As a result, the function would have access to the value of the field regardless of field permissions. This case includes functions called from within events and other clauses that support function calling.</p>
</li>
<li><p>When executing a query containing a <code>WHERE</code> clause filtering records by a field that the querying user does not have access to <code>SELECT</code> (e.g. <code>SELECT public FROM data WHERE private ~ "secret"</code>), the response of that query would still take the value of the field into account. Even though the value of the protected field would not be returned, this behavior could be used as a side channel by the querying user to infer information about the value of the field.</p>
</li>
<li><p>When performing <code>UPDATE</code> or <code>DELETE</code> operations over a table with a user that had those permissions but no <code>SELECT</code> permission, the <code>RETURN BEFORE</code> clause could be used (e.g. <code>DELETE data RETURN BEFORE</code>) to read the contents of the records prior to the authorized update or the deletion despite the querying user not being authorized to perform <code>SELECT</code> operations.</p>
</li>
<li><p>When performing <code>UPDATE</code> operations on a table for which the user had <code>SELECT</code> and <code>UPDATE</code> permissions, the <code>SET</code> clause could reference fields that the user had <code>UPDATE</code> but no <code>SELECT</code> permission for (e.g. <code>UPDATE data SET public = private</code>) in order to update the value of a field that the user had permission to <code>SELECT</code> to the value of another field for which the user did not.</p>
</li>
</ul>
<h3 id="impact">Impact</h3>
<p>Clients that were authorized by table permissions to execute <code>SELECT</code> statements for a table but were not authorized by field permissions to run <code>SELECT</code> queries for a specific field could still have been able to gain knowledge of the value of that field. Additionally, clients that were authorized to execute <code>UPDATE</code> or <code>DELETE</code> statements for a table but not authorized to execute <code>SELECT</code> statements for the same table may have been able to gain knowledge of the contents of records in that table. This could only be exploited by users who were already authorized to execute queries on the database with the affected table or field.</p>
<p>Due to its relationship with table and field permissions, which apply mainly to record users rather than system users, this issue mostly affects users relying on SurrealDB as a backend-as-a-service rather than SurrealDB as a traditional database backend.</p>
<h3 id="patches">Patches</h3>
<p>The behavior when evaluating table or field permissions and filtering records or fields as a result of those evaluations has been improved to consider permissions before any changes to the document have been made and, when relevant, permissions after changes to the document have taken place. When a user is unauthorized to view record contents and field values by permissions, the returned documents will behave as if the record or field did not exist in order to prevent leaking any information.</p>
<ul>
<li>Version 2.0.4 and later are not affected by this issue.</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>Users affected by this issue and unable to update should not rely on the authorization provided by field permissions when it comes to the <code>SELECT</code> permission. Instead, read access to fields in affected versions should be restricted at the table level. When allowing the <code>UPDATE</code> or <code>DELETE</code> operations for records via table permissions, users should not rely of the authorization provided by the <code>SELECT</code> permission. Instead, users should not allow clients to <code>UPDATE</code> or <code>DELETE</code> records that they should not be able to view.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/surrealdb/surrealdb/security/advisories/GHSA-9722-9j67-vjcr">https://github.com/surrealdb/surrealdb/security/advisories/GHSA-9722-9j67-vjcr</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/issues/2161">https://github.com/surrealdb/surrealdb/issues/2161</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/issues/3924">https://github.com/surrealdb/surrealdb/issues/3924</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/pull/4785">https://github.com/surrealdb/surrealdb/pull/4785</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/pull/4800">https://github.com/surrealdb/surrealdb/pull/4800</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/pull/4873">https://github.com/surrealdb/surrealdb/pull/4873</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/commit/439ab99e15314ec5cf87047bf58246db646e3f8c">https://github.com/surrealdb/surrealdb/commit/439ab99e15314ec5cf87047bf58246db646e3f8c</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/commit/c382fa158dc84b329328606f663efe574f102a7d">https://github.com/surrealdb/surrealdb/commit/c382fa158dc84b329328606f663efe574f102a7d</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/commit/e75e7736b3a028c4b6a4a4bdf00791d76f77e339">https://github.com/surrealdb/surrealdb/commit/e75e7736b3a028c4b6a4a4bdf00791d76f77e339</a></li>
<li><a href="https://surrealdb.com/docs/surrealdb/security/summary#permissions">https://surrealdb.com/docs/surrealdb/security/summary#permissions</a></li>
<li><a href="https://surrealdb.com/docs/surrealql/statements/define/field#setting-permissions-on-fields">https://surrealdb.com/docs/surrealql/statements/define/field#setting-permissions-on-fields</a></li>
<li><a href="https://surrealdb.com/docs/surrealql/statements/define/table#defining-permissions">https://surrealdb.com/docs/surrealql/statements/define/table#defining-permissions</a></li>
<li><a href="https://github.com/advisories/GHSA-9722-9j67-vjcr">https://github.com/advisories/GHSA-9722-9j67-vjcr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9722-9j67-vjcr</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-10-08T22:21:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[surrealdb] Improper Authorization in Select Permissions]]></title>
        <id>https://github.com/advisories/GHSA-9722-9j67-vjcr</id>
        <link href="https://github.com/advisories/GHSA-9722-9j67-vjcr"/>
        <updated>2024-10-08T22:21:11.000Z</updated>
        <content type="html"><![CDATA[<p>Due to the order in which permissions were processed, some statements, filters and computations could lead to leaking field values or record contents to users without the required permissions. This behavior could be triggered in different scenarios:</p>
<ul>
<li><p>When performing a <code>SELECT</code> operation on a table, the values that would be returned were iterated over, field permissions would be validated and any unauthorized value would be removed from the result returned. However, performing a <code>SELECT VALUE</code> operation (e.g. <code>SELECT VALUE private FROM data</code>) would result in a non-iterable value, which would not be removed from the returned result.</p>
</li>
<li><p>When aliasing a field (e.g. <code>SELECT private AS public FROM data</code>) for which the user did not have <code>SELECT</code> permissions within a <code>SELECT</code> query, permissions would be checked against the field of the resulting document containing the aliased field instead of the original document containing the original field. As a consequence, the original field value would be returned as the returned field would not match the original field where permissions had been defined.</p>
</li>
<li><p>When calling a function in the context of a <code>SELECT</code> query and passing a field with permissions as an argument to the function (e.g. <code>SELECT string::lowercase(private) FROM data</code>), the function would receive the field value before it had been removed from the document due to <code>SELECT</code> permissions. As a result, the function would have access to the value of the field regardless of field permissions. This case includes functions called from within events and other clauses that support function calling.</p>
</li>
<li><p>When executing a query containing a <code>WHERE</code> clause filtering records by a field that the querying user does not have access to <code>SELECT</code> (e.g. <code>SELECT public FROM data WHERE private ~ "secret"</code>), the response of that query would still take the value of the field into account. Even though the value of the protected field would not be returned, this behavior could be used as a side channel by the querying user to infer information about the value of the field.</p>
</li>
<li><p>When performing <code>UPDATE</code> or <code>DELETE</code> operations over a table with a user that had those permissions but no <code>SELECT</code> permission, the <code>RETURN BEFORE</code> clause could be used (e.g. <code>DELETE data RETURN BEFORE</code>) to read the contents of the records prior to the authorized update or the deletion despite the querying user not being authorized to perform <code>SELECT</code> operations.</p>
</li>
<li><p>When performing <code>UPDATE</code> operations on a table for which the user had <code>SELECT</code> and <code>UPDATE</code> permissions, the <code>SET</code> clause could reference fields that the user had <code>UPDATE</code> but no <code>SELECT</code> permission for (e.g. <code>UPDATE data SET public = private</code>) in order to update the value of a field that the user had permission to <code>SELECT</code> to the value of another field for which the user did not.</p>
</li>
</ul>
<h3 id="impact">Impact</h3>
<p>Clients that were authorized by table permissions to execute <code>SELECT</code> statements for a table but were not authorized by field permissions to run <code>SELECT</code> queries for a specific field could still have been able to gain knowledge of the value of that field. Additionally, clients that were authorized to execute <code>UPDATE</code> or <code>DELETE</code> statements for a table but not authorized to execute <code>SELECT</code> statements for the same table may have been able to gain knowledge of the contents of records in that table. This could only be exploited by users who were already authorized to execute queries on the database with the affected table or field.</p>
<p>Due to its relationship with table and field permissions, which apply mainly to record users rather than system users, this issue mostly affects users relying on SurrealDB as a backend-as-a-service rather than SurrealDB as a traditional database backend.</p>
<h3 id="patches">Patches</h3>
<p>The behavior when evaluating table or field permissions and filtering records or fields as a result of those evaluations has been improved to consider permissions before any changes to the document have been made and, when relevant, permissions after changes to the document have taken place. When a user is unauthorized to view record contents and field values by permissions, the returned documents will behave as if the record or field did not exist in order to prevent leaking any information.</p>
<ul>
<li>Version 2.0.4 and later are not affected by this issue.</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>Users affected by this issue and unable to update should not rely on the authorization provided by field permissions when it comes to the <code>SELECT</code> permission. Instead, read access to fields in affected versions should be restricted at the table level. When allowing the <code>UPDATE</code> or <code>DELETE</code> operations for records via table permissions, users should not rely of the authorization provided by the <code>SELECT</code> permission. Instead, users should not allow clients to <code>UPDATE</code> or <code>DELETE</code> records that they should not be able to view.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/surrealdb/surrealdb/security/advisories/GHSA-9722-9j67-vjcr">https://github.com/surrealdb/surrealdb/security/advisories/GHSA-9722-9j67-vjcr</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/issues/2161">https://github.com/surrealdb/surrealdb/issues/2161</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/issues/3924">https://github.com/surrealdb/surrealdb/issues/3924</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/pull/4785">https://github.com/surrealdb/surrealdb/pull/4785</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/pull/4800">https://github.com/surrealdb/surrealdb/pull/4800</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/pull/4873">https://github.com/surrealdb/surrealdb/pull/4873</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/commit/439ab99e15314ec5cf87047bf58246db646e3f8c">https://github.com/surrealdb/surrealdb/commit/439ab99e15314ec5cf87047bf58246db646e3f8c</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/commit/c382fa158dc84b329328606f663efe574f102a7d">https://github.com/surrealdb/surrealdb/commit/c382fa158dc84b329328606f663efe574f102a7d</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/commit/e75e7736b3a028c4b6a4a4bdf00791d76f77e339">https://github.com/surrealdb/surrealdb/commit/e75e7736b3a028c4b6a4a4bdf00791d76f77e339</a></li>
<li><a href="https://surrealdb.com/docs/surrealdb/security/summary#permissions">https://surrealdb.com/docs/surrealdb/security/summary#permissions</a></li>
<li><a href="https://surrealdb.com/docs/surrealql/statements/define/field#setting-permissions-on-fields">https://surrealdb.com/docs/surrealql/statements/define/field#setting-permissions-on-fields</a></li>
<li><a href="https://surrealdb.com/docs/surrealql/statements/define/table#defining-permissions">https://surrealdb.com/docs/surrealql/statements/define/table#defining-permissions</a></li>
<li><a href="https://github.com/advisories/GHSA-9722-9j67-vjcr">https://github.com/advisories/GHSA-9722-9j67-vjcr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9722-9j67-vjcr</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-10-08T22:21:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[surrealdb-core] SurrealDB has an Uncaught Exception Handling Parsing Errors on Empty Strings]]></title>
        <id>https://github.com/advisories/GHSA-qjrv-v6qp-x99x</id>
        <link href="https://github.com/advisories/GHSA-qjrv-v6qp-x99x"/>
        <updated>2024-10-08T22:20:06.000Z</updated>
        <content type="html"><![CDATA[<p>The error rendering code from the parser would panic when handling failed parsing of queries where the error occurred when converting an empty string to a SurrealDB value. This would be the case when casting an empty string to a <code>record</code>, <code>duration</code> or <code>datetime</code>, as well as potentially when parsing an empty string to JSON or providing an empty string to the <code>type::field</code> and <code>type::fields</code> functions.</p>
<h3 id="impact">Impact</h3>
<p>A client that is authorized to run queries in a SurrealDB server would be able to execute a malformed query which would fail to parse when converting an empty string and cause a panic in the error rendering code. This would crash the server, leading to denial of service.</p>
<h3 id="patches">Patches</h3>
<ul>
<li>Version 2.0.4 and later are not affected by this issue.</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>Affected users who are unable to update may want to limit the ability of untrusted clients to run arbitrary SurrealQL queries in the affected versions of SurrealDB. To limit the impact of the denial of service, SurrealDB administrators may also want to ensure that the SurrealDB process is running so that it can be automatically re-started after a crash.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/surrealdb/surrealdb/security/advisories/GHSA-qjrv-v6qp-x99x">https://github.com/surrealdb/surrealdb/security/advisories/GHSA-qjrv-v6qp-x99x</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/pull/4923">https://github.com/surrealdb/surrealdb/pull/4923</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/commit/709d6efe901dbf3e207b4fc2ebc30775595efc16">https://github.com/surrealdb/surrealdb/commit/709d6efe901dbf3e207b4fc2ebc30775595efc16</a></li>
<li><a href="https://github.com/advisories/GHSA-qjrv-v6qp-x99x">https://github.com/advisories/GHSA-qjrv-v6qp-x99x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qjrv-v6qp-x99x</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-10-08T22:20:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[surrealdb] SurrealDB has an Uncaught Exception Handling Parsing Errors on Empty Strings]]></title>
        <id>https://github.com/advisories/GHSA-qjrv-v6qp-x99x</id>
        <link href="https://github.com/advisories/GHSA-qjrv-v6qp-x99x"/>
        <updated>2024-10-08T22:20:06.000Z</updated>
        <content type="html"><![CDATA[<p>The error rendering code from the parser would panic when handling failed parsing of queries where the error occurred when converting an empty string to a SurrealDB value. This would be the case when casting an empty string to a <code>record</code>, <code>duration</code> or <code>datetime</code>, as well as potentially when parsing an empty string to JSON or providing an empty string to the <code>type::field</code> and <code>type::fields</code> functions.</p>
<h3 id="impact">Impact</h3>
<p>A client that is authorized to run queries in a SurrealDB server would be able to execute a malformed query which would fail to parse when converting an empty string and cause a panic in the error rendering code. This would crash the server, leading to denial of service.</p>
<h3 id="patches">Patches</h3>
<ul>
<li>Version 2.0.4 and later are not affected by this issue.</li>
</ul>
<h3 id="workarounds">Workarounds</h3>
<p>Affected users who are unable to update may want to limit the ability of untrusted clients to run arbitrary SurrealQL queries in the affected versions of SurrealDB. To limit the impact of the denial of service, SurrealDB administrators may also want to ensure that the SurrealDB process is running so that it can be automatically re-started after a crash.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/surrealdb/surrealdb/security/advisories/GHSA-qjrv-v6qp-x99x">https://github.com/surrealdb/surrealdb/security/advisories/GHSA-qjrv-v6qp-x99x</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/pull/4923">https://github.com/surrealdb/surrealdb/pull/4923</a></li>
<li><a href="https://github.com/surrealdb/surrealdb/commit/709d6efe901dbf3e207b4fc2ebc30775595efc16">https://github.com/surrealdb/surrealdb/commit/709d6efe901dbf3e207b4fc2ebc30775595efc16</a></li>
<li><a href="https://github.com/advisories/GHSA-qjrv-v6qp-x99x">https://github.com/advisories/GHSA-qjrv-v6qp-x99x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qjrv-v6qp-x99x</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-10-08T22:20:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[async-graphql] async-graphql Directive Overload]]></title>
        <id>https://github.com/advisories/GHSA-5gc2-7c65-8fq8</id>
        <link href="https://github.com/advisories/GHSA-5gc2-7c65-8fq8"/>
        <updated>2024-10-03T18:27:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<ul>
<li>Service Disruption: The server may become unresponsive or extremely slow, potentially leading to downtime.</li>
<li>Resource Exhaustion: Excessive use of server resources, such as CPU and memory, could negatively impact other services running on the same infrastructure.</li>
<li>User Experience Degradation: Users may experience delays or failures when accessing the service, which could lead to frustration and loss of trust in the service.</li>
</ul>
<h3 id="patches">Patches</h3>
<ol>
<li>Upgrade to v7.0.10</li>
<li>Use <a href="https://docs.rs/async-graphql/latest/async_graphql/struct.SchemaBuilder.html#method.limit_directives">SchemaBuilder.limit_directives</a> to limit the maximum number of directives for a single field.</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/async-graphql/async-graphql/security/advisories/GHSA-5gc2-7c65-8fq8">https://github.com/async-graphql/async-graphql/security/advisories/GHSA-5gc2-7c65-8fq8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-47614">https://nvd.nist.gov/vuln/detail/CVE-2024-47614</a></li>
<li><a href="https://github.com/async-graphql/async-graphql/commit/7f1791488463d4e9c5adcd543962173e2f6cbd34">https://github.com/async-graphql/async-graphql/commit/7f1791488463d4e9c5adcd543962173e2f6cbd34</a></li>
<li><a href="https://github.com/advisories/GHSA-5gc2-7c65-8fq8">https://github.com/advisories/GHSA-5gc2-7c65-8fq8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5gc2-7c65-8fq8</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2024-10-03T18:27:11.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[openssl-src] Denial of service by double-checked locking in openssl-src]]></title>
        <id>https://github.com/advisories/GHSA-vr8j-hgmm-jh9r</id>
        <link href="https://github.com/advisories/GHSA-vr8j-hgmm-jh9r"/>
        <updated>2024-10-02T18:03:45.000Z</updated>
        <content type="html"><![CDATA[<p>If an X.509 certificate contains a malformed policy constraint and policy processing is enabled, then a write lock will be taken twice recursively. On some operating systems (most widely: Windows) this results in a denial of service when the affected process hangs. Policy processing being enabled on a publicly facing server is not considered to be a common setup. Policy processing is enabled by passing the <code>-policy' argument to the command line utilities or by calling either </code>X509_VERIFY_PARAM_add0_policy()' or `X509_VERIFY_PARAM_set1_policies()' functions.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-3996">https://nvd.nist.gov/vuln/detail/CVE-2022-3996</a></li>
<li><a href="https://github.com/openssl/openssl/commit/7725e7bfe6f2ce8146b6552b44e0d226be7638e7">https://github.com/openssl/openssl/commit/7725e7bfe6f2ce8146b6552b44e0d226be7638e7</a></li>
<li><a href="https://www.openssl.org/news/secadv/20221213.txt">https://www.openssl.org/news/secadv/20221213.txt</a></li>
<li><a href="https://github.com/advisories/GHSA-vr8j-hgmm-jh9r">https://github.com/advisories/GHSA-vr8j-hgmm-jh9r</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vr8j-hgmm-jh9r</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-12-13T18:30:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cocoon] cocoon Reuses a Nonce, Key Pair in Encryption]]></title>
        <id>https://github.com/advisories/GHSA-r2jw-c95q-rj29</id>
        <link href="https://github.com/advisories/GHSA-r2jw-c95q-rj29"/>
        <updated>2024-10-02T17:57:50.000Z</updated>
        <content type="html"><![CDATA[<p>Versions of the package cocoon before 0.4.0 are vulnerable to Reusing a Nonce, Key Pair in Encryption when the encrypt, wrap, and dump functions are sequentially called. An attacker can generate the same ciphertext by creating a new encrypted message with the same cocoon object.</p>
<p><strong>Note:</strong>
The issue does NOT affect objects created with Cocoon::new which utilizes ThreadRng.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-21530">https://nvd.nist.gov/vuln/detail/CVE-2024-21530</a></li>
<li><a href="https://github.com/fadeevab/cocoon/issues/22">https://github.com/fadeevab/cocoon/issues/22</a></li>
<li><a href="https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441">https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441</a></li>
<li><a href="https://github.com/advisories/GHSA-6878-6wc2-pf5h">https://github.com/advisories/GHSA-6878-6wc2-pf5h</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0068.html">https://rustsec.org/advisories/RUSTSEC-2023-0068.html</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-RUST-COCOON-6028364">https://security.snyk.io/vuln/SNYK-RUST-COCOON-6028364</a></li>
<li><a href="https://github.com/advisories/GHSA-r2jw-c95q-rj29">https://github.com/advisories/GHSA-r2jw-c95q-rj29</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r2jw-c95q-rj29</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2024-10-02T06:30:26.000Z</published>
    </entry>
</feed>