<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2023-06-13T22:01:26.722Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[tokio] Race Condition in tokio]]></title>
        <id>https://github.com/advisories/GHSA-fg7r-2g4j-5cgr</id>
        <link href="https://github.com/advisories/GHSA-fg7r-2g4j-5cgr"/>
        <updated>2023-06-13T22:01:00.000Z</updated>
        <content type="html"><![CDATA[<p>If a tokio::sync::oneshot channel is closed (via the oneshot::Receiver::close method), a data race may occur if the oneshot::Sender::send method is called while the corresponding oneshot::Receiver is awaited or calling try_recv.</p>
<p>When these methods are called concurrently on a closed channel, the two halves of the channel can concurrently access a shared memory location, resulting in a data race. This has been observed to cause memory corruption.</p>
<p>Note that the race only occurs when both halves of the channel are used after the Receiver half has called close. Code where close is not used, or where the Receiver is not awaited and try_recv is not called after calling close, is not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45710">https://nvd.nist.gov/vuln/detail/CVE-2021-45710</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0124.html">https://rustsec.org/advisories/RUSTSEC-2021-0124.html</a></li>
<li><a href="https://github.com/tokio-rs/tokio/issues/4225">https://github.com/tokio-rs/tokio/issues/4225</a></li>
<li><a href="https://github.com/advisories/GHSA-fg7r-2g4j-5cgr">https://github.com/advisories/GHSA-fg7r-2g4j-5cgr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fg7r-2g4j-5cgr</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-01-06T22:04:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tokio] Race Condition in tokio]]></title>
        <id>https://github.com/advisories/GHSA-fg7r-2g4j-5cgr</id>
        <link href="https://github.com/advisories/GHSA-fg7r-2g4j-5cgr"/>
        <updated>2023-06-13T22:01:00.000Z</updated>
        <content type="html"><![CDATA[<p>If a tokio::sync::oneshot channel is closed (via the oneshot::Receiver::close method), a data race may occur if the oneshot::Sender::send method is called while the corresponding oneshot::Receiver is awaited or calling try_recv.</p>
<p>When these methods are called concurrently on a closed channel, the two halves of the channel can concurrently access a shared memory location, resulting in a data race. This has been observed to cause memory corruption.</p>
<p>Note that the race only occurs when both halves of the channel are used after the Receiver half has called close. Code where close is not used, or where the Receiver is not awaited and try_recv is not called after calling close, is not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45710">https://nvd.nist.gov/vuln/detail/CVE-2021-45710</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tokio/RUSTSEC-2021-0124.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0124.html">https://rustsec.org/advisories/RUSTSEC-2021-0124.html</a></li>
<li><a href="https://github.com/tokio-rs/tokio/issues/4225">https://github.com/tokio-rs/tokio/issues/4225</a></li>
<li><a href="https://github.com/advisories/GHSA-fg7r-2g4j-5cgr">https://github.com/advisories/GHSA-fg7r-2g4j-5cgr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fg7r-2g4j-5cgr</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-01-06T22:04:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[toodee] Double free in toodee]]></title>
        <id>https://github.com/advisories/GHSA-wcvp-r8j8-47pc</id>
        <link href="https://github.com/advisories/GHSA-wcvp-r8j8-47pc"/>
        <updated>2023-06-13T21:58:19.000Z</updated>
        <content type="html"><![CDATA[<p>When inserting rows from an iterator at a particular index, toodee would shift items over, duplicating their ownership. The space reserved for the new elements was based on the len() returned by the ExactSizeIterator.</p>
<p>This could result in elements in the array being freed twice if the iterator panics. Uninitialized or previously freed elements could also be exposed if the len() didn't match the number of elements.</p>
<p>These issues were fixed in commit <code>ced70c17</code> by temporarily setting the length of the array smaller while processing it and adding assertions on the number of elements returned by the iterator.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-28028">https://nvd.nist.gov/vuln/detail/CVE-2021-28028</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0028.html">https://rustsec.org/advisories/RUSTSEC-2021-0028.html</a></li>
<li><a href="https://github.com/antonmarsden/toodee/issues/13">https://github.com/antonmarsden/toodee/issues/13</a></li>
<li><a href="https://github.com/antonmarsden/toodee/commit/ced70c172486fb4827c172cd8238053df3d1dcdb">https://github.com/antonmarsden/toodee/commit/ced70c172486fb4827c172cd8238053df3d1dcdb</a></li>
<li><a href="https://github.com/advisories/GHSA-wcvp-r8j8-47pc">https://github.com/advisories/GHSA-wcvp-r8j8-47pc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wcvp-r8j8-47pc</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-09-01T18:30:35.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[totp-rs] Observable Timing Discrepancy in totp-rs]]></title>
        <id>https://github.com/advisories/GHSA-8vxv-2g8p-2249</id>
        <link href="https://github.com/advisories/GHSA-8vxv-2g8p-2249"/>
        <updated>2023-06-13T21:57:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Token comparison was not constant time, and could theorically be used to guess value of an TOTP token, and thus reuse it in the same time window. The attacker would have to know the password beforehand nonetheless.</p>
<h3 id="patches">Patches</h3>
<p>Library now used constant-time comparison.</p>
<h3 id="workarounds">Workarounds</h3>
<p>No.</p>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Open an issue in <a href="https://github.com/constantoine/totp-rs">totp-rs</a></li>
<li>Email us at <a href="mailto:cleo.rebert@gmail.com">cleo.rebert@gmail.com</a></li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/constantoine/totp-rs/security/advisories/GHSA-8vxv-2g8p-2249">https://github.com/constantoine/totp-rs/security/advisories/GHSA-8vxv-2g8p-2249</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-29185">https://nvd.nist.gov/vuln/detail/CVE-2022-29185</a></li>
<li><a href="https://github.com/constantoine/totp-rs/issues/13">https://github.com/constantoine/totp-rs/issues/13</a></li>
<li><a href="https://github.com/constantoine/totp-rs/releases/tag/v1.1.0">https://github.com/constantoine/totp-rs/releases/tag/v1.1.0</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0018.html">https://rustsec.org/advisories/RUSTSEC-2022-0018.html</a></li>
<li><a href="https://github.com/constantoine/totp-rs/commit/1f1e1a6fe722deb1656f483b1367ea4be978db5b">https://github.com/constantoine/totp-rs/commit/1f1e1a6fe722deb1656f483b1367ea4be978db5b</a></li>
<li><a href="https://github.com/constantoine/totp-rs/compare/v1.0...v1.1.0">https://github.com/constantoine/totp-rs/compare/v1.0...v1.1.0</a></li>
<li><a href="https://github.com/advisories/GHSA-8vxv-2g8p-2249">https://github.com/advisories/GHSA-8vxv-2g8p-2249</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8vxv-2g8p-2249</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-05-24T21:33:15.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[string-interner] Use after free in string-interner]]></title>
        <id>https://github.com/advisories/GHSA-49fq-pw77-6qxj</id>
        <link href="https://github.com/advisories/GHSA-49fq-pw77-6qxj"/>
        <updated>2023-06-13T21:55:42.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate did not clone contained strings when an interner is cloned. Interners have raw pointers to the contained strings, and they keep pointing the strings which the old interner owns, after the interner is cloned. If a new cloned interner is alive and the old original interner is dead, the new interner has dangling pointers to the old interner's storage, which is already dropped.</p>
<p>This allows an attacker to read the already freed memory. The dangling pointers are used by the interners to check a string is already interned. An attacker can do brute force attack to get the data pointed by the dangling pointer.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-16882">https://nvd.nist.gov/vuln/detail/CVE-2019-16882</a></li>
<li><a href="https://github.com/Robbepop/string-interner/issues/9">https://github.com/Robbepop/string-interner/issues/9</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0023.html">https://rustsec.org/advisories/RUSTSEC-2019-0023.html</a></li>
<li><a href="https://github.com/Robbepop/string-interner/commit/d91dac0cfe42512526879cdfaac0b81beff54089">https://github.com/Robbepop/string-interner/commit/d91dac0cfe42512526879cdfaac0b81beff54089</a></li>
<li><a href="https://github.com/Robbepop/string-interner/pull/10">https://github.com/Robbepop/string-interner/pull/10</a></li>
<li><a href="https://github.com/advisories/GHSA-49fq-pw77-6qxj">https://github.com/advisories/GHSA-49fq-pw77-6qxj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-49fq-pw77-6qxj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T20:44:15.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[string-interner] Use after free in string-interner]]></title>
        <id>https://github.com/advisories/GHSA-49fq-pw77-6qxj</id>
        <link href="https://github.com/advisories/GHSA-49fq-pw77-6qxj"/>
        <updated>2023-06-13T21:55:42.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate did not clone contained strings when an interner is cloned. Interners have raw pointers to the contained strings, and they keep pointing the strings which the old interner owns, after the interner is cloned. If a new cloned interner is alive and the old original interner is dead, the new interner has dangling pointers to the old interner's storage, which is already dropped.</p>
<p>This allows an attacker to read the already freed memory. The dangling pointers are used by the interners to check a string is already interned. An attacker can do brute force attack to get the data pointed by the dangling pointer.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-16882">https://nvd.nist.gov/vuln/detail/CVE-2019-16882</a></li>
<li><a href="https://github.com/Robbepop/string-interner/issues/9">https://github.com/Robbepop/string-interner/issues/9</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0023.html">https://rustsec.org/advisories/RUSTSEC-2019-0023.html</a></li>
<li><a href="https://github.com/Robbepop/string-interner/commit/d91dac0cfe42512526879cdfaac0b81beff54089">https://github.com/Robbepop/string-interner/commit/d91dac0cfe42512526879cdfaac0b81beff54089</a></li>
<li><a href="https://github.com/Robbepop/string-interner/pull/10">https://github.com/Robbepop/string-interner/pull/10</a></li>
<li><a href="https://github.com/advisories/GHSA-49fq-pw77-6qxj">https://github.com/advisories/GHSA-49fq-pw77-6qxj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-49fq-pw77-6qxj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T20:44:15.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[time] Segmentation fault in time]]></title>
        <id>https://github.com/advisories/GHSA-wcg3-cvx6-7396</id>
        <link href="https://github.com/advisories/GHSA-wcg3-cvx6-7396"/>
        <updated>2023-06-13T21:51:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Unix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.</p>
<p>The affected functions from time 0.2.7 through 0.2.22 are:</p>
<ul>
<li><code>time::UtcOffset::local_offset_at</code></li>
<li><code>time::UtcOffset::try_local_offset_at</code></li>
<li><code>time::UtcOffset::current_local_offset</code></li>
<li><code>time::UtcOffset::try_current_local_offset</code></li>
<li><code>time::OffsetDateTime::now_local</code></li>
<li><code>time::OffsetDateTime::try_now_local</code></li>
</ul>
<p>The affected functions in time 0.1 (all versions) are:</p>
<ul>
<li><code>at</code></li>
<li><code>at_utc</code></li>
<li><code>now</code></li>
</ul>
<p>Non-Unix targets (including Windows and wasm) are unaffected.</p>
<h3 id="patches">Patches</h3>
<p>In some versions of <code>time</code>, the internal method that determines the local offset has been modified to always return <code>None</code> on the affected operating systems. This has the effect of returning an <code>Err</code> on the <code>try_*</code> methods and <code>UTC</code> on the non-<code>try_*</code> methods. In later versions, <code>time</code> will attempt to determine the number of threads running in the process. If the process is single-threaded, the call will proceed as its safety invariant is upheld.</p>
<p>Users and library authors with time in their dependency tree must perform <code>cargo update</code>, which will pull in the updated, unaffected code.</p>
<p>Users of time 0.1 do not have a patch and must upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Library authors must ensure that the program only has one running thread at the time of calling any affected method. Binary authors may do the same and/or ensure that no other thread is actively mutating the environment.</p>
<h3 id="references">References</h3>
<p><a href="https://github.com/time-rs/time/issues/293">time-rs/time#293</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396">https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26235">https://nvd.nist.gov/vuln/detail/CVE-2020-26235</a></li>
<li><a href="https://github.com/time-rs/time/issues/293">https://github.com/time-rs/time/issues/293</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0071.html">https://rustsec.org/advisories/RUSTSEC-2020-0071.html</a></li>
<li><a href="https://crates.io/crates/time/0.2.23">https://crates.io/crates/time/0.2.23</a></li>
<li><a href="https://github.com/advisories/GHSA-wcg3-cvx6-7396">https://github.com/advisories/GHSA-wcg3-cvx6-7396</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wcg3-cvx6-7396</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:56:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tremor-script] Memory Safety Issue when using `patch` or `merge` on `state` and assign the result back to `state`]]></title>
        <id>https://github.com/advisories/GHSA-3pp4-64mp-9cg9</id>
        <link href="https://github.com/advisories/GHSA-3pp4-64mp-9cg9"/>
        <updated>2023-06-13T21:47:20.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate maintains references to memory that might have been freed already.
If affects the following two <code>tremor-script</code> language constructs:</p>
<ul>
<li>A <a href="https://www.tremor.rs/docs/tremor-script/index#merge">Merge</a> where we assign the result back to the target expression
and the expression to be merged needs to reference the <code>event</code>:</li>
</ul>
<pre><code>let state = merge state of event end;
</code></pre>
<ul>
<li>A <a href="https://www.tremor.rs/docs/tremor-script/index#patch">Patch</a> where we assign the result back to the target expression
and the patch operations used need to reference the <code>event</code>:</li>
</ul>
<pre><code>let state = patch state of insert event.key =&gt; event.value end;
</code></pre>
<p>For constructs like this (it doesnt matter what is references in the expression to be merged or the patch operations) an optimization
was applied to manipulate the target value in-place, instead of cloning it.</p>
<p>Our <code>Value</code> struct which underpins all event data in <code>tremor-script</code>, is representing as borrowed strings <code>beef::Cow&lt;'lifetime, str&gt;</code> 
that reference the actual <code>Vec&lt;u8&gt;</code> the event is based upon. We keep the raw byte-array next to the event structure inside our <code>Event</code> struct as a self-referential struct,
so we make sure that the structured <code>Value</code> and its references are valid across its whole lifetime.</p>
<p>The optimization was considered safe as long as it was only possible to merge or patche <code>event</code> data or static data.
When <code>state</code> was introduced to <code>tremor-script</code> a new possibility existed, to keep <code>Value</code> data around for longer than the lifetime of an event.
If <code>event</code> data is merged or patched into <code>state</code> without cloning <code>state</code> first, it can still reference keys or values from
the previous event, which will now be invalid. This allows access to those already freed regions of memory and to get their content out over the wire.</p>
<h2 id="workaround">Workaround</h2>
<p>If an upgrade is not possible, a possible workaround is to avoid the optimization
by introducing a temporary variable and not immediately reassigning to <code>state</code>:</p>
<pre><code>let tmp = merge state of event end;
let state = tmp
</code></pre>
<h2 id="fix">Fix</h2>
<p>The flaw was corrected in <code>tremor-script</code> version 0.11.6 via commit <a href="https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e">1a2efcd</a> by removing the optimization
and always clone the target expression of a <a href="https://www.tremor.rs/docs/tremor-script/index#merge">Merge</a> or [Patch](<a href="https://www.tremor.rs/docs/tremor-script/index#patch">https://www.tremor.rs/docs/tremor-script/index#patch</a>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tremor-rs/tremor-runtime/pull/1217">https://github.com/tremor-rs/tremor-runtime/pull/1217</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0111.html">https://rustsec.org/advisories/RUSTSEC-2021-0111.html</a></li>
<li><a href="https://github.com/advisories/GHSA-3pp4-64mp-9cg9">https://github.com/advisories/GHSA-3pp4-64mp-9cg9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3pp4-64mp-9cg9</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-17T00:27:30.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tremor-script] Use After Free in tremor-script]]></title>
        <id>https://github.com/advisories/GHSA-9qvw-46gf-4fv8</id>
        <link href="https://github.com/advisories/GHSA-9qvw-46gf-4fv8"/>
        <updated>2023-06-13T21:46:57.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the tremor-script crate before 0.11.6 for Rust. A merge operation may result in a use-after-free.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45702">https://nvd.nist.gov/vuln/detail/CVE-2021-45702</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tremor-script/RUSTSEC-2021-0111.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/tremor-script/RUSTSEC-2021-0111.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0111.html">https://rustsec.org/advisories/RUSTSEC-2021-0111.html</a></li>
<li><a href="https://github.com/tremor-rs/tremor-runtime/pull/1217">https://github.com/tremor-rs/tremor-runtime/pull/1217</a></li>
<li><a href="https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e">https://github.com/tremor-rs/tremor-runtime/commit/1a2efcdbe68e5e7fd0a05836ac32d2cde78a0b2e</a></li>
<li><a href="https://github.com/advisories/GHSA-9qvw-46gf-4fv8">https://github.com/advisories/GHSA-9qvw-46gf-4fv8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9qvw-46gf-4fv8</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-01-06T22:09:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[smallvec] Memory corruption in smallvec]]></title>
        <id>https://github.com/advisories/GHSA-69gw-hgj3-45m7</id>
        <link href="https://github.com/advisories/GHSA-69gw-hgj3-45m7"/>
        <updated>2023-06-13T21:37:37.000Z</updated>
        <content type="html"><![CDATA[<p>Attempting to call grow on a spilled SmallVec with a value less than the current capacity causes corruption of memory allocator data structures. An attacker that controls the value passed to grow may exploit this flaw to obtain memory contents or gain remote code execution.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-15554">https://nvd.nist.gov/vuln/detail/CVE-2019-15554</a></li>
<li><a href="https://github.com/servo/rust-smallvec/issues/149">https://github.com/servo/rust-smallvec/issues/149</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0012.html">https://rustsec.org/advisories/RUSTSEC-2019-0012.html</a></li>
<li><a href="https://github.com/advisories/GHSA-69gw-hgj3-45m7">https://github.com/advisories/GHSA-69gw-hgj3-45m7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-69gw-hgj3-45m7</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-08-25T20:43:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[safe-transmute] Heap overflow or corruption in safe-transmute]]></title>
        <id>https://github.com/advisories/GHSA-2v78-j59h-fmpf</id>
        <link href="https://github.com/advisories/GHSA-2v78-j59h-fmpf"/>
        <updated>2023-06-13T21:04:33.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate switched the length and capacity arguments in the Vec::from_raw_parts() constructor, which could lead to memory corruption or data leakage.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2018-21000">https://nvd.nist.gov/vuln/detail/CVE-2018-21000</a></li>
<li><a href="https://github.com/nabijaczleweli/safe-transmute-rs/pull/36">https://github.com/nabijaczleweli/safe-transmute-rs/pull/36</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2018-0013.html">https://rustsec.org/advisories/RUSTSEC-2018-0013.html</a></li>
<li><a href="https://github.com/nabijaczleweli/safe-transmute-rs/commit/a134e06d740f9d7c287f74c0af2cd06206774364">https://github.com/nabijaczleweli/safe-transmute-rs/commit/a134e06d740f9d7c287f74c0af2cd06206774364</a></li>
<li><a href="https://github.com/advisories/GHSA-2v78-j59h-fmpf">https://github.com/advisories/GHSA-2v78-j59h-fmpf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2v78-j59h-fmpf</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-08-25T20:43:23.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[serde_yaml] Uncontrolled recursion leads to abort in deserialization]]></title>
        <id>https://github.com/advisories/GHSA-39vw-qp34-rmwf</id>
        <link href="https://github.com/advisories/GHSA-39vw-qp34-rmwf"/>
        <updated>2023-06-13T21:03:37.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate did not properly check for recursion while deserializing aliases. This allows an attacker to make a YAML file with an alias referring to itself causing an abort. The flaw was corrected by checking the recursion depth.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dtolnay/serde-yaml/pull/105">https://github.com/dtolnay/serde-yaml/pull/105</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2018-0005.html">https://rustsec.org/advisories/RUSTSEC-2018-0005.html</a></li>
<li><a href="https://github.com/dtolnay/serde-yaml/commit/b93aff6e904cffbbfd1f421b82f6dcc5ca19a4fd">https://github.com/dtolnay/serde-yaml/commit/b93aff6e904cffbbfd1f421b82f6dcc5ca19a4fd</a></li>
<li><a href="https://github.com/advisories/GHSA-39vw-qp34-rmwf">https://github.com/advisories/GHSA-39vw-qp34-rmwf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-39vw-qp34-rmwf</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T21:00:18.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[simd-json] Out of bounds read in simd-json]]></title>
        <id>https://github.com/advisories/GHSA-gwfj-pw2x-h6c2</id>
        <link href="https://github.com/advisories/GHSA-gwfj-pw2x-h6c2"/>
        <updated>2023-06-13T21:01:36.000Z</updated>
        <content type="html"><![CDATA[<p>The affected version of this crate did not guard against accessing memory beyond the range of its input data. A pointer cast to read the data into a 256-bit register could lead to a segmentation fault when the end plus the 32 bytes (256 bit) read would overlap into the next page during string parsing. This allows an attacker to eventually crash a service. The flaw was corrected by using a padding buffer for the last read from the input. So that we are we never read over the boundary of the input data.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-15550">https://nvd.nist.gov/vuln/detail/CVE-2019-15550</a></li>
<li><a href="https://github.com/Licenser/simdjson-rs/pull/27">https://github.com/Licenser/simdjson-rs/pull/27</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0008.html">https://rustsec.org/advisories/RUSTSEC-2019-0008.html</a></li>
<li><a href="https://github.com/advisories/GHSA-gwfj-pw2x-h6c2">https://github.com/advisories/GHSA-gwfj-pw2x-h6c2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-gwfj-pw2x-h6c2</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T20:43:56.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[smallvec] Double free in smallvec]]></title>
        <id>https://github.com/advisories/GHSA-rxr4-x558-x7hw</id>
        <link href="https://github.com/advisories/GHSA-rxr4-x558-x7hw"/>
        <updated>2023-06-13T20:58:32.000Z</updated>
        <content type="html"><![CDATA[<p>If an iterator passed to SmallVec::insert_many panicked in Iterator::next, destructors were run during unwinding while the vector was in an inconsistent state, possibly causing a double free (a destructor running on two copies of the same value).</p>
<p>This is fixed in smallvec 0.6.3 by ensuring that the vector's length is not updated to include moved items until they have been removed from their original positions. Items may now be leaked if Iterator::next panics, but they will not be dropped more than once.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2018-20991">https://nvd.nist.gov/vuln/detail/CVE-2018-20991</a></li>
<li><a href="https://github.com/servo/rust-smallvec/issues/96">https://github.com/servo/rust-smallvec/issues/96</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2018-0003.html">https://rustsec.org/advisories/RUSTSEC-2018-0003.html</a></li>
<li><a href="https://github.com/advisories/GHSA-rxr4-x558-x7hw">https://github.com/advisories/GHSA-rxr4-x558-x7hw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rxr4-x558-x7hw</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-08-25T20:42:54.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[smallvec] Double free in smallvec]]></title>
        <id>https://github.com/advisories/GHSA-mm7v-vpv8-xfc3</id>
        <link href="https://github.com/advisories/GHSA-mm7v-vpv8-xfc3"/>
        <updated>2023-06-13T20:57:37.000Z</updated>
        <content type="html"><![CDATA[<p>Attempting to call grow on a spilled SmallVec with a value equal to the current capacity causes it to free the existing data. This performs a double free immediately and may lead to use-after-free on subsequent accesses to the SmallVec contents. An attacker that controls the value passed to grow may exploit this flaw to obtain memory contents or gain remote code execution.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-15551">https://nvd.nist.gov/vuln/detail/CVE-2019-15551</a></li>
<li><a href="https://github.com/servo/rust-smallvec/issues/148">https://github.com/servo/rust-smallvec/issues/148</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0009.html">https://rustsec.org/advisories/RUSTSEC-2019-0009.html</a></li>
<li><a href="https://github.com/servo/rust-smallvec/issues/149">https://github.com/servo/rust-smallvec/issues/149</a></li>
<li><a href="https://github.com/servo/rust-smallvec/commit/c20cfa8584e649f00dc0767ab6fad63a3f59a296">https://github.com/servo/rust-smallvec/commit/c20cfa8584e649f00dc0767ab6fad63a3f59a296</a></li>
<li><a href="https://github.com/servo/rust-smallvec/commit/f96322b9243405cc82701cc73f1b19313b413ab4">https://github.com/servo/rust-smallvec/commit/f96322b9243405cc82701cc73f1b19313b413ab4</a></li>
<li><a href="https://github.com/advisories/GHSA-mm7v-vpv8-xfc3">https://github.com/advisories/GHSA-mm7v-vpv8-xfc3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mm7v-vpv8-xfc3</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-08-25T20:44:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[slock] Slock<T> allows sending non-Send types across thread boundaries]]></title>
        <id>https://github.com/advisories/GHSA-83r8-p8v6-6gfm</id>
        <link href="https://github.com/advisories/GHSA-83r8-p8v6-6gfm"/>
        <updated>2023-06-13T20:56:17.000Z</updated>
        <content type="html"><![CDATA[<p><code>Slock&lt;T&gt;</code> unconditionally implements <code>Send</code>/<code>Sync</code>.</p>
<p>Affected versions of this crate allows sending non-Send types to other threads,
which can lead to data races and memory corruption due to the data race.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/BrokenLamp/slock-rs/issues/2">https://github.com/BrokenLamp/slock-rs/issues/2</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0135.html">https://rustsec.org/advisories/RUSTSEC-2020-0135.html</a></li>
<li><a href="https://github.com/advisories/GHSA-83r8-p8v6-6gfm">https://github.com/advisories/GHSA-83r8-p8v6-6gfm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-83r8-p8v6-6gfm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T21:00:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[spin] Wrong memory orderings violates mutual exclusion in spin]]></title>
        <id>https://github.com/advisories/GHSA-hv7x-f3pv-gpwr</id>
        <link href="https://github.com/advisories/GHSA-hv7x-f3pv-gpwr"/>
        <updated>2023-06-13T20:55:22.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the spin crate before 0.5.2 for Rust, when RwLock is used. Because memory ordering is mishandled, two writers can acquire the lock at the same time, violating mutual exclusion.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-16137">https://nvd.nist.gov/vuln/detail/CVE-2019-16137</a></li>
<li><a href="https://github.com/mvdnes/spin-rs/issues/65">https://github.com/mvdnes/spin-rs/issues/65</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0013.html">https://rustsec.org/advisories/RUSTSEC-2019-0013.html</a></li>
<li><a href="https://github.com/mvdnes/spin-rs/pull/66">https://github.com/mvdnes/spin-rs/pull/66</a></li>
<li><a href="https://github.com/advisories/GHSA-hv7x-f3pv-gpwr">https://github.com/advisories/GHSA-hv7x-f3pv-gpwr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-hv7x-f3pv-gpwr</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T20:44:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[stack_dst] Double free in stack_dst]]></title>
        <id>https://github.com/advisories/GHSA-8mjx-h23h-w2pg</id>
        <link href="https://github.com/advisories/GHSA-8mjx-h23h-w2pg"/>
        <updated>2023-06-13T20:52:44.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of stack_dst used a push_inner function that increased the internal length of the array and then called val.clone(). If the val.clone() call panics, the stack could drop an already dropped element or drop uninitialized memory. This issue was fixed in <code>2a4d538</code> by increasing the length of the array after elements are cloned.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-28034">https://nvd.nist.gov/vuln/detail/CVE-2021-28034</a></li>
<li><a href="https://github.com/thepowersgang/stack_dst-rs/commit/2a4d53809e3000f40085f2b229b6b1a33759881d">https://github.com/thepowersgang/stack_dst-rs/commit/2a4d53809e3000f40085f2b229b6b1a33759881d</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0033.html">https://rustsec.org/advisories/RUSTSEC-2021-0033.html</a></li>
<li><a href="https://github.com/thepowersgang/stack_dst-rs/issues/5">https://github.com/thepowersgang/stack_dst-rs/issues/5</a></li>
<li><a href="https://github.com/thepowersgang/stack_dst-rs/commit/2a4d538">https://github.com/thepowersgang/stack_dst-rs/commit/2a4d538</a></li>
<li><a href="https://github.com/advisories/GHSA-8mjx-h23h-w2pg">https://github.com/advisories/GHSA-8mjx-h23h-w2pg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8mjx-h23h-w2pg</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-09-01T18:30:44.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[smallvec] Buffer overflow in SmallVec::insert_many]]></title>
        <id>https://github.com/advisories/GHSA-43w2-9j62-hq99</id>
        <link href="https://github.com/advisories/GHSA-43w2-9j62-hq99"/>
        <updated>2023-06-13T20:51:42.000Z</updated>
        <content type="html"><![CDATA[<p>A bug in the SmallVec::insert_many method caused it to allocate a buffer that was smaller than needed. It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap. This bug was only triggered if the iterator passed to insert_many yielded more items than the lower bound returned from its size_hint method.</p>
<p>The flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted. The fix also simplified the implementation of insert_many to use less unsafe code, so it is easier to verify its correctness.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-25900">https://nvd.nist.gov/vuln/detail/CVE-2021-25900</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0003.html">https://rustsec.org/advisories/RUSTSEC-2021-0003.html</a></li>
<li><a href="https://github.com/servo/rust-smallvec/issues/252">https://github.com/servo/rust-smallvec/issues/252</a></li>
<li><a href="https://github.com/advisories/GHSA-43w2-9j62-hq99">https://github.com/advisories/GHSA-43w2-9j62-hq99</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-43w2-9j62-hq99</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-05-24T17:40:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[smallvec] Buffer overflow in SmallVec::insert_many]]></title>
        <id>https://github.com/advisories/GHSA-43w2-9j62-hq99</id>
        <link href="https://github.com/advisories/GHSA-43w2-9j62-hq99"/>
        <updated>2023-06-13T20:51:42.000Z</updated>
        <content type="html"><![CDATA[<p>A bug in the SmallVec::insert_many method caused it to allocate a buffer that was smaller than needed. It then wrote past the end of the buffer, causing a buffer overflow and memory corruption on the heap. This bug was only triggered if the iterator passed to insert_many yielded more items than the lower bound returned from its size_hint method.</p>
<p>The flaw was corrected in smallvec 0.6.14 and 1.6.1, by ensuring that additional space is always reserved for each item inserted. The fix also simplified the implementation of insert_many to use less unsafe code, so it is easier to verify its correctness.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-25900">https://nvd.nist.gov/vuln/detail/CVE-2021-25900</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0003.html">https://rustsec.org/advisories/RUSTSEC-2021-0003.html</a></li>
<li><a href="https://github.com/servo/rust-smallvec/issues/252">https://github.com/servo/rust-smallvec/issues/252</a></li>
<li><a href="https://github.com/advisories/GHSA-43w2-9j62-hq99">https://github.com/advisories/GHSA-43w2-9j62-hq99</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-43w2-9j62-hq99</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-05-24T17:40:21.000Z</published>
    </entry>
</feed>