<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2022-12-10T12:01:28.381Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code]]></title>
        <id>https://github.com/advisories/GHSA-969w-q74q-9j8v</id>
        <link href="https://github.com/advisories/GHSA-969w-q74q-9j8v"/>
        <updated>2022-12-08T16:00:29.000Z</updated>
        <content type="html"><![CDATA[<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to "free" memory not allocated by the appropriate allocator.</p>
<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to "deallocate" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>
<p>You are unaffected if you either</p>
<ul>
<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>
<li>manually checked that your usage of the method is sound</li>
<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>
</ul>
<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>
<p>See the <a href="https://github.com/rust-bitcoin/rust-secp256k1/issues/543">GitHub issue</a> for example "exploit" code and further discussion.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rust-bitcoin/rust-secp256k1/issues/543">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0070.html">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-969w-q74q-9j8v">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-969w-q74q-9j8v</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-12-08T16:00:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code]]></title>
        <id>https://github.com/advisories/GHSA-969w-q74q-9j8v</id>
        <link href="https://github.com/advisories/GHSA-969w-q74q-9j8v"/>
        <updated>2022-12-08T16:00:29.000Z</updated>
        <content type="html"><![CDATA[<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to "free" memory not allocated by the appropriate allocator.</p>
<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to "deallocate" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>
<p>You are unaffected if you either</p>
<ul>
<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>
<li>manually checked that your usage of the method is sound</li>
<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>
</ul>
<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>
<p>See the <a href="https://github.com/rust-bitcoin/rust-secp256k1/issues/543">GitHub issue</a> for example "exploit" code and further discussion.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rust-bitcoin/rust-secp256k1/issues/543">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0070.html">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-969w-q74q-9j8v">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-969w-q74q-9j8v</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-12-08T16:00:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[secp256k1] Unsound API in `secp256k1` allows use-after-free and invalid deallocation from safe code]]></title>
        <id>https://github.com/advisories/GHSA-969w-q74q-9j8v</id>
        <link href="https://github.com/advisories/GHSA-969w-q74q-9j8v"/>
        <updated>2022-12-08T16:00:29.000Z</updated>
        <content type="html"><![CDATA[<p>Because of incorrect bounds on method <code>Secp256k1::preallocated_gen_new</code> it was possible to cause use-after-free from safe consumer code. It was also possible to "free" memory not allocated by the appropriate allocator.</p>
<p>The method takes a place for storing the context as a mutable reference and returns context containing that reference. Because the code internally uses <code>unsafe</code> and the bounds were incorrect it was possible to create a context that outlived the passed reference (e.g. <code>'static</code>). Because the context can alternatively carry heap-allocated pointer freed on drop it was possible to "deallocate" a pointer that wasn't returned from appropriate allocator. The code decides whether to free the memory based on type parameter but because of missing bound it was possible to construct the context with invalid parameter.</p>
<p>You are unaffected if you either</p>
<ul>
<li>don't call <code>Secp256k1::preallocated_gen_new</code></li>
<li>manually checked that your usage of the method is sound</li>
<li>upgraded to the patched version of <code>secp256k1</code> (recommended)</li>
</ul>
<p>The patched version uses correct bounds which means it is API-breaking. This effectively means adopting the policy of Rust lang itself allowing API-breaking changes to fix soundness bugs. Note however that valid straigthforward usage of the code will continue to compile. Only unsound code or code that propagates the bound in custom generics will fail to compile. If the code is sound fixing the bounds should be sufficient to make the code compile.</p>
<p>See the <a href="https://github.com/rust-bitcoin/rust-secp256k1/issues/543">GitHub issue</a> for example "exploit" code and further discussion.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rust-bitcoin/rust-secp256k1/issues/543">https://github.com/rust-bitcoin/rust-secp256k1/issues/543</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0070.html">https://rustsec.org/advisories/RUSTSEC-2022-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-969w-q74q-9j8v">https://github.com/advisories/GHSA-969w-q74q-9j8v</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-969w-q74q-9j8v</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-12-08T16:00:29.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[time] Segmentation fault in time]]></title>
        <id>https://github.com/advisories/GHSA-wcg3-cvx6-7396</id>
        <link href="https://github.com/advisories/GHSA-wcg3-cvx6-7396"/>
        <updated>2022-12-08T00:54:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Unix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.</p>
<p>The affected functions from time 0.2.7 through 0.2.22 are:</p>
<ul>
<li><code>time::UtcOffset::local_offset_at</code></li>
<li><code>time::UtcOffset::try_local_offset_at</code></li>
<li><code>time::UtcOffset::current_local_offset</code></li>
<li><code>time::UtcOffset::try_current_local_offset</code></li>
<li><code>time::OffsetDateTime::now_local</code></li>
<li><code>time::OffsetDateTime::try_now_local</code></li>
</ul>
<p>The affected functions in time 0.1 (all versions) are:</p>
<ul>
<li><code>at</code></li>
<li><code>at_utc</code></li>
<li><code>now</code></li>
</ul>
<p>Non-Unix targets (including Windows and wasm) are unaffected.</p>
<h3 id="patches">Patches</h3>
<p>In some versions of <code>time</code>, the internal method that determines the local offset has been modified to always return <code>None</code> on the affected operating systems. This has the effect of returning an <code>Err</code> on the <code>try_*</code> methods and <code>UTC</code> on the non-<code>try_*</code> methods. In later versions, <code>time</code> will attempt to determine the number of threads running in the process. If the process is single-threaded, the call will proceed as its safety invariant is upheld.</p>
<p>Users and library authors with time in their dependency tree must perform <code>cargo update</code>, which will pull in the updated, unaffected code.</p>
<p>Users of time 0.1 do not have a patch and must upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Library authors must ensure that the program only has one running thread at the time of calling any affected method. Binary authors may do the same and/or ensure that no other thread is actively mutating the environment.</p>
<h3 id="references">References</h3>
<p><a href="https://github.com/time-rs/time/issues/293">time-rs/time#293</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396">https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26235">https://nvd.nist.gov/vuln/detail/CVE-2020-26235</a></li>
<li><a href="https://github.com/time-rs/time/issues/293">https://github.com/time-rs/time/issues/293</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0071.html">https://rustsec.org/advisories/RUSTSEC-2020-0071.html</a></li>
<li><a href="https://crates.io/crates/time/0.2.23">https://crates.io/crates/time/0.2.23</a></li>
<li><a href="https://github.com/advisories/GHSA-wcg3-cvx6-7396">https://github.com/advisories/GHSA-wcg3-cvx6-7396</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wcg3-cvx6-7396</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:56:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[libp2p] libp2p DoS vulnerability from lack of resource management]]></title>
        <id>https://github.com/advisories/GHSA-jvgw-gccv-q5p8</id>
        <link href="https://github.com/advisories/GHSA-jvgw-gccv-q5p8"/>
        <updated>2022-12-08T21:48:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>An attacker node can cause a victim node to allocate a large number of small memory chunks, which can ultimately lead to the victim’s process running out of memory and thus getting killed by its operating system. When executed continuously, this can lead to a denial of service attack, especially relevant on a larger scale when run against more than one node of a libp2p based network.</p>
<h3 id="details">Details</h3>
<p>In the original version of the attack, the malicious node would continuously open new streams on a single connection using a stream multiplexer that doesn’t provide sufficient back pressure (mplex or yamux). While allocations per stream might be considered small, they multiply with the number of streams and connections. It is easy to defend against this one attack, e.g. by setting a strict per connection stream limit and connection limit. But there are other variations of this attack, e.g. causing memory allocations by sending partial payloads on various protocol levels, forcing the victim to buffer the partial payload for a period of time or by tricking the victim into pre-allocating buffers for messages which are never sent by the attacker.</p>
<h3 id="patches">Patches</h3>
<p>Users are advised to upgrade to <code>libp2p</code> <code>v0.45.1</code> or above.</p>
<h3 id="references">References</h3>
<p>Please see our DoS Mitigation page for more information on how to incorporate mitigation strategies, monitor your application, and respond to attacks: <a href="https://docs.libp2p.io/reference/dos-mitigation/">https://docs.libp2p.io/reference/dos-mitigation/</a>.</p>
<p>Please see the related disclosure for go-libp2p: <a href="https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw">https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw</a> and js-libp2p: <a href="https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv">https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv</a></p>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory, please email us at <a href="mailto:security@libp2p.io">security@libp2p.io</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw">https://github.com/libp2p/go-libp2p/security/advisories/GHSA-j7qp-mfxf-8xjw</a></li>
<li><a href="https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv">https://github.com/libp2p/js-libp2p/security/advisories/GHSA-f44q-634c-jvwv</a></li>
<li><a href="https://github.com/libp2p/rust-libp2p/security/advisories/GHSA-jvgw-gccv-q5p8">https://github.com/libp2p/rust-libp2p/security/advisories/GHSA-jvgw-gccv-q5p8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-23486">https://nvd.nist.gov/vuln/detail/CVE-2022-23486</a></li>
<li><a href="https://github.com/advisories/GHSA-jvgw-gccv-q5p8">https://github.com/advisories/GHSA-jvgw-gccv-q5p8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jvgw-gccv-q5p8</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-12-07T20:28:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[time] Segmentation fault in time]]></title>
        <id>https://github.com/advisories/GHSA-wcg3-cvx6-7396</id>
        <link href="https://github.com/advisories/GHSA-wcg3-cvx6-7396"/>
        <updated>2022-12-08T00:54:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Unix-like operating systems may segfault due to dereferencing a dangling pointer in specific circumstances. This requires an environment variable to be set in a different thread than the affected functions. This may occur without the user's knowledge, notably in a third-party library.</p>
<p>The affected functions from time 0.2.7 through 0.2.22 are:</p>
<ul>
<li><code>time::UtcOffset::local_offset_at</code></li>
<li><code>time::UtcOffset::try_local_offset_at</code></li>
<li><code>time::UtcOffset::current_local_offset</code></li>
<li><code>time::UtcOffset::try_current_local_offset</code></li>
<li><code>time::OffsetDateTime::now_local</code></li>
<li><code>time::OffsetDateTime::try_now_local</code></li>
</ul>
<p>The affected functions in time 0.1 (all versions) are:</p>
<ul>
<li><code>at</code></li>
<li><code>at_utc</code></li>
<li><code>now</code></li>
</ul>
<p>Non-Unix targets (including Windows and wasm) are unaffected.</p>
<h3 id="patches">Patches</h3>
<p>In some versions of <code>time</code>, the internal method that determines the local offset has been modified to always return <code>None</code> on the affected operating systems. This has the effect of returning an <code>Err</code> on the <code>try_*</code> methods and <code>UTC</code> on the non-<code>try_*</code> methods. In later versions, <code>time</code> will attempt to determine the number of threads running in the process. If the process is single-threaded, the call will proceed as its safety invariant is upheld.</p>
<p>Users and library authors with time in their dependency tree must perform <code>cargo update</code>, which will pull in the updated, unaffected code.</p>
<p>Users of time 0.1 do not have a patch and must upgrade to an unaffected version: time 0.2.23 or greater or the 0.3 series.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Library authors must ensure that the program only has one running thread at the time of calling any affected method. Binary authors may do the same and/or ensure that no other thread is actively mutating the environment.</p>
<h3 id="references">References</h3>
<p><a href="https://github.com/time-rs/time/issues/293">time-rs/time#293</a>.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396">https://github.com/time-rs/time/security/advisories/GHSA-wcg3-cvx6-7396</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-26235">https://nvd.nist.gov/vuln/detail/CVE-2020-26235</a></li>
<li><a href="https://github.com/time-rs/time/issues/293">https://github.com/time-rs/time/issues/293</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0071.html">https://rustsec.org/advisories/RUSTSEC-2020-0071.html</a></li>
<li><a href="https://crates.io/crates/time/0.2.23">https://crates.io/crates/time/0.2.23</a></li>
<li><a href="https://github.com/advisories/GHSA-wcg3-cvx6-7396">https://github.com/advisories/GHSA-wcg3-cvx6-7396</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wcg3-cvx6-7396</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:56:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hyper-staticfile] hyper-staticfile's improper validation of Windows paths could lead to directory traversal attack]]></title>
        <id>https://github.com/advisories/GHSA-7p7c-pvvx-2vx3</id>
        <link href="https://github.com/advisories/GHSA-7p7c-pvvx-2vx3"/>
        <updated>2022-12-05T22:03:48.000Z</updated>
        <content type="html"><![CDATA[<p>Path resolution in <code>hyper-staticfile</code> didn't correctly validate Windows paths, meaning paths like <code>/foo/bar/c:/windows/web/screen/img101.png</code> would be allowed and respond with the contents of <code>c:/windows/web/screen/img101.png</code>. Thus users could potentially read files anywhere on the filesystem.</p>
<p>This only impacts Windows. Linux and other unix likes are not impacted by this.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/stephank/hyper-staticfile/issues/35">https://github.com/stephank/hyper-staticfile/issues/35</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0069.html">https://rustsec.org/advisories/RUSTSEC-2022-0069.html</a></li>
<li><a href="https://github.com/advisories/GHSA-7p7c-pvvx-2vx3">https://github.com/advisories/GHSA-7p7c-pvvx-2vx3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7p7c-pvvx-2vx3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-12-05T22:03:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hyper-staticfile] hyper-staticfile's improper validation of Windows paths could lead to directory traversal attack]]></title>
        <id>https://github.com/advisories/GHSA-7p7c-pvvx-2vx3</id>
        <link href="https://github.com/advisories/GHSA-7p7c-pvvx-2vx3"/>
        <updated>2022-12-05T22:03:48.000Z</updated>
        <content type="html"><![CDATA[<p>Path resolution in <code>hyper-staticfile</code> didn't correctly validate Windows paths, meaning paths like <code>/foo/bar/c:/windows/web/screen/img101.png</code> would be allowed and respond with the contents of <code>c:/windows/web/screen/img101.png</code>. Thus users could potentially read files anywhere on the filesystem.</p>
<p>This only impacts Windows. Linux and other unix likes are not impacted by this.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/stephank/hyper-staticfile/issues/35">https://github.com/stephank/hyper-staticfile/issues/35</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0069.html">https://rustsec.org/advisories/RUSTSEC-2022-0069.html</a></li>
<li><a href="https://github.com/advisories/GHSA-7p7c-pvvx-2vx3">https://github.com/advisories/GHSA-7p7c-pvvx-2vx3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7p7c-pvvx-2vx3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-12-05T22:03:46.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[capnp] Cap'n Proto and its Rust implementation vulnerable to out-of-bounds read due to logic error handling list-of-list]]></title>
        <id>https://github.com/advisories/GHSA-qqff-4vw4-f6hx</id>
        <link href="https://github.com/advisories/GHSA-qqff-4vw4-f6hx"/>
        <updated>2022-12-05T17:58:20.000Z</updated>
        <content type="html"><![CDATA[<p>The Cap'n Proto library and capnp Rust package are vulnerable to out-of-bounds read due to logic error handling list-of-list. If a message consumer expects data of type "list of pointers", and if the consumer performs certain specific actions on such data, then a message producer can cause the consumer to read out-of-bounds memory. This could trigger a process crash in the consumer, or in some cases could allow exfiltration of private in-memory data.</p>
<h1 id="impact">Impact</h1>
<ul>
<li>Remotely segfault a peer by sending it a malicious message, if the victim performs certain actions on a list-of-pointer type.</li>
<li>Possible exfiltration of memory, if the victim performs additional certain actions on a list-of-pointer type.</li>
<li>To be vulnerable, an application must perform a specific sequence of actions, described below. At present, <strong>we are not aware of any vulnerable application</strong>, but we advise updating regardless.</li>
</ul>
<h1 id="fixed-in">Fixed in</h1>
<p>Unfortunately, the bug is present in inlined code, therefore the fix will require rebuilding dependent applications.</p>
<p>C++ fix:</p>
<ul>
<li>git commit <a href="https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9">25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>
<li>release 0.11 (future)</li>
<li>release 0.10.3:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.10.3.tar.gz">https://capnproto.org/capnproto-c++-0.10.3.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.10.3.zip">https://capnproto.org/capnproto-c++-win32-0.10.3.zip</a></li>
</ul>
</li>
<li>release 0.9.2:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.9.2.tar.gz">https://capnproto.org/capnproto-c++-0.9.2.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.9.2.zip">https://capnproto.org/capnproto-c++-win32-0.9.2.zip</a></li>
</ul>
</li>
<li>release 0.8.1:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.8.1.tar.gz">https://capnproto.org/capnproto-c++-0.8.1.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.8.1.zip">https://capnproto.org/capnproto-c++-win32-0.8.1.zip</a></li>
</ul>
</li>
<li>release 0.7.1:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.7.1.tar.gz">https://capnproto.org/capnproto-c++-0.7.1.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.7.1.zip">https://capnproto.org/capnproto-c++-win32-0.7.1.zip</a></li>
</ul>
</li>
<li>release 0.5.4:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.5.4.tar.gz">https://capnproto.org/capnproto-c++-0.5.4.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.5.4.zip">https://capnproto.org/capnproto-c++-win32-0.5.4.zip</a></li>
</ul>
</li>
</ul>
<p>Rust fix:</p>
<ul>
<li><code>capnp</code> crate version <code>0.15.2</code>, <code>0.14.11</code>, or <code>0.13.7</code></li>
</ul>
<h1 id="details">Details</h1>
<p>A specially-crafted pointer could escape bounds checking by exploiting inconsistent handling of pointers when a list-of-structs is downgraded to a list-of-pointers.</p>
<p>For an in-depth explanation of how this bug works, see <a href="https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html">David Renshaw's blog post</a>. This details below focus only on determining whether an application is vulnerable.</p>
<p>In order to be vulnerable, an application must have certain properties.</p>
<p>First, the application must accept messages with a schema in which a field has list-of-pointer type. This includes <code>List(Text)</code>, <code>List(Data)</code>, <code>List(List(T))</code>, or <code>List(C)</code> where <code>C</code> is an interface type. In the following discussion, we will assume this field is named <code>foo</code>.</p>
<p>Second, the application must accept a message of this schema from a malicious source, where the attacker can maliciously encode the pointer representing the field <code>foo</code>.</p>
<p>Third, the application must call <code>getFoo()</code> to obtain a <code>List&lt;T&gt;::Reader</code> for the field, and then use it in one of the following two ways:</p>
<ol>
<li><p>Pass it as the parameter to another message's <code>setFoo()</code>, thus copying the field into a new message. Note that copying the parent struct as a whole will <em>not</em> trigger the bug; the bug only occurs if the specific field <code>foo</code> is get/set on its own.</p>
</li>
<li><p>Convert it into <code>AnyList::Reader</code>, and then attempt to access it through that. This is much less likely; very few apps use the <code>AnyList</code> API.</p>
</li>
</ol>
<p>The dynamic API equivalents of these actions (<code>capnp/dynamic.h</code>) are also affected.</p>
<p>If the application does these steps, the attacker may be able to cause the Cap'n Proto implementation to read beyond the end of the message. This could induce a segmentation fault. Or, worse, data that happened to be in memory immediately after the message might be returned as if it were part of the message. In the latter case, if the application then forwards that data back to the attacker or sends it to another third party, this could result in exfiltration of secrets.</p>
<p>Any exfiltration of data would have the following limitations:</p>
<ul>
<li>The attacker could exfiltrate no more than 512 KiB of memory immediately following the message buffer.<ul>
<li>The attacker chooses in advance how far past the end of the message to read.</li>
<li>The attacker's message itself must be larger than the exfiltrated data. Note that a sufficiently large message buffer will likely be allocated using mmap() in which case the attack will likely segfault.</li>
</ul>
</li>
<li>The attack can only work if the 8 bytes immediately following the exfiltrated data contains a valid in-bounds Cap'n Proto pointer. The easiest way to achieve this is if the pointer is null, i.e. 8 bytes of zero.<ul>
<li>The attacker must specify exactly how much data to exfiltrate, so must guess exactly where such a valid pointer will exist.</li>
<li>If the exfiltrated data is not followed by a valid pointer, the attack will throw an exception. If an application has chosen to ignore exceptions (e.g. by compiling with <code>-fno-exceptions</code> and not registering an alternative exception callback) then the attack may be able to proceed anyway.</li>
</ul>
</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx">https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-46149">https://nvd.nist.gov/vuln/detail/CVE-2022-46149</a></li>
<li><a href="https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9">https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>
<li><a href="https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html">https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html</a></li>
<li><a href="https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md">https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0068.html">https://rustsec.org/advisories/RUSTSEC-2022-0068.html</a></li>
<li><a href="https://github.com/advisories/GHSA-qqff-4vw4-f6hx">https://github.com/advisories/GHSA-qqff-4vw4-f6hx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qqff-4vw4-f6hx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-12-05T17:58:16.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[capnp] Cap'n Proto and its Rust implementation vulnerable to out-of-bounds read due to logic error handling list-of-list]]></title>
        <id>https://github.com/advisories/GHSA-qqff-4vw4-f6hx</id>
        <link href="https://github.com/advisories/GHSA-qqff-4vw4-f6hx"/>
        <updated>2022-12-05T17:58:20.000Z</updated>
        <content type="html"><![CDATA[<p>The Cap'n Proto library and capnp Rust package are vulnerable to out-of-bounds read due to logic error handling list-of-list. If a message consumer expects data of type "list of pointers", and if the consumer performs certain specific actions on such data, then a message producer can cause the consumer to read out-of-bounds memory. This could trigger a process crash in the consumer, or in some cases could allow exfiltration of private in-memory data.</p>
<h1 id="impact">Impact</h1>
<ul>
<li>Remotely segfault a peer by sending it a malicious message, if the victim performs certain actions on a list-of-pointer type.</li>
<li>Possible exfiltration of memory, if the victim performs additional certain actions on a list-of-pointer type.</li>
<li>To be vulnerable, an application must perform a specific sequence of actions, described below. At present, <strong>we are not aware of any vulnerable application</strong>, but we advise updating regardless.</li>
</ul>
<h1 id="fixed-in">Fixed in</h1>
<p>Unfortunately, the bug is present in inlined code, therefore the fix will require rebuilding dependent applications.</p>
<p>C++ fix:</p>
<ul>
<li>git commit <a href="https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9">25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>
<li>release 0.11 (future)</li>
<li>release 0.10.3:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.10.3.tar.gz">https://capnproto.org/capnproto-c++-0.10.3.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.10.3.zip">https://capnproto.org/capnproto-c++-win32-0.10.3.zip</a></li>
</ul>
</li>
<li>release 0.9.2:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.9.2.tar.gz">https://capnproto.org/capnproto-c++-0.9.2.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.9.2.zip">https://capnproto.org/capnproto-c++-win32-0.9.2.zip</a></li>
</ul>
</li>
<li>release 0.8.1:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.8.1.tar.gz">https://capnproto.org/capnproto-c++-0.8.1.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.8.1.zip">https://capnproto.org/capnproto-c++-win32-0.8.1.zip</a></li>
</ul>
</li>
<li>release 0.7.1:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.7.1.tar.gz">https://capnproto.org/capnproto-c++-0.7.1.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.7.1.zip">https://capnproto.org/capnproto-c++-win32-0.7.1.zip</a></li>
</ul>
</li>
<li>release 0.5.4:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.5.4.tar.gz">https://capnproto.org/capnproto-c++-0.5.4.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.5.4.zip">https://capnproto.org/capnproto-c++-win32-0.5.4.zip</a></li>
</ul>
</li>
</ul>
<p>Rust fix:</p>
<ul>
<li><code>capnp</code> crate version <code>0.15.2</code>, <code>0.14.11</code>, or <code>0.13.7</code></li>
</ul>
<h1 id="details">Details</h1>
<p>A specially-crafted pointer could escape bounds checking by exploiting inconsistent handling of pointers when a list-of-structs is downgraded to a list-of-pointers.</p>
<p>For an in-depth explanation of how this bug works, see <a href="https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html">David Renshaw's blog post</a>. This details below focus only on determining whether an application is vulnerable.</p>
<p>In order to be vulnerable, an application must have certain properties.</p>
<p>First, the application must accept messages with a schema in which a field has list-of-pointer type. This includes <code>List(Text)</code>, <code>List(Data)</code>, <code>List(List(T))</code>, or <code>List(C)</code> where <code>C</code> is an interface type. In the following discussion, we will assume this field is named <code>foo</code>.</p>
<p>Second, the application must accept a message of this schema from a malicious source, where the attacker can maliciously encode the pointer representing the field <code>foo</code>.</p>
<p>Third, the application must call <code>getFoo()</code> to obtain a <code>List&lt;T&gt;::Reader</code> for the field, and then use it in one of the following two ways:</p>
<ol>
<li><p>Pass it as the parameter to another message's <code>setFoo()</code>, thus copying the field into a new message. Note that copying the parent struct as a whole will <em>not</em> trigger the bug; the bug only occurs if the specific field <code>foo</code> is get/set on its own.</p>
</li>
<li><p>Convert it into <code>AnyList::Reader</code>, and then attempt to access it through that. This is much less likely; very few apps use the <code>AnyList</code> API.</p>
</li>
</ol>
<p>The dynamic API equivalents of these actions (<code>capnp/dynamic.h</code>) are also affected.</p>
<p>If the application does these steps, the attacker may be able to cause the Cap'n Proto implementation to read beyond the end of the message. This could induce a segmentation fault. Or, worse, data that happened to be in memory immediately after the message might be returned as if it were part of the message. In the latter case, if the application then forwards that data back to the attacker or sends it to another third party, this could result in exfiltration of secrets.</p>
<p>Any exfiltration of data would have the following limitations:</p>
<ul>
<li>The attacker could exfiltrate no more than 512 KiB of memory immediately following the message buffer.<ul>
<li>The attacker chooses in advance how far past the end of the message to read.</li>
<li>The attacker's message itself must be larger than the exfiltrated data. Note that a sufficiently large message buffer will likely be allocated using mmap() in which case the attack will likely segfault.</li>
</ul>
</li>
<li>The attack can only work if the 8 bytes immediately following the exfiltrated data contains a valid in-bounds Cap'n Proto pointer. The easiest way to achieve this is if the pointer is null, i.e. 8 bytes of zero.<ul>
<li>The attacker must specify exactly how much data to exfiltrate, so must guess exactly where such a valid pointer will exist.</li>
<li>If the exfiltrated data is not followed by a valid pointer, the attack will throw an exception. If an application has chosen to ignore exceptions (e.g. by compiling with <code>-fno-exceptions</code> and not registering an alternative exception callback) then the attack may be able to proceed anyway.</li>
</ul>
</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx">https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-46149">https://nvd.nist.gov/vuln/detail/CVE-2022-46149</a></li>
<li><a href="https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9">https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>
<li><a href="https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html">https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html</a></li>
<li><a href="https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md">https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0068.html">https://rustsec.org/advisories/RUSTSEC-2022-0068.html</a></li>
<li><a href="https://github.com/advisories/GHSA-qqff-4vw4-f6hx">https://github.com/advisories/GHSA-qqff-4vw4-f6hx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qqff-4vw4-f6hx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-12-05T17:58:16.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[capnp] Cap'n Proto and its Rust implementation vulnerable to out-of-bounds read due to logic error handling list-of-list]]></title>
        <id>https://github.com/advisories/GHSA-qqff-4vw4-f6hx</id>
        <link href="https://github.com/advisories/GHSA-qqff-4vw4-f6hx"/>
        <updated>2022-12-05T17:58:20.000Z</updated>
        <content type="html"><![CDATA[<p>The Cap'n Proto library and capnp Rust package are vulnerable to out-of-bounds read due to logic error handling list-of-list. If a message consumer expects data of type "list of pointers", and if the consumer performs certain specific actions on such data, then a message producer can cause the consumer to read out-of-bounds memory. This could trigger a process crash in the consumer, or in some cases could allow exfiltration of private in-memory data.</p>
<h1 id="impact">Impact</h1>
<ul>
<li>Remotely segfault a peer by sending it a malicious message, if the victim performs certain actions on a list-of-pointer type.</li>
<li>Possible exfiltration of memory, if the victim performs additional certain actions on a list-of-pointer type.</li>
<li>To be vulnerable, an application must perform a specific sequence of actions, described below. At present, <strong>we are not aware of any vulnerable application</strong>, but we advise updating regardless.</li>
</ul>
<h1 id="fixed-in">Fixed in</h1>
<p>Unfortunately, the bug is present in inlined code, therefore the fix will require rebuilding dependent applications.</p>
<p>C++ fix:</p>
<ul>
<li>git commit <a href="https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9">25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>
<li>release 0.11 (future)</li>
<li>release 0.10.3:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.10.3.tar.gz">https://capnproto.org/capnproto-c++-0.10.3.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.10.3.zip">https://capnproto.org/capnproto-c++-win32-0.10.3.zip</a></li>
</ul>
</li>
<li>release 0.9.2:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.9.2.tar.gz">https://capnproto.org/capnproto-c++-0.9.2.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.9.2.zip">https://capnproto.org/capnproto-c++-win32-0.9.2.zip</a></li>
</ul>
</li>
<li>release 0.8.1:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.8.1.tar.gz">https://capnproto.org/capnproto-c++-0.8.1.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.8.1.zip">https://capnproto.org/capnproto-c++-win32-0.8.1.zip</a></li>
</ul>
</li>
<li>release 0.7.1:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.7.1.tar.gz">https://capnproto.org/capnproto-c++-0.7.1.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.7.1.zip">https://capnproto.org/capnproto-c++-win32-0.7.1.zip</a></li>
</ul>
</li>
<li>release 0.5.4:<ul>
<li>Unix: <a href="https://capnproto.org/capnproto-c++-0.5.4.tar.gz">https://capnproto.org/capnproto-c++-0.5.4.tar.gz</a></li>
<li>Windows: <a href="https://capnproto.org/capnproto-c++-win32-0.5.4.zip">https://capnproto.org/capnproto-c++-win32-0.5.4.zip</a></li>
</ul>
</li>
</ul>
<p>Rust fix:</p>
<ul>
<li><code>capnp</code> crate version <code>0.15.2</code>, <code>0.14.11</code>, or <code>0.13.7</code></li>
</ul>
<h1 id="details">Details</h1>
<p>A specially-crafted pointer could escape bounds checking by exploiting inconsistent handling of pointers when a list-of-structs is downgraded to a list-of-pointers.</p>
<p>For an in-depth explanation of how this bug works, see <a href="https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html">David Renshaw's blog post</a>. This details below focus only on determining whether an application is vulnerable.</p>
<p>In order to be vulnerable, an application must have certain properties.</p>
<p>First, the application must accept messages with a schema in which a field has list-of-pointer type. This includes <code>List(Text)</code>, <code>List(Data)</code>, <code>List(List(T))</code>, or <code>List(C)</code> where <code>C</code> is an interface type. In the following discussion, we will assume this field is named <code>foo</code>.</p>
<p>Second, the application must accept a message of this schema from a malicious source, where the attacker can maliciously encode the pointer representing the field <code>foo</code>.</p>
<p>Third, the application must call <code>getFoo()</code> to obtain a <code>List&lt;T&gt;::Reader</code> for the field, and then use it in one of the following two ways:</p>
<ol>
<li><p>Pass it as the parameter to another message's <code>setFoo()</code>, thus copying the field into a new message. Note that copying the parent struct as a whole will <em>not</em> trigger the bug; the bug only occurs if the specific field <code>foo</code> is get/set on its own.</p>
</li>
<li><p>Convert it into <code>AnyList::Reader</code>, and then attempt to access it through that. This is much less likely; very few apps use the <code>AnyList</code> API.</p>
</li>
</ol>
<p>The dynamic API equivalents of these actions (<code>capnp/dynamic.h</code>) are also affected.</p>
<p>If the application does these steps, the attacker may be able to cause the Cap'n Proto implementation to read beyond the end of the message. This could induce a segmentation fault. Or, worse, data that happened to be in memory immediately after the message might be returned as if it were part of the message. In the latter case, if the application then forwards that data back to the attacker or sends it to another third party, this could result in exfiltration of secrets.</p>
<p>Any exfiltration of data would have the following limitations:</p>
<ul>
<li>The attacker could exfiltrate no more than 512 KiB of memory immediately following the message buffer.<ul>
<li>The attacker chooses in advance how far past the end of the message to read.</li>
<li>The attacker's message itself must be larger than the exfiltrated data. Note that a sufficiently large message buffer will likely be allocated using mmap() in which case the attack will likely segfault.</li>
</ul>
</li>
<li>The attack can only work if the 8 bytes immediately following the exfiltrated data contains a valid in-bounds Cap'n Proto pointer. The easiest way to achieve this is if the pointer is null, i.e. 8 bytes of zero.<ul>
<li>The attacker must specify exactly how much data to exfiltrate, so must guess exactly where such a valid pointer will exist.</li>
<li>If the exfiltrated data is not followed by a valid pointer, the attack will throw an exception. If an application has chosen to ignore exceptions (e.g. by compiling with <code>-fno-exceptions</code> and not registering an alternative exception callback) then the attack may be able to proceed anyway.</li>
</ul>
</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx">https://github.com/capnproto/capnproto/security/advisories/GHSA-qqff-4vw4-f6hx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-46149">https://nvd.nist.gov/vuln/detail/CVE-2022-46149</a></li>
<li><a href="https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9">https://github.com/capnproto/capnproto/commit/25d34c67863fd960af34fc4f82a7ca3362ee74b9</a></li>
<li><a href="https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html">https://dwrensha.github.io/capnproto-rust/2022/11/30/out_of_bounds_memory_access_bug.html</a></li>
<li><a href="https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md">https://github.com/capnproto/capnproto/tree/master/security-advisories/2022-11-30-0-pointer-list-bounds.md</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WKXM4JAFXLTXU5IQB3OUBQVCIICZWGYX/</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZOCQQOPMVQOFUWBWAGVGN76OYAV3WXY4/</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0068.html">https://rustsec.org/advisories/RUSTSEC-2022-0068.html</a></li>
<li><a href="https://github.com/advisories/GHSA-qqff-4vw4-f6hx">https://github.com/advisories/GHSA-qqff-4vw4-f6hx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qqff-4vw4-f6hx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-12-05T17:58:16.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[slock] Slock<T> allows sending non-Send types across thread boundaries]]></title>
        <id>https://github.com/advisories/GHSA-83r8-p8v6-6gfm</id>
        <link href="https://github.com/advisories/GHSA-83r8-p8v6-6gfm"/>
        <updated>2022-11-28T16:02:43.000Z</updated>
        <content type="html"><![CDATA[<p><code>Slock&lt;T&gt;</code> unconditionally implements <code>Send</code>/<code>Sync</code>.</p>
<p>Affected versions of this crate allows sending non-Send types to other threads,
which can lead to data races and memory corruption due to the data race.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/BrokenLamp/slock-rs/issues/2">https://github.com/BrokenLamp/slock-rs/issues/2</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0135.html">https://rustsec.org/advisories/RUSTSEC-2020-0135.html</a></li>
<li><a href="https://github.com/advisories/GHSA-83r8-p8v6-6gfm">https://github.com/advisories/GHSA-83r8-p8v6-6gfm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-83r8-p8v6-6gfm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T21:00:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[aliyun-oss-client] Leakage Aliyun KeySecret ]]></title>
        <id>https://github.com/advisories/GHSA-3w3h-7xgx-grwc</id>
        <link href="https://github.com/advisories/GHSA-3w3h-7xgx-grwc"/>
        <updated>2022-11-28T15:51:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Users of this library will be affected when using this library, the incoming secret will be disclosed unintentionally.</p>
<h3 id="patches">Patches</h3>
<p>This have already been solved.</p>
<h3 id="workarounds">Workarounds</h3>
<p>No, It cannot be patched without upgrading</p>
<h3 id="references">References</h3>
<p>No</p>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Email us at <a href="mailto:772364230@qq.com">email address</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/tu6ge/oss-rs/security/advisories/GHSA-3w3h-7xgx-grwc">https://github.com/tu6ge/oss-rs/security/advisories/GHSA-3w3h-7xgx-grwc</a></li>
<li><a href="https://github.com/tu6ge/oss-rs/commit/e4553f7d74fce682d802f8fb073943387796df29">https://github.com/tu6ge/oss-rs/commit/e4553f7d74fce682d802f8fb073943387796df29</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-39397">https://nvd.nist.gov/vuln/detail/CVE-2022-39397</a></li>
<li><a href="https://github.com/advisories/GHSA-3w3h-7xgx-grwc">https://github.com/advisories/GHSA-3w3h-7xgx-grwc</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3w3h-7xgx-grwc</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-11-21T20:39:05.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime may have data leakage between instances in the pooling allocator]]></title>
        <id>https://github.com/advisories/GHSA-wh6w-3828-g9qf</id>
        <link href="https://github.com/advisories/GHSA-wh6w-3828-g9qf"/>
        <updated>2022-11-18T06:12:17.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>There is a bug in Wasmtime's implementation of it's pooling instance allocator where when a linear memory is reused for another instance the initial heap snapshot of the prior instance can be visible, erroneously to the next instance. The pooling instance allocator in Wasmtime works by preallocating virtual memory for a fixed number of instances to reside in and then new instantiations pick a slot to use. Most conventional modules additionally have an initial copy-on-write "heap image" which is mapped in Wasmtime into the linear memory slot. When a heap slot is deallocated Wasmtime resets all of its contents back to the initial state but it does not unmap the image in case the next instance is an instantiation of the same module.</p>
<p>The bug in Wasmtime occurs when a slot in the pooling allocator previously was used for a module with a heap image, meaning that its current state of memory contains the initial heap contents of that module. If the next instantiation within that slot does not itself contain a heap image then Wasmtime would leave the old heap image in place erroneously and continue with instantiation. This means that instantiations of modules without a heap image can see the initial heap image of the prior instantiation within that slot.</p>
<p>Heap images in Wasmtime are created by precomputing WebAssembly <code>data</code> segments into one large mapping to be placed into linear memory at a particular offset. Most modules produced by toolchains today will have a heap image and an initialization snapshot. Creating a module without a heap image would require a hand-crafted <code>*.wat</code> file or a specially crafted source program. This consequence means that this bug is highly unlikely to be accidentally triggered and would otherwise require an intentional trigger with a hand-crafted module.</p>
<p>One important part of this vulnerability is Wasmtime is highly likely to segfault when the slot is reused again with a module that itself has an initialization image. For example if module A has a heap initialization image and module B does not have a heap initialization image, then the following sequence of events could happen if they all are instantiated into the same instance slot:</p>
<ul>
<li>Module A is instantiated, and then deallocated. This leaves A's heap image in place, reset to its initial contents.</li>
<li>Module B is instantiated and erroneously can see the initial heap contents of A. Module B is then deallocated and the entire heap is unmapped and reset back to zero.</li>
<li>Module A is instantiated again, but the state tracking the slot did not account for module B so it thinks the module image is still mapped and proceeds with instantiation. Any action on A's part to access linear memory will then trap and if the host accesses A's memory it will segfault because the data that's supposed to be mapped is all unmapped.</li>
</ul>
<p>Adding this all together this means that in practice modules must be deliberately crafted to not have an initial heap image to view the contents of a prior image. If this module is instantiated though then when the slot is reused the next, likely image-using, module will believe its memory is mapped when it isn't, causing the host to segfault on unmapped memory it believed was mapped. </p>
<h3 id="patches">Patches</h3>
<p>This bug has been patched and users should upgrade to Wasmtime 2.0.2.</p>
<h3 id="workarounds">Workarounds</h3>
<p>Trigging this bug requires the pooling allocator to be configured and for copy-on-write heap images to also be enabled. Pooling allocation is not enabled by default but copy-on-write heap images are. Mitigations for this bug include:</p>
<ul>
<li>Disabling the pooling allocator - note that pooling allocation is not enabled by default in Wasmtime</li>
<li>Disabling the <code>memory-init-cow</code> feature or with <a href="https://docs.rs/wasmtime/2.0.1/wasmtime/struct.Config.html#method.memory_init_cow"><code>Config::memory_init_cow</code></a></li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://docs.rs/wasmtime/2.0.1/wasmtime/struct.Config.html#method.allocation_strategy"><code>Config::allocation_strategy</code></a> - configuration required to enable the pooling allocator.</li>
<li><a href="https://docs.rs/wasmtime/2.0.1/wasmtime/struct.Config.html#method.memory_init_cow"><code>Config::memory_init_cow</code></a> - configuration required to enable or disable copy-on-write (this is enabled by default).</li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/c1HBDDJwNPA">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0">Patch for <code>release-2.0.0</code> branch</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/3535acbf3be032ef1ba0b469b8ab92538a8a18a6">Patch for <code>main</code></a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-wh6w-3828-g9qf</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0">https://github.com/bytecodealliance/wasmtime/commit/2614f2e9d2d36805ead8a8da0fa0c6e0d9e428a0</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/3535acbf3be032ef1ba0b469b8ab92538a8a18a6">https://github.com/bytecodealliance/wasmtime/commit/3535acbf3be032ef1ba0b469b8ab92538a8a18a6</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/c1HBDDJwNPA">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/c1HBDDJwNPA</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-39393">https://nvd.nist.gov/vuln/detail/CVE-2022-39393</a></li>
<li><a href="https://github.com/advisories/GHSA-wh6w-3828-g9qf">https://github.com/advisories/GHSA-wh6w-3828-g9qf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wh6w-3828-g9qf</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-11-10T21:16:22.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] Wasmtime out of bounds read/write with zero-memory-pages configuration]]></title>
        <id>https://github.com/advisories/GHSA-44mr-8vmm-wjhg</id>
        <link href="https://github.com/advisories/GHSA-44mr-8vmm-wjhg"/>
        <updated>2022-11-15T01:15:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>There is a bug in Wasmtime's implementation of its pooling instance allocator when the allocator is configured to give WebAssembly instances a maximum of zero pages of memory. In this configuration the virtual memory mapping for WebAssembly memories did not meet the compiler-required configuration requirements for safely executing WebAssembly modules. Wasmtime's default settings require virtual memory page faults to indicate that wasm reads/writes are out-of-bounds, but the pooling allocator's configuration would not create an appropriate virtual memory mapping for this meaning out of bounds reads/writes can successfully read/write memory unrelated to the wasm sandbox within range of the base address of the memory mapping created by the pooling allocator.</p>
<p>This bug can only be triggered by setting <a href="https://docs.rs/wasmtime/2.0.1/wasmtime/struct.InstanceLimits.html#structfield.memory_pages"><code>InstanceLimits::memory_pages</code></a> to zero. This is expected to be a very rare configuration since this means that wasm modules cannot allocate any pages of linear memory. All wasm modules produced by all current toolchains are highly likely to use linear memory, so it's expected to be unlikely that this configuration is set to zero by any production embedding of Wasmtime, hence the low severity of this bug despite the critical consequences.</p>
<h3 id="patches">Patches</h3>
<p>This bug has been patched and users should upgrade to Wasmtime 2.0.2.</p>
<h3 id="workarounds">Workarounds</h3>
<p>One way to mitigate this issue is to disable usage of the pooling allocator. Note that the pooling allocator is not enabled by default.</p>
<p>This bug can also only be worked around by increasing the <code>memory_pages</code> allotment when configuring the pooling allocator to a value greater than zero. If an embedding wishes to still prevent memory from actually being used then the <code>Store::limiter</code> method can be used to dynamically disallow growth of memory beyond 0 bytes large. Note that the default <code>memory_pages</code> value is greater than zero.</p>
<p>This bug is not applicable with the default settings of the <code>wasmtime</code> crate.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://docs.rs/wasmtime/2.0.1/wasmtime/struct.Config.html#method.allocation_strategy"><code>Config::allocation_strategy</code></a> - configuration required to enable the pooling allocator.</li>
<li><a href="https://docs.rs/wasmtime/2.0.1/wasmtime/struct.InstanceLimits.html#structfield.memory_pages"><code>InstanceLimits::memory_pages</code></a> - configuration field that, when zero, exhibits this bug.</li>
<li><a href="https://docs.rs/wasmtime/2.0.1/wasmtime/struct.Store.html#method.limiter"><code>Store::limiter</code></a> - means of limiting memory without using <code>memory_pages</code></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/c1HBDDJwNPA">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/e60c3742904ccbb3e26da201c9221c38a4981d72">Patch for the <code>release-2.0.0</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-44mr-8vmm-wjhg">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-44mr-8vmm-wjhg</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/e60c3742904ccbb3e26da201c9221c38a4981d72">https://github.com/bytecodealliance/wasmtime/commit/e60c3742904ccbb3e26da201c9221c38a4981d72</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/c1HBDDJwNPA">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/c1HBDDJwNPA</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-39392">https://nvd.nist.gov/vuln/detail/CVE-2022-39392</a></li>
<li><a href="https://github.com/advisories/GHSA-44mr-8vmm-wjhg">https://github.com/advisories/GHSA-44mr-8vmm-wjhg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-44mr-8vmm-wjhg</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-11-10T21:09:02.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lzf] Invalid use of `mem::uninitialized` causes `use-of-uninitialized-value`]]></title>
        <id>https://github.com/advisories/GHSA-5m39-wx2q-mxg3</id>
        <link href="https://github.com/advisories/GHSA-5m39-wx2q-mxg3"/>
        <updated>2022-11-08T21:56:43.000Z</updated>
        <content type="html"><![CDATA[<p>The compression and decompression function used <code>mem:uninitialized</code> to create an array of uninitialized values, to later write values into it. This later leads to reads from uninitialized memory.</p>
<p>The flaw was corrected in commit b633bf265e41c60dfce3be7eac4e4dd5e18d06cf by using a heap-allocated <code>Vec</code> and removing out use of <code>mem::uninitialized</code>. The fix was released in v0.3.2 and v1.0.0</p>
<p>Subsequently, the crate was deprecated and its use is discouraged.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/badboy/lzf-rs/issues/9">https://github.com/badboy/lzf-rs/issues/9</a></li>
<li><a href="https://github.com/badboy/lzf-rs/commit/b633bf265e41c60dfce3be7eac4e4dd5e18d06cf">https://github.com/badboy/lzf-rs/commit/b633bf265e41c60dfce3be7eac4e4dd5e18d06cf</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0067.html">https://rustsec.org/advisories/RUSTSEC-2022-0067.html</a></li>
<li><a href="https://github.com/advisories/GHSA-5m39-wx2q-mxg3">https://github.com/advisories/GHSA-5m39-wx2q-mxg3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5m39-wx2q-mxg3</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-11-08T21:42:06.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Tauri] Tauri Filesystem Scope can be Partially Bypassed]]></title>
        <id>https://github.com/advisories/GHSA-q9wv-22m9-vhqh</id>
        <link href="https://github.com/advisories/GHSA-q9wv-22m9-vhqh"/>
        <updated>2022-11-12T05:22:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Due to incorrect escaping of special characters in paths selected via the file dialog and drag and drop functionality, it was possible to partially bypass the <code>fs</code> scope definition. It was not possible to traverse into arbitrary paths, as the issue was limited to neighboring files and sub folders of already allowed paths.</p>
<p>The impact differs on Windows, MacOS and Linux due to different specifications of valid path characters.</p>
<p>On Linux or MacOS based systems it was possible to use the <code>*</code>, <code>**</code> and <code>[a-Z]</code> patterns inside a path, which allowed to read the content of sub directories and single character files in a folder, where only specific files or the directory itself were allowed.</p>
<p>On Windows <code>[a-Z]</code> was the possible bypass pattern, as <code>*</code> is not treated as a valid path component. This implies that only single character files inside an already allowed directory were unintentionally accessible.</p>
<p>This bypass depends on the file picker dialog or dragged files, as user selected paths are automatically added to the allow list at runtime.</p>
<p>A successful bypass requires the user to select a pre-existing malicious file or directory during the file picker dialog and an adversary controlled logic to access these files. This means the issue by itself can not be abused and requires further intentional or unintentional privileges.</p>
<h3 id="workaround">Workaround</h3>
<p>Disable the <code>dialog</code> and <code>fileDropEnabled</code> component inside the <code>tauri.conf.json</code>.</p>
<h3 id="patches">Patches</h3>
<p>The issue has been resolved in #5237 and the implementation now properly escapes the special characters. The patch has been included in releases: <code>1.0.7</code>, <code>1.1.2</code> and <code>1.2.0</code></p>
<h3 id="for-more-information">For more information</h3>
<p>This issue was initially reported by MessyComposer in #5234.</p>
<p>If you have any questions or comments about this advisory:</p>
<p>Open an issue in tauri
Email us at <a href="mailto:security@tauri.app">security@tauri.app</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tauri-apps/tauri/security/advisories/GHSA-q9wv-22m9-vhqh">https://github.com/tauri-apps/tauri/security/advisories/GHSA-q9wv-22m9-vhqh</a></li>
<li><a href="https://github.com/tauri-apps/tauri/issues/5234">https://github.com/tauri-apps/tauri/issues/5234</a></li>
<li><a href="https://github.com/tauri-apps/tauri/pull/5237">https://github.com/tauri-apps/tauri/pull/5237</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-41874">https://nvd.nist.gov/vuln/detail/CVE-2022-41874</a></li>
<li><a href="https://github.com/advisories/GHSA-q9wv-22m9-vhqh">https://github.com/advisories/GHSA-q9wv-22m9-vhqh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q9wv-22m9-vhqh</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2022-11-08T17:33:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Tauri] Tauri Filesystem Scope can be Partially Bypassed]]></title>
        <id>https://github.com/advisories/GHSA-q9wv-22m9-vhqh</id>
        <link href="https://github.com/advisories/GHSA-q9wv-22m9-vhqh"/>
        <updated>2022-11-12T05:22:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Due to incorrect escaping of special characters in paths selected via the file dialog and drag and drop functionality, it was possible to partially bypass the <code>fs</code> scope definition. It was not possible to traverse into arbitrary paths, as the issue was limited to neighboring files and sub folders of already allowed paths.</p>
<p>The impact differs on Windows, MacOS and Linux due to different specifications of valid path characters.</p>
<p>On Linux or MacOS based systems it was possible to use the <code>*</code>, <code>**</code> and <code>[a-Z]</code> patterns inside a path, which allowed to read the content of sub directories and single character files in a folder, where only specific files or the directory itself were allowed.</p>
<p>On Windows <code>[a-Z]</code> was the possible bypass pattern, as <code>*</code> is not treated as a valid path component. This implies that only single character files inside an already allowed directory were unintentionally accessible.</p>
<p>This bypass depends on the file picker dialog or dragged files, as user selected paths are automatically added to the allow list at runtime.</p>
<p>A successful bypass requires the user to select a pre-existing malicious file or directory during the file picker dialog and an adversary controlled logic to access these files. This means the issue by itself can not be abused and requires further intentional or unintentional privileges.</p>
<h3 id="workaround">Workaround</h3>
<p>Disable the <code>dialog</code> and <code>fileDropEnabled</code> component inside the <code>tauri.conf.json</code>.</p>
<h3 id="patches">Patches</h3>
<p>The issue has been resolved in #5237 and the implementation now properly escapes the special characters. The patch has been included in releases: <code>1.0.7</code>, <code>1.1.2</code> and <code>1.2.0</code></p>
<h3 id="for-more-information">For more information</h3>
<p>This issue was initially reported by MessyComposer in #5234.</p>
<p>If you have any questions or comments about this advisory:</p>
<p>Open an issue in tauri
Email us at <a href="mailto:security@tauri.app">security@tauri.app</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tauri-apps/tauri/security/advisories/GHSA-q9wv-22m9-vhqh">https://github.com/tauri-apps/tauri/security/advisories/GHSA-q9wv-22m9-vhqh</a></li>
<li><a href="https://github.com/tauri-apps/tauri/issues/5234">https://github.com/tauri-apps/tauri/issues/5234</a></li>
<li><a href="https://github.com/tauri-apps/tauri/pull/5237">https://github.com/tauri-apps/tauri/pull/5237</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-41874">https://nvd.nist.gov/vuln/detail/CVE-2022-41874</a></li>
<li><a href="https://github.com/advisories/GHSA-q9wv-22m9-vhqh">https://github.com/advisories/GHSA-q9wv-22m9-vhqh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q9wv-22m9-vhqh</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2022-11-08T17:33:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ckb] ckb type_id script resume may randomly fail]]></title>
        <id>https://github.com/advisories/GHSA-mcmr-49x3-4jqm</id>
        <link href="https://github.com/advisories/GHSA-mcmr-49x3-4jqm"/>
        <updated>2022-11-02T18:15:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p><a href="https://github.com/nervosnetwork/ckb/blob/v0.101.2/script/src/verify.rs#L871-L879">https://github.com/nervosnetwork/ckb/blob/v0.101.2/script/src/verify.rs#L871-L879</a>
TypeIdSystemScript resume handle is not correct when max_cycles is not enough, <code>ScriptError::ExceededMaximumCycles</code> will be raised directly ranther than suspend as expect, and also because script_group execution order is random, so this will happen randomly.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nervosnetwork/ckb/security/advisories/GHSA-mcmr-49x3-4jqm">https://github.com/nervosnetwork/ckb/security/advisories/GHSA-mcmr-49x3-4jqm</a></li>
<li><a href="https://github.com/nervosnetwork/ckb/blob/v0.101.2/script/src/verify.rs#L871-L879">https://github.com/nervosnetwork/ckb/blob/v0.101.2/script/src/verify.rs#L871-L879</a></li>
<li><a href="https://github.com/advisories/GHSA-mcmr-49x3-4jqm">https://github.com/advisories/GHSA-mcmr-49x3-4jqm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mcmr-49x3-4jqm</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-11-02T18:15:07.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ckb] ckb: Transaction header_deps validation issue (network forking)]]></title>
        <id>https://github.com/advisories/GHSA-7fw6-6mfj-g3q2</id>
        <link href="https://github.com/advisories/GHSA-7fw6-6mfj-g3q2"/>
        <updated>2022-11-02T18:14:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>fn <code>HeaderChecker#check_valid</code> skipped main chain checking after this PR: <a href="https://github.com/nervosnetwork/ckb/pull/1646/files#diff-c4e017b67c1b3005ca0c446a9b0879571aa36a858b1f7ddd1b9328a884e3214bR171-R176">https://github.com/nervosnetwork/ckb/pull/1646/files#diff-c4e017b67c1b3005ca0c446a9b0879571aa36a858b1f7ddd1b9328a884e3214bR171-R176</a></p>
<p>It will cause network forking if one transaction is using a forked block header which is not exists in local node's storage.</p>
<h3 id="patches">Patches</h3>
<p>0.101.1 and later versions</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nervosnetwork/ckb/security/advisories/GHSA-7fw6-6mfj-g3q2">https://github.com/nervosnetwork/ckb/security/advisories/GHSA-7fw6-6mfj-g3q2</a></li>
<li><a href="https://github.com/nervosnetwork/ckb/pull/1646/files#diff-c4e017b67c1b3005ca0c446a9b0879571aa36a858b1f7ddd1b9328a884e3214bR171-R176">https://github.com/nervosnetwork/ckb/pull/1646/files#diff-c4e017b67c1b3005ca0c446a9b0879571aa36a858b1f7ddd1b9328a884e3214bR171-R176</a></li>
<li><a href="https://github.com/advisories/GHSA-7fw6-6mfj-g3q2">https://github.com/advisories/GHSA-7fw6-6mfj-g3q2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-7fw6-6mfj-g3q2</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-11-02T18:14:30.000Z</published>
    </entry>
</feed>