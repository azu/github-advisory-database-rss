<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2023-06-13T18:01:23.916Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[libpulse-binding] Use After Free in libpulse-binding]]></title>
        <id>https://github.com/advisories/GHSA-jqpv-jm4m-86j9</id>
        <link href="https://github.com/advisories/GHSA-jqpv-jm4m-86j9"/>
        <updated>2023-06-13T17:45:07.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions contained a pair of use-after-free issues with the objects returned by the get_format_info and get_context methods of Stream objects. These objects were mistakenly being constructed without setting an important flag to prevent destruction of the underlying C objects they reference upon their own destruction.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2018-25028">https://nvd.nist.gov/vuln/detail/CVE-2018-25028</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/libpulse-binding/RUSTSEC-2018-0021.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/libpulse-binding/RUSTSEC-2018-0021.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2018-0021.html">https://rustsec.org/advisories/RUSTSEC-2018-0021.html</a></li>
<li><a href="https://github.com/jnqnfe/pulse-binding-rust/security/advisories/GHSA-ghpq-vjxw-ch5w">https://github.com/jnqnfe/pulse-binding-rust/security/advisories/GHSA-ghpq-vjxw-ch5w</a></li>
<li><a href="https://github.com/advisories/GHSA-jqpv-jm4m-86j9">https://github.com/advisories/GHSA-jqpv-jm4m-86j9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jqpv-jm4m-86j9</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-01-06T22:17:50.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[libflate] Use after free in libflate]]></title>
        <id>https://github.com/advisories/GHSA-rpcm-whqc-jfw8</id>
        <link href="https://github.com/advisories/GHSA-rpcm-whqc-jfw8"/>
        <updated>2023-06-13T17:42:24.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the libflate crate before 0.1.25 for Rust. MultiDecoder::read has a use-after-free, leading to arbitrary code execution.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-15552">https://nvd.nist.gov/vuln/detail/CVE-2019-15552</a></li>
<li><a href="https://github.com/sile/libflate/issues/35">https://github.com/sile/libflate/issues/35</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2019-0010.html">https://rustsec.org/advisories/RUSTSEC-2019-0010.html</a></li>
<li><a href="https://github.com/sile/libflate/pull/37">https://github.com/sile/libflate/pull/37</a></li>
<li><a href="https://github.com/sile/libflate/commit/ffeff7c65deac5a6f886db2a59bcae4e420e4706">https://github.com/sile/libflate/commit/ffeff7c65deac5a6f886db2a59bcae4e420e4706</a></li>
<li><a href="https://github.com/advisories/GHSA-rpcm-whqc-jfw8">https://github.com/advisories/GHSA-rpcm-whqc-jfw8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rpcm-whqc-jfw8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-08-25T20:44:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lettre] Argument injection in lettre]]></title>
        <id>https://github.com/advisories/GHSA-vc2p-r46x-m3vx</id>
        <link href="https://github.com/advisories/GHSA-vc2p-r46x-m3vx"/>
        <updated>2023-06-13T17:41:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Affected versions of lettre allowed argument injection to the sendmail command. It was possible, using forged to addresses, to pass arbitrary arguments to the sendmail executable.</p>
<p>Depending on the implementation (original sendmail, postfix, exim, etc.) it could be possible in some cases to write email data into abritrary files (using sendmail's logging features).</p>
<p><em>NOTE</em>: This vulnerability only affects the sendmail transport. Others, including smtp, are not affected.</p>
<h3 id="fix">Fix</h3>
<p>The flaw is corrected by modifying the executed command to stop parsing arguments before passing the destination addresses.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0069.html">RUSTSEC-2020-0069</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-28247">CVE-2020-28247</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/lettre/lettre/security/advisories/GHSA-vc2p-r46x-m3vx">https://github.com/lettre/lettre/security/advisories/GHSA-vc2p-r46x-m3vx</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-28247">https://nvd.nist.gov/vuln/detail/CVE-2020-28247</a></li>
<li><a href="https://github.com/RustSec/advisory-db/pull/478/files">https://github.com/RustSec/advisory-db/pull/478/files</a></li>
<li><a href="https://github.com/lettre/lettre/pull/508/commits/bbe7cc5381c5380b54fb8bbb4f77a3725917ff0b">https://github.com/lettre/lettre/pull/508/commits/bbe7cc5381c5380b54fb8bbb4f77a3725917ff0b</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0069.html">https://rustsec.org/advisories/RUSTSEC-2020-0069.html</a></li>
<li><a href="https://github.com/advisories/GHSA-vc2p-r46x-m3vx">https://github.com/advisories/GHSA-vc2p-r46x-m3vx</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-vc2p-r46x-m3vx</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:56:48.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hyper] Headers containing newline characters can split messages in hyper]]></title>
        <id>https://github.com/advisories/GHSA-q89x-f52w-6hj2</id>
        <link href="https://github.com/advisories/GHSA-q89x-f52w-6hj2"/>
        <updated>2023-06-13T17:39:47.000Z</updated>
        <content type="html"><![CDATA[<p>Serializing of headers to the socket did not filter the values for newline bytes (\r or \n), which allowed for header values to split a request or response. People would not likely include newlines in the headers in their own applications, so the way for most people to exploit this is if an application constructs headers based on unsanitized user input.</p>
<p>This issue was fixed by replacing all newline characters with a space during serialization of a header value.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2017-18587">https://nvd.nist.gov/vuln/detail/CVE-2017-18587</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2017-0002.html">https://rustsec.org/advisories/RUSTSEC-2017-0002.html</a></li>
<li><a href="https://github.com/hyperium/hyper/wiki/Security-001">https://github.com/hyperium/hyper/wiki/Security-001</a></li>
<li><a href="https://github.com/advisories/GHSA-q89x-f52w-6hj2">https://github.com/advisories/GHSA-q89x-f52w-6hj2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q89x-f52w-6hj2</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:43:04.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[hyper] Headers containing newline characters can split messages in hyper]]></title>
        <id>https://github.com/advisories/GHSA-q89x-f52w-6hj2</id>
        <link href="https://github.com/advisories/GHSA-q89x-f52w-6hj2"/>
        <updated>2023-06-13T17:39:47.000Z</updated>
        <content type="html"><![CDATA[<p>Serializing of headers to the socket did not filter the values for newline bytes (\r or \n), which allowed for header values to split a request or response. People would not likely include newlines in the headers in their own applications, so the way for most people to exploit this is if an application constructs headers based on unsanitized user input.</p>
<p>This issue was fixed by replacing all newline characters with a space during serialization of a header value.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2017-18587">https://nvd.nist.gov/vuln/detail/CVE-2017-18587</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2017-0002.html">https://rustsec.org/advisories/RUSTSEC-2017-0002.html</a></li>
<li><a href="https://github.com/hyperium/hyper/wiki/Security-001">https://github.com/hyperium/hyper/wiki/Security-001</a></li>
<li><a href="https://github.com/advisories/GHSA-q89x-f52w-6hj2">https://github.com/advisories/GHSA-q89x-f52w-6hj2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q89x-f52w-6hj2</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:43:04.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[crypto2] Non-aligned u32 read in Chacha20 encryption and decryption]]></title>
        <id>https://github.com/advisories/GHSA-pmcv-mgcf-rvxg</id>
        <link href="https://github.com/advisories/GHSA-pmcv-mgcf-rvxg"/>
        <updated>2023-06-13T17:32:10.000Z</updated>
        <content type="html"><![CDATA[<p>The implementation does not enforce alignment requirements on input slices while incorrectly assuming 4-byte alignment through an unsafe call to <code>std::slice::from_raw_parts_mut</code>, which breaks the contract and introduces undefined behavior.</p>
<p>This affects Chacha20 encryption and decryption in crypto2.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/shadowsocks/crypto2/issues/27">https://github.com/shadowsocks/crypto2/issues/27</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0121.html">https://rustsec.org/advisories/RUSTSEC-2021-0121.html</a></li>
<li><a href="https://github.com/advisories/GHSA-pmcv-mgcf-rvxg">https://github.com/advisories/GHSA-pmcv-mgcf-rvxg</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-pmcv-mgcf-rvxg</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-16T23:51:32.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[csv-sniffer] `Read` on uninitialized memory may cause UB (fn preamble_skipcount())]]></title>
        <id>https://github.com/advisories/GHSA-r67p-m7g9-gxw6</id>
        <link href="https://github.com/advisories/GHSA-r67p-m7g9-gxw6"/>
        <updated>2023-06-13T17:31:37.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate passes an uninitialized buffer to a user-provided <code>Read</code> implementation (within <code>fn preamble_skipcount()</code>).</p>
<p>Arbitrary <code>Read</code> implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer.
Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jblondin/csv-sniffer/issues/1">https://github.com/jblondin/csv-sniffer/issues/1</a></li>
<li><a href="https://github.com/jblondin/csv-sniffer/pull/2">https://github.com/jblondin/csv-sniffer/pull/2</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0088.html">https://rustsec.org/advisories/RUSTSEC-2021-0088.html</a></li>
<li><a href="https://github.com/advisories/GHSA-r67p-m7g9-gxw6">https://github.com/advisories/GHSA-r67p-m7g9-gxw6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r67p-m7g9-gxw6</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-16T23:51:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[dashmap] Unsoundness in `dashmap` references]]></title>
        <id>https://github.com/advisories/GHSA-mpg5-fvwp-42m2</id>
        <link href="https://github.com/advisories/GHSA-mpg5-fvwp-42m2"/>
        <updated>2023-06-13T17:30:43.000Z</updated>
        <content type="html"><![CDATA[<p>Reference returned by some methods of <code>Ref</code> (and similar types) may outlive the <code>Ref</code> and escape the lock.
This causes undefined behavior and may result in a segfault.</p>
<p>More information in <a href="https://github.com/xacrimon/dashmap/issues/167"><code>dashmap#167</code></a> issue.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/xacrimon/dashmap/issues/167">https://github.com/xacrimon/dashmap/issues/167</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0002.html">https://rustsec.org/advisories/RUSTSEC-2022-0002.html</a></li>
<li><a href="https://github.com/advisories/GHSA-mpg5-fvwp-42m2">https://github.com/advisories/GHSA-mpg5-fvwp-42m2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mpg5-fvwp-42m2</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-06-16T23:52:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[derive-com-impl] QueryInterface should call AddRef before returning pointer]]></title>
        <id>https://github.com/advisories/GHSA-9rg7-3j4f-cf4x</id>
        <link href="https://github.com/advisories/GHSA-9rg7-3j4f-cf4x"/>
        <updated>2023-06-13T17:29:15.000Z</updated>
        <content type="html"><![CDATA[<p>Affected version of this crate, which is a required dependency in com-impl, 
provides a faulty implementation of the <code>IUnknown::QueryInterface</code> method.</p>
<p><code>QueryInterface</code> implementation must call <code>IUnknown::AddRef</code> before returning the pointer,
as describe in this documentation:
<a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)">https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)</a></p>
<p>As it is not incrementing the refcount as expected, the following calls to <code>IUnknown::Release</code> method 
will cause WMI to drop reference to the interface, and can lead to invalid reference.</p>
<p>This is documented in <a href="https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object#reference-counting">https://docs.microsoft.com/en-us/windows/win32/learnwin32/managing-the-lifetime-of-an-object#reference-counting</a></p>
<p>There is no simple workaround, as you can't know how many time QueryInterface will be called.
The only way to quick fix this is to use the macro expanded version of the code and modify 
the QueryInterface method to add the AddRef call yourself.</p>
<p>The issue was corrected in commit <code>9803f31fbd1717d482d848f041044d061fca6da7</code>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Connicpu/com-impl/issues/1">https://github.com/Connicpu/com-impl/issues/1</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0083.html">https://rustsec.org/advisories/RUSTSEC-2021-0083.html</a></li>
<li><a href="https://github.com/Connicpu/com-impl/commit/9803f31fbd1717d482d848f041044d061fca6da7">https://github.com/Connicpu/com-impl/commit/9803f31fbd1717d482d848f041044d061fca6da7</a></li>
<li><a href="https://github.com/advisories/GHSA-9rg7-3j4f-cf4x">https://github.com/advisories/GHSA-9rg7-3j4f-cf4x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9rg7-3j4f-cf4x</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-06-16T23:52:51.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[fruity] Improper Input Validation in fruity]]></title>
        <id>https://github.com/advisories/GHSA-h352-g5vw-3926</id>
        <link href="https://github.com/advisories/GHSA-h352-g5vw-3926"/>
        <updated>2023-06-13T17:27:03.000Z</updated>
        <content type="html"><![CDATA[<p>Methods of NSString for conversion to a string may return a partial result. Since they call CStr::from_ptr on a pointer to the string buffer, the string is terminated at the first null byte, which might not be the end of the string.</p>
<p>In addition to the vulnerable functions listed for this issue, the implementations of Display, PartialEq, PartialOrd, and ToString for NSString are also affected, since they call those functions.</p>
<p>Since NSString is commonly used as the type for paths by the Foundation framework, null byte truncation might allow for easily bypassing file extension checks. For example, if a file name is provided by a user and validated to have one of a specific set of extensions, with validation taking place before truncation, an attacker can add an accepted extension after a null byte (e.g., file.exe\0.txt). After truncation, the file name used by the application would be file.exe.</p>
<p>It would be better to generate unique names for files, instead of using user-provided names, but not all applications take this approach.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-43620">https://nvd.nist.gov/vuln/detail/CVE-2021-43620</a></li>
<li><a href="https://github.com/nvzqz/fruity/issues/14">https://github.com/nvzqz/fruity/issues/14</a></li>
<li><a href="https://github.com/rustsec/advisory-db/pull/1102">https://github.com/rustsec/advisory-db/pull/1102</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0123.html">https://rustsec.org/advisories/RUSTSEC-2021-0123.html</a></li>
<li><a href="https://github.com/advisories/GHSA-h352-g5vw-3926">https://github.com/advisories/GHSA-h352-g5vw-3926</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-h352-g5vw-3926</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-11-16T17:26:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[futures-task] futures_task::waker may cause a use-after-free if used on a type that isn't 'static]]></title>
        <id>https://github.com/advisories/GHSA-r93v-9p5q-vhpf</id>
        <link href="https://github.com/advisories/GHSA-r93v-9p5q-vhpf"/>
        <updated>2023-06-13T17:25:42.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of the crate did not properly implement a 'static lifetime bound on the waker function. This resulted in a use-after-free if Waker::wake() is called after original data had been dropped.</p>
<p>The flaw was corrected by adding 'static lifetime bound to the data waker takes.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35906">https://nvd.nist.gov/vuln/detail/CVE-2020-35906</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0060.html">https://rustsec.org/advisories/RUSTSEC-2020-0060.html</a></li>
<li><a href="https://github.com/rust-lang/futures-rs/pull/2206">https://github.com/rust-lang/futures-rs/pull/2206</a></li>
<li><a href="https://github.com/advisories/GHSA-r93v-9p5q-vhpf">https://github.com/advisories/GHSA-r93v-9p5q-vhpf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-r93v-9p5q-vhpf</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-05-24T17:37:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[futures-task] futures_task::noop_waker_ref can segfault due to dereferencing a NULL pointer]]></title>
        <id>https://github.com/advisories/GHSA-p9m5-3hj7-cp5r</id>
        <link href="https://github.com/advisories/GHSA-p9m5-3hj7-cp5r"/>
        <updated>2023-06-13T17:24:57.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of the crate used a UnsafeCell in thread-local storage to return a noop waker reference, assuming that the reference would never be returned from another thread.</p>
<p>This resulted in a segmentation fault crash if Waker::wake_by_ref() was called on a waker returned from another thread due to it attempting to dereference a pointer that wasn't accessible from the main thread.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35907">https://nvd.nist.gov/vuln/detail/CVE-2020-35907</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0061.html">https://rustsec.org/advisories/RUSTSEC-2020-0061.html</a></li>
<li><a href="https://github.com/rust-lang/futures-rs/issues/2091">https://github.com/rust-lang/futures-rs/issues/2091</a></li>
<li><a href="https://github.com/advisories/GHSA-p9m5-3hj7-cp5r">https://github.com/advisories/GHSA-p9m5-3hj7-cp5r</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-p9m5-3hj7-cp5r</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-05-24T17:37:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[futures-util] MutexGuard::map can cause a data race in safe code]]></title>
        <id>https://github.com/advisories/GHSA-rh4w-94hh-9943</id>
        <link href="https://github.com/advisories/GHSA-rh4w-94hh-9943"/>
        <updated>2023-06-13T17:24:14.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of the crate had a Send/Sync implementation for MappedMutexGuard that only considered variance on T, while MappedMutexGuard dereferenced to U.</p>
<p>This could of led to data races in safe Rust code when a closure used in MutexGuard::map() returns U that is unrelated to T.</p>
<p>The issue was fixed by fixing Send and Sync implementations, and by adding a PhantomData&lt;&amp;'a mut U&gt; marker to the MappedMutexGuard type to tell the compiler that the guard is over U too.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35905">https://nvd.nist.gov/vuln/detail/CVE-2020-35905</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0059.html">https://rustsec.org/advisories/RUSTSEC-2020-0059.html</a></li>
<li><a href="https://github.com/rust-lang/futures-rs/issues/2239">https://github.com/rust-lang/futures-rs/issues/2239</a></li>
<li><a href="https://github.com/advisories/GHSA-rh4w-94hh-9943">https://github.com/advisories/GHSA-rh4w-94hh-9943</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-rh4w-94hh-9943</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2022-05-24T17:37:49.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[crypto2] Use of a Broken or Risky Cryptographic Algorithm in crypto2]]></title>
        <id>https://github.com/advisories/GHSA-9hfg-pxr6-q4vp</id>
        <link href="https://github.com/advisories/GHSA-9hfg-pxr6-q4vp"/>
        <updated>2023-06-13T17:23:04.000Z</updated>
        <content type="html"><![CDATA[<p>The implementation does not enforce alignment requirements on input slices while incorrectly assuming 4-byte alignment through an unsafe call to std::slice::from_raw_parts_mut, which breaks the contract and introduces undefined behavior.</p>
<p>This affects Chacha20 encryption and decryption in crypto2.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45709">https://nvd.nist.gov/vuln/detail/CVE-2021-45709</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/crypto2/RUSTSEC-2021-0121.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/crypto2/RUSTSEC-2021-0121.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0121.html">https://rustsec.org/advisories/RUSTSEC-2021-0121.html</a></li>
<li><a href="https://github.com/shadowsocks/crypto2/issues/27">https://github.com/shadowsocks/crypto2/issues/27</a></li>
<li><a href="https://github.com/advisories/GHSA-9hfg-pxr6-q4vp">https://github.com/advisories/GHSA-9hfg-pxr6-q4vp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9hfg-pxr6-q4vp</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-01-06T22:04:51.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[csv-sniffer] Use of Uninitialized Resource in csv-sniffer.]]></title>
        <id>https://github.com/advisories/GHSA-9783-42pm-x5jq</id>
        <link href="https://github.com/advisories/GHSA-9783-42pm-x5jq"/>
        <updated>2023-06-13T17:22:24.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate passes an uninitialized buffer to a user-provided Read implementation (within fn preamble_skipcount()).</p>
<p>Arbitrary Read implementations can read from the uninitialized buffer (memory exposure) and also can return incorrect number of bytes written to the buffer. Reading from uninitialized memory produces undefined values that can quickly invoke undefined behavior.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45686">https://nvd.nist.gov/vuln/detail/CVE-2021-45686</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/csv-sniffer/RUSTSEC-2021-0088.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/csv-sniffer/RUSTSEC-2021-0088.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0088.html">https://rustsec.org/advisories/RUSTSEC-2021-0088.html</a></li>
<li><a href="https://github.com/jblondin/csv-sniffer/pull/2">https://github.com/jblondin/csv-sniffer/pull/2</a></li>
<li><a href="https://github.com/jblondin/csv-sniffer/issues/1">https://github.com/jblondin/csv-sniffer/issues/1</a></li>
<li><a href="https://github.com/advisories/GHSA-9783-42pm-x5jq">https://github.com/advisories/GHSA-9783-42pm-x5jq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9783-42pm-x5jq</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2022-01-06T22:13:58.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[derive-com-impl] Out-of-bounds Write in derive-com-impl]]></title>
        <id>https://github.com/advisories/GHSA-w4cc-pc2h-whcj</id>
        <link href="https://github.com/advisories/GHSA-w4cc-pc2h-whcj"/>
        <updated>2023-06-13T17:21:56.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the derive-com-impl crate before 0.1.2 for Rust. An invalid reference (and memory corruption) can occur because AddRef might not be called before returning a pointer.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-45681">https://nvd.nist.gov/vuln/detail/CVE-2021-45681</a></li>
<li><a href="https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/derive-com-impl/RUSTSEC-2021-0083.md">https://raw.githubusercontent.com/rustsec/advisory-db/main/crates/derive-com-impl/RUSTSEC-2021-0083.md</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0083.html">https://rustsec.org/advisories/RUSTSEC-2021-0083.html</a></li>
<li><a href="https://github.com/Connicpu/com-impl/issues/1">https://github.com/Connicpu/com-impl/issues/1</a></li>
<li><a href="https://github.com/advisories/GHSA-w4cc-pc2h-whcj">https://github.com/advisories/GHSA-w4cc-pc2h-whcj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-w4cc-pc2h-whcj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-01-06T22:16:10.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[flatbuffers] Dangling reference in flatbuffers]]></title>
        <id>https://github.com/advisories/GHSA-c9h5-hf8r-m97x</id>
        <link href="https://github.com/advisories/GHSA-c9h5-hf8r-m97x"/>
        <updated>2023-06-13T17:18:26.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the flatbuffers crate through 2020-04-11 for Rust. read_scalar (and read_scalar_at) can transmute values without unsafe blocks.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35864">https://nvd.nist.gov/vuln/detail/CVE-2020-35864</a></li>
<li><a href="https://github.com/google/flatbuffers/issues/5825">https://github.com/google/flatbuffers/issues/5825</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0009.html">https://rustsec.org/advisories/RUSTSEC-2020-0009.html</a></li>
<li><a href="https://github.com/advisories/GHSA-c9h5-hf8r-m97x">https://github.com/advisories/GHSA-c9h5-hf8r-m97x</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c9h5-hf8r-m97x</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2021-08-25T20:47:36.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[crossbeam-channel] Incorrect buffer size in crossbeam-channel]]></title>
        <id>https://github.com/advisories/GHSA-m8h8-v6jh-c762</id>
        <link href="https://github.com/advisories/GHSA-m8h8-v6jh-c762"/>
        <updated>2023-06-13T17:12:10.000Z</updated>
        <content type="html"><![CDATA[<p>The affected version of this crate's the bounded channel incorrectly assumes that Vec::from_iter has allocated capacity that same as the number of iterator elements. Vec::from_iter does not actually guarantee that and may allocate extra memory. The destructor of the bounded channel reconstructs Vec from the raw pointer based on the incorrect assumes described above. This is unsound and causing deallocation with the incorrect capacity when Vec::from_iter has allocated different sizes with the number of iterator elements.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35904">https://nvd.nist.gov/vuln/detail/CVE-2020-35904</a></li>
<li><a href="https://github.com/crossbeam-rs/crossbeam/pull/533">https://github.com/crossbeam-rs/crossbeam/pull/533</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0052.html">https://rustsec.org/advisories/RUSTSEC-2020-0052.html</a></li>
<li><a href="https://github.com/advisories/GHSA-m8h8-v6jh-c762">https://github.com/advisories/GHSA-m8h8-v6jh-c762</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m8h8-v6jh-c762</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:49:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[crossbeam] Double free in crossbeam]]></title>
        <id>https://github.com/advisories/GHSA-c3cw-c387-pj65</id>
        <link href="https://github.com/advisories/GHSA-c3cw-c387-pj65"/>
        <updated>2023-06-13T17:11:25.000Z</updated>
        <content type="html"><![CDATA[<p>Even if an element is popped from a queue, crossbeam would run its destructor inside the epoch-based garbage collector. This is a source of double frees.</p>
<p>The flaw was corrected by wrapping elements inside queues in a ManuallyDrop.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2018-20996">https://nvd.nist.gov/vuln/detail/CVE-2018-20996</a></li>
<li><a href="https://github.com/crossbeam-rs/crossbeam-epoch/issues/82">https://github.com/crossbeam-rs/crossbeam-epoch/issues/82</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2018-0009.html">https://rustsec.org/advisories/RUSTSEC-2018-0009.html</a></li>
<li><a href="https://github.com/advisories/GHSA-c3cw-c387-pj65">https://github.com/advisories/GHSA-c3cw-c387-pj65</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c3cw-c387-pj65</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2021-08-25T20:43:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[branca] Unexpected panic when decoding tokens in branca]]></title>
        <id>https://github.com/advisories/GHSA-c9rv-3jmq-527w</id>
        <link href="https://github.com/advisories/GHSA-c9rv-3jmq-527w"/>
        <updated>2023-06-13T17:09:35.000Z</updated>
        <content type="html"><![CDATA[<p>Prior to 0.10.0 it was possible to have both decoding functions panic unexpectedly, by supplying tokens with an incorrect base62 encoding.
The documentation stated that an error should have been reported instead.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2020-35918">https://nvd.nist.gov/vuln/detail/CVE-2020-35918</a></li>
<li><a href="https://github.com/return/branca/issues/24">https://github.com/return/branca/issues/24</a></li>
<li><a href="https://github.com/tuupola/branca-spec/issues/22">https://github.com/tuupola/branca-spec/issues/22</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0075.html">https://rustsec.org/advisories/RUSTSEC-2020-0075.html</a></li>
<li><a href="https://github.com/return/branca/commit/7da3274bd99b05dce9c3f9b4b129d0145c71820b">https://github.com/return/branca/commit/7da3274bd99b05dce9c3f9b4b129d0145c71820b</a></li>
<li><a href="https://github.com/advisories/GHSA-c9rv-3jmq-527w">https://github.com/advisories/GHSA-c9rv-3jmq-527w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-c9rv-3jmq-527w</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2021-08-25T20:49:50.000Z</published>
    </entry>
</feed>