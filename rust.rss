<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2022-06-17T00:18:52.876Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <entry>
        <title type="html"><![CDATA[[shamir] Threshold value is ignored (all shares are n=3)]]></title>
        <id>https://github.com/advisories/GHSA-978j-88f3-p5j3</id>
        <link href="https://github.com/advisories/GHSA-978j-88f3-p5j3"/>
        <updated>2022-06-17T00:18:44.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate did not properly calculate secret shares requirements.</p>
<p>This reduces the security of the algorithm by restricting the crate to always
using a threshold value of three, rather than a configurable limit.</p>
<p>The flaw was corrected by correctly configuring the threshold.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Nebulosus/shamir/issues/3">https://github.com/Nebulosus/shamir/issues/3</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2020-0160.html">https://rustsec.org/advisories/RUSTSEC-2020-0160.html</a></li>
<li><a href="https://github.com/advisories/GHSA-978j-88f3-p5j3">https://github.com/advisories/GHSA-978j-88f3-p5j3</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-978j-88f3-p5j3</uri>
        </author>
        <published>2022-06-17T00:18:43.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rustc-serialize] Stack overflow in rustc_serialize when parsing deeply nested JSON]]></title>
        <id>https://github.com/advisories/GHSA-2226-4v3c-cff8</id>
        <link href="https://github.com/advisories/GHSA-2226-4v3c-cff8"/>
        <updated>2022-06-17T00:18:27.000Z</updated>
        <content type="html"><![CDATA[<p>When parsing JSON using <code>json::Json::from_str</code>, there is no limit to the depth of the stack, therefore deeply nested objects can cause a stack overflow, which aborts the process.</p>
<p>Example code that triggers the vulnerability is</p>
<pre><code class="language-rust">fn main() {
    let _ = rustc_serialize::json::Json::from_str(&amp;"[0,[".repeat(10000));
}
</code></pre>
<p><a href="https://crates.io/crates/serde">serde</a> is recommended as a replacement to rustc_serialize.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rust-lang-deprecated/rustc-serialize">https://github.com/rust-lang-deprecated/rustc-serialize</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0004.html">https://rustsec.org/advisories/RUSTSEC-2022-0004.html</a></li>
<li><a href="https://github.com/advisories/GHSA-2226-4v3c-cff8">https://github.com/advisories/GHSA-2226-4v3c-cff8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-2226-4v3c-cff8</uri>
        </author>
        <published>2022-06-17T00:18:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rust-embed] RustEmbed generated `get` method allows for directory traversal when reading files from disk]]></title>
        <id>https://github.com/advisories/GHSA-cgw6-f3mj-h742</id>
        <link href="https://github.com/advisories/GHSA-cgw6-f3mj-h742"/>
        <updated>2022-06-17T00:18:09.000Z</updated>
        <content type="html"><![CDATA[<p>When running in debug mode and the <code>debug-embed</code> (off by default) feature is
not enabled, the generated <code>get</code> method does not check that the input path is
a child of the folder given. </p>
<p>This allows attackers to read arbitrary files in the file system if they have
control over the filename given. The following code will print the contents of
your <code>/etc/passwd</code> if adjusted with a correct number of <code>../</code>s depending on
where it is run from.</p>
<pre><code class="language-rust">#[derive(rust_embed::RustEmbed)]
#[folder = "src/"]
pub struct Asset;

fn main() {
    let d = Asset::get("../../../etc/passwd").unwrap().data;
    println!("{}", String::from_utf8_lossy(&amp;d));
}
</code></pre>
<p>The flaw was corrected by canonicalizing the input filename and ensuring that
it starts with the canonicalized folder path.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/pyros2097/rust-embed/issues/159">https://github.com/pyros2097/rust-embed/issues/159</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0126.html">https://rustsec.org/advisories/RUSTSEC-2021-0126.html</a></li>
<li><a href="https://github.com/advisories/GHSA-cgw6-f3mj-h742">https://github.com/advisories/GHSA-cgw6-f3mj-h742</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-cgw6-f3mj-h742</uri>
        </author>
        <published>2022-06-17T00:18:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rust-crypto] Miscomputation when performing AES encryption in rust-crypto]]></title>
        <id>https://github.com/advisories/GHSA-jp3w-3q88-34cf</id>
        <link href="https://github.com/advisories/GHSA-jp3w-3q88-34cf"/>
        <updated>2022-06-17T00:17:09.000Z</updated>
        <content type="html"><![CDATA[<p>The following Rust program demonstrates some strangeness in AES encryption - if you have an immutable key slice and then operate on that slice, you get different encryption output than if you operate on a copy of that key.</p>
<p>For these functions, we expect that extending a 16 byte key to a 32 byte key by repeating it gives the same encrypted data, because the underlying rust-crypto functions repeat key data up to the necessary key size for the cipher.</p>
<pre><code class="language-rust">use crypto::{
    aes, blockmodes, buffer,
    buffer::{BufferResult, ReadBuffer, WriteBuffer},
    symmetriccipher,
};

fn encrypt(
    key: &amp;[u8],
    iv: &amp;[u8],
    data: &amp;str,
) -&gt; Result&lt;String, symmetriccipher::SymmetricCipherError&gt; {
    let mut encryptor =
        aes::cbc_encryptor(aes::KeySize::KeySize256, key, iv, blockmodes::PkcsPadding);

    let mut encrypted_data = Vec::&lt;u8&gt;::new();
    let mut read_buffer = buffer::RefReadBuffer::new(data.as_bytes());
    let mut buffer = [0; 4096];
    let mut write_buffer = buffer::RefWriteBuffer::new(&amp;mut buffer);

    loop {
        let result = encryptor.encrypt(&amp;mut read_buffer, &amp;mut write_buffer, true)?;

        encrypted_data.extend(
            write_buffer
                .take_read_buffer()
                .take_remaining()
                .iter()
                .copied(),
        );

        match result {
            BufferResult::BufferUnderflow =&gt; break,
            BufferResult::BufferOverflow =&gt; {}
        }
    }

    Ok(hex::encode(encrypted_data))
}

fn working() {
    let data = "data";
    let iv = [
        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,
        0xFF,
    ];
    let key = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];
    // The copy here makes the code work.
    let key_copy = key;
    let key2: Vec&lt;u8&gt; = key_copy.iter().cycle().take(32).copied().collect();
    println!("key1:{} key2: {}", hex::encode(&amp;key), hex::encode(&amp;key2));

    let x1 = encrypt(&amp;key, &amp;iv, data).unwrap();
    println!("X1: {}", x1);

    let x2 = encrypt(&amp;key2, &amp;iv, data).unwrap();
    println!("X2: {}", x2);

    assert_eq!(x1, x2);
}

fn broken() {
    let data = "data";
    let iv = [
        0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE,
        0xFF,
    ];
    let key = [
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
        0x0F,
    ];
    // This operation shouldn't affect the contents of key at all.
    let key2: Vec&lt;u8&gt; = key.iter().cycle().take(32).copied().collect();
    println!("key1:{} key2: {}", hex::encode(&amp;key), hex::encode(&amp;key2));

    let x1 = encrypt(&amp;key, &amp;iv, data).unwrap();
    println!("X1: {}", x1);

    let x2 = encrypt(&amp;key2, &amp;iv, data).unwrap();
    println!("X2: {}", x2);

    assert_eq!(x1, x2);
}

fn main() {
    working();
    broken();
}
</code></pre>
<p>The output from this program:</p>
<pre><code class="language-shell">     Running `target/host/debug/rust-crypto-test`
key1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f
X1: 90462bbe32965c8e7ea0addbbed4cddb
X2: 90462bbe32965c8e7ea0addbbed4cddb
key1:000102030405060708090a0b0c0d0e0f key2: 000102030405060708090a0b0c0d0e0f000102030405060708090a0b0c0d0e0f
X1: 26e847e5e7df1947bf82a650548a7d5b
X2: 90462bbe32965c8e7ea0addbbed4cddb
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `"26e847e5e7df1947bf82a650548a7d5b"`,
 right: `"90462bbe32965c8e7ea0addbbed4cddb"`', src/main.rs:83:5
</code></pre>
<p>Notably, the X1 key in the <code>broken()</code> test changes every time after rerunning the program.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/DaGenix/rust-crypto/issues/476">https://github.com/DaGenix/rust-crypto/issues/476</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0011.html">https://rustsec.org/advisories/RUSTSEC-2022-0011.html</a></li>
<li><a href="https://github.com/advisories/GHSA-jp3w-3q88-34cf">https://github.com/advisories/GHSA-jp3w-3q88-34cf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jp3w-3q88-34cf</uri>
        </author>
        <published>2022-06-17T00:17:08.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rusqlite] Incorrect Lifetime Bounds on Closures in `rusqlite`]]></title>
        <id>https://github.com/advisories/GHSA-q89g-4vhh-mvvm</id>
        <link href="https://github.com/advisories/GHSA-q89g-4vhh-mvvm"/>
        <updated>2022-06-17T00:16:49.000Z</updated>
        <content type="html"><![CDATA[<p>The lifetime bound on several closure-accepting <code>rusqlite</code> functions (specifically, functions which register a callback to be later invoked by SQLite) was too relaxed. If a closure referencing borrowed values on the stack is was passed to one of these functions, it could allow Rust code to access objects on the stack after they have been dropped.</p>
<p>The impacted functions are:</p>
<ul>
<li>Under <code>cfg(feature = "functions")</code>: <code>Connection::create_scalar_function</code>, <code>Connection::create_aggregate_function</code> and <code>Connection::create_window_function</code>.</li>
<li>Under <code>cfg(feature = "hooks")</code>: <code>Connection::commit_hook</code>, <code>Connection::rollback_hook</code> and <code>Connection::update_hook</code>.</li>
<li>Under <code>cfg(feature = "collation")</code>: <code>Connection::create_collation</code>.</li>
</ul>
<p>The issue exists in all <code>0.25.*</code> versions prior to <code>0.25.4</code>, and all <code>0.26.*</code> versions prior to 0.26.2 (specifically: <code>0.25.0</code>, <code>0.25.1</code>, <code>0.25.2</code>, <code>0.25.3</code>, <code>0.26.0</code>, and <code>0.26.1</code>).</p>
<p>The fix is available in versions <code>0.26.2</code> and newer, and also has been back-ported to <code>0.25.4</code>. As it does not exist in <code>0.24.*</code>, all affected versions should have an upgrade path to a semver-compatible release.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rusqlite/rusqlite/issues/1048">https://github.com/rusqlite/rusqlite/issues/1048</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0128.html">https://rustsec.org/advisories/RUSTSEC-2021-0128.html</a></li>
<li><a href="https://github.com/advisories/GHSA-q89g-4vhh-mvvm">https://github.com/advisories/GHSA-q89g-4vhh-mvvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q89g-4vhh-mvvm</uri>
        </author>
        <published>2022-06-17T00:16:48.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rusqlite] Incorrect Lifetime Bounds on Closures in `rusqlite`]]></title>
        <id>https://github.com/advisories/GHSA-q89g-4vhh-mvvm</id>
        <link href="https://github.com/advisories/GHSA-q89g-4vhh-mvvm"/>
        <updated>2022-06-17T00:16:49.000Z</updated>
        <content type="html"><![CDATA[<p>The lifetime bound on several closure-accepting <code>rusqlite</code> functions (specifically, functions which register a callback to be later invoked by SQLite) was too relaxed. If a closure referencing borrowed values on the stack is was passed to one of these functions, it could allow Rust code to access objects on the stack after they have been dropped.</p>
<p>The impacted functions are:</p>
<ul>
<li>Under <code>cfg(feature = "functions")</code>: <code>Connection::create_scalar_function</code>, <code>Connection::create_aggregate_function</code> and <code>Connection::create_window_function</code>.</li>
<li>Under <code>cfg(feature = "hooks")</code>: <code>Connection::commit_hook</code>, <code>Connection::rollback_hook</code> and <code>Connection::update_hook</code>.</li>
<li>Under <code>cfg(feature = "collation")</code>: <code>Connection::create_collation</code>.</li>
</ul>
<p>The issue exists in all <code>0.25.*</code> versions prior to <code>0.25.4</code>, and all <code>0.26.*</code> versions prior to 0.26.2 (specifically: <code>0.25.0</code>, <code>0.25.1</code>, <code>0.25.2</code>, <code>0.25.3</code>, <code>0.26.0</code>, and <code>0.26.1</code>).</p>
<p>The fix is available in versions <code>0.26.2</code> and newer, and also has been back-ported to <code>0.25.4</code>. As it does not exist in <code>0.24.*</code>, all affected versions should have an upgrade path to a semver-compatible release.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rusqlite/rusqlite/issues/1048">https://github.com/rusqlite/rusqlite/issues/1048</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0128.html">https://rustsec.org/advisories/RUSTSEC-2021-0128.html</a></li>
<li><a href="https://github.com/advisories/GHSA-q89g-4vhh-mvvm">https://github.com/advisories/GHSA-q89g-4vhh-mvvm</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q89g-4vhh-mvvm</uri>
        </author>
        <published>2022-06-17T00:16:48.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[raw-cpuid] Optional `Deserialize` implementations lacking validation]]></title>
        <id>https://github.com/advisories/GHSA-jf5h-cf95-w759</id>
        <link href="https://github.com/advisories/GHSA-jf5h-cf95-w759"/>
        <updated>2022-06-17T00:16:27.000Z</updated>
        <content type="html"><![CDATA[<p>When activating the non-default feature <code>serialize</code>, most structs implement
<code>serde::Deserialize</code> without sufficient validation. This allows breaking
invariants in safe code, leading to:</p>
<ul>
<li>Undefined behavior in <code>as_string()</code> methods (which use
<code>std::str::from_utf8_unchecked()</code> internally).</li>
<li>Panics due to failed assertions.</li>
</ul>
<p>See <a href="https://github.com/gz/rust-cpuid/issues/43">https://github.com/gz/rust-cpuid/issues/43</a>.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/gz/rust-cpuid/issues/43">https://github.com/gz/rust-cpuid/issues/43</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0089.html">https://rustsec.org/advisories/RUSTSEC-2021-0089.html</a></li>
<li><a href="https://github.com/advisories/GHSA-jf5h-cf95-w759">https://github.com/advisories/GHSA-jf5h-cf95-w759</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jf5h-cf95-w759</uri>
        </author>
        <published>2022-06-17T00:16:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qcell] A malicious coder can get unsound access to TCell or TLCell memory]]></title>
        <id>https://github.com/advisories/GHSA-9c9f-7x9p-4wqp</id>
        <link href="https://github.com/advisories/GHSA-9c9f-7x9p-4wqp"/>
        <updated>2022-06-17T00:16:12.000Z</updated>
        <content type="html"><![CDATA[<p>This is impossible to do by accident, but by carefully constructing
marker types to be covariant, a malicious coder can cheat the
singleton check in <code>TCellOwner</code> and <code>TLCellOwner</code>, giving unsound
access to cell memory.  This could take the form of getting two
mutable references to the same memory, or a mutable reference and an
immutable reference.</p>
<p>The fix is for the crate to internally force the marker type to be
invariant.  This blocks the conversion between covariant types which
Rust normally allows.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/uazu/qcell/issues/20">https://github.com/uazu/qcell/issues/20</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0007.html">https://rustsec.org/advisories/RUSTSEC-2022-0007.html</a></li>
<li><a href="https://github.com/advisories/GHSA-9c9f-7x9p-4wqp">https://github.com/advisories/GHSA-9c9f-7x9p-4wqp</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-9c9f-7x9p-4wqp</uri>
        </author>
        <published>2022-06-17T00:16:11.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[qwutils] insert_slice_clone can double drop if Clone panics.]]></title>
        <id>https://github.com/advisories/GHSA-68p4-pjpf-xwcq</id>
        <link href="https://github.com/advisories/GHSA-68p4-pjpf-xwcq"/>
        <updated>2022-06-17T00:14:34.000Z</updated>
        <content type="html"><![CDATA[<p>An issue was discovered in the qwutils crate before 0.3.1 for Rust. When a Clone panic occurs, insert_slice_clone can perform a double drop.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-26954">https://nvd.nist.gov/vuln/detail/CVE-2021-26954</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0018.html">https://rustsec.org/advisories/RUSTSEC-2021-0018.html</a></li>
<li><a href="https://github.com/qwertz19281/rust_utils/issues/3">https://github.com/qwertz19281/rust_utils/issues/3</a></li>
<li><a href="https://github.com/advisories/GHSA-68p4-pjpf-xwcq">https://github.com/advisories/GHSA-68p4-pjpf-xwcq</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-68p4-pjpf-xwcq</uri>
        </author>
        <published>2022-05-24T17:41:47.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[rdiff] Window can read out of bounds if Read instance returns more bytes than buffer size]]></title>
        <id>https://github.com/advisories/GHSA-q579-9wp9-gfp2</id>
        <link href="https://github.com/advisories/GHSA-q579-9wp9-gfp2"/>
        <updated>2022-06-17T00:14:19.000Z</updated>
        <content type="html"><![CDATA[<p><code>rdiff</code> performs a diff of two provided strings or files. As part of its reading
code it uses the return value of a <code>Read</code> instance to set the length of
its internal character vector.</p>
<p>If the <code>Read</code> implementation claims that it has read more bytes than the length
of the provided buffer, the length of the vector will be set to longer than its
capacity. This causes <code>rdiff</code> APIs to return uninitialized memory in its API
methods.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/dyule/rdiff/issues/3">https://github.com/dyule/rdiff/issues/3</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0094.html">https://rustsec.org/advisories/RUSTSEC-2021-0094.html</a></li>
<li><a href="https://github.com/advisories/GHSA-q579-9wp9-gfp2">https://github.com/advisories/GHSA-q579-9wp9-gfp2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q579-9wp9-gfp2</uri>
        </author>
        <published>2022-06-17T00:14:18.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds write in nix::unistd::getgrouplist]]></title>
        <id>https://github.com/advisories/GHSA-wgrg-5h56-jg27</id>
        <link href="https://github.com/advisories/GHSA-wgrg-5h56-jg27"/>
        <updated>2022-06-17T00:14:02.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the
<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>
function with a length parameter greater than the size of the buffer it
provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>
specifying the size of the group buffer. When the buffer is too small to
hold all of the reqested user's group memberships, some libc
implementations, including glibc and Solaris libc, will modify <code>ngroups</code>
to indicate the actual number of groups for the user, in addition to
returning an error. The version of <code>nix::unistd::getgrouplist</code> in nix
0.16.0 and up will resize the buffer to twice its size, but will not
read or modify the <code>ngroups</code> variable. Thus, if the user has more than
twice as many groups as the initial buffer size of 8, the next call to
<code>getgrouplist</code> will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually
only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wgrg-5h56-jg27</uri>
        </author>
        <published>2022-06-17T00:13:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds write in nix::unistd::getgrouplist]]></title>
        <id>https://github.com/advisories/GHSA-wgrg-5h56-jg27</id>
        <link href="https://github.com/advisories/GHSA-wgrg-5h56-jg27"/>
        <updated>2022-06-17T00:14:02.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the
<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>
function with a length parameter greater than the size of the buffer it
provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>
specifying the size of the group buffer. When the buffer is too small to
hold all of the reqested user's group memberships, some libc
implementations, including glibc and Solaris libc, will modify <code>ngroups</code>
to indicate the actual number of groups for the user, in addition to
returning an error. The version of <code>nix::unistd::getgrouplist</code> in nix
0.16.0 and up will resize the buffer to twice its size, but will not
read or modify the <code>ngroups</code> variable. Thus, if the user has more than
twice as many groups as the initial buffer size of 8, the next call to
<code>getgrouplist</code> will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually
only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wgrg-5h56-jg27</uri>
        </author>
        <published>2022-06-17T00:13:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nix] Out-of-bounds write in nix::unistd::getgrouplist]]></title>
        <id>https://github.com/advisories/GHSA-wgrg-5h56-jg27</id>
        <link href="https://github.com/advisories/GHSA-wgrg-5h56-jg27"/>
        <updated>2022-06-17T00:14:02.000Z</updated>
        <content type="html"><![CDATA[<p>On certain platforms, if a user has more than 16 groups, the
<code>nix::unistd::getgrouplist</code> function will call the libc <code>getgrouplist</code>
function with a length parameter greater than the size of the buffer it
provides, resulting in an out-of-bounds write and memory corruption.</p>
<p>The libc <code>getgrouplist</code> function takes an in/out parameter <code>ngroups</code>
specifying the size of the group buffer. When the buffer is too small to
hold all of the reqested user's group memberships, some libc
implementations, including glibc and Solaris libc, will modify <code>ngroups</code>
to indicate the actual number of groups for the user, in addition to
returning an error. The version of <code>nix::unistd::getgrouplist</code> in nix
0.16.0 and up will resize the buffer to twice its size, but will not
read or modify the <code>ngroups</code> variable. Thus, if the user has more than
twice as many groups as the initial buffer size of 8, the next call to
<code>getgrouplist</code> will then write past the end of the buffer.</p>
<p>The issue would require editing /etc/groups to exploit, which is usually
only editable by the root user.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/nix-rust/nix/issues/1541">https://github.com/nix-rust/nix/issues/1541</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0119.html">https://rustsec.org/advisories/RUSTSEC-2021-0119.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wgrg-5h56-jg27">https://github.com/advisories/GHSA-wgrg-5h56-jg27</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wgrg-5h56-jg27</uri>
        </author>
        <published>2022-06-17T00:13:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[neon] Use after free in Neon external buffers]]></title>
        <id>https://github.com/advisories/GHSA-8mj7-wxmc-f424</id>
        <link href="https://github.com/advisories/GHSA-8mj7-wxmc-f424"/>
        <updated>2022-06-17T00:13:42.000Z</updated>
        <content type="html"><![CDATA[<p>Neon provides functionality for creating JavaScript <code>ArrayBuffer</code> (and the <code>Buffer</code> subtype) instances backed by bytes allocated outside of V8/Node. The <a href="https://docs.rs/neon/0.10.0/neon/types/struct.JsArrayBuffer.html#method.external"><code>JsArrayBuffer::external</code></a> and <a href="https://docs.rs/neon/0.10.0/neon/types/struct.JsBuffer.html#method.external"><code>JsBuffer::external</code></a> did not require <code>T: 'static</code> prior to Neon <code>0.10.1</code>. This allowed creating an externally backed buffer from types that may be freed while they are still referenced by a JavaScript <code>ArrayBuffer</code>.</p>
<p>The following example demonstrates use after free. It compiles on versions <code>&lt;0.10.1</code> and fails to compile afterward.</p>
<pre><code class="language-rust">pub fn soundness_hole(mut cx: FunctionContext) -&gt; JsResult&lt;JsArrayBuffer&gt; {
    let mut data = vec![0u8, 1, 2, 3];
    
    // Creating an external from `&amp;mut [u8]` instead of `Vec&lt;u8&gt;` since there is a blanket impl
    // of `AsMut&lt;T&gt; for &amp;mut T`
    let buf = JsArrayBuffer::external(&amp;mut cx, data.as_mut_slice());

    // `buf` is still holding a reference to `data`!
    drop(data);

    Ok(buf)
}
</code></pre>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/neon-bindings/neon/issues/896">https://github.com/neon-bindings/neon/issues/896</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0028.html">https://rustsec.org/advisories/RUSTSEC-2022-0028.html</a></li>
<li><a href="https://github.com/advisories/GHSA-8mj7-wxmc-f424">https://github.com/advisories/GHSA-8mj7-wxmc-f424</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8mj7-wxmc-f424</uri>
        </author>
        <published>2022-06-17T00:13:40.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[nanorand] Aliased mutable references from `tls_rand` & `TlsWyRand`]]></title>
        <id>https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</id>
        <link href="https://github.com/advisories/GHSA-p6gj-gpc8-f8xw"/>
        <updated>2022-06-17T00:13:27.000Z</updated>
        <content type="html"><![CDATA[<p><code>TlsWyRand</code>'s implementation of <code>Deref</code> unconditionally dereferences a raw pointer, and returns 
multiple mutable references to the same object, which is undefined behavior.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/Absolucy/nanorand-rs/issues/28">https://github.com/Absolucy/nanorand-rs/issues/28</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0114.html">https://rustsec.org/advisories/RUSTSEC-2021-0114.html</a></li>
<li><a href="https://github.com/advisories/GHSA-p6gj-gpc8-f8xw">https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-p6gj-gpc8-f8xw</uri>
        </author>
        <published>2022-06-17T00:13:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[metrics-util] AtomicBucket<T> unconditionally implements Send/Sync]]></title>
        <id>https://github.com/advisories/GHSA-3hxh-7jxm-59x4</id>
        <link href="https://github.com/advisories/GHSA-3hxh-7jxm-59x4"/>
        <updated>2022-06-17T00:13:07.000Z</updated>
        <content type="html"><![CDATA[<p>In the affected versions of the crate, <code>AtomicBucket&lt;T&gt;</code> unconditionally implements <code>Send</code>/<code>Sync</code> traits. Therefore, users can create a data race to the inner
<code>T: !Sync</code> by using the <code>AtomicBucket::data_with()</code> API.
Such data races can potentially cause memory corruption or other undefined behavior.</p>
<p>The flaw was fixed in commit 8e6daab by adding appropriate Send/Sync bounds to the Send/Sync impl of struct <code>Block&lt;T&gt;</code> (which is a data type contained inside <code>AtomicBucket&lt;T&gt;</code>).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/metrics-rs/metrics/issues/190">https://github.com/metrics-rs/metrics/issues/190</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0113.html">https://rustsec.org/advisories/RUSTSEC-2021-0113.html</a></li>
<li><a href="https://github.com/advisories/GHSA-3hxh-7jxm-59x4">https://github.com/advisories/GHSA-3hxh-7jxm-59x4</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-3hxh-7jxm-59x4</uri>
        </author>
        <published>2022-06-17T00:13:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[mopa] `mopa` is technically unsound]]></title>
        <id>https://github.com/advisories/GHSA-8mv5-7x95-7wcf</id>
        <link href="https://github.com/advisories/GHSA-8mv5-7x95-7wcf"/>
        <updated>2022-06-17T00:12:36.000Z</updated>
        <content type="html"><![CDATA[<p>The <code>mopa</code> crate redefines the deprecated <code>TraitObject</code> struct from <code>core::raw</code> like so:</p>
<pre><code class="language-rust">#[repr(C)]
#[derive(Copy, Clone)]
#[doc(hidden)]
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
</code></pre>
<p>This is done to then transmute a reference to a trait object (<code>&amp;dyn Trait</code> for any trait <code>Trait</code>) into this struct and retrieve the <code>data</code> field for the purpose of downcasting. This is used to implement <code>downcast_ref_unchecked()</code>, in terms of which <code>downcast_ref()</code> is also implemented. Same goes for mutable reference downcasting and <code>Box</code> downcasting.</p>
<p>The Rust compiler explicitly reserves the right to change the memory layout of <code>&amp;dyn Trait</code> for any trait <code>Trait</code>. The worst case scenario is that it swaps <code>data</code> and <code>vtable</code>, making an executable location breach and compromisation of ASLR possible, since reads from <code>data</code> would read <code>vtable</code> instead. Likewise, arbitrary code execution is also theoretically possible if reads of <code>vtable</code> generated by the compiler read <code>data</code> instead.</p>
<p>While, as of Rust 1.52, this unsound assumption still holds true, updating the compiler may silently create UB in a crate which previously compiled and run without issues, compromising the security of builds which are believed to be reproducible.</p>
<p>A potential strategy to resolve this has already been suggested in an issue on the GitHub repository of the crate.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/chris-morgan/mopa/issues/13">https://github.com/chris-morgan/mopa/issues/13</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0095.html">https://rustsec.org/advisories/RUSTSEC-2021-0095.html</a></li>
<li><a href="https://github.com/advisories/GHSA-8mv5-7x95-7wcf">https://github.com/advisories/GHSA-8mv5-7x95-7wcf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-8mv5-7x95-7wcf</uri>
        </author>
        <published>2022-06-17T00:12:33.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[messagepack-rs] Deserialization functions pass uninitialized memory to user-provided Read]]></title>
        <id>https://github.com/advisories/GHSA-m325-rxjv-pwph</id>
        <link href="https://github.com/advisories/GHSA-m325-rxjv-pwph"/>
        <updated>2022-06-17T00:11:41.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate passed an uninitialized buffer to a
user-provided <code>Read</code> instance in:</p>
<ul>
<li><code>deserialize_binary</code></li>
<li><code>deserialize_string</code></li>
<li><code>deserialize_extension_others</code></li>
<li><code>deserialize_string_primitive</code></li>
</ul>
<p>This can result in safe <code>Read</code> implementations reading from the uninitialized
buffer leading to undefined behavior.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/otake84/messagepack-rs/issues/2">https://github.com/otake84/messagepack-rs/issues/2</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0092.html">https://rustsec.org/advisories/RUSTSEC-2021-0092.html</a></li>
<li><a href="https://github.com/advisories/GHSA-m325-rxjv-pwph">https://github.com/advisories/GHSA-m325-rxjv-pwph</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-m325-rxjv-pwph</uri>
        </author>
        <published>2022-06-17T00:11:41.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[lru] Use after free in lru crate]]></title>
        <id>https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</id>
        <link href="https://github.com/advisories/GHSA-qqmc-hwqp-8g2w"/>
        <updated>2022-06-17T00:11:13.000Z</updated>
        <content type="html"><![CDATA[<p>Lru crate has use after free vulnerability.</p>
<p>Lru crate has two functions for getting an iterator. Both iterators give
references to key and value. Calling specific functions, like pop(), will remove
and free the value, and but it's still possible to access the reference of value
which is already dropped causing use after free.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/jeromefroe/lru-rs/issues/120">https://github.com/jeromefroe/lru-rs/issues/120</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0130.html">https://rustsec.org/advisories/RUSTSEC-2021-0130.html</a></li>
<li><a href="https://github.com/advisories/GHSA-qqmc-hwqp-8g2w">https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-qqmc-hwqp-8g2w</uri>
        </author>
        <published>2022-06-17T00:11:13.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[openssl-src] Read buffer overruns processing ASN.1 strings]]></title>
        <id>https://github.com/advisories/GHSA-q9wj-f4qw-6vfj</id>
        <link href="https://github.com/advisories/GHSA-q9wj-f4qw-6vfj"/>
        <updated>2022-06-17T00:10:48.000Z</updated>
        <content type="html"><![CDATA[<p>ASN.1 strings are represented internally within OpenSSL as an ASN1_STRING structure which contains a buffer holding the string data and a field holding the buffer length. This contrasts with normal C strings which are repesented as a buffer for the string data which is terminated with a NUL (0) byte. Although not a strict requirement, ASN.1 strings that are parsed using OpenSSL's own "d2i" functions (and other similar parsing functions) as well as any string whose value has been set with the ASN1_STRING_set() function will additionally NUL terminate the byte array in the ASN1_STRING structure. However, it is possible for applications to directly construct valid ASN1_STRING structures which do not NUL terminate the byte array by directly setting the "data" and "length" fields in the ASN1_STRING array. This can also happen by using the ASN1_STRING_set0() function. Numerous OpenSSL functions that print ASN.1 data have been found to assume that the ASN1_STRING byte array will be NUL terminated, even though this is not guaranteed for strings that have been directly constructed. Where an application requests an ASN.1 structure to be printed, and where that ASN.1 structure contains ASN1_STRINGs that have been directly constructed by the application without NUL terminating the "data" field, then a read buffer overrun can occur. The same thing can also occur during name constraints processing of certificates (for example if a certificate has been directly constructed by the application instead of loading it via the OpenSSL parsing functions, and the certificate contains non NUL terminated ASN1_STRING structures). It can also occur in the X509_get1_email(), X509_REQ_get1_email() and X509_get1_ocsp() functions. If a malicious actor can cause an application to directly construct an ASN1_STRING and then process it through one of the affected OpenSSL functions then this issue could be hit. This might result in a crash (causing a Denial of Service attack). It could also result in the disclosure of private memory contents (such as private keys, or sensitive plaintext). Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1k). Fixed in OpenSSL 1.0.2za (Affected 1.0.2-1.0.2y).</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2021-3712">https://nvd.nist.gov/vuln/detail/CVE-2021-3712</a></li>
<li><a href="https://cert-portal.siemens.com/productcert/pdf/ssa-244969.pdf">https://cert-portal.siemens.com/productcert/pdf/ssa-244969.pdf</a></li>
<li><a href="https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf">https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf</a></li>
<li><a href="https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=94d23fcff9b2a7a8368dfe52214d5c2569882c11">https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=94d23fcff9b2a7a8368dfe52214d5c2569882c11</a></li>
<li><a href="https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=ccb0a11145ee72b042d10593a64eaf9e8a55ec12">https://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=ccb0a11145ee72b042d10593a64eaf9e8a55ec12</a></li>
<li><a href="https://kc.mcafee.com/corporate/index?page=content&amp;id=SB10366">https://kc.mcafee.com/corporate/index?page=content&amp;id=SB10366</a></li>
<li><a href="https://lists.apache.org/thread.html/r18995de860f0e63635f3008fd2a6aca82394249476d21691e7c59c9e@%3Cdev.tomcat.apache.org%3E">https://lists.apache.org/thread.html/r18995de860f0e63635f3008fd2a6aca82394249476d21691e7c59c9e@%3Cdev.tomcat.apache.org%3E</a></li>
<li><a href="https://lists.apache.org/thread.html/rad5d9f83f0d11fb3f8bb148d179b8a9ad7c6a17f18d70e5805a713d1@%3Cdev.tomcat.apache.org%3E">https://lists.apache.org/thread.html/rad5d9f83f0d11fb3f8bb148d179b8a9ad7c6a17f18d70e5805a713d1@%3Cdev.tomcat.apache.org%3E</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2021/09/msg00014.html">https://lists.debian.org/debian-lts-announce/2021/09/msg00014.html</a></li>
<li><a href="https://lists.debian.org/debian-lts-announce/2021/09/msg00021.html">https://lists.debian.org/debian-lts-announce/2021/09/msg00021.html</a></li>
<li><a href="https://security.netapp.com/advisory/ntap-20210827-0010/">https://security.netapp.com/advisory/ntap-20210827-0010/</a></li>
<li><a href="https://www.debian.org/security/2021/dsa-4963">https://www.debian.org/security/2021/dsa-4963</a></li>
<li><a href="https://www.openssl.org/news/secadv/20210824.txt">https://www.openssl.org/news/secadv/20210824.txt</a></li>
<li><a href="https://www.oracle.com/security-alerts/cpuapr2022.html">https://www.oracle.com/security-alerts/cpuapr2022.html</a></li>
<li><a href="https://www.oracle.com/security-alerts/cpujan2022.html">https://www.oracle.com/security-alerts/cpujan2022.html</a></li>
<li><a href="https://www.oracle.com/security-alerts/cpuoct2021.html">https://www.oracle.com/security-alerts/cpuoct2021.html</a></li>
<li><a href="https://www.tenable.com/security/tns-2021-16">https://www.tenable.com/security/tns-2021-16</a></li>
<li><a href="https://www.tenable.com/security/tns-2022-02">https://www.tenable.com/security/tns-2022-02</a></li>
<li><a href="http://www.openwall.com/lists/oss-security/2021/08/26/2">http://www.openwall.com/lists/oss-security/2021/08/26/2</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0098.html">https://rustsec.org/advisories/RUSTSEC-2021-0098.html</a></li>
<li><a href="https://github.com/advisories/GHSA-q9wj-f4qw-6vfj">https://github.com/advisories/GHSA-q9wj-f4qw-6vfj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-q9wj-f4qw-6vfj</uri>
        </author>
        <published>2022-05-24T19:12:03.000Z</published>
    </entry>
</feed>