<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://azu.github.io/github-advisory-database-rss/rust.rss</id>
    <title>Security Advisory for Rust crates</title>
    <updated>2023-03-15T09:01:33.537Z</updated>
    <generator>github-advisory-database-rss</generator>
    <link rel="alternate" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Arust"/>
    <subtitle>Security Advisory for Rust crates on GitHub</subtitle>
    <rights>github-advisory-database-rss</rights>
    <category term="CRITICAL"/>
    <category term="HIGH"/>
    <category term="MODERATE"/>
    <category term="LOW"/>
    <entry>
        <title type="html"><![CDATA[[out-reference] `out_reference::Out::from_raw` should be `unsafe`]]></title>
        <id>https://github.com/advisories/GHSA-p7mj-xvxg-grff</id>
        <link href="https://github.com/advisories/GHSA-p7mj-xvxg-grff"/>
        <updated>2023-03-13T20:49:28.000Z</updated>
        <content type="html"><![CDATA[<p><code>Out::from_raw</code> in affected versions allows writing a value to invalid memory address without requiring <code>unsafe</code>.</p>
<p>The soundness issue has been addressed by making <code>Out::from_raw</code> an unsafe function.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/RustyYato/out-ref/issues/1">https://github.com/RustyYato/out-ref/issues/1</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2021-0152.html">https://rustsec.org/advisories/RUSTSEC-2021-0152.html</a></li>
<li><a href="https://github.com/advisories/GHSA-p7mj-xvxg-grff">https://github.com/advisories/GHSA-p7mj-xvxg-grff</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-p7mj-xvxg-grff</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-03-13T20:49:24.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cranelift-codegen] wasmtime vulnerable to guest-controlled out-of-bounds read/write on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</id>
        <link href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8"/>
        <updated>2023-03-09T00:10:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generator, Cranelift, has a bug on x86_64 targets where address-mode computation mistakenly would calculate a 35-bit effective address instead of WebAssembly's defined 33-bit effective address. This bug means that, with default codegen settings, a wasm-controlled load/store operation could read/write addresses up to 35 bits away from the base of linear memory. Wasmtime's default sandbox settings provide up to 6G of protection from the base of linear memory to guarantee that any memory access in that range will be semantically correct. Due to this bug, however, addresses up to <code>0xffffffff * 8 + 0x7ffffffc = 36507222004 = ~34G</code> bytes away from the base of linear memory are possible from guest code. This means that the virtual memory 6G away from the base of linear memory up to ~34G away can be read/written by a malicious module.</p>
<p>This out of bounds read/write is not semantically correct and poses a threat as an arbitrary read/write within ~34G of linear memory away from the base of a wasm module's linear memory. A guest module can, without the knowledge of the embedder, read/write memory in this region. The memory may belong to other WebAssembly instances when using the pooling allocator, for example. The memory may also belong to the embedder, depending on address layout.</p>
<p>Embedders do not have a necessarily reliable means of detecting when this happens. Wasm loads/stores are allowed to cause machine segfaults meaning that an invalid read/write would be translated to a nominal WebAssembly trap. This means that a malicious module in the worst case silently reads/writes memory outside its bounds and in the "best" case looks like a normal "something trapped here" during its execution. This makes it difficult to retroactively determine whether this bug has been exploited on hosts. Affected embedders are recommended to analyze preexisting wasm modules to see if they're affected by the incorrect codegen rules and possibly correlate that with an anomalous number of traps during historical execution to locate possibly suspicious modules.</p>
<p>The specific bug in Cranelift's x86_64 backend is that a WebAssembly address which is left-shifted by a constant amount from 1 to 3 will get folded into x86_64's addressing modes which perform shifts. For example <code>(i32.load (i32.shl (local.get 0) (i32.const 3)))</code> loads from the WebAssembly address <code>$local0 &lt;&lt; 3</code>. When translated to Cranelift the <code>$local0 &lt;&lt; 3</code> computation, a 32-bit value, is zero-extended to a 64-bit value and then added to the base address of linear memory. Cranelift would generate an instruction of the form <code>movl (%base, %local0, 8), %dst</code> which calculates <code>%base + %local0 &lt;&lt; 3</code>. The bug here, however, is that the address computation happens with 64-bit values, where the <code>$local0 &lt;&lt; 3</code> computation was supposed to be truncated to a 32-bit value. This means that <code>%local0</code>, which can use up to 32-bits for an address, gets 3 extra bits of address space to be accessible via this <code>movl</code> instruction.</p>
<p>The fix in Cranelift is to remove the erroneous lowering rules in the backend which handle these zero-extended expressions. The above example is then translated to <code>movl %local0, %temp; shl $3, %temp; movl (%base, %temp), %dst</code> which correctly truncates the intermediate computation of <code>%local0 &lt;&lt; 3</code> to 32-bits inside the <code>%temp</code> register which is then added to the <code>%base</code> value.</p>
<h3 id="patches">Patches</h3>
<p>Wasmtime version 4.0.1, 5.0.1, and 6.0.1 have been released and have all been patched to no longer contain the erroneous lowering rules.</p>
<h3 id="workarounds">Workarounds</h3>
<p>While updating Wasmtime is recommended, there are a number of possible workarounds that embedders can employ to mitigate this issue if updating is not possible. Note that none of these workarounds are on-by-default and require explicit configuration:</p>
<ul>
<li>The <code>Config::static_memory_maximum_size(0)</code> option can be used to force all accesses to linear memory to be explicitly bounds-checked. This will perform a bounds check separately from the address-mode computation which correctly calculates the effective address of a load/store. Note that this can have a large impact on the execution performance of WebAssembly modules.</li>
<li>The <code>Config::static_memory_guard_size(1 &lt;&lt; 36)</code> option can be used to greatly increase the guard pages placed after linear memory. This will guarantee that memory accesses up-to-34G away are guaranteed to be semantically correct by reserving unmapped memory for the instance. Note that this reserves a very large amount of virtual memory per-instances and can greatly reduce the maximum number of concurrent instances being run.</li>
<li>If using a non-x86_64 host is possible, then that will also work around this bug. This bug does not affect Wasmtime's or Cranelift's AArch64 backend, for example.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size"><code>Config::static_memory_maximum_size</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size"><code>Config::static_memory_guard_size</code></a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-26489">https://nvd.nist.gov/vuln/detail/CVE-2023-26489</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-03-09T00:10:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cranelift-codegen] wasmtime vulnerable to guest-controlled out-of-bounds read/write on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</id>
        <link href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8"/>
        <updated>2023-03-09T00:10:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generator, Cranelift, has a bug on x86_64 targets where address-mode computation mistakenly would calculate a 35-bit effective address instead of WebAssembly's defined 33-bit effective address. This bug means that, with default codegen settings, a wasm-controlled load/store operation could read/write addresses up to 35 bits away from the base of linear memory. Wasmtime's default sandbox settings provide up to 6G of protection from the base of linear memory to guarantee that any memory access in that range will be semantically correct. Due to this bug, however, addresses up to <code>0xffffffff * 8 + 0x7ffffffc = 36507222004 = ~34G</code> bytes away from the base of linear memory are possible from guest code. This means that the virtual memory 6G away from the base of linear memory up to ~34G away can be read/written by a malicious module.</p>
<p>This out of bounds read/write is not semantically correct and poses a threat as an arbitrary read/write within ~34G of linear memory away from the base of a wasm module's linear memory. A guest module can, without the knowledge of the embedder, read/write memory in this region. The memory may belong to other WebAssembly instances when using the pooling allocator, for example. The memory may also belong to the embedder, depending on address layout.</p>
<p>Embedders do not have a necessarily reliable means of detecting when this happens. Wasm loads/stores are allowed to cause machine segfaults meaning that an invalid read/write would be translated to a nominal WebAssembly trap. This means that a malicious module in the worst case silently reads/writes memory outside its bounds and in the "best" case looks like a normal "something trapped here" during its execution. This makes it difficult to retroactively determine whether this bug has been exploited on hosts. Affected embedders are recommended to analyze preexisting wasm modules to see if they're affected by the incorrect codegen rules and possibly correlate that with an anomalous number of traps during historical execution to locate possibly suspicious modules.</p>
<p>The specific bug in Cranelift's x86_64 backend is that a WebAssembly address which is left-shifted by a constant amount from 1 to 3 will get folded into x86_64's addressing modes which perform shifts. For example <code>(i32.load (i32.shl (local.get 0) (i32.const 3)))</code> loads from the WebAssembly address <code>$local0 &lt;&lt; 3</code>. When translated to Cranelift the <code>$local0 &lt;&lt; 3</code> computation, a 32-bit value, is zero-extended to a 64-bit value and then added to the base address of linear memory. Cranelift would generate an instruction of the form <code>movl (%base, %local0, 8), %dst</code> which calculates <code>%base + %local0 &lt;&lt; 3</code>. The bug here, however, is that the address computation happens with 64-bit values, where the <code>$local0 &lt;&lt; 3</code> computation was supposed to be truncated to a 32-bit value. This means that <code>%local0</code>, which can use up to 32-bits for an address, gets 3 extra bits of address space to be accessible via this <code>movl</code> instruction.</p>
<p>The fix in Cranelift is to remove the erroneous lowering rules in the backend which handle these zero-extended expressions. The above example is then translated to <code>movl %local0, %temp; shl $3, %temp; movl (%base, %temp), %dst</code> which correctly truncates the intermediate computation of <code>%local0 &lt;&lt; 3</code> to 32-bits inside the <code>%temp</code> register which is then added to the <code>%base</code> value.</p>
<h3 id="patches">Patches</h3>
<p>Wasmtime version 4.0.1, 5.0.1, and 6.0.1 have been released and have all been patched to no longer contain the erroneous lowering rules.</p>
<h3 id="workarounds">Workarounds</h3>
<p>While updating Wasmtime is recommended, there are a number of possible workarounds that embedders can employ to mitigate this issue if updating is not possible. Note that none of these workarounds are on-by-default and require explicit configuration:</p>
<ul>
<li>The <code>Config::static_memory_maximum_size(0)</code> option can be used to force all accesses to linear memory to be explicitly bounds-checked. This will perform a bounds check separately from the address-mode computation which correctly calculates the effective address of a load/store. Note that this can have a large impact on the execution performance of WebAssembly modules.</li>
<li>The <code>Config::static_memory_guard_size(1 &lt;&lt; 36)</code> option can be used to greatly increase the guard pages placed after linear memory. This will guarantee that memory accesses up-to-34G away are guaranteed to be semantically correct by reserving unmapped memory for the instance. Note that this reserves a very large amount of virtual memory per-instances and can greatly reduce the maximum number of concurrent instances being run.</li>
<li>If using a non-x86_64 host is possible, then that will also work around this bug. This bug does not affect Wasmtime's or Cranelift's AArch64 backend, for example.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size"><code>Config::static_memory_maximum_size</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size"><code>Config::static_memory_guard_size</code></a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-26489">https://nvd.nist.gov/vuln/detail/CVE-2023-26489</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-03-09T00:10:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cranelift-codegen] wasmtime vulnerable to guest-controlled out-of-bounds read/write on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</id>
        <link href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8"/>
        <updated>2023-03-09T00:10:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generator, Cranelift, has a bug on x86_64 targets where address-mode computation mistakenly would calculate a 35-bit effective address instead of WebAssembly's defined 33-bit effective address. This bug means that, with default codegen settings, a wasm-controlled load/store operation could read/write addresses up to 35 bits away from the base of linear memory. Wasmtime's default sandbox settings provide up to 6G of protection from the base of linear memory to guarantee that any memory access in that range will be semantically correct. Due to this bug, however, addresses up to <code>0xffffffff * 8 + 0x7ffffffc = 36507222004 = ~34G</code> bytes away from the base of linear memory are possible from guest code. This means that the virtual memory 6G away from the base of linear memory up to ~34G away can be read/written by a malicious module.</p>
<p>This out of bounds read/write is not semantically correct and poses a threat as an arbitrary read/write within ~34G of linear memory away from the base of a wasm module's linear memory. A guest module can, without the knowledge of the embedder, read/write memory in this region. The memory may belong to other WebAssembly instances when using the pooling allocator, for example. The memory may also belong to the embedder, depending on address layout.</p>
<p>Embedders do not have a necessarily reliable means of detecting when this happens. Wasm loads/stores are allowed to cause machine segfaults meaning that an invalid read/write would be translated to a nominal WebAssembly trap. This means that a malicious module in the worst case silently reads/writes memory outside its bounds and in the "best" case looks like a normal "something trapped here" during its execution. This makes it difficult to retroactively determine whether this bug has been exploited on hosts. Affected embedders are recommended to analyze preexisting wasm modules to see if they're affected by the incorrect codegen rules and possibly correlate that with an anomalous number of traps during historical execution to locate possibly suspicious modules.</p>
<p>The specific bug in Cranelift's x86_64 backend is that a WebAssembly address which is left-shifted by a constant amount from 1 to 3 will get folded into x86_64's addressing modes which perform shifts. For example <code>(i32.load (i32.shl (local.get 0) (i32.const 3)))</code> loads from the WebAssembly address <code>$local0 &lt;&lt; 3</code>. When translated to Cranelift the <code>$local0 &lt;&lt; 3</code> computation, a 32-bit value, is zero-extended to a 64-bit value and then added to the base address of linear memory. Cranelift would generate an instruction of the form <code>movl (%base, %local0, 8), %dst</code> which calculates <code>%base + %local0 &lt;&lt; 3</code>. The bug here, however, is that the address computation happens with 64-bit values, where the <code>$local0 &lt;&lt; 3</code> computation was supposed to be truncated to a 32-bit value. This means that <code>%local0</code>, which can use up to 32-bits for an address, gets 3 extra bits of address space to be accessible via this <code>movl</code> instruction.</p>
<p>The fix in Cranelift is to remove the erroneous lowering rules in the backend which handle these zero-extended expressions. The above example is then translated to <code>movl %local0, %temp; shl $3, %temp; movl (%base, %temp), %dst</code> which correctly truncates the intermediate computation of <code>%local0 &lt;&lt; 3</code> to 32-bits inside the <code>%temp</code> register which is then added to the <code>%base</code> value.</p>
<h3 id="patches">Patches</h3>
<p>Wasmtime version 4.0.1, 5.0.1, and 6.0.1 have been released and have all been patched to no longer contain the erroneous lowering rules.</p>
<h3 id="workarounds">Workarounds</h3>
<p>While updating Wasmtime is recommended, there are a number of possible workarounds that embedders can employ to mitigate this issue if updating is not possible. Note that none of these workarounds are on-by-default and require explicit configuration:</p>
<ul>
<li>The <code>Config::static_memory_maximum_size(0)</code> option can be used to force all accesses to linear memory to be explicitly bounds-checked. This will perform a bounds check separately from the address-mode computation which correctly calculates the effective address of a load/store. Note that this can have a large impact on the execution performance of WebAssembly modules.</li>
<li>The <code>Config::static_memory_guard_size(1 &lt;&lt; 36)</code> option can be used to greatly increase the guard pages placed after linear memory. This will guarantee that memory accesses up-to-34G away are guaranteed to be semantically correct by reserving unmapped memory for the instance. Note that this reserves a very large amount of virtual memory per-instances and can greatly reduce the maximum number of concurrent instances being run.</li>
<li>If using a non-x86_64 host is possible, then that will also work around this bug. This bug does not affect Wasmtime's or Cranelift's AArch64 backend, for example.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size"><code>Config::static_memory_maximum_size</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size"><code>Config::static_memory_guard_size</code></a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-26489">https://nvd.nist.gov/vuln/detail/CVE-2023-26489</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-03-09T00:10:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime vulnerable to guest-controlled out-of-bounds read/write on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</id>
        <link href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8"/>
        <updated>2023-03-09T00:10:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generator, Cranelift, has a bug on x86_64 targets where address-mode computation mistakenly would calculate a 35-bit effective address instead of WebAssembly's defined 33-bit effective address. This bug means that, with default codegen settings, a wasm-controlled load/store operation could read/write addresses up to 35 bits away from the base of linear memory. Wasmtime's default sandbox settings provide up to 6G of protection from the base of linear memory to guarantee that any memory access in that range will be semantically correct. Due to this bug, however, addresses up to <code>0xffffffff * 8 + 0x7ffffffc = 36507222004 = ~34G</code> bytes away from the base of linear memory are possible from guest code. This means that the virtual memory 6G away from the base of linear memory up to ~34G away can be read/written by a malicious module.</p>
<p>This out of bounds read/write is not semantically correct and poses a threat as an arbitrary read/write within ~34G of linear memory away from the base of a wasm module's linear memory. A guest module can, without the knowledge of the embedder, read/write memory in this region. The memory may belong to other WebAssembly instances when using the pooling allocator, for example. The memory may also belong to the embedder, depending on address layout.</p>
<p>Embedders do not have a necessarily reliable means of detecting when this happens. Wasm loads/stores are allowed to cause machine segfaults meaning that an invalid read/write would be translated to a nominal WebAssembly trap. This means that a malicious module in the worst case silently reads/writes memory outside its bounds and in the "best" case looks like a normal "something trapped here" during its execution. This makes it difficult to retroactively determine whether this bug has been exploited on hosts. Affected embedders are recommended to analyze preexisting wasm modules to see if they're affected by the incorrect codegen rules and possibly correlate that with an anomalous number of traps during historical execution to locate possibly suspicious modules.</p>
<p>The specific bug in Cranelift's x86_64 backend is that a WebAssembly address which is left-shifted by a constant amount from 1 to 3 will get folded into x86_64's addressing modes which perform shifts. For example <code>(i32.load (i32.shl (local.get 0) (i32.const 3)))</code> loads from the WebAssembly address <code>$local0 &lt;&lt; 3</code>. When translated to Cranelift the <code>$local0 &lt;&lt; 3</code> computation, a 32-bit value, is zero-extended to a 64-bit value and then added to the base address of linear memory. Cranelift would generate an instruction of the form <code>movl (%base, %local0, 8), %dst</code> which calculates <code>%base + %local0 &lt;&lt; 3</code>. The bug here, however, is that the address computation happens with 64-bit values, where the <code>$local0 &lt;&lt; 3</code> computation was supposed to be truncated to a 32-bit value. This means that <code>%local0</code>, which can use up to 32-bits for an address, gets 3 extra bits of address space to be accessible via this <code>movl</code> instruction.</p>
<p>The fix in Cranelift is to remove the erroneous lowering rules in the backend which handle these zero-extended expressions. The above example is then translated to <code>movl %local0, %temp; shl $3, %temp; movl (%base, %temp), %dst</code> which correctly truncates the intermediate computation of <code>%local0 &lt;&lt; 3</code> to 32-bits inside the <code>%temp</code> register which is then added to the <code>%base</code> value.</p>
<h3 id="patches">Patches</h3>
<p>Wasmtime version 4.0.1, 5.0.1, and 6.0.1 have been released and have all been patched to no longer contain the erroneous lowering rules.</p>
<h3 id="workarounds">Workarounds</h3>
<p>While updating Wasmtime is recommended, there are a number of possible workarounds that embedders can employ to mitigate this issue if updating is not possible. Note that none of these workarounds are on-by-default and require explicit configuration:</p>
<ul>
<li>The <code>Config::static_memory_maximum_size(0)</code> option can be used to force all accesses to linear memory to be explicitly bounds-checked. This will perform a bounds check separately from the address-mode computation which correctly calculates the effective address of a load/store. Note that this can have a large impact on the execution performance of WebAssembly modules.</li>
<li>The <code>Config::static_memory_guard_size(1 &lt;&lt; 36)</code> option can be used to greatly increase the guard pages placed after linear memory. This will guarantee that memory accesses up-to-34G away are guaranteed to be semantically correct by reserving unmapped memory for the instance. Note that this reserves a very large amount of virtual memory per-instances and can greatly reduce the maximum number of concurrent instances being run.</li>
<li>If using a non-x86_64 host is possible, then that will also work around this bug. This bug does not affect Wasmtime's or Cranelift's AArch64 backend, for example.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size"><code>Config::static_memory_maximum_size</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size"><code>Config::static_memory_guard_size</code></a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-26489">https://nvd.nist.gov/vuln/detail/CVE-2023-26489</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-03-09T00:10:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime vulnerable to guest-controlled out-of-bounds read/write on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</id>
        <link href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8"/>
        <updated>2023-03-09T00:10:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generator, Cranelift, has a bug on x86_64 targets where address-mode computation mistakenly would calculate a 35-bit effective address instead of WebAssembly's defined 33-bit effective address. This bug means that, with default codegen settings, a wasm-controlled load/store operation could read/write addresses up to 35 bits away from the base of linear memory. Wasmtime's default sandbox settings provide up to 6G of protection from the base of linear memory to guarantee that any memory access in that range will be semantically correct. Due to this bug, however, addresses up to <code>0xffffffff * 8 + 0x7ffffffc = 36507222004 = ~34G</code> bytes away from the base of linear memory are possible from guest code. This means that the virtual memory 6G away from the base of linear memory up to ~34G away can be read/written by a malicious module.</p>
<p>This out of bounds read/write is not semantically correct and poses a threat as an arbitrary read/write within ~34G of linear memory away from the base of a wasm module's linear memory. A guest module can, without the knowledge of the embedder, read/write memory in this region. The memory may belong to other WebAssembly instances when using the pooling allocator, for example. The memory may also belong to the embedder, depending on address layout.</p>
<p>Embedders do not have a necessarily reliable means of detecting when this happens. Wasm loads/stores are allowed to cause machine segfaults meaning that an invalid read/write would be translated to a nominal WebAssembly trap. This means that a malicious module in the worst case silently reads/writes memory outside its bounds and in the "best" case looks like a normal "something trapped here" during its execution. This makes it difficult to retroactively determine whether this bug has been exploited on hosts. Affected embedders are recommended to analyze preexisting wasm modules to see if they're affected by the incorrect codegen rules and possibly correlate that with an anomalous number of traps during historical execution to locate possibly suspicious modules.</p>
<p>The specific bug in Cranelift's x86_64 backend is that a WebAssembly address which is left-shifted by a constant amount from 1 to 3 will get folded into x86_64's addressing modes which perform shifts. For example <code>(i32.load (i32.shl (local.get 0) (i32.const 3)))</code> loads from the WebAssembly address <code>$local0 &lt;&lt; 3</code>. When translated to Cranelift the <code>$local0 &lt;&lt; 3</code> computation, a 32-bit value, is zero-extended to a 64-bit value and then added to the base address of linear memory. Cranelift would generate an instruction of the form <code>movl (%base, %local0, 8), %dst</code> which calculates <code>%base + %local0 &lt;&lt; 3</code>. The bug here, however, is that the address computation happens with 64-bit values, where the <code>$local0 &lt;&lt; 3</code> computation was supposed to be truncated to a 32-bit value. This means that <code>%local0</code>, which can use up to 32-bits for an address, gets 3 extra bits of address space to be accessible via this <code>movl</code> instruction.</p>
<p>The fix in Cranelift is to remove the erroneous lowering rules in the backend which handle these zero-extended expressions. The above example is then translated to <code>movl %local0, %temp; shl $3, %temp; movl (%base, %temp), %dst</code> which correctly truncates the intermediate computation of <code>%local0 &lt;&lt; 3</code> to 32-bits inside the <code>%temp</code> register which is then added to the <code>%base</code> value.</p>
<h3 id="patches">Patches</h3>
<p>Wasmtime version 4.0.1, 5.0.1, and 6.0.1 have been released and have all been patched to no longer contain the erroneous lowering rules.</p>
<h3 id="workarounds">Workarounds</h3>
<p>While updating Wasmtime is recommended, there are a number of possible workarounds that embedders can employ to mitigate this issue if updating is not possible. Note that none of these workarounds are on-by-default and require explicit configuration:</p>
<ul>
<li>The <code>Config::static_memory_maximum_size(0)</code> option can be used to force all accesses to linear memory to be explicitly bounds-checked. This will perform a bounds check separately from the address-mode computation which correctly calculates the effective address of a load/store. Note that this can have a large impact on the execution performance of WebAssembly modules.</li>
<li>The <code>Config::static_memory_guard_size(1 &lt;&lt; 36)</code> option can be used to greatly increase the guard pages placed after linear memory. This will guarantee that memory accesses up-to-34G away are guaranteed to be semantically correct by reserving unmapped memory for the instance. Note that this reserves a very large amount of virtual memory per-instances and can greatly reduce the maximum number of concurrent instances being run.</li>
<li>If using a non-x86_64 host is possible, then that will also work around this bug. This bug does not affect Wasmtime's or Cranelift's AArch64 backend, for example.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size"><code>Config::static_memory_maximum_size</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size"><code>Config::static_memory_guard_size</code></a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-26489">https://nvd.nist.gov/vuln/detail/CVE-2023-26489</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-03-09T00:10:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime vulnerable to guest-controlled out-of-bounds read/write on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</id>
        <link href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8"/>
        <updated>2023-03-09T00:10:54.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generator, Cranelift, has a bug on x86_64 targets where address-mode computation mistakenly would calculate a 35-bit effective address instead of WebAssembly's defined 33-bit effective address. This bug means that, with default codegen settings, a wasm-controlled load/store operation could read/write addresses up to 35 bits away from the base of linear memory. Wasmtime's default sandbox settings provide up to 6G of protection from the base of linear memory to guarantee that any memory access in that range will be semantically correct. Due to this bug, however, addresses up to <code>0xffffffff * 8 + 0x7ffffffc = 36507222004 = ~34G</code> bytes away from the base of linear memory are possible from guest code. This means that the virtual memory 6G away from the base of linear memory up to ~34G away can be read/written by a malicious module.</p>
<p>This out of bounds read/write is not semantically correct and poses a threat as an arbitrary read/write within ~34G of linear memory away from the base of a wasm module's linear memory. A guest module can, without the knowledge of the embedder, read/write memory in this region. The memory may belong to other WebAssembly instances when using the pooling allocator, for example. The memory may also belong to the embedder, depending on address layout.</p>
<p>Embedders do not have a necessarily reliable means of detecting when this happens. Wasm loads/stores are allowed to cause machine segfaults meaning that an invalid read/write would be translated to a nominal WebAssembly trap. This means that a malicious module in the worst case silently reads/writes memory outside its bounds and in the "best" case looks like a normal "something trapped here" during its execution. This makes it difficult to retroactively determine whether this bug has been exploited on hosts. Affected embedders are recommended to analyze preexisting wasm modules to see if they're affected by the incorrect codegen rules and possibly correlate that with an anomalous number of traps during historical execution to locate possibly suspicious modules.</p>
<p>The specific bug in Cranelift's x86_64 backend is that a WebAssembly address which is left-shifted by a constant amount from 1 to 3 will get folded into x86_64's addressing modes which perform shifts. For example <code>(i32.load (i32.shl (local.get 0) (i32.const 3)))</code> loads from the WebAssembly address <code>$local0 &lt;&lt; 3</code>. When translated to Cranelift the <code>$local0 &lt;&lt; 3</code> computation, a 32-bit value, is zero-extended to a 64-bit value and then added to the base address of linear memory. Cranelift would generate an instruction of the form <code>movl (%base, %local0, 8), %dst</code> which calculates <code>%base + %local0 &lt;&lt; 3</code>. The bug here, however, is that the address computation happens with 64-bit values, where the <code>$local0 &lt;&lt; 3</code> computation was supposed to be truncated to a 32-bit value. This means that <code>%local0</code>, which can use up to 32-bits for an address, gets 3 extra bits of address space to be accessible via this <code>movl</code> instruction.</p>
<p>The fix in Cranelift is to remove the erroneous lowering rules in the backend which handle these zero-extended expressions. The above example is then translated to <code>movl %local0, %temp; shl $3, %temp; movl (%base, %temp), %dst</code> which correctly truncates the intermediate computation of <code>%local0 &lt;&lt; 3</code> to 32-bits inside the <code>%temp</code> register which is then added to the <code>%base</code> value.</p>
<h3 id="patches">Patches</h3>
<p>Wasmtime version 4.0.1, 5.0.1, and 6.0.1 have been released and have all been patched to no longer contain the erroneous lowering rules.</p>
<h3 id="workarounds">Workarounds</h3>
<p>While updating Wasmtime is recommended, there are a number of possible workarounds that embedders can employ to mitigate this issue if updating is not possible. Note that none of these workarounds are on-by-default and require explicit configuration:</p>
<ul>
<li>The <code>Config::static_memory_maximum_size(0)</code> option can be used to force all accesses to linear memory to be explicitly bounds-checked. This will perform a bounds check separately from the address-mode computation which correctly calculates the effective address of a load/store. Note that this can have a large impact on the execution performance of WebAssembly modules.</li>
<li>The <code>Config::static_memory_guard_size(1 &lt;&lt; 36)</code> option can be used to greatly increase the guard pages placed after linear memory. This will guarantee that memory accesses up-to-34G away are guaranteed to be semantically correct by reserving unmapped memory for the instance. Note that this reserves a very large amount of virtual memory per-instances and can greatly reduce the maximum number of concurrent instances being run.</li>
<li>If using a non-x86_64 host is possible, then that will also work around this bug. This bug does not affect Wasmtime's or Cranelift's AArch64 backend, for example.</li>
</ul>
<h3 id="references">References</h3>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size"><code>Config::static_memory_maximum_size</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size"><code>Config::static_memory_guard_size</code></a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-26489">https://nvd.nist.gov/vuln/detail/CVE-2023-26489</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f">https://github.com/bytecodealliance/wasmtime/commit/63fb30e4b4415455d47b3da5a19d79c12f4f2d1f</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_guard_size</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.static_memory_maximum_size</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-ff4p-7xrq-q5r8">https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-ff4p-7xrq-q5r8</uri>
        </author>
        <category label="severity" term="CRITICAL"/>
        <published>2023-03-09T00:10:53.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cranelift-codegen] wasmtime vulnerable to miscompilation of `i8x16.select` with the same inputs on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-xm67-587q-r2vw</id>
        <link href="https://github.com/advisories/GHSA-xm67-587q-r2vw"/>
        <updated>2023-03-09T00:09:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generation backend, Cranelift, has a bug on x86_64 platforms for the WebAssembly <code>i8x16.select</code> instruction which will produce the wrong results when the same operand is provided to the instruction and some of the selected indices are greater than 16. There is an off-by-one error  in the calculation of the mask to the <code>pshufb</code> instruction which causes incorrect results to be returned if lanes are selected from the second vector.</p>
<p>The impact of this miscompilation is that the WebAssembly instruction can produce incorrect results for the <code>i8x16.select</code> instruction. This should have no effect on embedders and does not represent a sandbox escape, for example. Guest programs, however, may behave unexpectedly due to the incorrect result of this instruction. In extreme cases if a guest program is handling untrusted input then the guest program may deviate from its intended execution, for example calling an imported host function with different arguments than intended. This still does not impact embedders, however, because there is no form of privilege escalation with the guest.</p>
<p>At this time it's expected that this codegen pattern doesn't show up in the wild that often. LLVM-generated modules, for example, do not appear to conventionally or idiomatically generate code which would hit this bug. It is possible, however, to still write code which triggers this, so it's recommended for embedders to analyze existing modules to see if any are affected.</p>
<h3 id="patches">Patches</h3>
<p>This codegen bug has been fixed in Wasmtime 6.0.1, 5.0.1, and 4.0.1. Users are recommended to upgrade to these updated versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If upgrading is not an option for you at this time, you can avoid this miscompilation by <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">disabling the Wasm simd proposal</a></p>
<pre><code class="language-rust">config.wasm_simd(false);
</code></pre>
<p>Additionally the bug is only present on x86_64 hosts. Other platforms such as AArch64 and s390x are not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/webassembly/simd">The WebAssembly simd proposal</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-27477">https://nvd.nist.gov/vuln/detail/CVE-2023-27477</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd</a></li>
<li><a href="https://github.com/webassembly/simd">https://github.com/webassembly/simd</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-xm67-587q-r2vw">https://github.com/advisories/GHSA-xm67-587q-r2vw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xm67-587q-r2vw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-03-09T00:09:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cranelift-codegen] wasmtime vulnerable to miscompilation of `i8x16.select` with the same inputs on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-xm67-587q-r2vw</id>
        <link href="https://github.com/advisories/GHSA-xm67-587q-r2vw"/>
        <updated>2023-03-09T00:09:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generation backend, Cranelift, has a bug on x86_64 platforms for the WebAssembly <code>i8x16.select</code> instruction which will produce the wrong results when the same operand is provided to the instruction and some of the selected indices are greater than 16. There is an off-by-one error  in the calculation of the mask to the <code>pshufb</code> instruction which causes incorrect results to be returned if lanes are selected from the second vector.</p>
<p>The impact of this miscompilation is that the WebAssembly instruction can produce incorrect results for the <code>i8x16.select</code> instruction. This should have no effect on embedders and does not represent a sandbox escape, for example. Guest programs, however, may behave unexpectedly due to the incorrect result of this instruction. In extreme cases if a guest program is handling untrusted input then the guest program may deviate from its intended execution, for example calling an imported host function with different arguments than intended. This still does not impact embedders, however, because there is no form of privilege escalation with the guest.</p>
<p>At this time it's expected that this codegen pattern doesn't show up in the wild that often. LLVM-generated modules, for example, do not appear to conventionally or idiomatically generate code which would hit this bug. It is possible, however, to still write code which triggers this, so it's recommended for embedders to analyze existing modules to see if any are affected.</p>
<h3 id="patches">Patches</h3>
<p>This codegen bug has been fixed in Wasmtime 6.0.1, 5.0.1, and 4.0.1. Users are recommended to upgrade to these updated versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If upgrading is not an option for you at this time, you can avoid this miscompilation by <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">disabling the Wasm simd proposal</a></p>
<pre><code class="language-rust">config.wasm_simd(false);
</code></pre>
<p>Additionally the bug is only present on x86_64 hosts. Other platforms such as AArch64 and s390x are not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/webassembly/simd">The WebAssembly simd proposal</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-27477">https://nvd.nist.gov/vuln/detail/CVE-2023-27477</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd</a></li>
<li><a href="https://github.com/webassembly/simd">https://github.com/webassembly/simd</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-xm67-587q-r2vw">https://github.com/advisories/GHSA-xm67-587q-r2vw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xm67-587q-r2vw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-03-09T00:09:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cranelift-codegen] wasmtime vulnerable to miscompilation of `i8x16.select` with the same inputs on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-xm67-587q-r2vw</id>
        <link href="https://github.com/advisories/GHSA-xm67-587q-r2vw"/>
        <updated>2023-03-09T00:09:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generation backend, Cranelift, has a bug on x86_64 platforms for the WebAssembly <code>i8x16.select</code> instruction which will produce the wrong results when the same operand is provided to the instruction and some of the selected indices are greater than 16. There is an off-by-one error  in the calculation of the mask to the <code>pshufb</code> instruction which causes incorrect results to be returned if lanes are selected from the second vector.</p>
<p>The impact of this miscompilation is that the WebAssembly instruction can produce incorrect results for the <code>i8x16.select</code> instruction. This should have no effect on embedders and does not represent a sandbox escape, for example. Guest programs, however, may behave unexpectedly due to the incorrect result of this instruction. In extreme cases if a guest program is handling untrusted input then the guest program may deviate from its intended execution, for example calling an imported host function with different arguments than intended. This still does not impact embedders, however, because there is no form of privilege escalation with the guest.</p>
<p>At this time it's expected that this codegen pattern doesn't show up in the wild that often. LLVM-generated modules, for example, do not appear to conventionally or idiomatically generate code which would hit this bug. It is possible, however, to still write code which triggers this, so it's recommended for embedders to analyze existing modules to see if any are affected.</p>
<h3 id="patches">Patches</h3>
<p>This codegen bug has been fixed in Wasmtime 6.0.1, 5.0.1, and 4.0.1. Users are recommended to upgrade to these updated versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If upgrading is not an option for you at this time, you can avoid this miscompilation by <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">disabling the Wasm simd proposal</a></p>
<pre><code class="language-rust">config.wasm_simd(false);
</code></pre>
<p>Additionally the bug is only present on x86_64 hosts. Other platforms such as AArch64 and s390x are not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/webassembly/simd">The WebAssembly simd proposal</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-27477">https://nvd.nist.gov/vuln/detail/CVE-2023-27477</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd</a></li>
<li><a href="https://github.com/webassembly/simd">https://github.com/webassembly/simd</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-xm67-587q-r2vw">https://github.com/advisories/GHSA-xm67-587q-r2vw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xm67-587q-r2vw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-03-09T00:09:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime vulnerable to miscompilation of `i8x16.select` with the same inputs on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-xm67-587q-r2vw</id>
        <link href="https://github.com/advisories/GHSA-xm67-587q-r2vw"/>
        <updated>2023-03-09T00:09:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generation backend, Cranelift, has a bug on x86_64 platforms for the WebAssembly <code>i8x16.select</code> instruction which will produce the wrong results when the same operand is provided to the instruction and some of the selected indices are greater than 16. There is an off-by-one error  in the calculation of the mask to the <code>pshufb</code> instruction which causes incorrect results to be returned if lanes are selected from the second vector.</p>
<p>The impact of this miscompilation is that the WebAssembly instruction can produce incorrect results for the <code>i8x16.select</code> instruction. This should have no effect on embedders and does not represent a sandbox escape, for example. Guest programs, however, may behave unexpectedly due to the incorrect result of this instruction. In extreme cases if a guest program is handling untrusted input then the guest program may deviate from its intended execution, for example calling an imported host function with different arguments than intended. This still does not impact embedders, however, because there is no form of privilege escalation with the guest.</p>
<p>At this time it's expected that this codegen pattern doesn't show up in the wild that often. LLVM-generated modules, for example, do not appear to conventionally or idiomatically generate code which would hit this bug. It is possible, however, to still write code which triggers this, so it's recommended for embedders to analyze existing modules to see if any are affected.</p>
<h3 id="patches">Patches</h3>
<p>This codegen bug has been fixed in Wasmtime 6.0.1, 5.0.1, and 4.0.1. Users are recommended to upgrade to these updated versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If upgrading is not an option for you at this time, you can avoid this miscompilation by <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">disabling the Wasm simd proposal</a></p>
<pre><code class="language-rust">config.wasm_simd(false);
</code></pre>
<p>Additionally the bug is only present on x86_64 hosts. Other platforms such as AArch64 and s390x are not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/webassembly/simd">The WebAssembly simd proposal</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-27477">https://nvd.nist.gov/vuln/detail/CVE-2023-27477</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd</a></li>
<li><a href="https://github.com/webassembly/simd">https://github.com/webassembly/simd</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-xm67-587q-r2vw">https://github.com/advisories/GHSA-xm67-587q-r2vw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xm67-587q-r2vw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-03-09T00:09:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime vulnerable to miscompilation of `i8x16.select` with the same inputs on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-xm67-587q-r2vw</id>
        <link href="https://github.com/advisories/GHSA-xm67-587q-r2vw"/>
        <updated>2023-03-09T00:09:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generation backend, Cranelift, has a bug on x86_64 platforms for the WebAssembly <code>i8x16.select</code> instruction which will produce the wrong results when the same operand is provided to the instruction and some of the selected indices are greater than 16. There is an off-by-one error  in the calculation of the mask to the <code>pshufb</code> instruction which causes incorrect results to be returned if lanes are selected from the second vector.</p>
<p>The impact of this miscompilation is that the WebAssembly instruction can produce incorrect results for the <code>i8x16.select</code> instruction. This should have no effect on embedders and does not represent a sandbox escape, for example. Guest programs, however, may behave unexpectedly due to the incorrect result of this instruction. In extreme cases if a guest program is handling untrusted input then the guest program may deviate from its intended execution, for example calling an imported host function with different arguments than intended. This still does not impact embedders, however, because there is no form of privilege escalation with the guest.</p>
<p>At this time it's expected that this codegen pattern doesn't show up in the wild that often. LLVM-generated modules, for example, do not appear to conventionally or idiomatically generate code which would hit this bug. It is possible, however, to still write code which triggers this, so it's recommended for embedders to analyze existing modules to see if any are affected.</p>
<h3 id="patches">Patches</h3>
<p>This codegen bug has been fixed in Wasmtime 6.0.1, 5.0.1, and 4.0.1. Users are recommended to upgrade to these updated versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If upgrading is not an option for you at this time, you can avoid this miscompilation by <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">disabling the Wasm simd proposal</a></p>
<pre><code class="language-rust">config.wasm_simd(false);
</code></pre>
<p>Additionally the bug is only present on x86_64 hosts. Other platforms such as AArch64 and s390x are not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/webassembly/simd">The WebAssembly simd proposal</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-27477">https://nvd.nist.gov/vuln/detail/CVE-2023-27477</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd</a></li>
<li><a href="https://github.com/webassembly/simd">https://github.com/webassembly/simd</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-xm67-587q-r2vw">https://github.com/advisories/GHSA-xm67-587q-r2vw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xm67-587q-r2vw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-03-09T00:09:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[wasmtime] wasmtime vulnerable to miscompilation of `i8x16.select` with the same inputs on x86_64]]></title>
        <id>https://github.com/advisories/GHSA-xm67-587q-r2vw</id>
        <link href="https://github.com/advisories/GHSA-xm67-587q-r2vw"/>
        <updated>2023-03-09T00:09:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="impact">Impact</h3>
<p>Wasmtime's code generation backend, Cranelift, has a bug on x86_64 platforms for the WebAssembly <code>i8x16.select</code> instruction which will produce the wrong results when the same operand is provided to the instruction and some of the selected indices are greater than 16. There is an off-by-one error  in the calculation of the mask to the <code>pshufb</code> instruction which causes incorrect results to be returned if lanes are selected from the second vector.</p>
<p>The impact of this miscompilation is that the WebAssembly instruction can produce incorrect results for the <code>i8x16.select</code> instruction. This should have no effect on embedders and does not represent a sandbox escape, for example. Guest programs, however, may behave unexpectedly due to the incorrect result of this instruction. In extreme cases if a guest program is handling untrusted input then the guest program may deviate from its intended execution, for example calling an imported host function with different arguments than intended. This still does not impact embedders, however, because there is no form of privilege escalation with the guest.</p>
<p>At this time it's expected that this codegen pattern doesn't show up in the wild that often. LLVM-generated modules, for example, do not appear to conventionally or idiomatically generate code which would hit this bug. It is possible, however, to still write code which triggers this, so it's recommended for embedders to analyze existing modules to see if any are affected.</p>
<h3 id="patches">Patches</h3>
<p>This codegen bug has been fixed in Wasmtime 6.0.1, 5.0.1, and 4.0.1. Users are recommended to upgrade to these updated versions.</p>
<h3 id="workarounds">Workarounds</h3>
<p>If upgrading is not an option for you at this time, you can avoid this miscompilation by <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">disabling the Wasm simd proposal</a></p>
<pre><code class="language-rust">config.wasm_simd(false);
</code></pre>
<p>Additionally the bug is only present on x86_64 hosts. Other platforms such as AArch64 and s390x are not affected.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/webassembly/simd">The WebAssembly simd proposal</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">Mailing list announcement</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">GitHub advisory</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">Commit to fix this issue on Wasmtime's <code>main</code> branch</a></li>
</ul>
<h3 id="for-more-information">For more information</h3>
<p>If you have any questions or comments about this advisory:</p>
<ul>
<li>Reach out to us on <a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">the Bytecode Alliance Zulip chat</a></li>
<li>Open an issue in <a href="https://github.com/bytecodealliance/wasmtime/">the bytecodealliance/wasmtime repository</a></li>
</ul>
<h3 id="references-1">References</h3>
<ul>
<li><a href="https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw">https://github.com/bytecodealliance/wasmtime/security/advisories/GHSA-xm67-587q-r2vw</a></li>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-27477">https://nvd.nist.gov/vuln/detail/CVE-2023-27477</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1">https://github.com/bytecodealliance/wasmtime/commit/5dc2bbccbb363e474d2c9a1b8e38a89a43bbd5d1</a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd">https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.wasm_simd</a></li>
<li><a href="https://github.com/webassembly/simd">https://github.com/webassembly/simd</a></li>
<li><a href="https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ">https://groups.google.com/a/bytecodealliance.org/g/sec-announce/c/Mov-ItrNJsQ</a></li>
<li><a href="https://github.com/advisories/GHSA-xm67-587q-r2vw">https://github.com/advisories/GHSA-xm67-587q-r2vw</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xm67-587q-r2vw</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-03-09T00:09:03.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[maligned] Maligned causes incorrect deallocation]]></title>
        <id>https://github.com/advisories/GHSA-wm8x-php5-hvq6</id>
        <link href="https://github.com/advisories/GHSA-wm8x-php5-hvq6"/>
        <updated>2023-03-07T20:13:20.000Z</updated>
        <content type="html"><![CDATA[<p><code>maligned::align_first</code> manually allocates with an alignment larger than T, and then uses <code>Vec::from_raw_parts</code> on that allocation to get a <code>Vec&lt;T&gt;</code>.</p>
<p><a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#tymethod.dealloc"><code>GlobalAlloc::dealloc</code></a> requires that the <code>layout</code> argument must be the same layout that was used to allocate that block of memory.</p>
<p>When deallocating, <code>Box</code> and <code>Vec</code> may not respect the specified alignment and can cause undefined behavior.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tylerhawkes/maligned/issues/5">https://github.com/tylerhawkes/maligned/issues/5</a></li>
<li><a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#tymethod.dealloc">https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#tymethod.dealloc</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0017.html">https://rustsec.org/advisories/RUSTSEC-2023-0017.html</a></li>
<li><a href="https://github.com/advisories/GHSA-wm8x-php5-hvq6">https://github.com/advisories/GHSA-wm8x-php5-hvq6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-wm8x-php5-hvq6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-03-07T20:13:19.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[partial_sort] partial_sort contains Out-of-bounds Read in release mode]]></title>
        <id>https://github.com/advisories/GHSA-5x36-7567-3cw6</id>
        <link href="https://github.com/advisories/GHSA-5x36-7567-3cw6"/>
        <updated>2023-02-28T20:31:06.000Z</updated>
        <content type="html"><![CDATA[<p>Affected versions of this crate were using a debug assertion to validate the <code>last</code> parameter of <code>partial_sort()</code>. This would allow invalid inputs to cause an out-of-bounds read instead of immediately panicking, when compiled without debug assertions.</p>
<p>All writes are bounds-checked, so the out-of-bounds memory access is read-only. This also means that the first attempted out-of-bounds write will panic, limiting the possible reads.</p>
<p>The accessible region is further limited by an initial bounds-checked read at <code>(last / 2) - 1</code>, i.e., it is proportional to the size of the vector.</p>
<p>This bug has been fixed in v0.2.0.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/sundy-li/partial_sort/issues/7">https://github.com/sundy-li/partial_sort/issues/7</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0016.html">https://rustsec.org/advisories/RUSTSEC-2023-0016.html</a></li>
<li><a href="https://github.com/advisories/GHSA-5x36-7567-3cw6">https://github.com/advisories/GHSA-5x36-7567-3cw6</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-5x36-7567-3cw6</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-02-28T20:31:05.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[ascii] Ascii (crate) allows out-of-bounds array indexing in safe code]]></title>
        <id>https://github.com/advisories/GHSA-mrrw-grhq-86gf</id>
        <link href="https://github.com/advisories/GHSA-mrrw-grhq-86gf"/>
        <updated>2023-02-28T20:30:10.000Z</updated>
        <content type="html"><![CDATA[<p>Affected version of this crate had implementation of <code>From&lt;&amp;mut AsciiStr&gt;</code> for <code>&amp;mut [u8]</code> and <code>&amp;mut str</code>. This can result in out-of-bounds array indexing in safe code.</p>
<p>The flaw was corrected in commit <a href="https://github.com/tomprogrammer/rust-ascii/pull/63/commits/8a6c7798c202766bd57d70fb8d12739dd68fb9dc">8a6c779</a> by removing those impls.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/tomprogrammer/rust-ascii/issues/64">https://github.com/tomprogrammer/rust-ascii/issues/64</a></li>
<li><a href="https://github.com/tomprogrammer/rust-ascii/pull/63/commits/8a6c7798c202766bd57d70fb8d12739dd68fb9dc">https://github.com/tomprogrammer/rust-ascii/pull/63/commits/8a6c7798c202766bd57d70fb8d12739dd68fb9dc</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0015.html">https://rustsec.org/advisories/RUSTSEC-2023-0015.html</a></li>
<li><a href="https://github.com/advisories/GHSA-mrrw-grhq-86gf">https://github.com/advisories/GHSA-mrrw-grhq-86gf</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mrrw-grhq-86gf</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-02-28T20:30:10.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[deno] Deno vulnerable to Regular Expression Denial of Service]]></title>
        <id>https://github.com/advisories/GHSA-xr9w-x6gw-c9mj</id>
        <link href="https://github.com/advisories/GHSA-xr9w-x6gw-c9mj"/>
        <updated>2023-03-07T04:03:57.000Z</updated>
        <content type="html"><![CDATA[<p>Versions of the package deno before 1.31.0 are vulnerable to Regular Expression Denial of Service (ReDoS) due to the upgradeWebSocket function, which contains regexes in the form of /s*,s*/, used for splitting the Connection/Upgrade header. A specially crafted Connection/Upgrade header can be used to significantly slow down a web socket server. This issue has been patched in version 1.31.0.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2023-26103">https://nvd.nist.gov/vuln/detail/CVE-2023-26103</a></li>
<li><a href="https://github.com/denoland/deno/pull/17722">https://github.com/denoland/deno/pull/17722</a></li>
<li><a href="https://github.com/denoland/deno/commit/cf06a7c7e672880e1b38598fe445e2c50b4a9d06">https://github.com/denoland/deno/commit/cf06a7c7e672880e1b38598fe445e2c50b4a9d06</a></li>
<li><a href="https://github.com/denoland/deno/blob/2b247be517d789a37e532849e2e40b724af0918f/ext/http/01_http.js%23L395-L409">https://github.com/denoland/deno/blob/2b247be517d789a37e532849e2e40b724af0918f/ext/http/01_http.js%23L395-L409</a></li>
<li><a href="https://github.com/denoland/deno/releases/tag/v1.31.0">https://github.com/denoland/deno/releases/tag/v1.31.0</a></li>
<li><a href="https://security.snyk.io/vuln/SNYK-RUST-DENO-3315970">https://security.snyk.io/vuln/SNYK-RUST-DENO-3315970</a></li>
<li><a href="https://github.com/advisories/GHSA-xr9w-x6gw-c9mj">https://github.com/advisories/GHSA-xr9w-x6gw-c9mj</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xr9w-x6gw-c9mj</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2023-02-25T06:30:21.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[remove_dir_all] Race Condition Enabling Link Following and Time-of-check Time-of-use (TOCTOU) Race Condition in remove_dir_all]]></title>
        <id>https://github.com/advisories/GHSA-mc8h-8q98-g5hr</id>
        <link href="https://github.com/advisories/GHSA-mc8h-8q98-g5hr"/>
        <updated>2023-03-06T19:51:56.000Z</updated>
        <content type="html"><![CDATA[<p>The <code>remove_dir_all</code> crate is a Rust library that offers additional features over the Rust standard library <code>fs::remove_dir_all</code> function. It suffers the same class of failure as the code it was layering over: TOCTOU race conditions, with the ability to cause arbitrary paths to be deleted by substituting a symlink for a path after the type of the path was checked.</p>
<p>Thanks to the Rust security team for identifying the problem and alerting us to it.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/XAMPPRocky/remove_dir_all/security/advisories/GHSA-mc8h-8q98-g5hr">https://github.com/XAMPPRocky/remove_dir_all/security/advisories/GHSA-mc8h-8q98-g5hr</a></li>
<li><a href="https://github.com/XAMPPRocky/remove_dir_all/commit/7247a8b6ee59fc99bbb69ca6b3ca4bfd8c809ead">https://github.com/XAMPPRocky/remove_dir_all/commit/7247a8b6ee59fc99bbb69ca6b3ca4bfd8c809ead</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0018.html">https://rustsec.org/advisories/RUSTSEC-2023-0018.html</a></li>
<li><a href="https://github.com/advisories/GHSA-mc8h-8q98-g5hr">https://github.com/advisories/GHSA-mc8h-8q98-g5hr</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-mc8h-8q98-g5hr</uri>
        </author>
        <category label="severity" term="LOW"/>
        <published>2023-02-24T16:23:59.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[libsqlite3-sys] `libsqlite3-sys` via C SQLite improperly validates array index]]></title>
        <id>https://github.com/advisories/GHSA-jw36-hf63-69r9</id>
        <link href="https://github.com/advisories/GHSA-jw36-hf63-69r9"/>
        <updated>2023-02-15T15:38:08.000Z</updated>
        <content type="html"><![CDATA[<p>SQLite 1.0.12 through 3.39.x before 3.39.2 sometimes allows an array-bounds overflow if billions of bytes are used in a string argument to a C API.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://nvd.nist.gov/vuln/detail/CVE-2022-35737">https://nvd.nist.gov/vuln/detail/CVE-2022-35737</a></li>
<li><a href="https://kb.cert.org/vuls/id/720344">https://kb.cert.org/vuls/id/720344</a></li>
<li><a href="https://www.sqlite.org/cves.html">https://www.sqlite.org/cves.html</a></li>
<li><a href="https://sqlite.org/releaselog/3_39_2.html">https://sqlite.org/releaselog/3_39_2.html</a></li>
<li><a href="https://security.netapp.com/advisory/ntap-20220915-0009/">https://security.netapp.com/advisory/ntap-20220915-0009/</a></li>
<li><a href="https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/">https://blog.trailofbits.com/2022/10/25/sqlite-vulnerability-july-2022-library-api/</a></li>
<li><a href="https://security.gentoo.org/glsa/202210-40">https://security.gentoo.org/glsa/202210-40</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2022-0090.html">https://rustsec.org/advisories/RUSTSEC-2022-0090.html</a></li>
<li><a href="https://github.com/advisories/GHSA-jw36-hf63-69r9">https://github.com/advisories/GHSA-jw36-hf63-69r9</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-jw36-hf63-69r9</uri>
        </author>
        <category label="severity" term="HIGH"/>
        <published>2022-08-04T00:00:26.000Z</published>
    </entry>
    <entry>
        <title type="html"><![CDATA[[cortex-m-rt] Miscompilation in cortex-m-rt 0.7.1 and 0.7.2]]></title>
        <id>https://github.com/advisories/GHSA-xw5j-gv2g-mjm2</id>
        <link href="https://github.com/advisories/GHSA-xw5j-gv2g-mjm2"/>
        <updated>2023-02-14T21:53:38.000Z</updated>
        <content type="html"><![CDATA[<p>Version 0.7.1 of the <code>cortex-m-rt</code> crate introduced a regression causing the stack to NOT be eight-byte aligned prior to calling <code>main</code> (or any other specified entrypoint), violating the <a href="https://github.com/ARM-software/abi-aa/blob/edd7460d87493fff124b8b5713acf71ffc06ee91/aapcs32/aapcs32.rst#6212stack-constraints-at-a-public-interface">stack ABI of AAPCS32</a>, the default ABI used by all Cortex-M targets. This regression is also present in version 0.7.2 of the <code>cortex-m-rt</code> crate.</p>
<p>This regression can cause certain compiler optimizations (which assume the eight-byte alignment) to produce incorrect behavior at runtime. This incorrect behavior has been <a href="https://github.com/peter9477/test2">observed in real-world applications</a>.</p>
<p><strong>It is advised that ALL users of <code>v0.7.1</code> and <code>v0.7.2</code> of the <code>cortex-m-rt</code> crate update to the latest version (<code>v0.7.3</code>), AS SOON AS POSSIBLE.</strong> Users of <code>v0.7.0</code> and prior versions of <code>cortex-m-rt</code> are not affected by this regression.</p>
<p>It will be necessary to rebuild all affected firmware binaries, and flash or deploy the new firmware binaries to affected devices.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/rust-embedded/cortex-m/discussions/469">https://github.com/rust-embedded/cortex-m/discussions/469</a></li>
<li><a href="https://rustsec.org/advisories/RUSTSEC-2023-0014.html">https://rustsec.org/advisories/RUSTSEC-2023-0014.html</a></li>
<li><a href="https://github.com/advisories/GHSA-xw5j-gv2g-mjm2">https://github.com/advisories/GHSA-xw5j-gv2g-mjm2</a></li>
</ul>
]]></content>
        <author>
            <name>GitHub</name>
            <email>GitHub@noreply.github.com</email>
            <uri>https://github.com/advisories/GHSA-xw5j-gv2g-mjm2</uri>
        </author>
        <category label="severity" term="MODERATE"/>
        <published>2023-02-14T21:53:37.000Z</published>
    </entry>
</feed>