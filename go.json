{
    "version": "https://jsonfeed.org/version/1",
    "title": "Security Advisory for Go modules",
    "home_page_url": "https://github.com/advisories?query=type%3Areviewed+ecosystem%3Ago",
    "feed_url": "https://azu.github.io/github-advisory-database-rss/go.json",
    "description": "Security Advisory for Go modules on GitHub",
    "items": [
        {
            "content_html": "<p>git-urls version 1.0.1 is vulnerable to ReDOS (Regular Expression Denial of Service) in Go package.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-46402\">https://nvd.nist.gov/vuln/detail/CVE-2023-46402</a></li>\n<li><a href=\"https://gist.github.com/6en6ar/7c2424c93e7fbf2b6fc44e7fb9acb95d\">https://gist.github.com/6en6ar/7c2424c93e7fbf2b6fc44e7fb9acb95d</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3f2q-6294-fmq5\">https://github.com/advisories/GHSA-3f2q-6294-fmq5</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3f2q-6294-fmq5",
            "title": "[https://pkg.go.dev/github.com/whilp/git-urls] Inefficient Regular Expression Complexity in git-urls",
            "date_modified": "2023-11-20T23:05:39.000Z",
            "date_published": "2023-11-18T00:30:17.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3f2q-6294-fmq5"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue in Free5gc v.3.3.0 allows a local attacker to cause a denial of service via the free5gc-compose component.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47025\">https://nvd.nist.gov/vuln/detail/CVE-2023-47025</a></li>\n<li><a href=\"https://github.com/free5gc/free5gc/issues/501\">https://github.com/free5gc/free5gc/issues/501</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-q27h-hw2v-x5jm\">https://github.com/advisories/GHSA-q27h-hw2v-x5jm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-q27h-hw2v-x5jm",
            "title": "[github.com/free5gc/free5gc] Free5gc allows a local attacker to cause a denial of service via the free5gc-compose component",
            "date_modified": "2023-11-17T14:58:09.000Z",
            "date_published": "2023-11-17T00:31:06.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-q27h-hw2v-x5jm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A vulnerability classified as critical was found in Abstrium Pydio Cells 4.2.0. This vulnerability affects unknown code of the component User Creation Handler. The manipulation leads to improper control of resource identifiers. The attack can be initiated remotely. Upgrading to version 4.2.1 is able to address this issue. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-230212.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-2980\">https://nvd.nist.gov/vuln/detail/CVE-2023-2980</a></li>\n<li><a href=\"https://pydio.com/en/community/releases/pydio-cells/pydio-cells-enterprise-421\">https://pydio.com/en/community/releases/pydio-cells/pydio-cells-enterprise-421</a></li>\n<li><a href=\"https://vuldb.com/?ctiid.230212\">https://vuldb.com/?ctiid.230212</a></li>\n<li><a href=\"https://vuldb.com/?id.230212\">https://vuldb.com/?id.230212</a></li>\n<li><a href=\"https://popalltheshells.medium.com/multiple-cves-affecting-pydio-cells-4-2-0-321e7e4712be\">https://popalltheshells.medium.com/multiple-cves-affecting-pydio-cells-4-2-0-321e7e4712be</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-j327-c69h-4gh8\">https://github.com/advisories/GHSA-j327-c69h-4gh8</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-j327-c69h-4gh8",
            "title": "[github.com/pydio/cells/v4] Abstrium Pydio Cells Resource Injection vulnerability",
            "date_modified": "2023-11-16T21:03:52.000Z",
            "date_published": "2023-05-30T15:30:27.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-j327-c69h-4gh8"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Buffer Overflow vulnerability in free5gc 3.3.0 allows attackers to cause a denial of service via crafted PFCP message with malformed PFCP Heartbeat message whose Recovery Time Stamp IE length is mutated to zero.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47345\">https://nvd.nist.gov/vuln/detail/CVE-2023-47345</a></li>\n<li><a href=\"https://github.com/free5gc/free5gc/issues/483\">https://github.com/free5gc/free5gc/issues/483</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-6944-6pmv-6mp2\">https://github.com/advisories/GHSA-6944-6pmv-6mp2</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-6944-6pmv-6mp2",
            "title": "[github.com/free5gc/free5gc] free5gc Buffer Overflow vulnerability",
            "date_modified": "2023-11-21T19:40:09.000Z",
            "date_published": "2023-11-16T00:30:55.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-6944-6pmv-6mp2"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A vulnerability, which was classified as problematic, has been found in Abstrium Pydio Cells 4.2.0. This issue affects some unknown processing of the component Chat. The manipulation leads to basic cross site scripting. The attack may be initiated remotely. Upgrading to version 4.2.1 is able to address this issue. It is recommended to upgrade the affected component. The identifier VDB-230213 was assigned to this vulnerability.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-2981\">https://nvd.nist.gov/vuln/detail/CVE-2023-2981</a></li>\n<li><a href=\"https://pydio.com/en/community/releases/pydio-cells/pydio-cells-enterprise-421\">https://pydio.com/en/community/releases/pydio-cells/pydio-cells-enterprise-421</a></li>\n<li><a href=\"https://vuldb.com/?ctiid.230213\">https://vuldb.com/?ctiid.230213</a></li>\n<li><a href=\"https://vuldb.com/?id.230213\">https://vuldb.com/?id.230213</a></li>\n<li><a href=\"https://popalltheshells.medium.com/multiple-cves-affecting-pydio-cells-4-2-0-321e7e4712be\">https://popalltheshells.medium.com/multiple-cves-affecting-pydio-cells-4-2-0-321e7e4712be</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wmfc-g86p-fjvr\">https://github.com/advisories/GHSA-wmfc-g86p-fjvr</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wmfc-g86p-fjvr",
            "title": "[github.com/pydio/cells] go package pydio cells vulnerable to cross-site scripting ",
            "date_modified": "2023-11-15T18:10:05.000Z",
            "date_published": "2023-05-30T15:30:27.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wmfc-g86p-fjvr"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A security issue was discovered in Kubernetes where a user that can create pods and persistent volumes on Windows nodes may be able to escalate to admin privileges on those nodes. Kubernetes clusters are only affected if they are using an in-tree storage plugin for Windows nodes.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5528\">https://nvd.nist.gov/vuln/detail/CVE-2023-5528</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/issues/121879\">https://github.com/kubernetes/kubernetes/issues/121879</a></li>\n<li><a href=\"https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA\">https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121881\">https://github.com/kubernetes/kubernetes/pull/121881</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121882\">https://github.com/kubernetes/kubernetes/pull/121882</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121883\">https://github.com/kubernetes/kubernetes/pull/121883</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121884\">https://github.com/kubernetes/kubernetes/pull/121884</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121885\">https://github.com/kubernetes/kubernetes/pull/121885</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hq6q-c2x6-hmch\">https://github.com/advisories/GHSA-hq6q-c2x6-hmch</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hq6q-c2x6-hmch",
            "title": "[k8s.io/kubernetes] Kubernetes Improper Input Validation vulnerability",
            "date_modified": "2023-11-14T22:25:08.000Z",
            "date_published": "2023-11-14T21:31:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hq6q-c2x6-hmch"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A security issue was discovered in Kubernetes where a user that can create pods and persistent volumes on Windows nodes may be able to escalate to admin privileges on those nodes. Kubernetes clusters are only affected if they are using an in-tree storage plugin for Windows nodes.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5528\">https://nvd.nist.gov/vuln/detail/CVE-2023-5528</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/issues/121879\">https://github.com/kubernetes/kubernetes/issues/121879</a></li>\n<li><a href=\"https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA\">https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121881\">https://github.com/kubernetes/kubernetes/pull/121881</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121882\">https://github.com/kubernetes/kubernetes/pull/121882</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121883\">https://github.com/kubernetes/kubernetes/pull/121883</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121884\">https://github.com/kubernetes/kubernetes/pull/121884</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121885\">https://github.com/kubernetes/kubernetes/pull/121885</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hq6q-c2x6-hmch\">https://github.com/advisories/GHSA-hq6q-c2x6-hmch</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hq6q-c2x6-hmch",
            "title": "[k8s.io/kubernetes] Kubernetes Improper Input Validation vulnerability",
            "date_modified": "2023-11-14T22:25:08.000Z",
            "date_published": "2023-11-14T21:31:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hq6q-c2x6-hmch"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A security issue was discovered in Kubernetes where a user that can create pods and persistent volumes on Windows nodes may be able to escalate to admin privileges on those nodes. Kubernetes clusters are only affected if they are using an in-tree storage plugin for Windows nodes.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5528\">https://nvd.nist.gov/vuln/detail/CVE-2023-5528</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/issues/121879\">https://github.com/kubernetes/kubernetes/issues/121879</a></li>\n<li><a href=\"https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA\">https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121881\">https://github.com/kubernetes/kubernetes/pull/121881</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121882\">https://github.com/kubernetes/kubernetes/pull/121882</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121883\">https://github.com/kubernetes/kubernetes/pull/121883</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121884\">https://github.com/kubernetes/kubernetes/pull/121884</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121885\">https://github.com/kubernetes/kubernetes/pull/121885</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hq6q-c2x6-hmch\">https://github.com/advisories/GHSA-hq6q-c2x6-hmch</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hq6q-c2x6-hmch",
            "title": "[k8s.io/kubernetes] Kubernetes Improper Input Validation vulnerability",
            "date_modified": "2023-11-14T22:25:08.000Z",
            "date_published": "2023-11-14T21:31:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hq6q-c2x6-hmch"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>A security issue was discovered in Kubernetes where a user that can create pods and persistent volumes on Windows nodes may be able to escalate to admin privileges on those nodes. Kubernetes clusters are only affected if they are using an in-tree storage plugin for Windows nodes.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5528\">https://nvd.nist.gov/vuln/detail/CVE-2023-5528</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/issues/121879\">https://github.com/kubernetes/kubernetes/issues/121879</a></li>\n<li><a href=\"https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA\">https://groups.google.com/g/kubernetes-security-announce/c/SL_d4NR8pzA</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121881\">https://github.com/kubernetes/kubernetes/pull/121881</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121882\">https://github.com/kubernetes/kubernetes/pull/121882</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121883\">https://github.com/kubernetes/kubernetes/pull/121883</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121884\">https://github.com/kubernetes/kubernetes/pull/121884</a></li>\n<li><a href=\"https://github.com/kubernetes/kubernetes/pull/121885\">https://github.com/kubernetes/kubernetes/pull/121885</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-hq6q-c2x6-hmch\">https://github.com/advisories/GHSA-hq6q-c2x6-hmch</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-hq6q-c2x6-hmch",
            "title": "[k8s.io/kubernetes] Kubernetes Improper Input Validation vulnerability",
            "date_modified": "2023-11-14T22:25:08.000Z",
            "date_published": "2023-11-14T21:31:03.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-hq6q-c2x6-hmch"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>An issue was found in Kyverno that allowed an attacker to control the digest of images used by Kyverno users. The issue would require the attacker to compromise the registry that the Kyverno fetch their images from. The attacker could then return a vulnerable image to the the user and leverage that to further escalate their position. As such, the attacker would need to know which images the Kyverno user consumes and know of one of multiple exploitable vulnerabilities in previous digests of the images. Alternatively, if the attacker has compromised the registry, they could craft a malicious image with a different digest with intentionally placed vulnerabilities and deliver the image to the user. </p>\n<p>An attacker was not be able to control other parameters of the image than the digest by exploiting this vulnerability.</p>\n<p>Users pulling their images from trusted registries are not impacted by this vulnerability. There is no evidence of this being exploited in the wild.</p>\n<p>The issue has been patched in 1.11.0. </p>\n<p>The vulnerability was found during an ongoing security audit of Kyverno conducted by Ada Logics, facilitated by OSTIF and funded by the CNCF.</p>\n<p>Members of the community have raised concerns over the similarity between this vulnerability and the one identified with CVE-2023-46737; They are two different issues with two different root causes and different levels of impact. Some differences are:</p>\n<ul>\n<li>The current advisory (GHSA-3hfq-cx9j-923w) has its root cause in Kyverno whereas the root cause of CVE-2023-46737 is in Cosigns code base. </li>\n<li>The impact of the current advisory (GHSA-3hfq-cx9j-923w) is that an attacker can trick Kyverno into consuming a different image than the one the user requested; The impact of CVE-2023-46737 is an endless data attack resulting in a denial-of-service.</li>\n<li>The fix of the current advisory (GHSA-3hfq-cx9j-923w) does not result in users being secure from CVE-2023-46737 and vice versa.</li>\n</ul>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/kyverno/kyverno/security/advisories/GHSA-3hfq-cx9j-923w\">https://github.com/kyverno/kyverno/security/advisories/GHSA-3hfq-cx9j-923w</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47630\">https://nvd.nist.gov/vuln/detail/CVE-2023-47630</a></li>\n<li><a href=\"https://github.com/kyverno/kyverno/releases/tag/v1.11.0\">https://github.com/kyverno/kyverno/releases/tag/v1.11.0</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-3hfq-cx9j-923w\">https://github.com/advisories/GHSA-3hfq-cx9j-923w</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-3hfq-cx9j-923w",
            "title": "[github.com/kyverno/kyverno] Attacker can cause Kyverno user to unintentionally consume insecure image",
            "date_modified": "2023-11-14T22:20:10.000Z",
            "date_published": "2023-11-14T22:20:09.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-3hfq-cx9j-923w"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>Headscale through 0.22.3 writes bearer tokens to info-level logs.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47390\">https://nvd.nist.gov/vuln/detail/CVE-2023-47390</a></li>\n<li><a href=\"https://github.com/juanfont/headscale/issues/1259\">https://github.com/juanfont/headscale/issues/1259</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-wp76-cf2j-rqq7\">https://github.com/advisories/GHSA-wp76-cf2j-rqq7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-wp76-cf2j-rqq7",
            "title": "[github.com/juanfont/headscale] Headscale writes bearer tokens to info-level logs",
            "date_modified": "2023-11-20T22:06:54.000Z",
            "date_published": "2023-11-11T18:30:25.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-wp76-cf2j-rqq7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>In certain versions of gitsign, Rekor public keys were fetched via the Rekor API, instead of through the local TUF client. If the upstream Rekor server happened to be compromised, gitsign clients could potentially be tricked into trusting incorrect signatures.</p>\n<p>There is no known compromise the default public good instance (<code>rekor.sigstore.dev</code>) - anyone using this instance is unlikely to be affected.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>This was fixed in v0.8.0 via <a href=\"https://github.com/sigstore/gitsign/pull/399\">https://github.com/sigstore/gitsign/pull/399</a></p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>n/a</p>\n<h3 id=\"references\">References</h3>\n<p><em>Are there any links users can visit to find out more?</em></p>\n<p><a href=\"https://docs.sigstore.dev/about/threat-model/#sigstore-threat-model\">https://docs.sigstore.dev/about/threat-model/#sigstore-threat-model</a></p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/sigstore/gitsign/security/advisories/GHSA-xvrc-2wvh-49vc\">https://github.com/sigstore/gitsign/security/advisories/GHSA-xvrc-2wvh-49vc</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47122\">https://nvd.nist.gov/vuln/detail/CVE-2023-47122</a></li>\n<li><a href=\"https://github.com/sigstore/gitsign/pull/399\">https://github.com/sigstore/gitsign/pull/399</a></li>\n<li><a href=\"https://github.com/sigstore/gitsign/commit/cd66ccb03c86a3600955f0c15f6bfeb75f697236\">https://github.com/sigstore/gitsign/commit/cd66ccb03c86a3600955f0c15f6bfeb75f697236</a></li>\n<li><a href=\"https://docs.sigstore.dev/about/threat-model/#sigstore-threat-model\">https://docs.sigstore.dev/about/threat-model/#sigstore-threat-model</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-xvrc-2wvh-49vc\">https://github.com/advisories/GHSA-xvrc-2wvh-49vc</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-xvrc-2wvh-49vc",
            "title": "[github.com/sigstore/gitsign] Gitsign's Rekor public keys fetched from upstream API instead of local TUF client.",
            "date_modified": "2023-11-14T20:31:24.000Z",
            "date_published": "2023-11-14T20:31:23.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-xvrc-2wvh-49vc"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"short-summary\">Short summary</h1>\n<p>Combining two molecules to one another, called \"cross-linking\" results in a molecule with a chemical formula that is composed of all atoms of the original two molecules. </p>\n<p>In Fabric, one can take a block of transactions and cross-link the transactions in a way that alters the way the peers parse the transactions. If a first peer receives a block <code>B</code> and a second peer receives a block identical to <code>B</code> but with the transactions being cross-linked, the second peer will parse transactions in a different way and thus its world state will deviate from the first peer. </p>\n<p>Orderers or peers cannot detect that a block has its transactions cross-linked, because there is a vulnerability in the way Fabric hashes the transactions of blocks. It simply and naively concatenates them, which is insecure and lets an adversary craft a \"cross-linked block\" (block with cross-linked transactions) which alters the way peers process transactions. \nFor example, it is possible to select a transaction and manipulate a peer to completely avoid processing it, without changing the computed hash of the block.</p>\n<p>Additional validations have been added in v2.2.14 and v2.5.5 to detect potential cross-linking issues before processing blocks.</p>\n<h2 id=\"impact\">Impact</h2>\n<p>In V1 and V2, we only have a crash fault tolerant orderer and as such, the security model Fabric operates in is that the orderer is honest,\nbut peers may be malicious. As such, a peer that replicates a block from a malicious peer can have a state fork.</p>\n<p>In V3 which we did not a release a GA yet (only a preview), we have a byzantine fault tolerant orderering service, so the security model that Fabric operates in such a case includes malicious orderers. If the orderer is malicious, it can cause state forks for peers, and can infect non-malicious orderers with cross-linked blocks.</p>\n<h1 id=\"long-summary\">Long summary</h1>\n<p>In order to create a signature on a big chunk of data  such as a block, the data needs to be \"compressed\" first to the input size of the signature algorithm.</p>\n<p>In Fabric's case, we use a hash function which compressed a Fabric block from arbitrary size to a 32 byte string.</p>\n<p>In order to understand the problem we need to be more specific: The block structure has three parts to it: (1) Header, (2) Transactions, and (3) Metadata.</p>\n<p>When hashing the block, the header and metadata are stitched together and then hashed, and this hash of the header and the metadata is what signed (it's a simplification but let's not get into details)</p>\n<p>However, the transactions of the block are not part of the above hash. Instead, the header contains a hash, called the \"Data hash\" and despite the fact that in the comments it is said: \"// The hash of the BlockData, by MerkleTree\", actually it is far from being the case, and that is where our problem lies.</p>\n<p>The problem is that the way the transactions are hashed gives an attacker some freedom in manipulating the data. </p>\n<p>To create the Data Hash, the transactions in the block are concatenated to one another, creating a big long byte array and then this big long byte array is hashed, and this is essentially the Data Hash.</p>\n<p>The transactions in the block are a list of raw byte arrays, and when they are concatenated they look like this:</p>\n<p><code>|$$$$$$$$$$$$|*************|@@@@@@@@@@@@|%%%%%%%%%|</code>  (The vertical lines \" | \" represent how transactions are separated in a block.)</p>\n<p>When the transactions are concatenated in order to be hashed, the payload that is hashed is: \n<code>$$$$$$$$$$$$*************@@@@@@@@@@@@%%%%%%%%%</code></p>\n<p>An adversary can't change the bytes of the concatenation, however what it can do, is to modify how transactions are encoded in the block:</p>\n<p>For example, consider an adversary wants to manipulate a peer to skip the second transaction (******).</p>\n<p>It can then create a block with the transactions as follows:</p>\n<p><code>|$$$$$$$$$$$$*************|@@@@@@@@@@@@|%%%%%%%%%| </code></p>\n<p>Notice that a block with the above transactions has the same concatenation of bytes as the original block, but the block has one less transaction - the first transaction is a concatenation of the first and second transactions in the original block.</p>\n<p>When the peer receives this block, it looks at the first transaction and when it parses it, it completely ignores the ***** bytes, (we will see why soon), and so, an adversary can create a block with the same hash but different transactions and this would create a fork in the network.</p>\n<p>I made a small PoC where I created a block with 2 transactions (by invoking two chaincodes at the same time) with a Raft orderer:</p>\n<pre><code>    [e][OrdererOrg.orderer] 2023-10-14 23:07:34.076 CEST 0079 INFO [orderer.consensus.etcdraft] propose -&gt; Created block [10] with 2 transactions, there are 0 blocks in flight channel=testchannel node=1\n</code></pre>\n<p>But right after creating the block, I just modified only its transaction content (without modifying the block hash) and then the peers only detect a single transaction inside that block:</p>\n<pre><code>    [e][Org2.peer0] 2023-10-14 23:07:34.079 CEST 0099 INFO [kvledger] commit -&gt; [testchannel] Committed block [10] with 1 transaction(s) in 0ms (state_validation=0ms block_and_pvtdata_commit=0ms state_commit=0ms) commitHash=[c5ecca818da9319af2f276dd01cd1337938f20c3535dd23f95a33933a114fe84]\n</code></pre>\n<p>The important takeaway from this experiment is that the peer does not detect any tempering was done to the block. If an attacker performs this attack, the network can be forked silently and no one will notice the network was forked until it's too late.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>Here is the patch I propose (the explanation is further below): </p>\n<pre><code>diff --git a/internal/peer/gossip/mcs.go b/internal/peer/gossip/mcs.go\nindex b46df8b6a..9c3b5c8fd 100644\n--- a/internal/peer/gossip/mcs.go\n+++ b/internal/peer/gossip/mcs.go\n@@ -150,6 +150,10 @@ func (s *MSPMessageCryptoService) VerifyBlock(chainID common.ChannelID, seqNum u\n         return fmt.Errorf(\"Block with id [%d] on channel [%s] does not have metadata. Block not valid.\", block.Header.Number, chainID)\n     }\n \n+\tif err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {\n+\t\treturn err\n+\t}\n+\n     // - Verify that Header.DataHash is equal to the hash of block.Data\n     // This is to ensure that the header is consistent with the data carried by this block\n     if !bytes.Equal(protoutil.BlockDataHash(block.Data), block.Header.DataHash) {\ndiff --git a/orderer/common/cluster/util.go b/orderer/common/cluster/util.go\nindex e229bebfc..05b1bfaa9 100644\n--- a/orderer/common/cluster/util.go\n+++ b/orderer/common/cluster/util.go\n@@ -260,6 +260,9 @@ func VerifyBlockHash(indexInBuffer int, blockBuff []*common.Block) error {\n     if block.Header == nil {\n         return errors.New(\"missing block header\")\n     }\n+\tif err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {\n+\t\treturn err\n+\t}\n     seq := block.Header.Number\n     dataHash := protoutil.BlockDataHash(block.Data)\n     // Verify data hash matches the hash in the header\ndiff --git a/orderer/consensus/smartbft/verifier.go b/orderer/consensus/smartbft/verifier.go\nindex 2b9fdfc4c..f232a1eae 100644\n--- a/orderer/consensus/smartbft/verifier.go\n+++ b/orderer/consensus/smartbft/verifier.go\n@@ -237,6 +237,10 @@ func verifyHashChain(block *cb.Block, prevHeaderHash string) error {\n         return errors.Errorf(\"previous header hash is %s but expected %s\", thisHdrHashOfPrevHdr, prevHeaderHash)\n     }\n \n+\tif err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {\n+\t\treturn err\n+\t}\n+\n     dataHash := hex.EncodeToString(block.Header.DataHash)\n     actualHashOfData := hex.EncodeToString(protoutil.BlockDataHash(block.Data))\n     if dataHash != actualHashOfData {\ndiff --git a/protoutil/blockutils.go b/protoutil/blockutils.go\nindex 8527869e4..fca3c386f 100644\n--- a/protoutil/blockutils.go\n+++ b/protoutil/blockutils.go\n@@ -10,6 +10,7 @@ import (\n     \"bytes\"\n     \"crypto/sha256\"\n     \"encoding/asn1\"\n+\t\"encoding/base64\"\n     \"fmt\"\n     \"math/big\"\n \n@@ -298,3 +299,35 @@ func searchConsenterIdentityByID(consenters []*cb.Consenter, identifier uint32)\n     }\n     return nil\n }\n+\n+func VerifyTransactionsAreWellFormed(block *cb.Block) error {\n+\tif block == nil || block.Data == nil || len(block.Data.Data) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tfor i, rawTx := range block.Data.Data {\n+\t\tenv := &amp;cb.Envelope{}\n+\t\tif err := proto.Unmarshal(rawTx, env); err != nil {\n+\t\t\treturn fmt.Errorf(\"transaction %d is invalid: %v\", i, err)\n+\t\t}\n+\n+\t\tif len(env.Payload) == 0 {\n+\t\t\treturn fmt.Errorf(\"transaction %d has no payload\", i)\n+\t\t}\n+\n+\t\tif len(env.Signature) == 0 {\n+\t\t\treturn fmt.Errorf(\"transaction %d has no signature\", i)\n+\t\t}\n+\n+\t\texpected := MarshalOrPanic(env)\n+\t\tif len(expected) &lt; len(rawTx) {\n+\t\t\treturn fmt.Errorf(\"transaction %d has %d trailing bytes\", i, len(rawTx)-len(expected))\n+\t\t}\n+\t\tif !bytes.Equal(expected, rawTx) {\n+\t\t\treturn fmt.Errorf(\"transaction %d (%s) does not match its raw form (%s)\", i,\n+\t\t\t\tbase64.StdEncoding.EncodeToString(expected), base64.StdEncoding.EncodeToString(rawTx))\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\ndiff --git a/protoutil/blockutils_test.go b/protoutil/blockutils_test.go\nindex b2159da9f..2871483f1 100644\n--- a/protoutil/blockutils_test.go\n+++ b/protoutil/blockutils_test.go\n@@ -489,3 +489,109 @@ func TestBlockSignatureVerifierByCreator(t *testing.T) {\n     require.Len(t, signatureSet, 1)\n     require.Equal(t, []byte(\"creator1\"), signatureSet[0].Identity)\n }\n+\n+func TestVerifyTransactionsAreWellFormed(t *testing.T) {\n+\toriginalBlock := &amp;cb.Block{\n+\t\tData: &amp;cb.BlockData{\n+\t\t\tData: [][]byte{\n+\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\tPayload:   []byte{1, 2, 3},\n+\t\t\t\t\tSignature: []byte{4, 5, 6},\n+\t\t\t\t}),\n+\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\tPayload:   []byte{7, 8, 9},\n+\t\t\t\t\tSignature: []byte{10, 11, 12},\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tforgedBlock := proto.Clone(originalBlock).(*cb.Block)\n+\ttmp := make([]byte, len(forgedBlock.Data.Data[0])+len(forgedBlock.Data.Data[1]))\n+\tcopy(tmp, forgedBlock.Data.Data[0])\n+\tcopy(tmp[len(forgedBlock.Data.Data[0]):], forgedBlock.Data.Data[1])\n+\tforgedBlock.Data.Data = [][]byte{tmp} // Replace transactions {0,1} with transaction {0 || 1}\n+\n+\tfor _, tst := range []struct {\n+\t\tname          string\n+\t\texpectedError string\n+\t\tblock         *cb.Block\n+\t}{\n+\t\t{\n+\t\t\tname: \"empty block\",\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"no block data\",\n+\t\t\tblock: &amp;cb.Block{},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"no transactions\",\n+\t\t\tblock: &amp;cb.Block{Data: &amp;cb.BlockData{}},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"single transaction\",\n+\t\t\tblock: &amp;cb.Block{Data: &amp;cb.BlockData{Data: [][]byte{marshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\tPayload:   []byte{1, 2, 3},\n+\t\t\t\tSignature: []byte{4, 5, 6},\n+\t\t\t})}}},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"good block\",\n+\t\t\tblock: originalBlock,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"forged block\",\n+\t\t\tblock:         forgedBlock,\n+\t\t\texpectedError: \"transaction 0 has 10 trailing bytes\",\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"no signature\",\n+\t\t\texpectedError: \"transaction 0 has no signature\",\n+\t\t\tblock: &amp;cb.Block{\n+\t\t\t\tData: &amp;cb.BlockData{\n+\t\t\t\t\tData: [][]byte{\n+\t\t\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\t\t\tPayload: []byte{1, 2, 3},\n+\t\t\t\t\t\t}),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"no payload\",\n+\t\t\texpectedError: \"transaction 0 has no payload\",\n+\t\t\tblock: &amp;cb.Block{\n+\t\t\t\tData: &amp;cb.BlockData{\n+\t\t\t\t\tData: [][]byte{\n+\t\t\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\t\t\tSignature: []byte{4, 5, 6},\n+\t\t\t\t\t\t}),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"transaction invalid\",\n+\t\t\texpectedError: \"transaction 0 is invalid: proto: cannot parse invalid wire-format data\",\n+\t\t\tblock: &amp;cb.Block{\n+\t\t\t\tData: &amp;cb.BlockData{\n+\t\t\t\t\tData: [][]byte{\n+\t\t\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\t\t\tPayload:   []byte{1, 2, 3},\n+\t\t\t\t\t\t\tSignature: []byte{4, 5, 6},\n+\t\t\t\t\t\t})[9:],\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t} {\n+\t\tt.Run(tst.name, func(t *testing.T) {\n+\t\t\terr := protoutil.VerifyTransactionsAreWellFormed(tst.block)\n+\t\t\tif tst.expectedError == \"\" {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t} else {\n+\t\t\t\trequire.EqualError(t, err, tst.expectedError)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n</code></pre>\n<p>The idea is as follows:</p>\n<p>When we validate that the block's transactions match the hash in the header, we not only hash the transactions are earlier, </p>\n<p>but also ensure that if the transactions in the block are encoded into bytes, they re-create the exact split in the original block: <code>|$$$$$$$$$$$$|***********|@@@@@@@@@|%%%%%%%%%%%|</code></p>\n<p>More specifically, each transaction in the block is parsed and then re-encoded to bytes, and we check that the original encoding of a transaction is as the second encoding after parsing the original bytes of the transaction.</p>\n<p>This fix keeps the legacy way of hashing transactions to create the block data hash, but also aims to check if some manipulation was done.</p>\n<p>To understand why the fix works, we need to understand how protobuf, the wire protocol that Fabric uses to encode transactions (and almost anything it sends over the wire or writes to disk) encodes a transaction.</p>\n<p>A transaction is a protobuf message with two fields of bytes: (1) Payload and (2) Signature.</p>\n<p>When encoding a field of bytes, protobuf first writes a tag for the field (a byte) and then writes the length of the field in variable-length encoding, and then the bytes themselves.</p>\n<p>For example, to encode a transaction, protobuf writes 10 (the tag for payload), then two bytes for the length of the payload, then the payload, and then 18, the tag for the signature, and then a single byte for the length of the signature, and finally the signature.</p>\n<p>Now, we can understand a proof sketch of why my solution works:</p>\n<p>Assume in contradiction that an adversary takes a block of transactions and changes the split of the concatenation in a way that changes the transactions for a peer:</p>\n<p>From <code>|$$$$$$$$$$$$|************|@@@@@@@@@@@|...|%%%%%%%|</code> to (for example): From <code>|$$$$$$$$$$$$************|@@@@@@@@@@@|...|%%%%%%%|</code> </p>\n<p>Since this split is not identical to the original split, there exists at least one transaction index of different size between the two splits. Let's look at the first transaction that is of different size.</p>\n<p>For example, for the split:</p>\n<p><code>|$$$$$$$$$$$$|************|@@@@@@@@@@@|...|%%%%%%%|</code>  we have two options:</p>\n<ol>\n<li><p>The first transaction of different size is smaller in the new split:  <code>|$$$$$$$$$$$$|*****|*******|@@@@@@@@@@@|...|%%%%%%%|</code>  In such a case, it must contain both a payload and a signature, so it needs two fields (we can say we will return an error if one of the two is missing). If the protobuf parser detects it lacks bytes to parse a payload, it will fail with an error. Else, it has enough bytes to parse the payload, and then the signature is parsed. If the signature field is too short then we also error similarly.</p>\n</li>\n<li><p>The first transaction of different size is bigger in the new split: <code>|$$$$$$$$$$$$|************@@@@|@@@@@@@|...|%%%%%%%|</code> \nIn that case, once this transaction is parsed, the extra bytes are skipped, so encoding the transaction to bytes yields a shorter byte array, and we detect a tempering.</p>\n</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/hyperledger/fabric/security/advisories/GHSA-v9w2-543f-h69m\">https://github.com/hyperledger/fabric/security/advisories/GHSA-v9w2-543f-h69m</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/pull/4503\">https://github.com/hyperledger/fabric/pull/4503</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/pull/4504\">https://github.com/hyperledger/fabric/pull/4504</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/commit/389b2e66de9a6fbc6043216d554c97bbbdf0e008\">https://github.com/hyperledger/fabric/commit/389b2e66de9a6fbc6043216d554c97bbbdf0e008</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/commit/93bef10bd3ce3c54d7f3b064f765dbde61da7def\">https://github.com/hyperledger/fabric/commit/93bef10bd3ce3c54d7f3b064f765dbde61da7def</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/releases/tag/v2.2.14\">https://github.com/hyperledger/fabric/releases/tag/v2.2.14</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/releases/tag/v2.5.5\">https://github.com/hyperledger/fabric/releases/tag/v2.5.5</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-46132\">https://nvd.nist.gov/vuln/detail/CVE-2023-46132</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-v9w2-543f-h69m\">https://github.com/advisories/GHSA-v9w2-543f-h69m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-v9w2-543f-h69m",
            "title": "[github.com/hyperledger/fabric] Fabric vulnerable to crosslinking transaction attack",
            "date_modified": "2023-11-14T21:37:11.000Z",
            "date_published": "2023-11-14T20:28:34.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-v9w2-543f-h69m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h1 id=\"short-summary\">Short summary</h1>\n<p>Combining two molecules to one another, called \"cross-linking\" results in a molecule with a chemical formula that is composed of all atoms of the original two molecules. </p>\n<p>In Fabric, one can take a block of transactions and cross-link the transactions in a way that alters the way the peers parse the transactions. If a first peer receives a block <code>B</code> and a second peer receives a block identical to <code>B</code> but with the transactions being cross-linked, the second peer will parse transactions in a different way and thus its world state will deviate from the first peer. </p>\n<p>Orderers or peers cannot detect that a block has its transactions cross-linked, because there is a vulnerability in the way Fabric hashes the transactions of blocks. It simply and naively concatenates them, which is insecure and lets an adversary craft a \"cross-linked block\" (block with cross-linked transactions) which alters the way peers process transactions. \nFor example, it is possible to select a transaction and manipulate a peer to completely avoid processing it, without changing the computed hash of the block.</p>\n<p>Additional validations have been added in v2.2.14 and v2.5.5 to detect potential cross-linking issues before processing blocks.</p>\n<h2 id=\"impact\">Impact</h2>\n<p>In V1 and V2, we only have a crash fault tolerant orderer and as such, the security model Fabric operates in is that the orderer is honest,\nbut peers may be malicious. As such, a peer that replicates a block from a malicious peer can have a state fork.</p>\n<p>In V3 which we did not a release a GA yet (only a preview), we have a byzantine fault tolerant orderering service, so the security model that Fabric operates in such a case includes malicious orderers. If the orderer is malicious, it can cause state forks for peers, and can infect non-malicious orderers with cross-linked blocks.</p>\n<h1 id=\"long-summary\">Long summary</h1>\n<p>In order to create a signature on a big chunk of data  such as a block, the data needs to be \"compressed\" first to the input size of the signature algorithm.</p>\n<p>In Fabric's case, we use a hash function which compressed a Fabric block from arbitrary size to a 32 byte string.</p>\n<p>In order to understand the problem we need to be more specific: The block structure has three parts to it: (1) Header, (2) Transactions, and (3) Metadata.</p>\n<p>When hashing the block, the header and metadata are stitched together and then hashed, and this hash of the header and the metadata is what signed (it's a simplification but let's not get into details)</p>\n<p>However, the transactions of the block are not part of the above hash. Instead, the header contains a hash, called the \"Data hash\" and despite the fact that in the comments it is said: \"// The hash of the BlockData, by MerkleTree\", actually it is far from being the case, and that is where our problem lies.</p>\n<p>The problem is that the way the transactions are hashed gives an attacker some freedom in manipulating the data. </p>\n<p>To create the Data Hash, the transactions in the block are concatenated to one another, creating a big long byte array and then this big long byte array is hashed, and this is essentially the Data Hash.</p>\n<p>The transactions in the block are a list of raw byte arrays, and when they are concatenated they look like this:</p>\n<p><code>|$$$$$$$$$$$$|*************|@@@@@@@@@@@@|%%%%%%%%%|</code>  (The vertical lines \" | \" represent how transactions are separated in a block.)</p>\n<p>When the transactions are concatenated in order to be hashed, the payload that is hashed is: \n<code>$$$$$$$$$$$$*************@@@@@@@@@@@@%%%%%%%%%</code></p>\n<p>An adversary can't change the bytes of the concatenation, however what it can do, is to modify how transactions are encoded in the block:</p>\n<p>For example, consider an adversary wants to manipulate a peer to skip the second transaction (******).</p>\n<p>It can then create a block with the transactions as follows:</p>\n<p><code>|$$$$$$$$$$$$*************|@@@@@@@@@@@@|%%%%%%%%%| </code></p>\n<p>Notice that a block with the above transactions has the same concatenation of bytes as the original block, but the block has one less transaction - the first transaction is a concatenation of the first and second transactions in the original block.</p>\n<p>When the peer receives this block, it looks at the first transaction and when it parses it, it completely ignores the ***** bytes, (we will see why soon), and so, an adversary can create a block with the same hash but different transactions and this would create a fork in the network.</p>\n<p>I made a small PoC where I created a block with 2 transactions (by invoking two chaincodes at the same time) with a Raft orderer:</p>\n<pre><code>    [e][OrdererOrg.orderer] 2023-10-14 23:07:34.076 CEST 0079 INFO [orderer.consensus.etcdraft] propose -&gt; Created block [10] with 2 transactions, there are 0 blocks in flight channel=testchannel node=1\n</code></pre>\n<p>But right after creating the block, I just modified only its transaction content (without modifying the block hash) and then the peers only detect a single transaction inside that block:</p>\n<pre><code>    [e][Org2.peer0] 2023-10-14 23:07:34.079 CEST 0099 INFO [kvledger] commit -&gt; [testchannel] Committed block [10] with 1 transaction(s) in 0ms (state_validation=0ms block_and_pvtdata_commit=0ms state_commit=0ms) commitHash=[c5ecca818da9319af2f276dd01cd1337938f20c3535dd23f95a33933a114fe84]\n</code></pre>\n<p>The important takeaway from this experiment is that the peer does not detect any tempering was done to the block. If an attacker performs this attack, the network can be forked silently and no one will notice the network was forked until it's too late.</p>\n<h1 id=\"patches\">Patches</h1>\n<p>Here is the patch I propose (the explanation is further below): </p>\n<pre><code>diff --git a/internal/peer/gossip/mcs.go b/internal/peer/gossip/mcs.go\nindex b46df8b6a..9c3b5c8fd 100644\n--- a/internal/peer/gossip/mcs.go\n+++ b/internal/peer/gossip/mcs.go\n@@ -150,6 +150,10 @@ func (s *MSPMessageCryptoService) VerifyBlock(chainID common.ChannelID, seqNum u\n         return fmt.Errorf(\"Block with id [%d] on channel [%s] does not have metadata. Block not valid.\", block.Header.Number, chainID)\n     }\n \n+\tif err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {\n+\t\treturn err\n+\t}\n+\n     // - Verify that Header.DataHash is equal to the hash of block.Data\n     // This is to ensure that the header is consistent with the data carried by this block\n     if !bytes.Equal(protoutil.BlockDataHash(block.Data), block.Header.DataHash) {\ndiff --git a/orderer/common/cluster/util.go b/orderer/common/cluster/util.go\nindex e229bebfc..05b1bfaa9 100644\n--- a/orderer/common/cluster/util.go\n+++ b/orderer/common/cluster/util.go\n@@ -260,6 +260,9 @@ func VerifyBlockHash(indexInBuffer int, blockBuff []*common.Block) error {\n     if block.Header == nil {\n         return errors.New(\"missing block header\")\n     }\n+\tif err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {\n+\t\treturn err\n+\t}\n     seq := block.Header.Number\n     dataHash := protoutil.BlockDataHash(block.Data)\n     // Verify data hash matches the hash in the header\ndiff --git a/orderer/consensus/smartbft/verifier.go b/orderer/consensus/smartbft/verifier.go\nindex 2b9fdfc4c..f232a1eae 100644\n--- a/orderer/consensus/smartbft/verifier.go\n+++ b/orderer/consensus/smartbft/verifier.go\n@@ -237,6 +237,10 @@ func verifyHashChain(block *cb.Block, prevHeaderHash string) error {\n         return errors.Errorf(\"previous header hash is %s but expected %s\", thisHdrHashOfPrevHdr, prevHeaderHash)\n     }\n \n+\tif err := protoutil.VerifyTransactionsAreWellFormed(block); err != nil {\n+\t\treturn err\n+\t}\n+\n     dataHash := hex.EncodeToString(block.Header.DataHash)\n     actualHashOfData := hex.EncodeToString(protoutil.BlockDataHash(block.Data))\n     if dataHash != actualHashOfData {\ndiff --git a/protoutil/blockutils.go b/protoutil/blockutils.go\nindex 8527869e4..fca3c386f 100644\n--- a/protoutil/blockutils.go\n+++ b/protoutil/blockutils.go\n@@ -10,6 +10,7 @@ import (\n     \"bytes\"\n     \"crypto/sha256\"\n     \"encoding/asn1\"\n+\t\"encoding/base64\"\n     \"fmt\"\n     \"math/big\"\n \n@@ -298,3 +299,35 @@ func searchConsenterIdentityByID(consenters []*cb.Consenter, identifier uint32)\n     }\n     return nil\n }\n+\n+func VerifyTransactionsAreWellFormed(block *cb.Block) error {\n+\tif block == nil || block.Data == nil || len(block.Data.Data) == 0 {\n+\t\treturn nil\n+\t}\n+\n+\tfor i, rawTx := range block.Data.Data {\n+\t\tenv := &amp;cb.Envelope{}\n+\t\tif err := proto.Unmarshal(rawTx, env); err != nil {\n+\t\t\treturn fmt.Errorf(\"transaction %d is invalid: %v\", i, err)\n+\t\t}\n+\n+\t\tif len(env.Payload) == 0 {\n+\t\t\treturn fmt.Errorf(\"transaction %d has no payload\", i)\n+\t\t}\n+\n+\t\tif len(env.Signature) == 0 {\n+\t\t\treturn fmt.Errorf(\"transaction %d has no signature\", i)\n+\t\t}\n+\n+\t\texpected := MarshalOrPanic(env)\n+\t\tif len(expected) &lt; len(rawTx) {\n+\t\t\treturn fmt.Errorf(\"transaction %d has %d trailing bytes\", i, len(rawTx)-len(expected))\n+\t\t}\n+\t\tif !bytes.Equal(expected, rawTx) {\n+\t\t\treturn fmt.Errorf(\"transaction %d (%s) does not match its raw form (%s)\", i,\n+\t\t\t\tbase64.StdEncoding.EncodeToString(expected), base64.StdEncoding.EncodeToString(rawTx))\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\ndiff --git a/protoutil/blockutils_test.go b/protoutil/blockutils_test.go\nindex b2159da9f..2871483f1 100644\n--- a/protoutil/blockutils_test.go\n+++ b/protoutil/blockutils_test.go\n@@ -489,3 +489,109 @@ func TestBlockSignatureVerifierByCreator(t *testing.T) {\n     require.Len(t, signatureSet, 1)\n     require.Equal(t, []byte(\"creator1\"), signatureSet[0].Identity)\n }\n+\n+func TestVerifyTransactionsAreWellFormed(t *testing.T) {\n+\toriginalBlock := &amp;cb.Block{\n+\t\tData: &amp;cb.BlockData{\n+\t\t\tData: [][]byte{\n+\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\tPayload:   []byte{1, 2, 3},\n+\t\t\t\t\tSignature: []byte{4, 5, 6},\n+\t\t\t\t}),\n+\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\tPayload:   []byte{7, 8, 9},\n+\t\t\t\t\tSignature: []byte{10, 11, 12},\n+\t\t\t\t}),\n+\t\t\t},\n+\t\t},\n+\t}\n+\n+\tforgedBlock := proto.Clone(originalBlock).(*cb.Block)\n+\ttmp := make([]byte, len(forgedBlock.Data.Data[0])+len(forgedBlock.Data.Data[1]))\n+\tcopy(tmp, forgedBlock.Data.Data[0])\n+\tcopy(tmp[len(forgedBlock.Data.Data[0]):], forgedBlock.Data.Data[1])\n+\tforgedBlock.Data.Data = [][]byte{tmp} // Replace transactions {0,1} with transaction {0 || 1}\n+\n+\tfor _, tst := range []struct {\n+\t\tname          string\n+\t\texpectedError string\n+\t\tblock         *cb.Block\n+\t}{\n+\t\t{\n+\t\t\tname: \"empty block\",\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"no block data\",\n+\t\t\tblock: &amp;cb.Block{},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"no transactions\",\n+\t\t\tblock: &amp;cb.Block{Data: &amp;cb.BlockData{}},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"single transaction\",\n+\t\t\tblock: &amp;cb.Block{Data: &amp;cb.BlockData{Data: [][]byte{marshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\tPayload:   []byte{1, 2, 3},\n+\t\t\t\tSignature: []byte{4, 5, 6},\n+\t\t\t})}}},\n+\t\t},\n+\t\t{\n+\t\t\tname:  \"good block\",\n+\t\t\tblock: originalBlock,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"forged block\",\n+\t\t\tblock:         forgedBlock,\n+\t\t\texpectedError: \"transaction 0 has 10 trailing bytes\",\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"no signature\",\n+\t\t\texpectedError: \"transaction 0 has no signature\",\n+\t\t\tblock: &amp;cb.Block{\n+\t\t\t\tData: &amp;cb.BlockData{\n+\t\t\t\t\tData: [][]byte{\n+\t\t\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\t\t\tPayload: []byte{1, 2, 3},\n+\t\t\t\t\t\t}),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"no payload\",\n+\t\t\texpectedError: \"transaction 0 has no payload\",\n+\t\t\tblock: &amp;cb.Block{\n+\t\t\t\tData: &amp;cb.BlockData{\n+\t\t\t\t\tData: [][]byte{\n+\t\t\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\t\t\tSignature: []byte{4, 5, 6},\n+\t\t\t\t\t\t}),\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"transaction invalid\",\n+\t\t\texpectedError: \"transaction 0 is invalid: proto: cannot parse invalid wire-format data\",\n+\t\t\tblock: &amp;cb.Block{\n+\t\t\t\tData: &amp;cb.BlockData{\n+\t\t\t\t\tData: [][]byte{\n+\t\t\t\t\t\tmarshalOrPanic(&amp;cb.Envelope{\n+\t\t\t\t\t\t\tPayload:   []byte{1, 2, 3},\n+\t\t\t\t\t\t\tSignature: []byte{4, 5, 6},\n+\t\t\t\t\t\t})[9:],\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t} {\n+\t\tt.Run(tst.name, func(t *testing.T) {\n+\t\t\terr := protoutil.VerifyTransactionsAreWellFormed(tst.block)\n+\t\t\tif tst.expectedError == \"\" {\n+\t\t\t\trequire.NoError(t, err)\n+\t\t\t} else {\n+\t\t\t\trequire.EqualError(t, err, tst.expectedError)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n</code></pre>\n<p>The idea is as follows:</p>\n<p>When we validate that the block's transactions match the hash in the header, we not only hash the transactions are earlier, </p>\n<p>but also ensure that if the transactions in the block are encoded into bytes, they re-create the exact split in the original block: <code>|$$$$$$$$$$$$|***********|@@@@@@@@@|%%%%%%%%%%%|</code></p>\n<p>More specifically, each transaction in the block is parsed and then re-encoded to bytes, and we check that the original encoding of a transaction is as the second encoding after parsing the original bytes of the transaction.</p>\n<p>This fix keeps the legacy way of hashing transactions to create the block data hash, but also aims to check if some manipulation was done.</p>\n<p>To understand why the fix works, we need to understand how protobuf, the wire protocol that Fabric uses to encode transactions (and almost anything it sends over the wire or writes to disk) encodes a transaction.</p>\n<p>A transaction is a protobuf message with two fields of bytes: (1) Payload and (2) Signature.</p>\n<p>When encoding a field of bytes, protobuf first writes a tag for the field (a byte) and then writes the length of the field in variable-length encoding, and then the bytes themselves.</p>\n<p>For example, to encode a transaction, protobuf writes 10 (the tag for payload), then two bytes for the length of the payload, then the payload, and then 18, the tag for the signature, and then a single byte for the length of the signature, and finally the signature.</p>\n<p>Now, we can understand a proof sketch of why my solution works:</p>\n<p>Assume in contradiction that an adversary takes a block of transactions and changes the split of the concatenation in a way that changes the transactions for a peer:</p>\n<p>From <code>|$$$$$$$$$$$$|************|@@@@@@@@@@@|...|%%%%%%%|</code> to (for example): From <code>|$$$$$$$$$$$$************|@@@@@@@@@@@|...|%%%%%%%|</code> </p>\n<p>Since this split is not identical to the original split, there exists at least one transaction index of different size between the two splits. Let's look at the first transaction that is of different size.</p>\n<p>For example, for the split:</p>\n<p><code>|$$$$$$$$$$$$|************|@@@@@@@@@@@|...|%%%%%%%|</code>  we have two options:</p>\n<ol>\n<li><p>The first transaction of different size is smaller in the new split:  <code>|$$$$$$$$$$$$|*****|*******|@@@@@@@@@@@|...|%%%%%%%|</code>  In such a case, it must contain both a payload and a signature, so it needs two fields (we can say we will return an error if one of the two is missing). If the protobuf parser detects it lacks bytes to parse a payload, it will fail with an error. Else, it has enough bytes to parse the payload, and then the signature is parsed. If the signature field is too short then we also error similarly.</p>\n</li>\n<li><p>The first transaction of different size is bigger in the new split: <code>|$$$$$$$$$$$$|************@@@@|@@@@@@@|...|%%%%%%%|</code> \nIn that case, once this transaction is parsed, the extra bytes are skipped, so encoding the transaction to bytes yields a shorter byte array, and we detect a tempering.</p>\n</li>\n</ol>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/hyperledger/fabric/security/advisories/GHSA-v9w2-543f-h69m\">https://github.com/hyperledger/fabric/security/advisories/GHSA-v9w2-543f-h69m</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/pull/4503\">https://github.com/hyperledger/fabric/pull/4503</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/pull/4504\">https://github.com/hyperledger/fabric/pull/4504</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/commit/389b2e66de9a6fbc6043216d554c97bbbdf0e008\">https://github.com/hyperledger/fabric/commit/389b2e66de9a6fbc6043216d554c97bbbdf0e008</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/commit/93bef10bd3ce3c54d7f3b064f765dbde61da7def\">https://github.com/hyperledger/fabric/commit/93bef10bd3ce3c54d7f3b064f765dbde61da7def</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/releases/tag/v2.2.14\">https://github.com/hyperledger/fabric/releases/tag/v2.2.14</a></li>\n<li><a href=\"https://github.com/hyperledger/fabric/releases/tag/v2.5.5\">https://github.com/hyperledger/fabric/releases/tag/v2.5.5</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-46132\">https://nvd.nist.gov/vuln/detail/CVE-2023-46132</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-v9w2-543f-h69m\">https://github.com/advisories/GHSA-v9w2-543f-h69m</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-v9w2-543f-h69m",
            "title": "[github.com/hyperledger/fabric] Fabric vulnerable to crosslinking transaction attack",
            "date_modified": "2023-11-14T21:37:11.000Z",
            "date_published": "2023-11-14T20:28:34.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-v9w2-543f-h69m"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"impact\">Impact</h3>\n<p>gnark provides a gadget in the standard library to allow optimized checking of the bitwidth of the inputs. The gadget works by constructing a fixed lookup table containing all valid entries, partitioning the input and checking that all parts are inside the lookup table. The range checker gadget did not take into account that the highest partition may be less than the width limit, allowing the inputs to be up to 16 bits wider than checked.</p>\n<p>Range checking gadget is extensively used in field emulation. Users using any dependant gadget (ECDSA verification, proof recursion etc.) is impacted.</p>\n<p>We consider the impact of the vulnerability being low as the number of attacker-modifiable bits is significantly smaller compared to the bit-width of scalar field modulus and it won't be possible to construct inputs which would allow to overflow the scalar field.</p>\n<h3 id=\"patches\">Patches</h3>\n<p>The issue has been patched in the stable branch of gnark. </p>\n<p>Due to low severity of the issue no emergency release will be issued and we follow the existing release plan. Versions v0.9.2 and higher are patched.</p>\n<h3 id=\"workarounds\">Workarounds</h3>\n<p>We consider the issue very hard to exploit and do not recommend manual remediation. However, it is possible to perform manual bit decomposition using <code>std/math/bits</code> gadget.</p>\n<h3 id=\"references\">References</h3>\n<p>Initial issue <a href=\"https://github.com/Consensys/gnark/issues/897\">https://github.com/Consensys/gnark/issues/897</a></p>\n<h3 id=\"acknowledgement\">Acknowledgement</h3>\n<p>The issue was reported by <a href=\"https://github.com/ultrainstinct30\">@ultrainstinct30</a>.</p>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/Consensys/gnark/security/advisories/GHSA-rjjm-x32p-m3f7\">https://github.com/Consensys/gnark/security/advisories/GHSA-rjjm-x32p-m3f7</a></li>\n<li><a href=\"https://github.com/Consensys/gnark/issues/897\">https://github.com/Consensys/gnark/issues/897</a></li>\n<li><a href=\"https://github.com/Consensys/gnark/commit/f528807119e9443df94b8c01fe8ee65abe3c75d8\">https://github.com/Consensys/gnark/commit/f528807119e9443df94b8c01fe8ee65abe3c75d8</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-rjjm-x32p-m3f7\">https://github.com/advisories/GHSA-rjjm-x32p-m3f7</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-rjjm-x32p-m3f7",
            "title": "[github.com/consensys/gnark] gnark's range checker gadget allows wider inputs up to word alignment",
            "date_modified": "2023-11-12T15:56:49.000Z",
            "date_published": "2023-11-12T15:56:48.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-rjjm-x32p-m3f7"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>The grpc Unary Server Interceptor <a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/blob/9d4eb7e7706038b07d33f83f76afbe13f53d171d/instrumentation/google.golang.org/grpc/otelgrpc/interceptor.go#L327\">opentelemetry-go-contrib/instrumentation/google.golang.org/grpc/otelgrpc/interceptor.go</a></p>\n<pre><code>// UnaryServerInterceptor returns a grpc.UnaryServerInterceptor suitable\n// for use in a grpc.NewServer call.\nfunc UnaryServerInterceptor(opts ...Option) grpc.UnaryServerInterceptor {\n</code></pre>\n<p>out of the box adds labels</p>\n<ul>\n<li><code>net.peer.sock.addr</code></li>\n<li><code>net.peer.sock.port</code></li>\n</ul>\n<p>that have unbound cardinality. It leads to the server's potential memory exhaustion when many malicious requests are sent.</p>\n<h3 id=\"details\">Details</h3>\n<p>An attacker can easily flood the peer address and port for requests.  </p>\n<h3 id=\"poc\">PoC</h3>\n<p>Apply the attached patch to the example and run the client multiple times.  Observe how each request will create a unique histogram and how the memory consumption increases during it.</p>\n<h3 id=\"impact\">Impact</h3>\n<p>In order to be affected, the program has to configure a metrics pipeline, use  <a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/blob/9d4eb7e7706038b07d33f83f76afbe13f53d171d/instrumentation/google.golang.org/grpc/otelgrpc/interceptor.go#L327\">UnaryServerInterceptor</a>, and does not filter any client IP address and ports via middleware or proxies, etc.</p>\n<h3 id=\"others\">Others</h3>\n<p>It is similar to already reported vulnerabilities.</p>\n<ul>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/security/advisories/GHSA-rcjv-mgp8-qvmr\">GHSA-rcjv-mgp8-qvmr</a> (<a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib\">open-telemetry/opentelemetry-go-contrib</a>)</li>\n</ul>\n<ul>\n<li><a title=\"GHSA-5r5m-65gx-7vrh\" href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/security/advisories/GHSA-5r5m-65gx-7vrh\">GHSA-5r5m-65gx-7vrh</a> (<a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib\">open-telemetry/opentelemetry-go-contrib</a>)</li>\n<li><a title=\"GHSA-cg3q-j54f-5p7p\" href=\"https://github.com/advisories/GHSA-cg3q-j54f-5p7p\">GHSA-cg3q-j54f-5p7p</a> (<a href=\"https://github.com/prometheus/client_golang\">prometheus/client_golang</a>)</li>\n</ul>\n<h3 id=\"workaround-for-affected-versions\">Workaround for affected versions</h3>\n<p>As a workaround to stop being affected, a view removing the attributes can be used.</p>\n<p>The other possibility is to disable grpc metrics instrumentation by passing <a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/blob/instrumentation/google.golang.org/grpc/otelgrpc/v0.45.0/instrumentation/google.golang.org/grpc/otelgrpc/config.go#L138\"><code>otelgrpc.WithMeterProvider</code></a> option with <a href=\"https://pkg.go.dev/go.opentelemetry.io/otel/metric/noop#NewMeterProvider\"><code>noop.NewMeterProvider</code></a>.</p>\n<h3 id=\"solution-provided-by-upgrading\">Solution provided by upgrading</h3>\n<p>In PR <a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/pull/4322\">#4322</a>, to be released with v0.46.0, the attributes were removed.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/pull/4322\">#4322</a></li>\n</ul>\n<h3 id=\"references-1\">References</h3>\n<ul>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/security/advisories/GHSA-8pgv-569h-w5rw\">https://github.com/open-telemetry/opentelemetry-go-contrib/security/advisories/GHSA-8pgv-569h-w5rw</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-47108\">https://nvd.nist.gov/vuln/detail/CVE-2023-47108</a></li>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/pull/4322\">https://github.com/open-telemetry/opentelemetry-go-contrib/pull/4322</a></li>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/commit/b44dfc9092b157625a5815cb437583cee663333b\">https://github.com/open-telemetry/opentelemetry-go-contrib/commit/b44dfc9092b157625a5815cb437583cee663333b</a></li>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/blob/9d4eb7e7706038b07d33f83f76afbe13f53d171d/instrumentation/google.golang.org/grpc/otelgrpc/interceptor.go#L327\">https://github.com/open-telemetry/opentelemetry-go-contrib/blob/9d4eb7e7706038b07d33f83f76afbe13f53d171d/instrumentation/google.golang.org/grpc/otelgrpc/interceptor.go#L327</a></li>\n<li><a href=\"https://github.com/open-telemetry/opentelemetry-go-contrib/blob/instrumentation/google.golang.org/grpc/otelgrpc/v0.45.0/instrumentation/google.golang.org/grpc/otelgrpc/config.go#L138\">https://github.com/open-telemetry/opentelemetry-go-contrib/blob/instrumentation/google.golang.org/grpc/otelgrpc/v0.45.0/instrumentation/google.golang.org/grpc/otelgrpc/config.go#L138</a></li>\n<li><a href=\"https://pkg.go.dev/go.opentelemetry.io/otel/metric/noop#NewMeterProvider\">https://pkg.go.dev/go.opentelemetry.io/otel/metric/noop#NewMeterProvider</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-8pgv-569h-w5rw\">https://github.com/advisories/GHSA-8pgv-569h-w5rw</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-8pgv-569h-w5rw",
            "title": "[go.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc] otelgrpc DoS vulnerability due to unbound cardinality metrics ",
            "date_modified": "2023-11-12T15:55:40.000Z",
            "date_published": "2023-11-12T15:55:39.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-8pgv-569h-w5rw"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>HashiCorp Vault and Vault Enterprise inbound client requests triggering a policy check can lead to an unbounded consumption of memory. A large number of these requests may lead to denial-of-service. Fixed in Vault 1.15.2, 1.14.6, and 1.13.10.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5954\">https://nvd.nist.gov/vuln/detail/CVE-2023-5954</a></li>\n<li><a href=\"https://discuss.hashicorp.com/t/hcsec-2023-33-vault-requests-triggering-policy-checks-may-lead-to-unbounded-memory-consumption/59926\">https://discuss.hashicorp.com/t/hcsec-2023-33-vault-requests-triggering-policy-checks-may-lead-to-unbounded-memory-consumption/59926</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4qhc-v8r6-8vwm\">https://github.com/advisories/GHSA-4qhc-v8r6-8vwm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4qhc-v8r6-8vwm",
            "title": "[github.com/hashicorp/vault] HashiCorp Vault Missing Release of Memory after Effective Lifetime vulnerability",
            "date_modified": "2023-11-17T22:01:35.000Z",
            "date_published": "2023-11-09T21:30:39.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4qhc-v8r6-8vwm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>HashiCorp Vault and Vault Enterprise inbound client requests triggering a policy check can lead to an unbounded consumption of memory. A large number of these requests may lead to denial-of-service. Fixed in Vault 1.15.2, 1.14.6, and 1.13.10.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5954\">https://nvd.nist.gov/vuln/detail/CVE-2023-5954</a></li>\n<li><a href=\"https://discuss.hashicorp.com/t/hcsec-2023-33-vault-requests-triggering-policy-checks-may-lead-to-unbounded-memory-consumption/59926\">https://discuss.hashicorp.com/t/hcsec-2023-33-vault-requests-triggering-policy-checks-may-lead-to-unbounded-memory-consumption/59926</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4qhc-v8r6-8vwm\">https://github.com/advisories/GHSA-4qhc-v8r6-8vwm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4qhc-v8r6-8vwm",
            "title": "[github.com/hashicorp/vault] HashiCorp Vault Missing Release of Memory after Effective Lifetime vulnerability",
            "date_modified": "2023-11-17T22:01:35.000Z",
            "date_published": "2023-11-09T21:30:39.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4qhc-v8r6-8vwm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<p>HashiCorp Vault and Vault Enterprise inbound client requests triggering a policy check can lead to an unbounded consumption of memory. A large number of these requests may lead to denial-of-service. Fixed in Vault 1.15.2, 1.14.6, and 1.13.10.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-5954\">https://nvd.nist.gov/vuln/detail/CVE-2023-5954</a></li>\n<li><a href=\"https://discuss.hashicorp.com/t/hcsec-2023-33-vault-requests-triggering-policy-checks-may-lead-to-unbounded-memory-consumption/59926\">https://discuss.hashicorp.com/t/hcsec-2023-33-vault-requests-triggering-policy-checks-may-lead-to-unbounded-memory-consumption/59926</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-4qhc-v8r6-8vwm\">https://github.com/advisories/GHSA-4qhc-v8r6-8vwm</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-4qhc-v8r6-8vwm",
            "title": "[github.com/hashicorp/vault] HashiCorp Vault Missing Release of Memory after Effective Lifetime vulnerability",
            "date_modified": "2023-11-17T22:01:35.000Z",
            "date_published": "2023-11-09T21:30:39.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-4qhc-v8r6-8vwm"
            },
            "tags": [
                "severity"
            ]
        },
        {
            "content_html": "<h3 id=\"summary\">Summary</h3>\n<p>Cosign is susceptible to a denial of service by an attacker controlled registry. An attacker who controls a remote registry can return a high number of attestations and/or signatures to Cosign and cause Cosign to enter a long loop resulting in an endless data attack. The root cause is that Cosign loops through all attestations fetched from the remote registry in <code>pkg/cosign.FetchAttestations</code>.</p>\n<p>The attacker needs to compromise the registry or make a request to a registry they control. When doing so, the attacker must return a high number of attestations in the response to Cosign. The result will be that the attacker can cause Cosign to go into a long or infinite loop that will prevent other users from verifying their data. In Kyvernos case, an attacker whose privileges are limited to making requests to the cluster can make a request with an image reference to their own registry, trigger the infinite loop and deny other users from completing their admission requests. Alternatively, the attacker can obtain control of the registry used by an organization and return a high number of attestations instead the expected number of attestations.</p>\n<p>The vulnerable loop in Cosign starts on line 154 below:\n<a href=\"https://github.com/sigstore/cosign/blob/004443228442850fb28f248fd59765afad99b6df/pkg/cosign/fetch.go#L135-L196\">https://github.com/sigstore/cosign/blob/004443228442850fb28f248fd59765afad99b6df/pkg/cosign/fetch.go#L135-L196</a></p>\n<p>The <code>l</code> slice is controllable by an attacker who controls the remote registry.</p>\n<p>Many cloud-native projects consider the remote registry to be untrusted, including Crossplane, Notary and Kyverno. We consider the same to be the case for Cosign, since users are not in control of whether the registry returns the expected data.</p>\n<p>TUF's security model labels this type of vulnerability an <a href=\"https://theupdateframework.io/security/\">\"Endless data attack\"</a>, but an attacker could use this as a type of rollback attack, in case the user attempts to deploy a patched version of a vulnerable image; The attacker could prevent this upgrade by causing Cosign to get stuck in an infinite loop and never complete.</p>\n<h3 id=\"mitigation\">Mitigation</h3>\n<p>The issue can be mitigated rather simply by setting a limit to the limit of attestations that Cosign will loop through. The limit does not need to be high to be within the vast majority of use cases and still prevent the endless data attack.</p>\n<h3 id=\"references\">References</h3>\n<ul>\n<li><a href=\"https://github.com/sigstore/cosign/security/advisories/GHSA-vfp6-jrw2-99g9\">https://github.com/sigstore/cosign/security/advisories/GHSA-vfp6-jrw2-99g9</a></li>\n<li><a href=\"https://nvd.nist.gov/vuln/detail/CVE-2023-46737\">https://nvd.nist.gov/vuln/detail/CVE-2023-46737</a></li>\n<li><a href=\"https://github.com/sigstore/cosign/commit/8ac891ff0e29ddc67965423bee8f826219c6eb0f\">https://github.com/sigstore/cosign/commit/8ac891ff0e29ddc67965423bee8f826219c6eb0f</a></li>\n<li><a href=\"https://github.com/sigstore/cosign/releases/tag/v2.2.1\">https://github.com/sigstore/cosign/releases/tag/v2.2.1</a></li>\n<li><a href=\"https://github.com/advisories/GHSA-vfp6-jrw2-99g9\">https://github.com/advisories/GHSA-vfp6-jrw2-99g9</a></li>\n</ul>\n",
            "url": "https://github.com/advisories/GHSA-vfp6-jrw2-99g9",
            "title": "[github.com/sigstore/cosign] Cosign vulnerable to possible endless data attack from attacker-controlled registry",
            "date_modified": "2023-11-14T21:38:50.000Z",
            "date_published": "2023-11-08T15:02:51.000Z",
            "author": {
                "name": "GitHub",
                "url": "https://github.com/advisories/GHSA-vfp6-jrw2-99g9"
            },
            "tags": [
                "severity"
            ]
        }
    ]
}